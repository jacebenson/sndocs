<!DOCTYPE html>

<html>
<head>
  <title>js_includes_sp_deps.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="AJAXCompleter.html">
                  AJAXCompleter.js
                </a>
              
                
                <a class="source" href="AJAXEmailClientCompleter.html">
                  AJAXEmailClientCompleter.js
                </a>
              
                
                <a class="source" href="AJAXOtherCompleter.html">
                  AJAXOtherCompleter.js
                </a>
              
                
                <a class="source" href="AJAXReferenceChoice.html">
                  AJAXReferenceChoice.js
                </a>
              
                
                <a class="source" href="AJAXReferenceCompleter.html">
                  AJAXReferenceCompleter.js
                </a>
              
                
                <a class="source" href="AJAXReferenceCompleterMulti.html">
                  AJAXReferenceCompleterMulti.js
                </a>
              
                
                <a class="source" href="AJAXReferenceControls.html">
                  AJAXReferenceControls.js
                </a>
              
                
                <a class="source" href="AJAXTableCompleter.html">
                  AJAXTableCompleter.js
                </a>
              
                
                <a class="source" href="AttachmentUploader.html">
                  AttachmentUploader.js
                </a>
              
                
                <a class="source" href="AutoComplete.html">
                  AutoComplete.js
                </a>
              
                
                <a class="source" href="BoundsUtil2.html">
                  BoundsUtil2.js
                </a>
              
                
                <a class="source" href="CookieJar.html">
                  CookieJar.js
                </a>
              
                
                <a class="source" href="CustomEventManager.html">
                  CustomEventManager.js
                </a>
              
                
                <a class="source" href="DaysOfWeekElement.html">
                  DaysOfWeekElement.js
                </a>
              
                
                <a class="source" href="DerivedFields.html">
                  DerivedFields.js
                </a>
              
                
                <a class="source" href="Draggable2.html">
                  Draggable2.js
                </a>
              
                
                <a class="source" href="DropTarget2.html">
                  DropTarget2.js
                </a>
              
                
                <a class="source" href="FieldListElement.html">
                  FieldListElement.js
                </a>
              
                
                <a class="source" href="GlideAPI1.html">
                  GlideAPI1.js
                </a>
              
                
                <a class="source" href="GlideAjax.html">
                  GlideAjax.js
                </a>
              
                
                <a class="source" href="GlideAjaxForm.html">
                  GlideAjaxForm.js
                </a>
              
                
                <a class="source" href="GlideBox.html">
                  GlideBox.js
                </a>
              
                
                <a class="source" href="GlideClientCache.html">
                  GlideClientCache.js
                </a>
              
                
                <a class="source" href="GlideDecoration.html">
                  GlideDecoration.js
                </a>
              
                
                <a class="source" href="GlideDialogForm.html">
                  GlideDialogForm.js
                </a>
              
                
                <a class="source" href="GlideDialogWindow.html">
                  GlideDialogWindow.js
                </a>
              
                
                <a class="source" href="GlideDraggable.html">
                  GlideDraggable.js
                </a>
              
                
                <a class="source" href="GlideDuration.html">
                  GlideDuration.js
                </a>
              
                
                <a class="source" href="GlideEvent.html">
                  GlideEvent.js
                </a>
              
                
                <a class="source" href="GlideEventHandler.html">
                  GlideEventHandler.js
                </a>
              
                
                <a class="source" href="GlideFilter14.html">
                  GlideFilter14.js
                </a>
              
                
                <a class="source" href="GlideFilterDate.html">
                  GlideFilterDate.js
                </a>
              
                
                <a class="source" href="GlideFilterDescription.html">
                  GlideFilterDescription.js
                </a>
              
                
                <a class="source" href="GlideFilterHandlers.html">
                  GlideFilterHandlers.js
                </a>
              
                
                <a class="source" href="GlideFilterItemVariables.html">
                  GlideFilterItemVariables.js
                </a>
              
                
                <a class="source" href="GlideFilterLabels.html">
                  GlideFilterLabels.js
                </a>
              
                
                <a class="source" href="GlideFilterQuestions.html">
                  GlideFilterQuestions.js
                </a>
              
                
                <a class="source" href="GlideFilterReference.html">
                  GlideFilterReference.js
                </a>
              
                
                <a class="source" href="GlideFilterReferenceMulti.html">
                  GlideFilterReferenceMulti.js
                </a>
              
                
                <a class="source" href="GlideFilterVariables.html">
                  GlideFilterVariables.js
                </a>
              
                
                <a class="source" href="GlideForm14.html">
                  GlideForm14.js
                </a>
              
                
                <a class="source" href="GlideHeaderSearch.html">
                  GlideHeaderSearch.js
                </a>
              
                
                <a class="source" href="GlideList2.html">
                  GlideList2.js
                </a>
              
                
                <a class="source" href="GlideList2FilterUtil.html">
                  GlideList2FilterUtil.js
                </a>
              
                
                <a class="source" href="GlideList2Handlers.html">
                  GlideList2Handlers.js
                </a>
              
                
                <a class="source" href="GlideList2InitEvents.html">
                  GlideList2InitEvents.js
                </a>
              
                
                <a class="source" href="GlideList2Statics.html">
                  GlideList2Statics.js
                </a>
              
                
                <a class="source" href="GlideListAggregates.html">
                  GlideListAggregates.js
                </a>
              
                
                <a class="source" href="GlideListEditor.html">
                  GlideListEditor.js
                </a>
              
                
                <a class="source" href="GlideListEditorMessaging.html">
                  GlideListEditorMessaging.js
                </a>
              
                
                <a class="source" href="GlideListElement.html">
                  GlideListElement.js
                </a>
              
                
                <a class="source" href="GlideListWidget.html">
                  GlideListWidget.js
                </a>
              
                
                <a class="source" href="GlideListv3Compatibility.html">
                  GlideListv3Compatibility.js
                </a>
              
                
                <a class="source" href="GlideModalForm.html">
                  GlideModalForm.js
                </a>
              
                
                <a class="source" href="GlideOverlay.html">
                  GlideOverlay.js
                </a>
              
                
                <a class="source" href="GlidePane.html">
                  GlidePane.js
                </a>
              
                
                <a class="source" href="GlidePaneForm.html">
                  GlidePaneForm.js
                </a>
              
                
                <a class="source" href="GlideRecord.html">
                  GlideRecord.js
                </a>
              
                
                <a class="source" href="GlideTabs2.html">
                  GlideTabs2.js
                </a>
              
                
                <a class="source" href="GlideTabs2State.html">
                  GlideTabs2State.js
                </a>
              
                
                <a class="source" href="GlideTabs2Tab.html">
                  GlideTabs2Tab.js
                </a>
              
                
                <a class="source" href="GlideTimeElement.html">
                  GlideTimeElement.js
                </a>
              
                
                <a class="source" href="GlideTimerElement.html">
                  GlideTimerElement.js
                </a>
              
                
                <a class="source" href="GlideTransactionScope.html">
                  GlideTransactionScope.js
                </a>
              
                
                <a class="source" href="GlideUI.html">
                  GlideUI.js
                </a>
              
                
                <a class="source" href="GlideUIDefault.html">
                  GlideUIDefault.js
                </a>
              
                
                <a class="source" href="GlideUIElement.html">
                  GlideUIElement.js
                </a>
              
                
                <a class="source" href="GlideUINotification.html">
                  GlideUINotification.js
                </a>
              
                
                <a class="source" href="GlideURL.html">
                  GlideURL.js
                </a>
              
                
                <a class="source" href="GlideURLElement.html">
                  GlideURLElement.js
                </a>
              
                
                <a class="source" href="GlideUserImageElement.html">
                  GlideUserImageElement.js
                </a>
              
                
                <a class="source" href="GlideWidgetActions.html">
                  GlideWidgetActions.js
                </a>
              
                
                <a class="source" href="GlideWidgetFilter.html">
                  GlideWidgetFilter.js
                </a>
              
                
                <a class="source" href="GlideWidgetHideOnEmpty.html">
                  GlideWidgetHideOnEmpty.js
                </a>
              
                
                <a class="source" href="GlideWidgetSearch.html">
                  GlideWidgetSearch.js
                </a>
              
                
                <a class="source" href="GlideWidgetVCR.html">
                  GlideWidgetVCR.js
                </a>
              
                
                <a class="source" href="GlideWindow.html">
                  GlideWindow.js
                </a>
              
                
                <a class="source" href="GuidedTourElementTranslator.html">
                  GuidedTourElementTranslator.js
                </a>
              
                
                <a class="source" href="GwtCellEditor.html">
                  GwtCellEditor.js
                </a>
              
                
                <a class="source" href="GwtCellSelector.html">
                  GwtCellSelector.js
                </a>
              
                
                <a class="source" href="GwtContextMenu.html">
                  GwtContextMenu.js
                </a>
              
                
                <a class="source" href="GwtCursor.html">
                  GwtCursor.js
                </a>
              
                
                <a class="source" href="GwtDate.html">
                  GwtDate.js
                </a>
              
                
                <a class="source" href="GwtDraggable.html">
                  GwtDraggable.js
                </a>
              
                
                <a class="source" href="GwtDraggableSnap.html">
                  GwtDraggableSnap.js
                </a>
              
                
                <a class="source" href="GwtExportScheduleDialog.html">
                  GwtExportScheduleDialog.js
                </a>
              
                
                <a class="source" href="GwtGridEdit.html">
                  GwtGridEdit.js
                </a>
              
                
                <a class="source" href="GwtListEditAjaxChangeSaver.html">
                  GwtListEditAjaxChangeSaver.js
                </a>
              
                
                <a class="source" href="GwtListEditAjaxValueLoader.html">
                  GwtListEditAjaxValueLoader.js
                </a>
              
                
                <a class="source" href="GwtListEditBoolean.html">
                  GwtListEditBoolean.js
                </a>
              
                
                <a class="source" href="GwtListEditCalendar.html">
                  GwtListEditCalendar.js
                </a>
              
                
                <a class="source" href="GwtListEditDuration.html">
                  GwtListEditDuration.js
                </a>
              
                
                <a class="source" href="GwtListEditEncryptedText.html">
                  GwtListEditEncryptedText.js
                </a>
              
                
                <a class="source" href="GwtListEditError.html">
                  GwtListEditError.js
                </a>
              
                
                <a class="source" href="GwtListEditGList.html">
                  GwtListEditGList.js
                </a>
              
                
                <a class="source" href="GwtListEditGlideRecord.html">
                  GwtListEditGlideRecord.js
                </a>
              
                
                <a class="source" href="GwtListEditGridSelector.html">
                  GwtListEditGridSelector.js
                </a>
              
                
                <a class="source" href="GwtListEditInternalType.html">
                  GwtListEditInternalType.js
                </a>
              
                
                <a class="source" href="GwtListEditJournal.html">
                  GwtListEditJournal.js
                </a>
              
                
                <a class="source" href="GwtListEditMultiText.html">
                  GwtListEditMultiText.js
                </a>
              
                
                <a class="source" href="GwtListEditPassword.html">
                  GwtListEditPassword.js
                </a>
              
                
                <a class="source" href="GwtListEditRecord.html">
                  GwtListEditRecord.js
                </a>
              
                
                <a class="source" href="GwtListEditRecordDecorations.html">
                  GwtListEditRecordDecorations.js
                </a>
              
                
                <a class="source" href="GwtListEditReference.html">
                  GwtListEditReference.js
                </a>
              
                
                <a class="source" href="GwtListEditRelatedTags.html">
                  GwtListEditRelatedTags.js
                </a>
              
                
                <a class="source" href="GwtListEditSavePolicy.html">
                  GwtListEditSavePolicy.js
                </a>
              
                
                <a class="source" href="GwtListEditSelect.html">
                  GwtListEditSelect.js
                </a>
              
                
                <a class="source" href="GwtListEditTableController.html">
                  GwtListEditTableController.js
                </a>
              
                
                <a class="source" href="GwtListEditTablename.html">
                  GwtListEditTablename.js
                </a>
              
                
                <a class="source" href="GwtListEditText.html">
                  GwtListEditText.js
                </a>
              
                
                <a class="source" href="GwtListEditTranslatedField.html">
                  GwtListEditTranslatedField.js
                </a>
              
                
                <a class="source" href="GwtListEditUpdateTablename.html">
                  GwtListEditUpdateTablename.js
                </a>
              
                
                <a class="source" href="GwtListEditValueRenderer.html">
                  GwtListEditValueRenderer.js
                </a>
              
                
                <a class="source" href="GwtListEditWindow.html">
                  GwtListEditWindow.js
                </a>
              
                
                <a class="source" href="GwtListEditor.html">
                  GwtListEditor.js
                </a>
              
                
                <a class="source" href="GwtListEditorPendingChanges.html">
                  GwtListEditorPendingChanges.js
                </a>
              
                
                <a class="source" href="GwtMessage14.html">
                  GwtMessage14.js
                </a>
              
                
                <a class="source" href="GwtObservable.html">
                  GwtObservable.js
                </a>
              
                
                <a class="source" href="GwtPollDialog.html">
                  GwtPollDialog.js
                </a>
              
                
                <a class="source" href="InPlaceEdit.html">
                  InPlaceEdit.js
                </a>
              
                
                <a class="source" href="ListDraggableRow2.html">
                  ListDraggableRow2.js
                </a>
              
                
                <a class="source" href="ListSelectManager2.html">
                  ListSelectManager2.js
                </a>
              
                
                <a class="source" href="ListSortDual2.html">
                  ListSortDual2.js
                </a>
              
                
                <a class="source" href="ListSortWindow2.html">
                  ListSortWindow2.js
                </a>
              
                
                <a class="source" href="NOW.messaging.html">
                  NOW.messaging.js
                </a>
              
                
                <a class="source" href="NOW.messaging.record.html">
                  NOW.messaging.record.js
                </a>
              
                
                <a class="source" href="NameMapEntry.html">
                  NameMapEntry.js
                </a>
              
                
                <a class="source" href="NotificationMessage.html">
                  NotificationMessage.js
                </a>
              
                
                <a class="source" href="PageTiming14.html">
                  PageTiming14.js
                </a>
              
                
                <a class="source" href="PersonalizeForm.html">
                  PersonalizeForm.js
                </a>
              
                
                <a class="source" href="Point.html">
                  Point.js
                </a>
              
                
                <a class="source" href="SLARepairClient.html">
                  SLARepairClient.js
                </a>
              
                
                <a class="source" href="ScriptLoader.html">
                  ScriptLoader.js
                </a>
              
                
                <a class="source" href="Select.html">
                  Select.js
                </a>
              
                
                <a class="source" href="SlushBucket.html">
                  SlushBucket.js
                </a>
              
                
                <a class="source" href="SortDraggable2.html">
                  SortDraggable2.js
                </a>
              
                
                <a class="source" href="SortDropTarget2.html">
                  SortDropTarget2.js
                </a>
              
                
                <a class="source" href="SortListManager2.html">
                  SortListManager2.js
                </a>
              
                
                <a class="source" href="SortUtil2.html">
                  SortUtil2.js
                </a>
              
                
                <a class="source" href="StopWatch.html">
                  StopWatch.js
                </a>
              
                
                <a class="source" href="Table.html">
                  Table.js
                </a>
              
                
                <a class="source" href="TableElement.html">
                  TableElement.js
                </a>
              
                
                <a class="source" href="TableExtension.html">
                  TableExtension.js
                </a>
              
                
                <a class="source" href="TemplateRecord.html">
                  TemplateRecord.js
                </a>
              
                
                <a class="source" href="TextAreaElement.html">
                  TextAreaElement.js
                </a>
              
                
                <a class="source" href="UserRolesElement.html">
                  UserRolesElement.js
                </a>
              
                
                <a class="source" href="UtilityAndOverrides2.html">
                  UtilityAndOverrides2.js
                </a>
              
                
                <a class="source" href="_module.html">
                  _module.js
                </a>
              
                
                <a class="source" href="ac.html">
                  ac.js
                </a>
              
                
                <a class="source" href="ac_derived_field_support.html">
                  ac_derived_field_support.js
                </a>
              
                
                <a class="source" href="accessibility_tabindex.html">
                  accessibility_tabindex.js
                </a>
              
                
                <a class="source" href="affix.html">
                  affix.js
                </a>
              
                
                <a class="source" href="alert.html">
                  alert.js
                </a>
              
                
                <a class="source" href="amb.Channel.html">
                  amb.Channel.js
                </a>
              
                
                <a class="source" href="amb.ChannelListener.html">
                  amb.ChannelListener.js
                </a>
              
                
                <a class="source" href="amb.ChannelRedirect.html">
                  amb.ChannelRedirect.js
                </a>
              
                
                <a class="source" href="amb.EventManager.html">
                  amb.EventManager.js
                </a>
              
                
                <a class="source" href="amb.Logger.html">
                  amb.Logger.js
                </a>
              
                
                <a class="source" href="amb.MessageClient.html">
                  amb.MessageClient.js
                </a>
              
                
                <a class="source" href="amb.MessageClientBuilder.html">
                  amb.MessageClientBuilder.js
                </a>
              
                
                <a class="source" href="amb.ServerConnection.html">
                  amb.ServerConnection.js
                </a>
              
                
                <a class="source" href="amb_initialize.html">
                  amb_initialize.js
                </a>
              
                
                <a class="source" href="amb_properties.html">
                  amb_properties.js
                </a>
              
                
                <a class="source" href="angular-animate.html">
                  angular-animate.js
                </a>
              
                
                <a class="source" href="angular-aria.html">
                  angular-aria.js
                </a>
              
                
                <a class="source" href="angular-cookies.html">
                  angular-cookies.js
                </a>
              
                
                <a class="source" href="angular-file-upload-all.html">
                  angular-file-upload-all.js
                </a>
              
                
                <a class="source" href="angular-resource.html">
                  angular-resource.js
                </a>
              
                
                <a class="source" href="angular-route.html">
                  angular-route.js
                </a>
              
                
                <a class="source" href="angular-sanitize.html">
                  angular-sanitize.js
                </a>
              
                
                <a class="source" href="angular-touch.html">
                  angular-touch.js
                </a>
              
                
                <a class="source" href="angular-ui-tinymce.html">
                  angular-ui-tinymce.js
                </a>
              
                
                <a class="source" href="angular.html">
                  angular.js
                </a>
              
                
                <a class="source" href="annotations_toggle.html">
                  annotations_toggle.js
                </a>
              
                
                <a class="source" href="app.$sp.html">
                  app.$sp.js
                </a>
              
                
                <a class="source" href="app.config.html">
                  app.config.js
                </a>
              
                
                <a class="source" href="app.ng.amb.html">
                  app.ng.amb.js
                </a>
              
                
                <a class="source" href="app_guided_tours.html">
                  app_guided_tours.js
                </a>
              
                
                <a class="source" href="attachments.html">
                  attachments.js
                </a>
              
                
                <a class="source" href="bootstrap-datetimepicker.html">
                  bootstrap-datetimepicker.js
                </a>
              
                
                <a class="source" href="bootstrap-iconpicker.html">
                  bootstrap-iconpicker.js
                </a>
              
                
                <a class="source" href="bootstrap_336.html">
                  bootstrap_336.js
                </a>
              
                
                <a class="source" href="button.html">
                  button.js
                </a>
              
                
                <a class="source" href="cabrillo.factory.html">
                  cabrillo.factory.js
                </a>
              
                
                <a class="source" href="calendar.html">
                  calendar.js
                </a>
              
                
                <a class="source" href="camera.html">
                  camera.js
                </a>
              
                
                <a class="source" href="carousel.html">
                  carousel.js
                </a>
              
                
                <a class="source" href="catalogDataLookup.html">
                  catalogDataLookup.js
                </a>
              
                
                <a class="source" href="catalogGlideFormFactory.html">
                  catalogGlideFormFactory.js
                </a>
              
                
                <a class="source" href="catalogItemFactory.html">
                  catalogItemFactory.js
                </a>
              
                
                <a class="source" href="clientScript_components.html">
                  clientScript_components.js
                </a>
              
                
                <a class="source" href="collapse.html">
                  collapse.js
                </a>
              
                
                <a class="source" href="cometd.html">
                  cometd.js
                </a>
              
                
                <a class="source" href="condition14_new.html">
                  condition14_new.js
                </a>
              
                
                <a class="source" href="condition14_reporting.html">
                  condition14_reporting.js
                </a>
              
                
                <a class="source" href="condition14_templates.html">
                  condition14_templates.js
                </a>
              
                
                <a class="source" href="condition_global_variables14.html">
                  condition_global_variables14.js
                </a>
              
                
                <a class="source" href="constants_embedded_help.html">
                  constants_embedded_help.js
                </a>
              
                
                <a class="source" href="context_actions.html">
                  context_actions.js
                </a>
              
                
                <a class="source" href="controller.AMBRecordWatcher.html">
                  controller.AMBRecordWatcher.js
                </a>
              
                
                <a class="source" href="controller.Stream.html">
                  controller.Stream.js
                </a>
              
                
                <a class="source" href="controller.guidedTours.html">
                  controller.guidedTours.js
                </a>
              
                
                <a class="source" href="core.html">
                  core.js
                </a>
              
                
                <a class="source" href="debug.html">
                  debug.js
                </a>
              
                
                <a class="source" href="decorator.uiTinymce.html">
                  decorator.uiTinymce.js
                </a>
              
                
                <a class="source" href="deferred_related_lists.html">
                  deferred_related_lists.js
                </a>
              
                
                <a class="source" href="depends.html">
                  depends.js
                </a>
              
                
                <a class="source" href="directive.contenteditable.html">
                  directive.contenteditable.js
                </a>
              
                
                <a class="source" href="directive.glideFormField.html">
                  directive.glideFormField.js
                </a>
              
                
                <a class="source" href="directive.glyph.html">
                  directive.glyph.js
                </a>
              
                
                <a class="source" href="directive.message.html">
                  directive.message.js
                </a>
              
                
                <a class="source" href="directive.nowAttachmentsList.html">
                  directive.nowAttachmentsList.js
                </a>
              
                
                <a class="source" href="directive.recursiveHelper.html">
                  directive.recursiveHelper.js
                </a>
              
                
                <a class="source" href="directive.snAttachmentList.html">
                  directive.snAttachmentList.js
                </a>
              
                
                <a class="source" href="directive.snAttachmentPreview.html">
                  directive.snAttachmentPreview.js
                </a>
              
                
                <a class="source" href="directive.snAvatar.html">
                  directive.snAvatar.js
                </a>
              
                
                <a class="source" href="directive.snAvatarPopover.html">
                  directive.snAvatarPopover.js
                </a>
              
                
                <a class="source" href="directive.snBindI18n.html">
                  directive.snBindI18n.js
                </a>
              
                
                <a class="source" href="directive.snBindOnce.html">
                  directive.snBindOnce.js
                </a>
              
                
                <a class="source" href="directive.snBindPopoverSelection.html">
                  directive.snBindPopoverSelection.js
                </a>
              
                
                <a class="source" href="directive.snBlurOnEnter.html">
                  directive.snBlurOnEnter.js
                </a>
              
                
                <a class="source" href="directive.snChoiceList.html">
                  directive.snChoiceList.js
                </a>
              
                
                <a class="source" href="directive.snCloak.html">
                  directive.snCloak.js
                </a>
              
                
                <a class="source" href="directive.snComplexPopover.html">
                  directive.snComplexPopover.js
                </a>
              
                
                <a class="source" href="directive.snConfirmModal.html">
                  directive.snConfirmModal.js
                </a>
              
                
                <a class="source" href="directive.snContextMenu.html">
                  directive.snContextMenu.js
                </a>
              
                
                <a class="source" href="directive.snDayAgo.html">
                  directive.snDayAgo.js
                </a>
              
                
                <a class="source" href="directive.snDialog.html">
                  directive.snDialog.js
                </a>
              
                
                <a class="source" href="directive.snExpandedEmail.html">
                  directive.snExpandedEmail.js
                </a>
              
                
                <a class="source" href="directive.snFieldReference.html">
                  directive.snFieldReference.js
                </a>
              
                
                <a class="source" href="directive.snFileUploadInput.html">
                  directive.snFileUploadInput.js
                </a>
              
                
                <a class="source" href="directive.snFlyout.html">
                  directive.snFlyout.js
                </a>
              
                
                <a class="source" href="directive.snFocus.html">
                  directive.snFocus.js
                </a>
              
                
                <a class="source" href="directive.snGlyph.html">
                  directive.snGlyph.js
                </a>
              
                
                <a class="source" href="directive.snImageUploader.html">
                  directive.snImageUploader.js
                </a>
              
                
                <a class="source" href="directive.snLinkContent.html">
                  directive.snLinkContent.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentArticle.html">
                  directive.snLinkContentArticle.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentAttachment.html">
                  directive.snLinkContentAttachment.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentError.html">
                  directive.snLinkContentError.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentImage.html">
                  directive.snLinkContentImage.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentRecord.html">
                  directive.snLinkContentRecord.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentSoundcloud.html">
                  directive.snLinkContentSoundcloud.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentYoutube.html">
                  directive.snLinkContentYoutube.js
                </a>
              
                
                <a class="source" href="directive.snMentionPopover.html">
                  directive.snMentionPopover.js
                </a>
              
                
                <a class="source" href="directive.snModal.html">
                  directive.snModal.js
                </a>
              
                
                <a class="source" href="directive.snModalShow.html">
                  directive.snModalShow.js
                </a>
              
                
                <a class="source" href="directive.snNotification.html">
                  directive.snNotification.js
                </a>
              
                
                <a class="source" href="directive.snPasteImageHandler.html">
                  directive.snPasteImageHandler.js
                </a>
              
                
                <a class="source" href="directive.snPresence.html">
                  directive.snPresence.js
                </a>
              
                
                <a class="source" href="directive.snRecordPicker.html">
                  directive.snRecordPicker.js
                </a>
              
                
                <a class="source" href="directive.snReferencePicker.html">
                  directive.snReferencePicker.js
                </a>
              
                
                <a class="source" href="directive.snResizeHeight.html">
                  directive.snResizeHeight.js
                </a>
              
                
                <a class="source" href="directive.snSelectBasic.html">
                  directive.snSelectBasic.js
                </a>
              
                
                <a class="source" href="directive.snStickyHeaders.html">
                  directive.snStickyHeaders.js
                </a>
              
                
                <a class="source" href="directive.snStream.html">
                  directive.snStream.js
                </a>
              
                
                <a class="source" href="directive.snSyncWith.html">
                  directive.snSyncWith.js
                </a>
              
                
                <a class="source" href="directive.snTableReference.html">
                  directive.snTableReference.js
                </a>
              
                
                <a class="source" href="directive.snTabs.html">
                  directive.snTabs.js
                </a>
              
                
                <a class="source" href="directive.snTextExpander.html">
                  directive.snTextExpander.js
                </a>
              
                
                <a class="source" href="directive.snTimeAgo.html">
                  directive.snTimeAgo.js
                </a>
              
                
                <a class="source" href="directive.snUserAvatar.html">
                  directive.snUserAvatar.js
                </a>
              
                
                <a class="source" href="directive.snUserProfile.html">
                  directive.snUserProfile.js
                </a>
              
                
                <a class="source" href="directive.spCLink.html">
                  directive.spCLink.js
                </a>
              
                
                <a class="source" href="directive.spCatItem.html">
                  directive.spCatItem.js
                </a>
              
                
                <a class="source" href="directive.spChoiceList.html">
                  directive.spChoiceList.js
                </a>
              
                
                <a class="source" href="directive.spCodeMirror.html">
                  directive.spCodeMirror.js
                </a>
              
                
                <a class="source" href="directive.spColorPicker.html">
                  directive.spColorPicker.js
                </a>
              
                
                <a class="source" href="directive.spContextMenu.html">
                  directive.spContextMenu.js
                </a>
              
                
                <a class="source" href="directive.spCssEditor.html">
                  directive.spCssEditor.js
                </a>
              
                
                <a class="source" href="directive.spDatePicker.html">
                  directive.spDatePicker.js
                </a>
              
                
                <a class="source" href="directive.spDropdownTree.html">
                  directive.spDropdownTree.js
                </a>
              
                
                <a class="source" href="directive.spEditableField.html">
                  directive.spEditableField.js
                </a>
              
                
                <a class="source" href="directive.spFieldListElement.html">
                  directive.spFieldListElement.js
                </a>
              
                
                <a class="source" href="directive.spFormField.html">
                  directive.spFormField.js
                </a>
              
                
                <a class="source" href="directive.spGlyph.html">
                  directive.spGlyph.js
                </a>
              
                
                <a class="source" href="directive.spGlyphPicker.html">
                  directive.spGlyphPicker.js
                </a>
              
                
                <a class="source" href="directive.spHTMLEditor.html">
                  directive.spHTMLEditor.js
                </a>
              
                
                <a class="source" href="directive.spHtmlContent.html">
                  directive.spHtmlContent.js
                </a>
              
                
                <a class="source" href="directive.spPanel.html">
                  directive.spPanel.js
                </a>
              
                
                <a class="source" href="directive.spReferenceElement.html">
                  directive.spReferenceElement.js
                </a>
              
                
                <a class="source" href="directive.spReferenceField.html">
                  directive.spReferenceField.js
                </a>
              
                
                <a class="source" href="directive.spScriptEditor.html">
                  directive.spScriptEditor.js
                </a>
              
                
                <a class="source" href="directive.spTinymceEditor.html">
                  directive.spTinymceEditor.js
                </a>
              
                
                <a class="source" href="dropdown.html">
                  dropdown.js
                </a>
              
                
                <a class="source" href="dropdowns.html">
                  dropdowns.js
                </a>
              
                
                <a class="source" href="email_activity.html">
                  email_activity.js
                </a>
              
                
                <a class="source" href="event_initialize.html">
                  event_initialize.js
                </a>
              
                
                <a class="source" href="factory.AMBOverlay.html">
                  factory.AMBOverlay.js
                </a>
              
                
                <a class="source" href="factory.ArraySynchronizer.html">
                  factory.ArraySynchronizer.js
                </a>
              
                
                <a class="source" href="factory.glideUrlBuilder.html">
                  factory.glideUrlBuilder.js
                </a>
              
                
                <a class="source" href="factory.notificationWrapper.html">
                  factory.notificationWrapper.js
                </a>
              
                
                <a class="source" href="factory.nowAttachmentHandler.html">
                  factory.nowAttachmentHandler.js
                </a>
              
                
                <a class="source" href="factory.paneManager.html">
                  factory.paneManager.js
                </a>
              
                
                <a class="source" href="factory.snAttachmentHandler.html">
                  factory.snAttachmentHandler.js
                </a>
              
                
                <a class="source" href="factory.snPresence.html">
                  factory.snPresence.js
                </a>
              
                
                <a class="source" href="factory.snRecordPresence.html">
                  factory.snRecordPresence.js
                </a>
              
                
                <a class="source" href="factory.snRecordWatcher.html">
                  factory.snRecordWatcher.js
                </a>
              
                
                <a class="source" href="factory.spMacro.html">
                  factory.spMacro.js
                </a>
              
                
                <a class="source" href="factory.spUIActionFactory.html">
                  factory.spUIActionFactory.js
                </a>
              
                
                <a class="source" href="factory.unwrappedHTTPPromise.html">
                  factory.unwrappedHTTPPromise.js
                </a>
              
                
                <a class="source" href="fixedHeaders.html">
                  fixedHeaders.js
                </a>
              
                
                <a class="source" href="form.html">
                  form.js
                </a>
              
                
                <a class="source" href="form_submitted_mask.html">
                  form_submitted_mask.js
                </a>
              
                
                <a class="source" href="form_tags.html">
                  form_tags.js
                </a>
              
                
                <a class="source" href="formatting.html">
                  formatting.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="functions_attachments.html">
                  functions_attachments.js
                </a>
              
                
                <a class="source" href="functions_bootstrap14.html">
                  functions_bootstrap14.js
                </a>
              
                
                <a class="source" href="functions_calendar.html">
                  functions_calendar.js
                </a>
              
                
                <a class="source" href="functions_clipboard.html">
                  functions_clipboard.js
                </a>
              
                
                <a class="source" href="functions_email.html">
                  functions_email.js
                </a>
              
                
                <a class="source" href="functions_fontsizer.html">
                  functions_fontsizer.js
                </a>
              
                
                <a class="source" href="functions_onchange.html">
                  functions_onchange.js
                </a>
              
                
                <a class="source" href="functions_reference.html">
                  functions_reference.js
                </a>
              
                
                <a class="source" href="functions_showloading.html">
                  functions_showloading.js
                </a>
              
                
                <a class="source" href="functions_user_image.html">
                  functions_user_image.js
                </a>
              
                
                <a class="source" href="geolocation.html">
                  geolocation.js
                </a>
              
                
                <a class="source" href="glide-highcharts-v5.html">
                  glide-highcharts-v5.js
                </a>
              
                
                <a class="source" href="glideAjaxFactory.html">
                  glideAjaxFactory.js
                </a>
              
                
                <a class="source" href="glideFormEnvironmentFactory.html">
                  glideFormEnvironmentFactory.js
                </a>
              
                
                <a class="source" href="glideFormFactory.html">
                  glideFormFactory.js
                </a>
              
                
                <a class="source" href="glideFormFieldFactory.html">
                  glideFormFieldFactory.js
                </a>
              
                
                <a class="source" href="glideFormMessageHandler.html">
                  glideFormMessageHandler.js
                </a>
              
                
                <a class="source" href="glideListFactory.html">
                  glideListFactory.js
                </a>
              
                
                <a class="source" href="glideModalFactory.html">
                  glideModalFactory.js
                </a>
              
                
                <a class="source" href="glideRecordData.html">
                  glideRecordData.js
                </a>
              
                
                <a class="source" href="glideRecordFactory.html">
                  glideRecordFactory.js
                </a>
              
                
                <a class="source" href="glideRequest.html">
                  glideRequest.js
                </a>
              
                
                <a class="source" href="glideUIActionsFactory.html">
                  glideUIActionsFactory.js
                </a>
              
                
                <a class="source" href="glideUser.html">
                  glideUser.js
                </a>
              
                
                <a class="source" href="glideUserFactory.html">
                  glideUserFactory.js
                </a>
              
                
                <a class="source" href="glideUserSession.html">
                  glideUserSession.js
                </a>
              
                
                <a class="source" href="guided_tours_template.html">
                  guided_tours_template.js
                </a>
              
                
                <a class="source" href="heisenberg_all.html">
                  heisenberg_all.js
                </a>
              
                
                <a class="source" href="html_class_setter.html">
                  html_class_setter.js
                </a>
              
                
                <a class="source" href="iconset-fontawesome-4.2.0.html">
                  iconset-fontawesome-4.2.0.js
                </a>
              
                
                <a class="source" href="jQueryRequestShim.html">
                  jQueryRequestShim.js
                </a>
              
                
                <a class="source" href="jquery-1.11.0_no_conflict.html">
                  jquery-1.11.0_no_conflict.js
                </a>
              
                
                <a class="source" href="jquery-2.1.html">
                  jquery-2.1.js
                </a>
              
                
                <a class="source" href="jquery-ui-1.9.2.custom.html">
                  jquery-ui-1.9.2.custom.js
                </a>
              
                
                <a class="source" href="jquery.cometd.html">
                  jquery.cometd.js
                </a>
              
                
                <a class="source" href="jquery_clean.html">
                  jquery_clean.js
                </a>
              
                
                <a class="source" href="jquery_includes.html">
                  jquery_includes.js
                </a>
              
                
                <a class="source" href="jquery_no_conflict.html">
                  jquery_no_conflict.js
                </a>
              
                
                <a class="source" href="js_guided_tours_includes.html">
                  js_guided_tours_includes.js
                </a>
              
                
                <a class="source" href="js_includes_amb.html">
                  js_includes_amb.js
                </a>
              
                
                <a class="source" href="js_includes_angular.html">
                  js_includes_angular.js
                </a>
              
                
                <a class="source" href="js_includes_attachments.html">
                  js_includes_attachments.js
                </a>
              
                
                <a class="source" href="js_includes_avatar.html">
                  js_includes_avatar.js
                </a>
              
                
                <a class="source" href="js_includes_cabrillo.html">
                  js_includes_cabrillo.js
                </a>
              
                
                <a class="source" href="js_includes_clientScript.html">
                  js_includes_clientScript.js
                </a>
              
                
                <a class="source" href="js_includes_common.html">
                  js_includes_common.js
                </a>
              
                
                <a class="source" href="js_includes_controls.html">
                  js_includes_controls.js
                </a>
              
                
                <a class="source" href="js_includes_customer.html">
                  js_includes_customer.js
                </a>
              
                
                <a class="source" href="js_includes_data.html">
                  js_includes_data.js
                </a>
              
                
                <a class="source" href="js_includes_datetime.html">
                  js_includes_datetime.js
                </a>
              
                
                <a class="source" href="js_includes_doctype.html">
                  js_includes_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_form.html">
                  js_includes_form.js
                </a>
              
                
                <a class="source" href="js_includes_glide.html">
                  js_includes_glide.js
                </a>
              
                
                <a class="source" href="js_includes_i18n.html">
                  js_includes_i18n.js
                </a>
              
                
                <a class="source" href="js_includes_last_doctype.html">
                  js_includes_last_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_link.html">
                  js_includes_link.js
                </a>
              
                
                <a class="source" href="js_includes_list_edit_doctype.html">
                  js_includes_list_edit_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_listv2_doctype.html">
                  js_includes_listv2_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_mention.html">
                  js_includes_mention.js
                </a>
              
                
                <a class="source" href="js_includes_messaging.html">
                  js_includes_messaging.js
                </a>
              
                
                <a class="source" href="js_includes_ng_amb.html">
                  js_includes_ng_amb.js
                </a>
              
                
                <a class="source" href="js_includes_notification.html">
                  js_includes_notification.js
                </a>
              
                
                <a class="source" href="js_includes_presence.html">
                  js_includes_presence.js
                </a>
              
                
                <a class="source" href="js_includes_sorting_new.html">
                  js_includes_sorting_new.js
                </a>
              
                
                <a class="source" href="js_includes_sp.html">
                  js_includes_sp.js
                </a>
              
                
                <a class="source" href="js_includes_sp_core.html">
                  js_includes_sp_core.js
                </a>
              
                
                <a class="source" href="js_includes_sp_deps.html">
                  js_includes_sp_deps.js
                </a>
              
                
                <a class="source" href="js_includes_sp_tinymce.html">
                  js_includes_sp_tinymce.js
                </a>
              
                
                <a class="source" href="js_includes_stream.html">
                  js_includes_stream.js
                </a>
              
                
                <a class="source" href="js_includes_ui.html">
                  js_includes_ui.js
                </a>
              
                
                <a class="source" href="js_includes_ui_popover.html">
                  js_includes_ui_popover.js
                </a>
              
                
                <a class="source" href="js_includes_user_profile.html">
                  js_includes_user_profile.js
                </a>
              
                
                <a class="source" href="js_includes_util.html">
                  js_includes_util.js
                </a>
              
                
                <a class="source" href="list.html">
                  list.js
                </a>
              
                
                <a class="source" href="list_filter.html">
                  list_filter.js
                </a>
              
                
                <a class="source" href="mentio.html">
                  mentio.js
                </a>
              
                
                <a class="source" href="modal.html">
                  modal.js
                </a>
              
                
                <a class="source" href="modals.html">
                  modals.js
                </a>
              
                
                <a class="source" href="moment-2.8.3.html">
                  moment-2.8.3.js
                </a>
              
                
                <a class="source" href="navigation.html">
                  navigation.js
                </a>
              
                
                <a class="source" href="newtag-it.html">
                  newtag-it.js
                </a>
              
                
                <a class="source" href="ng-sortable.html">
                  ng-sortable.js
                </a>
              
                
                <a class="source" href="page_title.html">
                  page_title.js
                </a>
              
                
                <a class="source" href="popover.html">
                  popover.js
                </a>
              
                
                <a class="source" href="popovers.html">
                  popovers.js
                </a>
              
                
                <a class="source" href="popupdivs14.html">
                  popupdivs14.js
                </a>
              
                
                <a class="source" href="popups.html">
                  popups.js
                </a>
              
                
                <a class="source" href="prism.html">
                  prism.js
                </a>
              
                
                <a class="source" href="prototype.effects.html">
                  prototype.effects.js
                </a>
              
                
                <a class="source" href="prototype.hidefix.html">
                  prototype.hidefix.js
                </a>
              
                
                <a class="source" href="prototype.html">
                  prototype.js
                </a>
              
                
                <a class="source" href="prototype.plugin.html">
                  prototype.plugin.js
                </a>
              
                
                <a class="source" href="prototype.template.html">
                  prototype.template.js
                </a>
              
                
                <a class="source" href="provider.lazyloader.html">
                  provider.lazyloader.js
                </a>
              
                
                <a class="source" href="provider.linkContentTypes.html">
                  provider.linkContentTypes.js
                </a>
              
                
                <a class="source" href="scoped_object_generators.html">
                  scoped_object_generators.js
                </a>
              
                
                <a class="source" href="scrollable.html">
                  scrollable.js
                </a>
              
                
                <a class="source" href="scrollspy.html">
                  scrollspy.js
                </a>
              
                
                <a class="source" href="section.html">
                  section.js
                </a>
              
                
                <a class="source" href="select2.html">
                  select2.js
                </a>
              
                
                <a class="source" href="selects.html">
                  selects.js
                </a>
              
                
                <a class="source" href="service.AMB.html">
                  service.AMB.js
                </a>
              
                
                <a class="source" href="service.authInterceptor.html">
                  service.authInterceptor.js
                </a>
              
                
                <a class="source" href="service.avatarProfilePersister.html">
                  service.avatarProfilePersister.js
                </a>
              
                
                <a class="source" href="service.dateUtils.html">
                  service.dateUtils.js
                </a>
              
                
                <a class="source" href="service.debounceFn.html">
                  service.debounceFn.js
                </a>
              
                
                <a class="source" href="service.filterExpressionParser.html">
                  service.filterExpressionParser.js
                </a>
              
                
                <a class="source" href="service.getTemplateUrl.html">
                  service.getTemplateUrl.js
                </a>
              
                
                <a class="source" href="service.guidedToursService.html">
                  service.guidedToursService.js
                </a>
              
                
                <a class="source" href="service.i18n.html">
                  service.i18n.js
                </a>
              
                
                <a class="source" href="service.md5.html">
                  service.md5.js
                </a>
              
                
                <a class="source" href="service.nowServer.html">
                  service.nowServer.js
                </a>
              
                
                <a class="source" href="service.nowStream.html">
                  service.nowStream.js
                </a>
              
                
                <a class="source" href="service.priorityQueue.html">
                  service.priorityQueue.js
                </a>
              
                
                <a class="source" href="service.progressDialog.html">
                  service.progressDialog.js
                </a>
              
                
                <a class="source" href="service.queryFilter.html">
                  service.queryFilter.js
                </a>
              
                
                <a class="source" href="service.snComplexPopoverService.html">
                  service.snComplexPopoverService.js
                </a>
              
                
                <a class="source" href="service.snConnect.html">
                  service.snConnect.js
                </a>
              
                
                <a class="source" href="service.snCustomEvent.html">
                  service.snCustomEvent.js
                </a>
              
                
                <a class="source" href="service.snMention.html">
                  service.snMention.js
                </a>
              
                
                <a class="source" href="service.snNotification.html">
                  service.snNotification.js
                </a>
              
                
                <a class="source" href="service.snNotifier.html">
                  service.snNotifier.js
                </a>
              
                
                <a class="source" href="service.snResource.html">
                  service.snResource.js
                </a>
              
                
                <a class="source" href="service.snTabActivity.html">
                  service.snTabActivity.js
                </a>
              
                
                <a class="source" href="service.spCommunicator.html">
                  service.spCommunicator.js
                </a>
              
                
                <a class="source" href="service.spFileSelect.html">
                  service.spFileSelect.js
                </a>
              
                
                <a class="source" href="service.spModal.html">
                  service.spModal.js
                </a>
              
                
                <a class="source" href="service.spUtil.html">
                  service.spUtil.js
                </a>
              
                
                <a class="source" href="service.urlTools.html">
                  service.urlTools.js
                </a>
              
                
                <a class="source" href="service.userPreferences.html">
                  service.userPreferences.js
                </a>
              
                
                <a class="source" href="simpleStorage.html">
                  simpleStorage.js
                </a>
              
                
                <a class="source" href="snPolyfill.html">
                  snPolyfill.js
                </a>
              
                
                <a class="source" href="snPopover.html">
                  snPopover.js
                </a>
              
                
                <a class="source" href="snTimeAgoSettings.html">
                  snTimeAgoSettings.js
                </a>
              
                
                <a class="source" href="snm.auth.data.module.html">
                  snm.auth.data.module.js
                </a>
              
                
                <a class="source" href="snm.serviceCatalog.data.shim.html">
                  snm.serviceCatalog.data.shim.js
                </a>
              
                
                <a class="source" href="snm.serviceCatalog.form.module.html">
                  snm.serviceCatalog.form.module.js
                </a>
              
                
                <a class="source" href="sp.geo.html">
                  sp.geo.js
                </a>
              
                
                <a class="source" href="streamButton.html">
                  streamButton.js
                </a>
              
                
                <a class="source" href="tables.html">
                  tables.js
                </a>
              
                
                <a class="source" href="tabs.html">
                  tabs.js
                </a>
              
                
                <a class="source" href="tabs2_14.html">
                  tabs2_14.js
                </a>
              
                
                <a class="source" href="templates.html">
                  templates.js
                </a>
              
                
                <a class="source" href="textutil.html">
                  textutil.js
                </a>
              
                
                <a class="source" href="timeAgo.html">
                  timeAgo.js
                </a>
              
                
                <a class="source" href="tooltip.html">
                  tooltip.js
                </a>
              
                
                <a class="source" href="tooltips.html">
                  tooltips.js
                </a>
              
                
                <a class="source" href="transaction_scope_includes.html">
                  transaction_scope_includes.js
                </a>
              
                
                <a class="source" href="transition.html">
                  transition.js
                </a>
              
                
                <a class="source" href="ui-bootstrap-tpls-1.1.2.html">
                  ui-bootstrap-tpls-1.1.2.js
                </a>
              
                
                <a class="source" href="uiPolicyFactory.html">
                  uiPolicyFactory.js
                </a>
              
                
                <a class="source" href="uiPolicyTypes.html">
                  uiPolicyTypes.js
                </a>
              
                
                <a class="source" href="ui_policy.html">
                  ui_policy.js
                </a>
              
                
                <a class="source" href="utils14.html">
                  utils14.js
                </a>
              
                
                <a class="source" href="viewLayout.html">
                  viewLayout.js
                </a>
              
                
                <a class="source" href="xmlUtil.html">
                  xmlUtil.js
                </a>
              
                
                <a class="source" href="xmlhttp.html">
                  xmlhttp.js
                </a>
              
                
                <a class="source" href="z_last_include.html">
                  z_last_include.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>js_includes_sp_deps.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>/*! RESOURCE: /scripts/js_includes_sp_deps.js */
/*! RESOURCE: /scripts/lib/jquery/jquery-2.1.js */
(function(global, factory) {
  if (typeof module === "object" &amp;&amp; typeof module.exports === "object") {
    module.exports = global.document ?
      factory(global, true) :
      function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var
    document = window.document,
    version = "2.1.4",
    jQuery = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    },
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,
    fcamelCase = function(all, letter) {
      return letter.toUpperCase();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ?
        (num &lt; 0 ? this[num + this.length] : this[num]) :
        slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
        j = +i + (i &lt; 0 ? len : 0);
      return this.pushStack(j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" &amp;&amp; !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i &lt; length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src &amp;&amp; jQuery.isArray(src) ? src : [];
            } else {
              clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null &amp;&amp; obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) &amp;&amp; (obj - parseFloat(obj) + 1) &gt;= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor &amp;&amp;
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
    },
    globalEval: function(code) {
      var script,
        indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i &lt; length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i &lt; length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ?
        "" :
        (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret,
            typeof arr === "string" ? [arr] : arr
          );
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;
      for (; j &lt; len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;
      for (; i &lt; length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike(elems),
        ret = [];
      if (isArray) {
        for (; i &lt; length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArraylike(obj) {
    var length = "length" in obj &amp;&amp; obj.length,
      type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 &amp;&amp; length) {
      return true;
    }
    return type === "array" || length === 0 ||
      typeof length === "number" &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj;
  }
  var Sizzle =
    (function(window) {
      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 &lt;&lt; 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
            len = list.length;
          for (; i &lt; len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
        "*([*^$|!~]?=)" + whitespace +
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
        "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" +
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
        ".*" +
        ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([&gt;+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ?
            escaped :
            high &lt; 0 ?
            String.fromCharCode(high + 0x10000) :
            String.fromCharCode(high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ?
            function(target, els) {
              push_native.apply(target, slice.call(els));
            } : function(target, els) {
              var j = target.length,
                i = 0;
              while ((target[j++] = els[i++])) {}
              target.length = j - 1;
            }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var match, elem, m, nodeType,
          i, groups, old, nid, newContext, newSelector;
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        results = results || [];
        nodeType = context.nodeType;
        if (typeof selector !== "string" || !selector ||
          nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11) {
          return results;
        }
        if (!seed &amp;&amp; documentIsHTML) {
          if (nodeType !== 11 &amp;&amp; (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                elem = context.getElementById(m);
                if (elem &amp;&amp; elem.parentNode) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById(m)) &amp;&amp;
                  contains(context, elem) &amp;&amp; elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) &amp;&amp; support.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType !== 1 &amp;&amp; selector;
            if (nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== "object") {
              groups = tokenize(selector);
              if ((old = context.getAttribute("id"))) {
                nid = old.replace(rescape, "\\$&amp;");
              } else {
                context.setAttribute("id", nid);
              }
              nid = "[id='" + nid + "'] ";
              i = groups.length;
              while (i--) {
                groups[i] = nid + toSelector(groups[i]);
              }
              newContext = rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context;
              newSelector = groups.join(",");
            }
            if (newSelector) {
              try {
                push.apply(results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {} finally {
                if (!old) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }

      function createCache() {
        var keys = [];

        function cache(key, value) {
          if (keys.push(key + " ") &gt; Expr.cacheLength) {
            delete cache[keys.shift()];
          }
          return (cache[key + " "] = value);
        }
        return cache;
      }

      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      function assert(fn) {
        var div = document.createElement("div");
        try {
          return !!fn(div);
        } catch (e) {
          return false;
        } finally {
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
          div = null;
        }
      }

      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
          i = attrs.length;
        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }

      function siblingCheck(a, b) {
        var cur = b &amp;&amp; a,
          diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
          (~b.sourceIndex || MAX_NEGATIVE) -
          (~a.sourceIndex || MAX_NEGATIVE);
        if (diff) {
          return diff;
        }
        if (cur) {
          while ((cur = cur.nextSibling)) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }

      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" &amp;&amp; elem.type === type;
        };
      }

      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") &amp;&amp; elem.type === type;
        };
      }

      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
            while (i--) {
              if (seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      function testContext(context) {
        return context &amp;&amp; typeof context.getElementsByTagName !== "undefined" &amp;&amp; context;
      }
      support = Sizzle.support = {};
      isXML = Sizzle.isXML = function(elem) {
        var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare, parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }
        document = doc;
        docElem = doc.documentElement;
        parent = doc.defaultView;
        if (parent &amp;&amp; parent !== parent.top) {
          if (parent.addEventListener) {
            parent.addEventListener("unload", unloadHandler, false);
          } else if (parent.attachEvent) {
            parent.attachEvent("onunload", unloadHandler);
          }
        }
        documentIsHTML = !isXML(doc);
        support.attributes = assert(function(div) {
          div.className = "i";
          return !div.getAttribute("className");
        });
        support.getElementsByTagName = assert(function(div) {
          div.appendChild(doc.createComment(""));
          return !div.getElementsByTagName("*").length;
        });
        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
        support.getById = assert(function(div) {
          docElem.appendChild(div).id = expando;
          return !doc.getElementsByName || !doc.getElementsByName(expando).length;
        });
        if (support.getById) {
          Expr.find["ID"] = function(id, context) {
            if (typeof context.getElementById !== "undefined" &amp;&amp; documentIsHTML) {
              var m = context.getElementById(id);
              return m &amp;&amp; m.parentNode ? [m] : [];
            }
          };
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
        } else {
          delete Expr.find["ID"];
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node = typeof elem.getAttributeNode !== "undefined" &amp;&amp; elem.getAttributeNode("id");
              return node &amp;&amp; node.value === attrId;
            };
          };
        }
        Expr.find["TAG"] = support.getElementsByTagName ?
          function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          } :
          function(tag, context) {
            var elem,
              tmp = [],
              i = 0,
              results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while ((elem = results[i++])) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
        Expr.find["CLASS"] = support.getElementsByClassName &amp;&amp; function(className, context) {
          if (documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if ((support.qsa = rnative.test(doc.querySelectorAll))) {
          assert(function(div) {
            docElem.appendChild(div).innerHTML = "&lt;a id='" + expando + "'&gt;&lt;/a&gt;" +
              "&lt;select id='" + expando + "-\f]' msallowcapture=''&gt;" +
              "&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;";
            if (div.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }
            if (!div.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!div.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            if (!div.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function(div) {
            var input = doc.createElement("input");
            input.setAttribute("type", "hidden");
            div.appendChild(input).setAttribute("name", "D");
            if (div.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }
            if (!div.querySelectorAll(":enabled").length) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
            docElem.webkitMatchesSelector ||
            docElem.mozMatchesSelector ||
            docElem.oMatchesSelector ||
            docElem.msMatchesSelector)))) {
          assert(function(div) {
            support.disconnectedMatch = matches.call(div, "div");
            matches.call(div, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains = hasCompare || rnative.test(docElem.contains) ?
          function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b &amp;&amp; b.parentNode;
            return a === bup || !!(bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
              adown.contains ?
              adown.contains(bup) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; 16
            ));
          } :
          function(a, b) {
            if (b) {
              while ((b = b.parentNode)) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
        sortOrder = hasCompare ?
          function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
              a.compareDocumentPosition(b) :
              1;
            if (compare &amp; 1 ||
              (!support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare)) {
              if (a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a)) {
                return -1;
              }
              if (b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;
            }
            return compare &amp; 4 ? -1 : 1;
          } :
          function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b];
            if (!aup || !bup) {
              return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while ((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while ((cur = cur.parentNode)) {
              bp.unshift(cur);
            }
            while (ap[i] === bp[i]) {
              i++;
            }
            return i ?
              siblingCheck(ap[i], bp[i]) :
              ap[i] === preferredDoc ? -1 :
              bp[i] === preferredDoc ? 1 :
              0;
          };
        return doc;
      };
      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };
      Sizzle.matchesSelector = function(elem, expr) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        expr = expr.replace(rattributeQuotes, "='$1']");
        if (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
          (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp;
          (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support.disconnectedMatch ||
              elem.document &amp;&amp; elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }
        return Sizzle(expr, document, null, [elem]).length &gt; 0;
      };
      Sizzle.contains = function(context, elem) {
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle.attr = function(elem, name) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
          fn(elem, name, !documentIsHTML) :
          undefined;
        return val !== undefined ?
          val :
          support.attributes || !documentIsHTML ?
          elem.getAttribute(name) :
          (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
          val.value :
          null;
      };
      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle.uniqueSort = function(results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable &amp;&amp; results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while ((elem = results[i++])) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle.getText = function(elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
        if (!nodeType) {
          while ((node = elem[i++])) {
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          "&gt;": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function(match) {
            match[1] = match[1].replace(runescape, funescape);
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
          },
          "CHILD": function(match) {
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
              if (!match[3]) {
                Sizzle.error(match[0]);
              }
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +((match[7] + match[8]) || match[3] === "odd");
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }
            return match;
          },
          "PSEUDO": function(match) {
            var excess,
              unquoted = !match[6] &amp;&amp; match[2];
            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }
            if (match[3]) {
              match[2] = match[4] || match[5] || "";
            } else if (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp;
              (excess = tokenize(unquoted, true)) &amp;&amp;
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ?
              function() {
                return true;
              } :
              function(elem) {
                return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
              };
          },
          "CLASS": function(className) {
            var pattern = classCache[className + " "];
            return pattern ||
              (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &amp;&amp;
              classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" &amp;&amp; elem.className || typeof elem.getAttribute !== "undefined" &amp;&amp; elem.getAttribute("class") || "");
              });
          },
          "ATTR": function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check :
                operator === "!=" ? result !== check :
                operator === "^=" ? check &amp;&amp; result.indexOf(check) === 0 :
                operator === "*=" ? check &amp;&amp; result.indexOf(check) &gt; -1 :
                operator === "$=" ? check &amp;&amp; result.slice(-check.length) === check :
                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) &gt; -1 :
                operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                false;
            };
          },
          "CHILD": function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
            return first === 1 &amp;&amp; last === 0 ?
              function(elem) {
                return !!elem.parentNode;
              } :
              function(elem, context, xml) {
                var cache, outerCache, node, diff, nodeIndex, start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
                  useCache = !xml &amp;&amp; !ofType;
                if (parent) {
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir = type === "only" &amp;&amp; !start &amp;&amp; "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward &amp;&amp; useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
                    diff = cache[0] === dirruns &amp;&amp; cache[2];
                    node = nodeIndex &amp;&amp; parent.childNodes[nodeIndex];
                    while ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {
                      if (node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else if (useCache &amp;&amp; (cache = (elem[expando] || (elem[expando] = {}))[type]) &amp;&amp; cache[0] === dirruns) {
                    diff = cache[1];
                  } else {
                    while ((node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) &amp;&amp; ++diff) {
                        if (useCache) {
                          (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || (diff % first === 0 &amp;&amp; diff / first &gt;= 0);
                }
              };
          },
          "PSEUDO": function(pseudo, argument) {
            var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
              Sizzle.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length &gt; 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                markFunction(function(seed, matches) {
                  var idx,
                    matched = fn(seed, argument),
                    i = matched.length;
                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) :
                function(elem) {
                  return fn(elem, 0, args);
                };
            }
            return fn;
          }
        },
        pseudos: {
          "not": markFunction(function(selector) {
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ?
              markFunction(function(seed, matches, context, xml) {
                var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length;
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) :
              function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
          }),
          "has": markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length &gt; 0;
            };
          }),
          "contains": markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) &gt; -1;
            };
          }),
          "lang": markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if ((elemLang = documentIsHTML ?
                    elem.lang :
                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) &amp;&amp; elem.nodeType === 1);
              return false;
            };
          }),
          "target": function(elem) {
            var hash = window.location &amp;&amp; window.location.hash;
            return hash &amp;&amp; hash.slice(1) === elem.id;
          },
          "root": function(elem) {
            return elem === docElem;
          },
          "focus": function(elem) {
            return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
          },
          "enabled": function(elem) {
            return elem.disabled === false;
          },
          "disabled": function(elem) {
            return elem.disabled === true;
          },
          "checked": function(elem) {
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" &amp;&amp; !!elem.checked) || (nodeName === "option" &amp;&amp; !!elem.selected);
          },
          "selected": function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          "empty": function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType &lt; 6) {
                return false;
              }
            }
            return true;
          },
          "parent": function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          "header": function(elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function(elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" &amp;&amp; elem.type === "button" || name === "button";
          },
          "text": function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &amp;&amp;
              elem.type === "text" &amp;&amp;
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          "first": createPositionalPseudo(function() {
            return [0];
          }),
          "last": createPositionalPseudo(function(matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
            return [argument &lt; 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for (; i &lt; length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for (; i &lt; length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument &lt; 0 ? argument + length : argument;
            for (; --i &gt;= 0;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument &lt; 0 ? argument + length : argument;
            for (; ++i &lt; length;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in {
          submit: true,
          reset: true
        }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[selector + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }
          matched = false;
          if ((match = rcombinators.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] ||
                (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ?
          soFar.length :
          soFar ?
          Sizzle.error(selector) :
          tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for (; i &lt; len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          checkNonElements = base &amp;&amp; dir === "parentNode",
          doneName = done++;
        return combinator.first ?
          function(elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          } :
          function(elem, context, xml) {
            var oldCache, outerCache,
              newCache = [dirruns, doneName];
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if ((oldCache = outerCache[dir]) &amp;&amp;
                    oldCache[0] === dirruns &amp;&amp; oldCache[1] === doneName) {
                    return (newCache[2] = oldCache[2]);
                  } else {
                    outerCache[dir] = newCache;
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
      }

      function elementMatcher(matchers) {
        return matchers.length &gt; 1 ?
          function(elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } :
          matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for (; i &lt; len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
        for (; i &lt; len; i++) {
          if ((elem = unmatched[i])) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }
        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter &amp;&amp; !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder &amp;&amp; !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter &amp;&amp; (seed || !selector) ?
            condense(elems, preMap, preFilter, context, xml) :
            elems,
            matcherOut = matcher ?
            postFinder || (seed ? preFilter : preexisting || postFilter) ? [] :
            results :
            matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            i = temp.length;
            while (i--) {
              if ((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i])) {
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) &amp;&amp;
                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) &gt; -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(
              matcherOut === results ?
              matcherOut.splice(preexisting, matcherOut.length) :
              matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) &gt; -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative &amp;&amp; (xml || context !== outermostContext)) || (
              (checkContext = context).nodeType ?
              matchContext(elem, context, xml) :
              matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
        for (; i &lt; len; i++) {
          if ((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
            if (matcher[expando]) {
              j = ++i;
              for (; j &lt; len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i &gt; 1 &amp;&amp; elementMatcher(matchers),
                i &gt; 1 &amp;&amp; toSelector(
                  tokens.slice(0, i - 1).concat({
                    value: tokens[i - 2].type === " " ? "*" : ""
                  })
                ).replace(rtrim, "$1"),
                matcher,
                i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)),
                j &lt; len &amp;&amp; matcherFromTokens((tokens = tokens.slice(j))),
                j &lt; len &amp;&amp; toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length &gt; 0,
          byElement = elementMatchers.length &gt; 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed &amp;&amp; [],
              setMatched = [],
              contextBackup = outermostContext,
              elems = seed || byElement &amp;&amp; Expr.find["TAG"]("*", outermost),
              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;
            if (outermost) {
              outermostContext = context !== document &amp;&amp; context;
            }
            for (; i !== len &amp;&amp; (elem = elems[i]) != null; i++) {
              if (byElement &amp;&amp; elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher &amp;&amp; elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet &amp;&amp; i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount &gt; 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
                (matchedCount + setMatchers.length) &gt; 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
        return bySet ?
          markFunction(superMatcher) :
          superMatcher;
      }
      compile = Sizzle.compile = function(selector, match) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
        if (!cached) {
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
          cached.selector = selector;
        }
        return cached;
      };
      select = Sizzle.select = function(selector, context, results, seed) {
        var i, tokens, token, type, find,
          compiled = typeof selector === "function" &amp;&amp; selector,
          match = !seed &amp;&amp; tokenize((selector = compiled.selector || selector));
        results = results || [];
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === "ID" &amp;&amp;
            support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp;
            Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {
              if ((seed = find(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) &amp;&amp; testContext(context.parentNode) || context
                ))) {
                tokens.splice(i, 1);
                selector = seed.length &amp;&amp; toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile(selector, match))(
          seed,
          context, !documentIsHTML,
          results,
          rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context
        );
        return results;
      };
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support.detectDuplicates = !!hasDuplicate;
      setDocument();
      support.sortDetached = assert(function(div1) {
        return div1.compareDocumentPosition(document.createElement("div")) &amp; 1;
      });
      if (!assert(function(div) {
          div.innerHTML = "&lt;a href='#'&gt;&lt;/a&gt;";
          return div.firstChild.getAttribute("href") === "#";
        })) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support.attributes || !assert(function(div) {
          div.innerHTML = "&lt;input/&gt;";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
        addHandle("value", function(elem, name, isXML) {
          if (!isXML &amp;&amp; elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() :
              (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
              val.value :
              null;
          }
        });
      }
      return Sizzle;
    })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;

  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) &gt;= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 &amp;&amp; elem.nodeType === 1 ?
      jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
      jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
        return elem.nodeType === 1;
      }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
        len = this.length,
        ret = [],
        self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i &lt; len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i &lt; len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len &gt; 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(
        this,
        typeof selector === "string" &amp;&amp; rneedsContext.test(selector) ?
        jQuery(selector) :
        selector || [],
        false
      ).length;
    }
  });
  var rootjQuery,
    rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,
    init = jQuery.fn.init = function(selector, context) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === "string") {
        if (selector[0] === "&lt;" &amp;&amp; selector[selector.length - 1] === "&gt;" &amp;&amp; selector.length &gt;= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match &amp;&amp; (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(
              match[1],
              context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
              true
            ));
            if (rsingleTag.test(match[1]) &amp;&amp; jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem &amp;&amp; elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return typeof rootjQuery.ready !== "undefined" ?
          rootjQuery.ready(selector) :
          selector(jQuery);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
        truncate = until !== undefined;
      while ((elem = elem[dir]) &amp;&amp; elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate &amp;&amp; jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 &amp;&amp; n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
        l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i &lt; l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
        jQuery(selectors, context || this.context) :
        0;
      for (; i &lt; l; i++) {
        for (cur = this[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode) {
          if (cur.nodeType &lt; 11 &amp;&amp; (pos ?
              pos.index(cur) &gt; -1 :
              cur.nodeType === 1 &amp;&amp;
              jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length &gt; 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] &amp;&amp; this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this,
        elem.jquery ? elem[0] : elem
      );
    },
    add: function(selector, context) {
      return this.pushStack(
        jQuery.unique(
          jQuery.merge(this.get(), jQuery(selector, context))
        )
      );
    },
    addBack: function(selector) {
      return this.add(selector == null ?
        this.prevObject : this.prevObject.filter(selector)
      );
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) &amp;&amp; cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector &amp;&amp; typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length &gt; 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};

  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ?
      (optionsCache[options] || createOptions(options)) :
      jQuery.extend({}, options);
    var
      memory,
      fired,
      firing,
      firingStart,
      firingLength,
      firingIndex,
      list = [],
      stack = !options.once &amp;&amp; [],
      fire = function(data) {
        memory = options.memory &amp;&amp; data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false &amp;&amp; options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      self = {
        add: function() {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function(_, arg) {
                var type = jQuery.type(arg);
                if (type === "function") {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg &amp;&amp; arg.length &amp;&amp; type !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function() {
          if (list) {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) &gt; -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index &lt;= firingLength) {
                    firingLength--;
                  }
                  if (index &lt;= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) &gt; -1 : !!(list &amp;&amp; list.length);
        },
        empty: function() {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function() {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function() {
          return !list;
        },
        lock: function() {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function() {
          return !stack;
        },
        fireWith: function(context, args) {
          if (list &amp;&amp; (!fired || stack)) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function() {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function() {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [
          ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
          ["notify", "progress", jQuery.Callbacks("memory")]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(i, tuple) {
                var fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];
                deferred[tuple[1]](function() {
                  var returned = fn &amp;&amp; fn.apply(this, arguments);
                  if (returned &amp;&amp; jQuery.isFunction(returned.promise)) {
                    returned.promise()
                      .done(newDefer.resolve)
                      .fail(newDefer.reject)
                      .progress(newDefer.notify);
                  } else {
                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
        deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
          stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
        resolveValues = slice.call(arguments),
        length = resolveValues.length,
        remaining = length !== 1 || (subordinate &amp;&amp; jQuery.isFunction(subordinate.promise)) ? length : 0,
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        updateFunc = function(i, contexts, values) {
          return function(value) {
            contexts[i] = this;
            values[i] = arguments.length &gt; 1 ? slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!(--remaining)) {
              deferred.resolveWith(contexts, values);
            }
          };
        },
        progressValues, progressContexts, resolveContexts;
      if (length &gt; 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i &lt; length; i++) {
          if (resolveValues[i] &amp;&amp; jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise()
              .done(updateFunc(i, resolveContexts, resolveValues))
              .fail(deferred.reject)
              .progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true &amp;&amp; --jQuery.readyWait &gt; 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i &lt; len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ?
      elems :
      bulk ?
      fn.call(elems) :
      len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };

  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function() {
        return {};
      }
    });
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
        unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {
            value: unlock
          };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ?
        cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined ||
        ((key &amp;&amp; typeof key === "string") &amp;&amp; value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ?
          stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i, name, camel,
        unlock = this.key(owner),
        cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(
        this.cache[owner[this.expando]] || {}
      );
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined &amp;&amp; elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true :
            data === "false" ? false :
            data === "null" ? null :
            +data + "" === data ? +data :
            rbrace.test(data) ? jQuery.parseJSON(data) :
            data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i, name, data,
        elem = this[0],
        attrs = elem &amp;&amp; elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 &amp;&amp; !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
          camelKey = jQuery.camelCase(key);
        if (elem &amp;&amp; value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 &amp;&amp; data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length &gt; 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function() {
          jQuery.dequeue(elem, type);
        };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength &amp;&amp; hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length &lt; setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ?
        this :
        this.each(function() {
          var queue = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" &amp;&amp; queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
          if (!(--count)) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp &amp;&amp; tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "&lt;textarea&gt;x&lt;/textarea&gt;";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp,
        events, t, handleObj,
        special, handlers, type, namespaces, origType,
        elemData = data_priv.hasData(elem) &amp;&amp; data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] &amp;&amp; new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) &amp;&amp;
            (!handler || handler.guid === handleObj.guid) &amp;&amp;
            (!tmp || tmp.test(handleObj.namespace)) &amp;&amp;
            (!selector || selector === handleObj.selector || selector === "**" &amp;&amp; handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount &amp;&amp; !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") &gt;= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") &lt; 0 &amp;&amp; "on" + type;
      event = event[jQuery.expando] ?
        event :
        new jQuery.Event(type, typeof event === "object" &amp;&amp; event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ?
        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
        null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] :
        jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped()) {
        event.type = i &gt; 1 ?
          bubbleType :
          special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] &amp;&amp; data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype &amp;&amp; cur[ontype];
        if (handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers &amp;&amp; !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &amp;&amp;
          jQuery.acceptData(elem)) {
          if (ontype &amp;&amp; jQuery.isFunction(elem[type]) &amp;&amp; !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj,
        handlerQueue = [],
        args = slice.call(arguments),
        handlers = (data_priv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch &amp;&amp; special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) &amp;&amp; !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) &amp;&amp; !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
              .apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i, matches, sel, handleObj,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;
      if (delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i &lt; delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ?
                  jQuery(sel, this).index(cur) &gt;= 0 :
                  jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount &lt; handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc, doc, body,
          button = original.button;
        if (event.pageX == null &amp;&amp; original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);
          event.pageY = original.clientY + (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0) - (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0);
        }
        if (!event.which &amp;&amp; button !== undefined) {
          event.which = (button &amp; 1 ? 1 : (button &amp; 2 ? 3 : (button &amp; 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy,
        type = event.type,
        originalEvent = event,
        fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook =
          rmouseEvent.test(type) ? this.mouseHooks :
          rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {
        noBubble: true
      },
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() &amp;&amp; this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() &amp;&amp; this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" &amp;&amp; this.click &amp;&amp; jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function(event) {
          if (event.result !== undefined &amp;&amp; event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(
        new jQuery.Event(),
        event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        }
      );
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src &amp;&amp; src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &amp;&amp;
        src.returnValue === false ?
        returnTrue :
        returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e &amp;&amp; e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e &amp;&amp; e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e &amp;&amp; e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;
        if (!related || (related !== target &amp;&amp; !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
            attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null &amp;&amp; fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj, type;
      if (types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var
    rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
    rtagName = /&lt;([\w:]+)/,
    rhtml = /&lt;|&amp;#?\w+;/,
    rnoInnerhtml = /&lt;(?:script|style|link)/i,
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,
    wrapMap = {
      option: [1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;"],
      thead: [1, "&lt;table&gt;", "&lt;/table&gt;"],
      col: [2, "&lt;table&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;"],
      tr: [2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;"],
      td: [3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"],
      _default: [0, "", ""]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") &amp;&amp;
      jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?
      elem.getElementsByTagName("tbody")[0] ||
      elem.appendChild(elem.ownerDocument.createElement("tbody")) :
      elem;
  }

  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }

  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;
    for (; i &lt; l; i++) {
      data_priv.set(
        elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval")
      );
    }
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i &lt; l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }

  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") :
      context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag &amp;&amp; jQuery.nodeName(context, tag) ?
      jQuery.merge([context], ret) :
      ret;
  }

  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" &amp;&amp; rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked &amp;&amp; (elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp;
        !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i &lt; l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i &lt; l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length &gt; 0) {
        setGlobalEval(destElements, !inPage &amp;&amp; getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
      for (; i &lt; l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "&lt;$1&gt;&lt;/$2&gt;") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection &amp;&amp; jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data, elem, type, key,
        special = jQuery.event.special,
        i = 0;
      for (;
        (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key &amp;&amp; (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ?
          jQuery.text(this) :
          this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
        elems = selector ? jQuery.filter(selector, this) : this,
        i = 0;
      for (;
        (elem = elems[i]) != null; i++) {
        if (!keepData &amp;&amp; elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData &amp;&amp; jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
        i = 0;
      for (;
        (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
          i = 0,
          l = this.length;
        if (value === undefined &amp;&amp; elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" &amp;&amp; !rnoInnerhtml.test(value) &amp;&amp;
          !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "&lt;$1&gt;&lt;/$2&gt;");
          try {
            for (; i &lt; l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg &amp;&amp; (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc,
        i = 0,
        l = this.length,
        set = this,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
      if (isFunction ||
        (l &gt; 1 &amp;&amp; typeof value === "string" &amp;&amp;
          !support.checkClone &amp;&amp; rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i &lt; l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i &lt; hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") &amp;&amp;
                !data_priv.access(node, "globalEval") &amp;&amp; jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
        ret = [],
        insert = jQuery(selector),
        last = insert.length - 1,
        i = 0;
      for (; i &lt;= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
    elemdisplay = {};

  function actualDisplay(name, doc) {
    var style,
      elem = jQuery(doc.createElement(name)).appendTo(doc.body),
      display = window.getDefaultComputedStyle &amp;&amp; (style = window.getDefaultComputedStyle(elem[0])) ?
      style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }

  function defaultDisplay(nodeName) {
    var doc = document,
      display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("&lt;iframe frameborder='0' width='0' height='0'/&gt;")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };

  function curCSS(elem, name, computed) {
    var width, minWidth, maxWidth, ret,
      style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" &amp;&amp; !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) &amp;&amp; rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ?
      ret + "" :
      ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    return {
      get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }
  (function() {
    var pixelPositionVal, boxSizingReliableVal,
      docElem = document.documentElement,
      container = document.createElement("div"),
      div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
      "position:absolute";
    container.appendChild(div);

    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText =
        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
        "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
        "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
            marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
            "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret, name,
      old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
    rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
    cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    cssPrefixes = ["Webkit", "O", "Moz", "ms"];

  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
      origName = name,
      i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ?
      Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
      value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ?
      4 :
      name === "width" ? 1 : 0,
      val = 0;
    for (; i &lt; 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
      val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
      styles = getStyles(elem),
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val &lt;= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val &lt; 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox &amp;&amp;
        (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      )
    ) + "px";
  }

  function showHide(elements, show) {
    var display, elem, hidden,
      values = [],
      index = 0,
      length = elements.length;
    for (; index &lt; length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] &amp;&amp; display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" &amp;&amp; isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index &lt; length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks,
        origName = jQuery.camelCase(name),
        style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" &amp;&amp; (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number" &amp;&amp; !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle &amp;&amp; value === "" &amp;&amp; name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val, num, hooks,
        origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks &amp;&amp; "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" &amp;&amp; name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) &amp;&amp; elem.offsetWidth === 0 ?
            jQuery.swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, name, extra);
            }) :
            getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra &amp;&amp; getStyles(elem);
        return setPositiveNumber(elem, value, extra ?
          augmentWidthOrHeight(
            elem,
            name,
            extra,
            jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            styles
          ) : 0
        );
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
    function(elem, computed) {
      if (computed) {
        return jQuery.swap(elem, {
            "display": "inline-block"
          },
          curCSS, [elem, "marginRight"]);
      }
    }
  );
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function(value) {
        var i = 0,
          expanded = {},
          parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i &lt; 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] =
            parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles, len,
          map = {},
          i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i &lt; len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ?
          jQuery.style(elem, name, value) :
          jQuery.css(elem, name);
      }, name, value, arguments.length &gt; 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks &amp;&amp; hooks.get ?
        hooks.get(this) :
        Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent, this.options.duration * percent, 0, 1, this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks &amp;&amp; hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null &amp;&amp;
          (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style &amp;&amp; (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function(tween) {
      if (tween.elem.nodeType &amp;&amp; tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
    rrun = /queueHooks$/,
    animationPrefilters = [defaultPrefilter],
    tweeners = {
      "*": [function(prop, value) {
        var tween = this.createTween(prop, value),
          target = tween.cur(),
          parts = rfxnum.exec(value),
          unit = parts &amp;&amp; parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          start = (jQuery.cssNumber[prop] || unit !== "px" &amp;&amp; +target) &amp;&amp;
          rfxnum.exec(jQuery.css(tween.elem, prop)),
          scale = 1,
          maxIterations = 20;
        if (start &amp;&amp; start[3] !== unit) {
          unit = unit || start[3];
          parts = parts || [];
          start = +target || 1;
          do {
            scale = scale || ".5";
            start = start / scale;
            jQuery.style(tween.elem, prop, start + unit);
          } while (scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations);
        }
        if (parts) {
          start = tween.start = +start || +target || 0;
          tween.unit = unit;
          tween.end = parts[1] ?
            start + (parts[1] + 1) * parts[2] :
            +parts[2];
        }
        return tween;
      }]
    };

  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }

  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = {
        height: type
      };
    includeWidth = includeWidth ? 1 : 0;
    for (; i &lt; 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
      collection = (tweeners[prop] || []).concat(tweeners["*"]),
      index = 0,
      length = collection.length;
    for (; index &lt; length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType &amp;&amp; isHidden(elem),
      dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 &amp;&amp; ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ?
        data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" &amp;&amp; jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" &amp;&amp; dataShow &amp;&amp; dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow &amp;&amp; dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks &amp;&amp; "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = animationPrefilters.length,
      deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }),
      tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
        for (; index &lt; length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent &lt; 1 &amp;&amp; length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {}
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end,
            animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index = 0,
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index &lt; length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index &lt; length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      })
    );
    return animation.progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
        index = 0,
        length = props.length;
      for (; index &lt; length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed &amp;&amp; typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn &amp;&amp; easing ||
        jQuery.isFunction(speed) &amp;&amp; speed,
      duration: speed,
      easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction(easing) &amp;&amp; easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show()
        .end().animate({
          opacity: to
        }, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ?
        this.each(doAnimation) :
        this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue &amp;&amp; type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
          index = type != null &amp;&amp; type + "queueHooks",
          timers = jQuery.timers,
          data = data_priv.get(this);
        if (index) {
          if (data[index] &amp;&amp; data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] &amp;&amp; data[index].stop &amp;&amp; rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this &amp;&amp; (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
          data = data_priv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks &amp;&amp; hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this &amp;&amp; timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index &lt; length; index++) {
          if (queue[index] &amp;&amp; queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ?
        cssFn.apply(this, arguments) :
        this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
      i = 0,
      timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i &lt; timers.length; i++) {
      timer = timers[i];
      if (!timer() &amp;&amp; timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length &gt; 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks, ret,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks &amp;&amp; "set" in hooks &amp;&amp; (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ?
          undefined :
          ret;
      }
    },
    removeAttr: function(elem, value) {
      var name, propName,
        i = 0,
        attrNames = value &amp;&amp; value.match(rnotwhite);
      if (attrNames &amp;&amp; elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function(elem, value) {
          if (!support.radioValue &amp;&amp; value === "radio" &amp;&amp;
            jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    }
  });
  boolHook = {
    set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret, handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ?
          name.toLowerCase() :
          null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length &gt; 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret, hooks, notxml,
        nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks &amp;&amp; "set" in hooks &amp;&amp; (ret = hooks.set(elem, value, name)) !== undefined ?
          ret :
          (elem[name] = value);
      } else {
        return hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, name)) !== null ?
          ret :
          elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ?
            elem.tabIndex :
            -1;
        }
      }
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent &amp;&amp; parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
  ], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = typeof value === "string" &amp;&amp; value,
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i &lt; len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 &amp;&amp; (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            " "
          );
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") &lt; 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes, elem, cur, clazz, j, finalValue,
        proceed = arguments.length === 0 || typeof value === "string" &amp;&amp; value,
        i = 0,
        len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i &lt; len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 &amp;&amp; (elem.className ?
            (" " + elem.className + " ").replace(rclass, " ") :
            ""
          );
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") &gt;= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" &amp;&amp; type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
            i = 0,
            self = jQuery(this),
            classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
        i = 0,
        l = this.length;
      for (; i &lt; l; i++) {
        if (this[i].nodeType === 1 &amp;&amp; (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) &gt;= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function(value) {
      var hooks, ret, isFunction,
        elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ?
            ret.replace(rreturn, "") :
            ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ?
            val :
            jQuery.trim(jQuery.text(elem));
        }
      },
      select: {
        get: function(elem) {
          var value, option,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one" || index &lt; 0,
            values = one ? null : [],
            max = one ? index + 1 : options.length,
            i = index &lt; 0 ?
            max :
            one ? index : 0;
          for (; i &lt; max; i++) {
            option = options[i];
            if ((option.selected || i === index) &amp;&amp;
              (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &amp;&amp;
              (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet, option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) &gt;= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {
      set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) &gt;= 0);
        }
      }
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length &gt; 0 ?
        this.on(name, null, data, fn) :
        this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml, tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var
    rhash = /#.*$/,
    rts = /([?&amp;])_=[^&amp;]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    prefilters = {},
    transports = {},
    allTypes = "*/".concat("*"),
    ajaxLocation = window.location.href,
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
      seekingTransport = (structure === transports);

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" &amp;&amp; !seekingTransport &amp;&amp; !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] &amp;&amp; inspect("*");
  }

  function ajaxExtend(target, src) {
    var key, deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }

  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] &amp;&amp; contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev,
      converters = {},
      dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" &amp;&amp; prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] ||
                  converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv &amp;&amp; s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ?
        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
        ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
        cacheURL,
        responseHeadersString,
        responseHeaders,
        timeoutTimer,
        parts,
        fireGlobals,
        i,
        s = jQuery.ajaxSetup({}, options),
        callbackContext = s.context || s,
        globalEventContext = s.context &amp;&amp; (callbackContext.nodeType || callbackContext.jquery) ?
        jQuery(callbackContext) :
        jQuery.event,
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        statusCode = s.statusCode || {},
        requestHeaders = {},
        requestHeadersNames = {},
        state = 0,
        strAbort = "canceled",
        jqXHR = {
          readyState: 0,
          getResponseHeader: function(key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while ((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function() {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function(name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function(type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function(map) {
            var code;
            if (map) {
              if (state &lt; 2) {
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "")
        .replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts &amp;&amp;
          (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
            (parts[3] || (parts[1] === "http:" ? "80" : "443")) !==
            (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443")))
        );
      }
      if (s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event &amp;&amp; s.global;
      if (fireGlobals &amp;&amp; jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&amp;" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ?
            cacheURL.replace(rts, "$1_=" + nonce++) :
            cacheURL + (rquery.test(cacheURL) ? "&amp;" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] &amp;&amp; s.accepts[s.dataTypes[0]] ?
        s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
        s.accepts["*"]
      );
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend &amp;&amp; (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async &amp;&amp; s.timeout &gt; 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state &lt; 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }

      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified,
          statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status &gt; 0 ? 4 : 0;
        isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status &lt; 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
          contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth &lt;= 0 &amp;&amp; elem.offsetHeight &lt;= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional &amp;&amp; jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
      s = [],
      add = function(key, value) {
        value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery &amp;&amp; !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&amp;").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        })
        .filter(function() {
          var type = this.type;
          return this.name &amp;&amp; !jQuery(this).is(":disabled") &amp;&amp;
            rsubmittable.test(this.nodeName) &amp;&amp; !rsubmitterTypes.test(type) &amp;&amp;
            (this.checked || !rcheckableType.test(type));
        })
        .map(function(i, elem) {
          var val = jQuery(this).val();
          return val == null ?
            null :
            jQuery.isArray(val) ?
            jQuery.map(val, function(val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            }) : {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
        }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
    xhrCallbacks = {},
    xhrSuccessStatus = {
      0: 200,
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported &amp;&amp; ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported &amp;&amp; !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
            xhr = options.xhr(),
            id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType &amp;&amp; xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain &amp;&amp; !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(
                    xhr.status,
                    xhr.statusText
                  );
                } else {
                  complete(
                    xhrSuccessStatus[xhr.status] || xhr.status,
                    xhr.statusText,
                    typeof xhr.responseText === "string" ? {
                      text: xhr.responseText
                    } : undefined,
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent &amp;&amp; options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function(_, complete) {
          script = jQuery("&lt;script&gt;").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on(
            "load error",
            callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            }
          );
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&amp;|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer,
      jsonProp = s.jsonp !== false &amp;&amp; (rjsonp.test(s.url) ?
        "url" :
        typeof s.data === "string" &amp;&amp; !(s.contentType || "").indexOf("application/x-www-form-urlencoded") &amp;&amp; rjsonp.test(s.data) &amp;&amp; "data"
      );
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
        s.jsonpCallback() :
        s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&amp;" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer &amp;&amp; jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
      scripts = !keepScripts &amp;&amp; [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts &amp;&amp; scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" &amp;&amp; _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response,
      self = this,
      off = url.indexOf(" ");
    if (off &gt;= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params &amp;&amp; typeof params === "object") {
      type = "POST";
    }
    if (self.length &gt; 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ?
          jQuery("&lt;div&gt;").append(jQuery.parseHTML(responseText)).find(selector) :
          responseText);
      }).complete(callback &amp;&amp; function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;

  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
  }
  jQuery.offset = {
    setOffset: function(elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") &amp;&amp;
        (curCSSTop + curCSSLeft).indexOf("auto") &gt; -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ?
          this :
          this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
      }
      var docElem, win,
        elem = this[0],
        box = {
          top: 0,
          left: 0
        },
        doc = elem &amp;&amp; elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset,
        elem = this[0],
        parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent &amp;&amp; (!jQuery.nodeName(offsetParent, "html") &amp;&amp; jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset,
            top ? val : window.pageYOffset
          );
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
      function(elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop);
          return rnumnonpx.test(computed) ?
            jQuery(elem).position()[prop] + "px" :
            computed;
        }
      }
    );
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length &amp;&amp; (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(
              elem.body["scroll" + name], doc["scroll" + name],
              elem.body["offset" + name], doc["offset" + name],
              doc["client" + name]
            );
          }
          return value === undefined ?
            jQuery.css(elem, type, extra) :
            jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" &amp;&amp; define.amd) {
    define("jquery", [], function() {
      return jQuery;
    });
  }
  var
    _jQuery = window.jQuery,
    _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep &amp;&amp; window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));;
/*! RESOURCE: /scripts/angular_includes_no_min_1.5.3.js */
/*! RESOURCE: /scripts/angular_1.5.3/angular.js */
(function(window, document, undefined) {
  'use strict';

  function minErr(module, ErrorConstructor) {
    ErrorConstructor = ErrorConstructor || Error;
    return function() {
      var SKIP_INDEXES = 2;
      var templateArgs = arguments,
        code = templateArgs[0],
        message = '[' + (module ? module + ':' : '') + code + '] ',
        template = templateArgs[1],
        paramPrefix, i;
      message += template.replace(/\{\d+\}/g, function(match) {
        var index = +match.slice(1, -1),
          shiftedIndex = index + SKIP_INDEXES;
        if (shiftedIndex &lt; templateArgs.length) {
          return toDebugString(templateArgs[shiftedIndex]);
        }
        return match;
      });
      message += '\nhttp://errors.angularjs.org/1.5.3/' +
        (module ? module + '/' : '') + code;
      for (i = SKIP_INDEXES, paramPrefix = '?'; i &lt; templateArgs.length; i++, paramPrefix = '&amp;') {
        message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' +
          encodeURIComponent(toDebugString(templateArgs[i]));
      }
      return new ErrorConstructor(message);
    };
  }
  var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
  var VALIDITY_STATE_PROPERTY = 'validity';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var lowercase = function(string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function(string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function(s) {
    return isString(s) ?
      s.replace(/[A-Z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) | 32);
      }) :
      s;
  };
  var manualUppercase = function(s) {
    return isString(s) ?
      s.replace(/[a-z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) &amp; ~32);
      }) :
      s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var
    msie,
    jqLite,
    jQuery,
    slice = [].slice,
    splice = [].splice,
    push = [].push,
    toString = Object.prototype.toString,
    getPrototypeOf = Object.getPrototypeOf,
    ngMinErr = minErr('ng'),
    angular = window.angular || (window.angular = {}),
    angularModule,
    uid = 0;
  msie = document.documentMode;

  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) return false;
    if (isArray(obj) || isString(obj) || (jqLite &amp;&amp; obj instanceof jqLite)) return true;
    var length = "length" in Object(obj) &amp;&amp; obj.length;
    return isNumber(length) &amp;&amp;
      (length &gt;= 0 &amp;&amp; ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
  }

  function forEach(obj, iterator, context) {
    var key, length;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' &amp;&amp; key != 'length' &amp;&amp; key != 'name' &amp;&amp; (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (isArray(obj) || isArrayLike(obj)) {
        var isPrimitive = typeof obj !== 'object';
        for (key = 0, length = obj.length; key &lt; length; key++) {
          if (isPrimitive || key in obj) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else if (obj.forEach &amp;&amp; obj.forEach !== forEach) {
        obj.forEach(iterator, context, obj);
      } else if (isBlankObject(obj)) {
        for (key in obj) {
          iterator.call(context, obj[key], key, obj);
        }
      } else if (typeof obj.hasOwnProperty === 'function') {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      } else {
        for (key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            iterator.call(context, obj[key], key, obj);
          }
        }
      }
    }
    return obj;
  }

  function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort();
    for (var i = 0; i &lt; keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }

  function reverseParams(iteratorFn) {
    return function(value, key) {
      iteratorFn(key, value);
    };
  }

  function nextUid() {
    return ++uid;
  }

  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }

  function baseExtend(dst, objs, deep) {
    var h = dst.$$hashKey;
    for (var i = 0, ii = objs.length; i &lt; ii; ++i) {
      var obj = objs[i];
      if (!isObject(obj) &amp;&amp; !isFunction(obj)) continue;
      var keys = Object.keys(obj);
      for (var j = 0, jj = keys.length; j &lt; jj; j++) {
        var key = keys[j];
        var src = obj[key];
        if (deep &amp;&amp; isObject(src)) {
          if (isDate(src)) {
            dst[key] = new Date(src.valueOf());
          } else if (isRegExp(src)) {
            dst[key] = new RegExp(src);
          } else if (src.nodeName) {
            dst[key] = src.cloneNode(true);
          } else if (isElement(src)) {
            dst[key] = src.clone();
          } else {
            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
            baseExtend(dst[key], [src], true);
          }
        } else {
          dst[key] = src;
        }
      }
    }
    setHashKey(dst, h);
    return dst;
  }

  function extend(dst) {
    return baseExtend(dst, slice.call(arguments, 1), false);
  }

  function merge(dst) {
    return baseExtend(dst, slice.call(arguments, 1), true);
  }

  function toInt(str) {
    return parseInt(str, 10);
  }

  function inherit(parent, extra) {
    return extend(Object.create(parent), extra);
  }

  function noop() {}
  noop.$inject = [];

  function identity($) {
    return $;
  }
  identity.$inject = [];

  function valueFn(value) {
    return function valueRef() {
      return value;
    };
  }

  function hasCustomToString(obj) {
    return isFunction(obj.toString) &amp;&amp; obj.toString !== toString;
  }

  function isUndefined(value) {
    return typeof value === 'undefined';
  }

  function isDefined(value) {
    return typeof value !== 'undefined';
  }

  function isObject(value) {
    return value !== null &amp;&amp; typeof value === 'object';
  }

  function isBlankObject(value) {
    return value !== null &amp;&amp; typeof value === 'object' &amp;&amp; !getPrototypeOf(value);
  }

  function isString(value) {
    return typeof value === 'string';
  }

  function isNumber(value) {
    return typeof value === 'number';
  }

  function isDate(value) {
    return toString.call(value) === '[object Date]';
  }
  var isArray = Array.isArray;

  function isFunction(value) {
    return typeof value === 'function';
  }

  function isRegExp(value) {
    return toString.call(value) === '[object RegExp]';
  }

  function isWindow(obj) {
    return obj &amp;&amp; obj.window === obj;
  }

  function isScope(obj) {
    return obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;
  }

  function isFile(obj) {
    return toString.call(obj) === '[object File]';
  }

  function isFormData(obj) {
    return toString.call(obj) === '[object FormData]';
  }

  function isBlob(obj) {
    return toString.call(obj) === '[object Blob]';
  }

  function isBoolean(value) {
    return typeof value === 'boolean';
  }

  function isPromiseLike(obj) {
    return obj &amp;&amp; isFunction(obj.then);
  }
  var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;

  function isTypedArray(value) {
    return value &amp;&amp; isNumber(value.length) &amp;&amp; TYPED_ARRAY_REGEXP.test(toString.call(value));
  }

  function isArrayBuffer(obj) {
    return toString.call(obj) === '[object ArrayBuffer]';
  }
  var trim = function(value) {
    return isString(value) ? value.trim() : value;
  };
  var escapeForRegexp = function(s) {
    return s.replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, '\\$1').
    replace(/\x08/g, '\\x08');
  };

  function isElement(node) {
    return !!(node &amp;&amp;
      (node.nodeName ||
        (node.prop &amp;&amp; node.attr &amp;&amp; node.find)));
  }

  function makeMap(str) {
    var obj = {},
      items = str.split(','),
      i;
    for (i = 0; i &lt; items.length; i++) {
      obj[items[i]] = true;
    }
    return obj;
  }

  function nodeName_(element) {
    return lowercase(element.nodeName || (element[0] &amp;&amp; element[0].nodeName));
  }

  function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) != -1;
  }

  function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index &gt;= 0) {
      array.splice(index, 1);
    }
    return index;
  }

  function copy(source, destination) {
    var stackSource = [];
    var stackDest = [];
    if (destination) {
      if (isTypedArray(destination) || isArrayBuffer(destination)) {
        throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
      }
      if (source === destination) {
        throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
      }
      if (isArray(destination)) {
        destination.length = 0;
      } else {
        forEach(destination, function(value, key) {
          if (key !== '$$hashKey') {
            delete destination[key];
          }
        });
      }
      stackSource.push(source);
      stackDest.push(destination);
      return copyRecurse(source, destination);
    }
    return copyElement(source);

    function copyRecurse(source, destination) {
      var h = destination.$$hashKey;
      var key;
      if (isArray(source)) {
        for (var i = 0, ii = source.length; i &lt; ii; i++) {
          destination.push(copyElement(source[i]));
        }
      } else if (isBlankObject(source)) {
        for (key in source) {
          destination[key] = copyElement(source[key]);
        }
      } else if (source &amp;&amp; typeof source.hasOwnProperty === 'function') {
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      } else {
        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = copyElement(source[key]);
          }
        }
      }
      setHashKey(destination, h);
      return destination;
    }

    function copyElement(source) {
      if (!isObject(source)) {
        return source;
      }
      var index = stackSource.indexOf(source);
      if (index !== -1) {
        return stackDest[index];
      }
      if (isWindow(source) || isScope(source)) {
        throw ngMinErr('cpws',
          "Can't copy! Making copies of Window or Scope instances is not supported.");
      }
      var needsRecurse = false;
      var destination = copyType(source);
      if (destination === undefined) {
        destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
        needsRecurse = true;
      }
      stackSource.push(source);
      stackDest.push(destination);
      return needsRecurse ?
        copyRecurse(source, destination) :
        destination;
    }

    function copyType(source) {
      switch (toString.call(source)) {
        case '[object Int8Array]':
        case '[object Int16Array]':
        case '[object Int32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Uint16Array]':
        case '[object Uint32Array]':
          return new source.constructor(copyElement(source.buffer));
        case '[object ArrayBuffer]':
          if (!source.slice) {
            var copied = new ArrayBuffer(source.byteLength);
            new Uint8Array(copied).set(new Uint8Array(source));
            return copied;
          }
          return source.slice(0);
        case '[object Boolean]':
        case '[object Number]':
        case '[object String]':
        case '[object Date]':
          return new source.constructor(source.valueOf());
        case '[object RegExp]':
          var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
          re.lastIndex = source.lastIndex;
          return re;
        case '[object Blob]':
          return new source.constructor([source], {
            type: source.type
          });
      }
      if (isFunction(source.cloneNode)) {
        return source.cloneNode(true);
      }
    }
  }

  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0, ii = src.length; i &lt; ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (!(key.charAt(0) === '$' &amp;&amp; key.charAt(1) === '$')) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }

  function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 &amp;&amp; o2 !== o2) return true;
    var t1 = typeof o1,
      t2 = typeof o2,
      length, key, keySet;
    if (t1 == t2 &amp;&amp; t1 == 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) == o2.length) {
          for (key = 0; key &lt; length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        if (!isDate(o2)) return false;
        return equals(o1.getTime(), o2.getTime());
      } else if (isRegExp(o1)) {
        if (!isRegExp(o2)) return false;
        return o1.toString() == o2.toString();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
          isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
        keySet = createMap();
        for (key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for (key in o2) {
          if (!(key in keySet) &amp;&amp;
            key.charAt(0) !== '$' &amp;&amp;
            isDefined(o2[key]) &amp;&amp;
            !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
    return false;
  }
  var csp = function() {
    if (!isDefined(csp.rules)) {
      var ngCspElement = (document.querySelector('[ng-csp]') ||
        document.querySelector('[data-ng-csp]'));
      if (ngCspElement) {
        var ngCspAttribute = ngCspElement.getAttribute('ng-csp') ||
          ngCspElement.getAttribute('data-ng-csp');
        csp.rules = {
          noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
          noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
        };
      } else {
        csp.rules = {
          noUnsafeEval: noUnsafeEval(),
          noInlineStyle: false
        };
      }
    }
    return csp.rules;

    function noUnsafeEval() {
      try {
        new Function('');
        return false;
      } catch (e) {
        return true;
      }
    }
  };
  var jq = function() {
    if (isDefined(jq.name_)) return jq.name_;
    var el;
    var i, ii = ngAttrPrefixes.length,
      prefix, name;
    for (i = 0; i &lt; ii; ++i) {
      prefix = ngAttrPrefixes[i];
      if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
        name = el.getAttribute(prefix + 'jq');
        break;
      }
    }
    return (jq.name_ = name);
  };

  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }

  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }

  function bind(self, fn) {
    var curryArgs = arguments.length &gt; 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {
      return curryArgs.length ?
        function() {
          return arguments.length ?
            fn.apply(self, concat(curryArgs, arguments, 0)) :
            fn.apply(self, curryArgs);
        } :
        function() {
          return arguments.length ?
            fn.apply(self, arguments) :
            fn.call(self);
        };
    } else {
      return fn;
    }
  }

  function toJsonReplacer(key, value) {
    var val = value;
    if (typeof key === 'string' &amp;&amp; key.charAt(0) === '$' &amp;&amp; key.charAt(1) === '$') {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value &amp;&amp; document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }

  function toJson(obj, pretty) {
    if (isUndefined(obj)) return undefined;
    if (!isNumber(pretty)) {
      pretty = pretty ? 2 : null;
    }
    return JSON.stringify(obj, toJsonReplacer, pretty);
  }

  function fromJson(json) {
    return isString(json) ?
      JSON.parse(json) :
      json;
  }
  var ALL_COLONS = /:/g;

  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(ALL_COLONS, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }

  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.empty();
    } catch (e) {}
    var elemHtml = jqLite('&lt;div&gt;').append(element).html();
    try {
      return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
        elemHtml.
      match(/^(&lt;[^&gt;]+&gt;)/)[1].
      replace(/^&lt;([\w\-]+)/, function(match, nodeName) {
        return '&lt;' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }

  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {}
  }

  function parseKeyValue(keyValue) {
    var obj = {};
    forEach((keyValue || "").split('&amp;'), function(keyValue) {
      var splitPoint, key, val;
      if (keyValue) {
        key = keyValue = keyValue.replace(/\+/g, '%20');
        splitPoint = keyValue.indexOf('=');
        if (splitPoint !== -1) {
          key = keyValue.substring(0, splitPoint);
          val = keyValue.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);
        if (isDefined(key)) {
          val = isDefined(val) ? tryDecodeURIComponent(val) : true;
          if (!hasOwnProperty.call(obj, key)) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [obj[key], val];
          }
        }
      }
    });
    return obj;
  }

  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function(value, key) {
      if (isArray(value)) {
        forEach(value, function(arrayValue) {
          parts.push(encodeUriQuery(key, true) +
            (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
        });
      } else {
        parts.push(encodeUriQuery(key, true) +
          (value === true ? '' : '=' + encodeUriQuery(value, true)));
      }
    });
    return parts.length ? parts.join('&amp;') : '';
  }

  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).
    replace(/%26/gi, '&amp;').
    replace(/%3D/gi, '=').
    replace(/%2B/gi, '+');
  }

  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%3B/gi, ';').
    replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
  }
  var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];

  function getNgAttribute(element, ngAttr) {
    var attr, i, ii = ngAttrPrefixes.length;
    for (i = 0; i &lt; ii; ++i) {
      attr = ngAttrPrefixes[i] + ngAttr;
      if (isString(attr = element.getAttribute(attr))) {
        return attr;
      }
    }
    return null;
  }

  function angularInit(element, bootstrap) {
    var appElement,
      module,
      config = {};
    forEach(ngAttrPrefixes, function(prefix) {
      var name = prefix + 'app';
      if (!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name)) {
        appElement = element;
        module = element.getAttribute(name);
      }
    });
    forEach(ngAttrPrefixes, function(prefix) {
      var name = prefix + 'app';
      var candidate;
      if (!appElement &amp;&amp; (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
        appElement = candidate;
        module = candidate.getAttribute(name);
      }
    });
    if (appElement) {
      config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
      bootstrap(appElement, module ? [module] : [], config);
    }
  }

  function bootstrap(element, modules, config) {
    if (!isObject(config)) config = {};
    var defaultConfig = {
      strictDi: false
    };
    config = extend(defaultConfig, config);
    var doBootstrap = function() {
      element = jqLite(element);
      if (element.injector()) {
        var tag = (element[0] === document) ? 'document' : startingTag(element);
        throw ngMinErr(
          'btstrpd',
          "App Already Bootstrapped with this Element '{0}'",
          tag.replace(/&lt;/, '&amp;lt;').replace(/&gt;/, '&amp;gt;'));
      }
      modules = modules || [];
      modules.unshift(['$provide', function($provide) {
        $provide.value('$rootElement', element);
      }]);
      if (config.debugInfoEnabled) {
        modules.push(['$compileProvider', function($compileProvider) {
          $compileProvider.debugInfoEnabled(true);
        }]);
      }
      modules.unshift('ng');
      var injector = createInjector(modules, config.strictDi);
      injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',
        function bootstrapApply(scope, element, compile, injector) {
          scope.$apply(function() {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window &amp;&amp; NG_ENABLE_DEBUG_INFO.test(window.name)) {
      config.debugInfoEnabled = true;
      window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
    }
    if (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function(extraModules) {
      forEach(extraModules, function(module) {
        modules.push(module);
      });
      return doBootstrap();
    };
    if (isFunction(angular.resumeDeferredBootstrap)) {
      angular.resumeDeferredBootstrap();
    }
  }

  function reloadWithDebugInfo() {
    window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
    window.location.reload();
  }

  function getTestability(rootElement) {
    var injector = angular.element(rootElement).injector();
    if (!injector) {
      throw ngMinErr('test',
        'no injector found for element argument to getTestability');
    }
    return injector.get('$$testability');
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;

  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  var bindJQueryFired = false;

  function bindJQuery() {
    var originalCleanData;
    if (bindJQueryFired) {
      return;
    }
    var jqName = jq();
    jQuery = isUndefined(jqName) ? window.jQuery :
      !jqName ? undefined :
      window[jqName];
    if (jQuery &amp;&amp; jQuery.fn.on) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      originalCleanData = jQuery.cleanData;
      jQuery.cleanData = function(elems) {
        var events;
        for (var i = 0, elem;
          (elem = elems[i]) != null; i++) {
          events = jQuery._data(elem, "events");
          if (events &amp;&amp; events.$destroy) {
            jQuery(elem).triggerHandler('$destroy');
          }
        }
        originalCleanData(elems);
      };
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
    bindJQueryFired = true;
  }

  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
    }
    return arg;
  }

  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation &amp;&amp; isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' +
      (arg &amp;&amp; typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }

  function assertNotHasOwnProperty(name, context) {
    if (name === 'hasOwnProperty') {
      throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
    }
  }

  function getter(obj, path, bindFnToScope) {
    if (!path) return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i &lt; len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope &amp;&amp; isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }

  function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode &amp;&amp; (node = node.nextSibling); i++) {
      if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
          blockNodes = jqLite(slice.call(nodes, 0, i));
        }
        blockNodes.push(node);
      }
    }
    return blockNodes || nodes;
  }

  function createMap() {
    return Object.create(null);
  }
  var NODE_TYPE_ELEMENT = 1;
  var NODE_TYPE_ATTRIBUTE = 2;
  var NODE_TYPE_TEXT = 3;
  var NODE_TYPE_COMMENT = 8;
  var NODE_TYPE_DOCUMENT = 9;
  var NODE_TYPE_DOCUMENT_FRAGMENT = 11;

  function setupModuleLoader(window) {
    var $injectorMinErr = minErr('$injector');
    var ngMinErr = minErr('ng');

    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, 'angular', Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, 'module', function() {
      var modules = {};
      return function module(name, requires, configFn) {
        var assertNotHasOwnProperty = function(name, context) {
          if (name === 'hasOwnProperty') {
            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
          }
        };
        assertNotHasOwnProperty(name, 'module');
        if (requires &amp;&amp; modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function() {
          if (!requires) {
            throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
              "the module name or forgot to load it. If registering a module ensure that you " +
              "specify the dependencies as the second argument.", name);
          }
          var invokeQueue = [];
          var configBlocks = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
          var moduleInstance = {
            _invokeQueue: invokeQueue,
            _configBlocks: configBlocks,
            _runBlocks: runBlocks,
            requires: requires,
            name: name,
            provider: invokeLaterAndSetModuleName('$provide', 'provider'),
            factory: invokeLaterAndSetModuleName('$provide', 'factory'),
            service: invokeLaterAndSetModuleName('$provide', 'service'),
            value: invokeLater('$provide', 'value'),
            constant: invokeLater('$provide', 'constant', 'unshift'),
            decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
            animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
            filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
            controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
            directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
            component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
            config: config,
            run: function(block) {
              runBlocks.push(block);
              return this;
            }
          };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;

          function invokeLater(provider, method, insertMethod, queue) {
            if (!queue) queue = invokeQueue;
            return function() {
              queue[insertMethod || 'push']([provider, method, arguments]);
              return moduleInstance;
            };
          }

          function invokeLaterAndSetModuleName(provider, method) {
            return function(recipeName, factoryFunction) {
              if (factoryFunction &amp;&amp; isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
              invokeQueue.push([provider, method, arguments]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }

  function serializeObject(obj) {
    var seen = [];
    return JSON.stringify(obj, function(key, val) {
      val = toJsonReplacer(key, val);
      if (isObject(val)) {
        if (seen.indexOf(val) &gt;= 0) return '...';
        seen.push(val);
      }
      return val;
    });
  }

  function toDebugString(obj) {
    if (typeof obj === 'function') {
      return obj.toString().replace(/ \{[\s\S]*$/, '');
    } else if (isUndefined(obj)) {
      return 'undefined';
    } else if (typeof obj !== 'string') {
      return serializeObject(obj);
    }
    return obj;
  }
  var version = {
    full: '1.5.3',
    major: 1,
    minor: 5,
    dot: 3,
    codeName: 'diplohaplontic-meiosis'
  };

  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'merge': merge,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': {
        counter: 0
      },
      'getTestability': getTestability,
      '$$minErr': minErr,
      '$$csp': csp,
      'reloadWithDebugInfo': reloadWithDebugInfo
    });
    angularModule = setupModuleLoader(window);
    angularModule('ng', ['ngLocale'], ['$provide',
      function ngModule($provide) {
        $provide.provider({
          $$sanitizeUri: $$SanitizeUriProvider
        });
        $provide.provider('$compile', $CompileProvider).
        directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtml: ngBindHtmlDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngIf: ngIfDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          pattern: patternDirective,
          ngPattern: patternDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          minlength: minlengthDirective,
          ngMinlength: minlengthDirective,
          maxlength: maxlengthDirective,
          ngMaxlength: maxlengthDirective,
          ngValue: ngValueDirective,
          ngModelOptions: ngModelOptionsDirective
        }).
        directive({
          ngInclude: ngIncludeFillContentDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $animate: $AnimateProvider,
          $animateCss: $CoreAnimateCssProvider,
          $$animateJs: $$CoreAnimateJsProvider,
          $$animateQueue: $$CoreAnimateQueueProvider,
          $$AnimateRunner: $$AnimateRunnerFactoryProvider,
          $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $$forceReflow: $$ForceReflowProvider,
          $interpolate: $InterpolateProvider,
          $interval: $IntervalProvider,
          $http: $HttpProvider,
          $httpParamSerializer: $HttpParamSerializerProvider,
          $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
          $httpBackend: $HttpBackendProvider,
          $xhrFactory: $xhrFactoryProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $$q: $$QProvider,
          $sce: $SceProvider,
          $sceDelegate: $SceDelegateProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $templateRequest: $TemplateRequestProvider,
          $$testability: $$TestabilityProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider,
          $$rAF: $$RAFProvider,
          $$jqLite: $$jqLiteProvider,
          $$HashMap: $$HashMapProvider,
          $$cookieReader: $$CookieReaderProvider
        });
      }
    ]);
  }
  JQLite.expando = 'ng339';
  var jqCache = JQLite.cache = {},
    jqId = 1,
    addEventListenerFn = function(element, type, fn) {
      element.addEventListener(type, fn, false);
    },
    removeEventListenerFn = function(element, type, fn) {
      element.removeEventListener(type, fn, false);
    };
  JQLite._data = function(node) {
    return this.cache[node[this.expando]] || {};
  };

  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var MOUSE_EVENT_MAP = {
    mouseleave: "mouseout",
    mouseenter: "mouseover"
  };
  var jqLiteMinErr = minErr('jqLite');

  function camelCase(name) {
    return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  var SINGLE_TAG_REGEXP = /^&lt;([\w-]+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/;
  var HTML_REGEXP = /&lt;|&amp;#?\w+;/;
  var TAG_NAME_REGEXP = /&lt;([\w:-]+)/;
  var XHTML_TAG_REGEXP = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^&gt;]*)\/&gt;/gi;
  var wrapMap = {
    'option': [1, '&lt;select multiple="multiple"&gt;', '&lt;/select&gt;'],
    'thead': [1, '&lt;table&gt;', '&lt;/table&gt;'],
    'col': [2, '&lt;table&gt;&lt;colgroup&gt;', '&lt;/colgroup&gt;&lt;/table&gt;'],
    'tr': [2, '&lt;table&gt;&lt;tbody&gt;', '&lt;/tbody&gt;&lt;/table&gt;'],
    'td': [3, '&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;', '&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;'],
    '_default': [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
  }

  function jqLiteAcceptsData(node) {
    var nodeType = node.nodeType;
    return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
  }

  function jqLiteHasData(node) {
    for (var key in jqCache[node.ng339]) {
      return true;
    }
    return false;
  }

  function jqLiteCleanData(nodes) {
    for (var i = 0, ii = nodes.length; i &lt; ii; i++) {
      jqLiteRemoveData(nodes[i]);
    }
  }

  function jqLiteBuildFragment(html, context) {
    var tmp, tag, wrap,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i;
    if (jqLiteIsTextNode(html)) {
      nodes.push(context.createTextNode(html));
    } else {
      tmp = tmp || fragment.appendChild(context.createElement("div"));
      tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
      wrap = wrapMap[tag] || wrapMap._default;
      tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "&lt;$1&gt;&lt;/$2&gt;") + wrap[2];
      i = wrap[0];
      while (i--) {
        tmp = tmp.lastChild;
      }
      nodes = concat(nodes, tmp.childNodes);
      tmp = fragment.firstChild;
      tmp.textContent = "";
    }
    fragment.textContent = "";
    fragment.innerHTML = "";
    forEach(nodes, function(node) {
      fragment.appendChild(node);
    });
    return fragment;
  }

  function jqLiteParseHTML(html, context) {
    context = context || document;
    var parsed;
    if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
      return [context.createElement(parsed[1])];
    }
    if ((parsed = jqLiteBuildFragment(html, context))) {
      return parsed.childNodes;
    }
    return [];
  }

  function jqLiteWrapNode(node, wrapper) {
    var parent = node.parentNode;
    if (parent) {
      parent.replaceChild(wrapper, node);
    }
    wrapper.appendChild(node);
  }
  var jqLiteContains = Node.prototype.contains || function(arg) {
    return !!(this.compareDocumentPosition(arg) &amp; 16);
  };

  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    var argIsString;
    if (isString(element)) {
      element = trim(element);
      argIsString = true;
    }
    if (!(this instanceof JQLite)) {
      if (argIsString &amp;&amp; element.charAt(0) != '&lt;') {
        throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
      }
      return new JQLite(element);
    }
    if (argIsString) {
      jqLiteAddNodes(this, jqLiteParseHTML(element));
    } else {
      jqLiteAddNodes(this, element);
    }
  }

  function jqLiteClone(element) {
    return element.cloneNode(true);
  }

  function jqLiteDealoc(element, onlyDescendants) {
    if (!onlyDescendants) jqLiteRemoveData(element);
    if (element.querySelectorAll) {
      var descendants = element.querySelectorAll('*');
      for (var i = 0, l = descendants.length; i &lt; l; i++) {
        jqLiteRemoveData(descendants[i]);
      }
    }
  }

  function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore &amp;&amp; expandoStore.events;
    var handle = expandoStore &amp;&amp; expandoStore.handle;
    if (!handle) return;
    if (!type) {
      for (type in events) {
        if (type !== '$destroy') {
          removeEventListenerFn(element, type, handle);
        }
        delete events[type];
      }
    } else {
      var removeHandler = function(type) {
        var listenerFns = events[type];
        if (isDefined(fn)) {
          arrayRemove(listenerFns || [], fn);
        }
        if (!(isDefined(fn) &amp;&amp; listenerFns &amp;&amp; listenerFns.length &gt; 0)) {
          removeEventListenerFn(element, type, handle);
          delete events[type];
        }
      };
      forEach(type.split(' '), function(type) {
        removeHandler(type);
        if (MOUSE_EVENT_MAP[type]) {
          removeHandler(MOUSE_EVENT_MAP[type]);
        }
      });
    }
  }

  function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339;
    var expandoStore = expandoId &amp;&amp; jqCache[expandoId];
    if (expandoStore) {
      if (name) {
        delete expandoStore.data[name];
        return;
      }
      if (expandoStore.handle) {
        if (expandoStore.events.$destroy) {
          expandoStore.handle({}, '$destroy');
        }
        jqLiteOff(element);
      }
      delete jqCache[expandoId];
      element.ng339 = undefined;
    }
  }

  function jqLiteExpandoStore(element, createIfNecessary) {
    var expandoId = element.ng339,
      expandoStore = expandoId &amp;&amp; jqCache[expandoId];
    if (createIfNecessary &amp;&amp; !expandoStore) {
      element.ng339 = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {
        events: {},
        data: {},
        handle: undefined
      };
    }
    return expandoStore;
  }

  function jqLiteData(element, key, value) {
    if (jqLiteAcceptsData(element)) {
      var isSimpleSetter = isDefined(value);
      var isSimpleGetter = !isSimpleSetter &amp;&amp; key &amp;&amp; !isObject(key);
      var massGetter = !key;
      var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
      var data = expandoStore &amp;&amp; expandoStore.data;
      if (isSimpleSetter) {
        data[key] = value;
      } else {
        if (massGetter) {
          return data;
        } else {
          if (isSimpleGetter) {
            return data &amp;&amp; data[key];
          } else {
            extend(data, key);
          }
        }
      }
    }
  }

  function jqLiteHasClass(element, selector) {
    if (!element.getAttribute) return false;
    return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") &gt; -1);
  }

  function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses &amp;&amp; element.setAttribute) {
      forEach(cssClasses.split(' '), function(cssClass) {
        element.setAttribute('class', trim(
          (" " + (element.getAttribute('class') || '') + " ")
          .replace(/[\n\t]/g, " ")
          .replace(" " + trim(cssClass) + " ", " ")));
      });
    }
  }

  function jqLiteAddClass(element, cssClasses) {
    if (cssClasses &amp;&amp; element.setAttribute) {
      var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
        .replace(/[\n\t]/g, " ");
      forEach(cssClasses.split(' '), function(cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
          existingClasses += cssClass + ' ';
        }
      });
      element.setAttribute('class', trim(existingClasses));
    }
  }

  function jqLiteAddNodes(root, elements) {
    if (elements) {
      if (elements.nodeType) {
        root[root.length++] = elements;
      } else {
        var length = elements.length;
        if (typeof length === 'number' &amp;&amp; elements.window !== elements) {
          if (length) {
            for (var i = 0; i &lt; length; i++) {
              root[root.length++] = elements[i];
            }
          }
        } else {
          root[root.length++] = elements;
        }
      }
    }
  }

  function jqLiteController(element, name) {
    return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }

  function jqLiteInheritedData(element, name, value) {
    if (element.nodeType == NODE_TYPE_DOCUMENT) {
      element = element.documentElement;
    }
    var names = isArray(name) ? name : [name];
    while (element) {
      for (var i = 0, ii = names.length; i &lt; ii; i++) {
        if (isDefined(value = jqLite.data(element, names[i]))) return value;
      }
      element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT &amp;&amp; element.host);
    }
  }

  function jqLiteEmpty(element) {
    jqLiteDealoc(element, true);
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function jqLiteRemove(element, keepData) {
    if (!keepData) jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  }

  function jqLiteDocumentLoaded(action, win) {
    win = win || window;
    if (win.document.readyState === 'complete') {
      win.setTimeout(action);
    } else {
      jqLite(win).on('load', action);
    }
  }
  var JQLitePrototype = JQLite.prototype = {
    ready: function(fn) {
      var fired = false;

      function trigger() {
        if (fired) return;
        fired = true;
        fn();
      }
      if (document.readyState === 'complete') {
        setTimeout(trigger);
      } else {
        this.on('DOMContentLoaded', trigger);
        JQLite(window).on('load', trigger);
      }
    },
    toString: function() {
      var value = [];
      forEach(this, function(e) {
        value.push('' + e);
      });
      return '[' + value.join(', ') + ']';
    },
    eq: function(index) {
      return (index &gt;= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice
  };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
    BOOLEAN_ELEMENTS[value] = true;
  });
  var ALIASED_ATTR = {
    'ngMinlength': 'minlength',
    'ngMaxlength': 'maxlength',
    'ngMin': 'min',
    'ngMax': 'max',
    'ngPattern': 'pattern'
  };

  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[nodeName_(element)] &amp;&amp; booleanAttr;
  }

  function getAliasedAttrName(name) {
    return ALIASED_ATTR[name];
  }
  forEach({
    data: jqLiteData,
    removeData: jqLiteRemoveData,
    hasData: jqLiteHasData,
    cleanData: jqLiteCleanData
  }, function(fn, name) {
    JQLite[name] = fn;
  });
  forEach({
    data: jqLiteData,
    inheritedData: jqLiteInheritedData,
    scope: function(element) {
      return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
    },
    isolateScope: function(element) {
      return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
    },
    controller: jqLiteController,
    injector: function(element) {
      return jqLiteInheritedData(element, '$injector');
    },
    removeAttr: function(element, name) {
      element.removeAttribute(name);
    },
    hasClass: jqLiteHasClass,
    css: function(element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        return element.style[name];
      }
    },
    attr: function(element, name, value) {
      var nodeType = element.nodeType;
      if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
        return;
      }
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return (element[name] ||
              (element.attributes.getNamedItem(name) || noop).specified) ?
            lowercasedName :
            undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function(element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: (function() {
      getText.$dv = '';
      return getText;

      function getText(element, value) {
        if (isUndefined(value)) {
          var nodeType = element.nodeType;
          return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
        }
        element.textContent = value;
      }
    })(),
    val: function(element, value) {
      if (isUndefined(value)) {
        if (element.multiple &amp;&amp; nodeName_(element) === 'select') {
          var result = [];
          forEach(element.options, function(option) {
            if (option.selected) {
              result.push(option.value || option.text);
            }
          });
          return result.length === 0 ? null : result;
        }
        return element.value;
      }
      element.value = value;
    },
    html: function(element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      jqLiteDealoc(element, true);
      element.innerHTML = value;
    },
    empty: jqLiteEmpty
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2) {
      var i, key;
      var nodeCount = this.length;
      if (fn !== jqLiteEmpty &amp;&amp;
        (isUndefined((fn.length == 2 &amp;&amp; (fn !== jqLiteHasClass &amp;&amp; fn !== jqLiteController)) ? arg1 : arg2))) {
        if (isObject(arg1)) {
          for (i = 0; i &lt; nodeCount; i++) {
            if (fn === jqLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          var value = fn.$dv;
          var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
          for (var j = 0; j &lt; jj; j++) {
            var nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
          }
          return value;
        }
      } else {
        for (i = 0; i &lt; nodeCount; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
    };
  });

  function createEventHandler(element, events) {
    var eventHandler = function(event, type) {
      event.isDefaultPrevented = function() {
        return event.defaultPrevented;
      };
      var eventFns = events[type || event.type];
      var eventFnsLength = eventFns ? eventFns.length : 0;
      if (!eventFnsLength) return;
      if (isUndefined(event.immediatePropagationStopped)) {
        var originalStopImmediatePropagation = event.stopImmediatePropagation;
        event.stopImmediatePropagation = function() {
          event.immediatePropagationStopped = true;
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (originalStopImmediatePropagation) {
            originalStopImmediatePropagation.call(event);
          }
        };
      }
      event.isImmediatePropagationStopped = function() {
        return event.immediatePropagationStopped === true;
      };
      var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
      if ((eventFnsLength &gt; 1)) {
        eventFns = shallowCopy(eventFns);
      }
      for (var i = 0; i &lt; eventFnsLength; i++) {
        if (!event.isImmediatePropagationStopped()) {
          handlerWrapper(element, event, eventFns[i]);
        }
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }

  function defaultHandlerWrapper(element, event, handler) {
    handler.call(element, event);
  }

  function specialMouseHandlerWrapper(target, event, handler) {
    var related = event.relatedTarget;
    if (!related || (related !== target &amp;&amp; !jqLiteContains.call(target, related))) {
      handler.call(target, event);
    }
  }
  forEach({
    removeData: jqLiteRemoveData,
    on: function jqLiteOn(element, type, fn, unsupported) {
      if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
      if (!jqLiteAcceptsData(element)) {
        return;
      }
      var expandoStore = jqLiteExpandoStore(element, true);
      var events = expandoStore.events;
      var handle = expandoStore.handle;
      if (!handle) {
        handle = expandoStore.handle = createEventHandler(element, events);
      }
      var types = type.indexOf(' ') &gt;= 0 ? type.split(' ') : [type];
      var i = types.length;
      var addHandler = function(type, specialHandlerWrapper, noEventListener) {
        var eventFns = events[type];
        if (!eventFns) {
          eventFns = events[type] = [];
          eventFns.specialHandlerWrapper = specialHandlerWrapper;
          if (type !== '$destroy' &amp;&amp; !noEventListener) {
            addEventListenerFn(element, type, handle);
          }
        }
        eventFns.push(fn);
      };
      while (i--) {
        type = types[i];
        if (MOUSE_EVENT_MAP[type]) {
          addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
          addHandler(type, undefined, true);
        } else {
          addHandler(type);
        }
      }
    },
    off: jqLiteOff,
    one: function(element, type, fn) {
      element = jqLite(element);
      element.on(type, function onFn() {
        element.off(type, fn);
        element.off(type, onFn);
      });
      element.on(type, fn);
    },
    replaceWith: function(element, replaceNode) {
      var index, parent = element.parentNode;
      jqLiteDealoc(element);
      forEach(new JQLite(replaceNode), function(node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function(element) {
      var children = [];
      forEach(element.childNodes, function(element) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
          children.push(element);
        }
      });
      return children;
    },
    contents: function(element) {
      return element.contentDocument || element.childNodes || [];
    },
    append: function(element, node) {
      var nodeType = element.nodeType;
      if (nodeType !== NODE_TYPE_ELEMENT &amp;&amp; nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
      node = new JQLite(node);
      for (var i = 0, ii = node.length; i &lt; ii; i++) {
        var child = node[i];
        element.appendChild(child);
      }
    },
    prepend: function(element, node) {
      if (element.nodeType === NODE_TYPE_ELEMENT) {
        var index = element.firstChild;
        forEach(new JQLite(node), function(child) {
          element.insertBefore(child, index);
        });
      }
    },
    wrap: function(element, wrapNode) {
      jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
    },
    remove: jqLiteRemove,
    detach: function(element) {
      jqLiteRemove(element, true);
    },
    after: function(element, newElement) {
      var index = element,
        parent = element.parentNode;
      newElement = new JQLite(newElement);
      for (var i = 0, ii = newElement.length; i &lt; ii; i++) {
        var node = newElement[i];
        parent.insertBefore(node, index.nextSibling);
        index = node;
      }
    },
    addClass: jqLiteAddClass,
    removeClass: jqLiteRemoveClass,
    toggleClass: function(element, selector, condition) {
      if (selector) {
        forEach(selector.split(' '), function(className) {
          var classCondition = condition;
          if (isUndefined(classCondition)) {
            classCondition = !jqLiteHasClass(element, className);
          }
          (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
        });
      }
    },
    parent: function(element) {
      var parent = element.parentNode;
      return parent &amp;&amp; parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
    },
    next: function(element) {
      return element.nextElementSibling;
    },
    find: function(element, selector) {
      if (element.getElementsByTagName) {
        return element.getElementsByTagName(selector);
      } else {
        return [];
      }
    },
    clone: jqLiteClone,
    triggerHandler: function(element, event, extraParameters) {
      var dummyEvent, eventFnsCopy, handlerArgs;
      var eventName = event.type || event;
      var expandoStore = jqLiteExpandoStore(element);
      var events = expandoStore &amp;&amp; expandoStore.events;
      var eventFns = events &amp;&amp; events[eventName];
      if (eventFns) {
        dummyEvent = {
          preventDefault: function() {
            this.defaultPrevented = true;
          },
          isDefaultPrevented: function() {
            return this.defaultPrevented === true;
          },
          stopImmediatePropagation: function() {
            this.immediatePropagationStopped = true;
          },
          isImmediatePropagationStopped: function() {
            return this.immediatePropagationStopped === true;
          },
          stopPropagation: noop,
          type: eventName,
          target: element
        };
        if (event.type) {
          dummyEvent = extend(dummyEvent, event);
        }
        eventFnsCopy = shallowCopy(eventFns);
        handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
        forEach(eventFnsCopy, function(fn) {
          if (!dummyEvent.isImmediatePropagationStopped()) {
            fn.apply(element, handlerArgs);
          }
        });
      }
    }
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2, arg3) {
      var value;
      for (var i = 0, ii = this.length; i &lt; ii; i++) {
        if (isUndefined(value)) {
          value = fn(this[i], arg1, arg2, arg3);
          if (isDefined(value)) {
            value = jqLite(value);
          }
        } else {
          jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
        }
      }
      return isDefined(value) ? value : this;
    };
    JQLite.prototype.bind = JQLite.prototype.on;
    JQLite.prototype.unbind = JQLite.prototype.off;
  });

  function $$jqLiteProvider() {
    this.$get = function $$jqLite() {
      return extend(JQLite, {
        hasClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteHasClass(node, classes);
        },
        addClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteAddClass(node, classes);
        },
        removeClass: function(node, classes) {
          if (node.attr) node = node[0];
          return jqLiteRemoveClass(node, classes);
        }
      });
    };
  }

  function hashKey(obj, nextUidFn) {
    var key = obj &amp;&amp; obj.$$hashKey;
    if (key) {
      if (typeof key === 'function') {
        key = obj.$$hashKey();
      }
      return key;
    }
    var objType = typeof obj;
    if (objType == 'function' || (objType == 'object' &amp;&amp; obj !== null)) {
      key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
    } else {
      key = objType + ':' + obj;
    }
    return key;
  }

  function HashMap(array, isolatedUid) {
    if (isolatedUid) {
      var uid = 0;
      this.nextUid = function() {
        return ++uid;
      };
    }
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function(key, value) {
      this[hashKey(key, this.nextUid)] = value;
    },
    get: function(key) {
      return this[hashKey(key, this.nextUid)];
    },
    remove: function(key) {
      var value = this[key = hashKey(key, this.nextUid)];
      delete this[key];
      return value;
    }
  };
  var $$HashMapProvider = [function() {
    this.$get = [function() {
      return HashMap;
    }];
  }];
  var ARROW_ARG = /^([^\(]+?)=&gt;/;
  var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
  var $injectorMinErr = minErr('$injector');

  function extractArgs(fn) {
    var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
      args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    return args;
  }

  function anonFn(fn) {
    var args = extractArgs(fn);
    if (args) {
      return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
    }
    return 'fn';
  }

  function annotate(fn, strictDi, name) {
    var $inject,
      argDecl,
      last;
    if (typeof fn === 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
          if (strictDi) {
            if (!isString(name) || !name) {
              name = fn.name || anonFn(fn);
            }
            throw $injectorMinErr('strictdi',
              '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
          }
          argDecl = extractArgs(fn);
          forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
              $inject.push(name);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }

  function createInjector(modulesToLoad, strictDi) {
    strictDi = (strictDi === true);
    var INSTANTIATING = {},
      providerSuffix = 'Provider',
      path = [],
      loadedModules = new HashMap([], true),
      providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      },
      providerInjector = (providerCache.$injector =
        createInternalInjector(providerCache, function(serviceName, caller) {
          if (angular.isString(caller)) {
            path.push(caller);
          }
          throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' &lt;- '));
        })),
      instanceCache = {},
      protoInstanceInjector =
      createInternalInjector(instanceCache, function(serviceName, caller) {
        var provider = providerInjector.get(serviceName + providerSuffix, caller);
        return instanceInjector.invoke(
          provider.$get, provider, undefined, serviceName);
      }),
      instanceInjector = protoInstanceInjector;
    providerCache['$injector' + providerSuffix] = {
      $get: valueFn(protoInstanceInjector)
    };
    var runBlocks = loadModules(modulesToLoad);
    instanceInjector = protoInstanceInjector.get('$injector');
    instanceInjector.strictDi = strictDi;
    forEach(runBlocks, function(fn) {
      if (fn) instanceInjector.invoke(fn);
    });
    return instanceInjector;

    function supportObject(delegate) {
      return function(key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }

    function provider(name, provider_) {
      assertNotHasOwnProperty(name, 'service');
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
      }
      return providerCache[name + providerSuffix] = provider_;
    }

    function enforceReturnValue(name, factory) {
      return function enforcedReturnValue() {
        var result = instanceInjector.invoke(factory, this);
        if (isUndefined(result)) {
          throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
        }
        return result;
      };
    }

    function factory(name, factoryFn, enforce) {
      return provider(name, {
        $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
      });
    }

    function service(name, constructor) {
      return factory(name, ['$injector', function($injector) {
        return $injector.instantiate(constructor);
      }]);
    }

    function value(name, val) {
      return factory(name, valueFn(val), false);
    }

    function constant(name, value) {
      assertNotHasOwnProperty(name, 'constant');
      providerCache[name] = value;
      instanceCache[name] = value;
    }

    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;
      origProvider.$get = function() {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance
        });
      };
    }

    function loadModules(modulesToLoad) {
      assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
      var runBlocks = [],
        moduleFn;
      forEach(modulesToLoad, function(module) {
        if (loadedModules.get(module)) return;
        loadedModules.put(module, true);

        function runInvokeQueue(queue) {
          var i, ii;
          for (i = 0, ii = queue.length; i &lt; ii; i++) {
            var invokeArgs = queue[i],
              provider = providerInjector.get(invokeArgs[0]);
            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        }
        try {
          if (isString(module)) {
            moduleFn = angularModule(module);
            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
            runInvokeQueue(moduleFn._invokeQueue);
            runInvokeQueue(moduleFn._configBlocks);
          } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, 'module');
          }
        } catch (e) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          if (e.message &amp;&amp; e.stack &amp;&amp; e.stack.indexOf(e.message) == -1) {
            e = e.message + '\n' + e.stack;
          }
          throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
            module, e.stack || e.message || e);
        }
      });
      return runBlocks;
    }

    function createInternalInjector(cache, factory) {
      function getService(serviceName, caller) {
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw $injectorMinErr('cdep', 'Circular dependency found: {0}',
              serviceName + ' &lt;- ' + path.join(' &lt;- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName, caller);
          } catch (err) {
            if (cache[serviceName] === INSTANTIATING) {
              delete cache[serviceName];
            }
            throw err;
          } finally {
            path.shift();
          }
        }
      }

      function injectionArgs(fn, locals, serviceName) {
        var args = [],
          $inject = createInjector.$$annotate(fn, strictDi, serviceName);
        for (var i = 0, length = $inject.length; i &lt; length; i++) {
          var key = $inject[i];
          if (typeof key !== 'string') {
            throw $injectorMinErr('itkn',
              'Incorrect injection token! Expected service name as string, got {0}', key);
          }
          args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] :
            getService(key, serviceName));
        }
        return args;
      }

      function isClass(func) {
        if (msie &lt;= 11) {
          return false;
        }
        return typeof func === 'function' &amp;&amp;
          /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(func));
      }

      function invoke(fn, self, locals, serviceName) {
        if (typeof locals === 'string') {
          serviceName = locals;
          locals = null;
        }
        var args = injectionArgs(fn, locals, serviceName);
        if (isArray(fn)) {
          fn = fn[fn.length - 1];
        }
        if (!isClass(fn)) {
          return fn.apply(self, args);
        } else {
          args.unshift(null);
          return new(Function.prototype.bind.apply(fn, args))();
        }
      }

      function instantiate(Type, locals, serviceName) {
        var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
        var args = injectionArgs(Type, locals, serviceName);
        args.unshift(null);
        return new(Function.prototype.bind.apply(ctor, args))();
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: createInjector.$$annotate,
        has: function(name) {
          return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
        }
      };
    }
  }
  createInjector.$$annotate = annotate;

  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function() {
      autoScrollingEnabled = false;
    };
    this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
      var document = $window.document;

      function getFirstAnchor(list) {
        var result = null;
        Array.prototype.some.call(list, function(element) {
          if (nodeName_(element) === 'a') {
            result = element;
            return true;
          }
        });
        return result;
      }

      function getYOffset() {
        var offset = scroll.yOffset;
        if (isFunction(offset)) {
          offset = offset();
        } else if (isElement(offset)) {
          var elem = offset[0];
          var style = $window.getComputedStyle(elem);
          if (style.position !== 'fixed') {
            offset = 0;
          } else {
            offset = elem.getBoundingClientRect().bottom;
          }
        } else if (!isNumber(offset)) {
          offset = 0;
        }
        return offset;
      }

      function scrollTo(elem) {
        if (elem) {
          elem.scrollIntoView();
          var offset = getYOffset();
          if (offset) {
            var elemTop = elem.getBoundingClientRect().top;
            $window.scrollBy(0, elemTop - offset);
          }
        } else {
          $window.scrollTo(0, 0);
        }
      }

      function scroll(hash) {
        hash = isString(hash) ? hash : $location.hash();
        var elm;
        if (!hash) scrollTo(null);
        else if ((elm = document.getElementById(hash))) scrollTo(elm);
        else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);
        else if (hash === 'top') scrollTo(null);
      }
      if (autoScrollingEnabled) {
        $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          },
          function autoScrollWatchAction(newVal, oldVal) {
            if (newVal === oldVal &amp;&amp; newVal === '') return;
            jqLiteDocumentLoaded(function() {
              $rootScope.$evalAsync(scroll);
            });
          });
      }
      return scroll;
    }];
  }
  var $animateMinErr = minErr('$animate');
  var ELEMENT_NODE = 1;
  var NG_ANIMATE_CLASSNAME = 'ng-animate';

  function mergeClasses(a, b) {
    if (!a &amp;&amp; !b) return '';
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(' ');
    if (isArray(b)) b = b.join(' ');
    return a + ' ' + b;
  }

  function extractElementNode(element) {
    for (var i = 0; i &lt; element.length; i++) {
      var elm = element[i];
      if (elm.nodeType === ELEMENT_NODE) {
        return elm;
      }
    }
  }

  function splitClasses(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }
    var obj = createMap();
    forEach(classes, function(klass) {
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  function prepareAnimateOptions(options) {
    return isObject(options) ?
      options :
      {};
  }
  var $$CoreAnimateJsProvider = function() {
    this.$get = noop;
  };
  var $$CoreAnimateQueueProvider = function() {
    var postDigestQueue = new HashMap();
    var postDigestElements = [];
    this.$get = ['$$AnimateRunner', '$rootScope',
      function($$AnimateRunner, $rootScope) {
        return {
          enabled: noop,
          on: noop,
          off: noop,
          pin: noop,
          push: function(element, event, options, domOperation) {
            domOperation &amp;&amp; domOperation();
            options = options || {};
            options.from &amp;&amp; element.css(options.from);
            options.to &amp;&amp; element.css(options.to);
            if (options.addClass || options.removeClass) {
              addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
            }
            var runner = new $$AnimateRunner();
            runner.complete();
            return runner;
          }
        };

        function updateData(data, classes, value) {
          var changed = false;
          if (classes) {
            classes = isString(classes) ? classes.split(' ') :
              isArray(classes) ? classes : [];
            forEach(classes, function(className) {
              if (className) {
                changed = true;
                data[className] = value;
              }
            });
          }
          return changed;
        }

        function handleCSSClassChanges() {
          forEach(postDigestElements, function(element) {
            var data = postDigestQueue.get(element);
            if (data) {
              var existing = splitClasses(element.attr('class'));
              var toAdd = '';
              var toRemove = '';
              forEach(data, function(status, className) {
                var hasClass = !!existing[className];
                if (status !== hasClass) {
                  if (status) {
                    toAdd += (toAdd.length ? ' ' : '') + className;
                  } else {
                    toRemove += (toRemove.length ? ' ' : '') + className;
                  }
                }
              });
              forEach(element, function(elm) {
                toAdd &amp;&amp; jqLiteAddClass(elm, toAdd);
                toRemove &amp;&amp; jqLiteRemoveClass(elm, toRemove);
              });
              postDigestQueue.remove(element);
            }
          });
          postDigestElements.length = 0;
        }

        function addRemoveClassesPostDigest(element, add, remove) {
          var data = postDigestQueue.get(element) || {};
          var classesAdded = updateData(data, add, true);
          var classesRemoved = updateData(data, remove, false);
          if (classesAdded || classesRemoved) {
            postDigestQueue.put(element, data);
            postDigestElements.push(element);
            if (postDigestElements.length === 1) {
              $rootScope.$$postDigest(handleCSSClassChanges);
            }
          }
        }
      }
    ];
  };
  var $AnimateProvider = ['$provide', function($provide) {
    var provider = this;
    this.$$registeredAnimations = Object.create(null);
    this.register = function(name, factory) {
      if (name &amp;&amp; name.charAt(0) !== '.') {
        throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
      }
      var key = name + '-animation';
      provider.$$registeredAnimations[name.substr(1)] = key;
      $provide.factory(key, factory);
    };
    this.classNameFilter = function(expression) {
      if (arguments.length === 1) {
        this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
        if (this.$$classNameFilter) {
          var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
          if (reservedRegex.test(this.$$classNameFilter.toString())) {
            throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
          }
        }
      }
      return this.$$classNameFilter;
    };
    this.$get = ['$$animateQueue', function($$animateQueue) {
      function domInsert(element, parentElement, afterElement) {
        if (afterElement) {
          var afterNode = extractElementNode(afterElement);
          if (afterNode &amp;&amp; !afterNode.parentNode &amp;&amp; !afterNode.previousElementSibling) {
            afterElement = null;
          }
        }
        afterElement ? afterElement.after(element) : parentElement.prepend(element);
      }
      return {
        on: $$animateQueue.on,
        off: $$animateQueue.off,
        pin: $$animateQueue.pin,
        enabled: $$animateQueue.enabled,
        cancel: function(runner) {
          runner.end &amp;&amp; runner.end();
        },
        enter: function(element, parent, after, options) {
          parent = parent &amp;&amp; jqLite(parent);
          after = after &amp;&amp; jqLite(after);
          parent = parent || after.parent();
          domInsert(element, parent, after);
          return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
        },
        move: function(element, parent, after, options) {
          parent = parent &amp;&amp; jqLite(parent);
          after = after &amp;&amp; jqLite(after);
          parent = parent || after.parent();
          domInsert(element, parent, after);
          return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
        },
        leave: function(element, options) {
          return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
            element.remove();
          });
        },
        addClass: function(element, className, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addclass, className);
          return $$animateQueue.push(element, 'addClass', options);
        },
        removeClass: function(element, className, options) {
          options = prepareAnimateOptions(options);
          options.removeClass = mergeClasses(options.removeClass, className);
          return $$animateQueue.push(element, 'removeClass', options);
        },
        setClass: function(element, add, remove, options) {
          options = prepareAnimateOptions(options);
          options.addClass = mergeClasses(options.addClass, add);
          options.removeClass = mergeClasses(options.removeClass, remove);
          return $$animateQueue.push(element, 'setClass', options);
        },
        animate: function(element, from, to, className, options) {
          options = prepareAnimateOptions(options);
          options.from = options.from ? extend(options.from, from) : from;
          options.to = options.to ? extend(options.to, to) : to;
          className = className || 'ng-inline-animate';
          options.tempClasses = mergeClasses(options.tempClasses, className);
          return $$animateQueue.push(element, 'animate', options);
        }
      };
    }];
  }];
  var $$AnimateAsyncRunFactoryProvider = function() {
    this.$get = ['$$rAF', function($$rAF) {
      var waitQueue = [];

      function waitForTick(fn) {
        waitQueue.push(fn);
        if (waitQueue.length &gt; 1) return;
        $$rAF(function() {
          for (var i = 0; i &lt; waitQueue.length; i++) {
            waitQueue[i]();
          }
          waitQueue = [];
        });
      }
      return function() {
        var passed = false;
        waitForTick(function() {
          passed = true;
        });
        return function(callback) {
          passed ? callback() : waitForTick(callback);
        };
      };
    }];
  };
  var $$AnimateRunnerFactoryProvider = function() {
    this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout',
      function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function(chain, callback) {
          var index = 0;
          next();

          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index](function(response) {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
        };
        AnimateRunner.all = function(runners, callback) {
          var count = 0;
          var status = true;
          forEach(runners, function(runner) {
            runner.done(onProgress);
          });

          function onProgress(response) {
            status = status &amp;&amp; response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        };

        function AnimateRunner(host) {
          this.setHost(host);
          var rafTick = $$animateAsyncRun();
          var timeoutTick = function(fn) {
            $timeout(fn, 0, false);
          };
          this._doneCallbacks = [];
          this._tick = function(fn) {
            var doc = $document[0];
            if (doc &amp;&amp; doc.hidden) {
              timeoutTick(fn);
            } else {
              rafTick(fn);
            }
          };
          this._state = 0;
        }
        AnimateRunner.prototype = {
          setHost: function(host) {
            this.host = host || {};
          },
          done: function(fn) {
            if (this._state === DONE_COMPLETE_STATE) {
              fn();
            } else {
              this._doneCallbacks.push(fn);
            }
          },
          progress: noop,
          getPromise: function() {
            if (!this.promise) {
              var self = this;
              this.promise = $q(function(resolve, reject) {
                self.done(function(status) {
                  status === false ? reject() : resolve();
                });
              });
            }
            return this.promise;
          },
          then: function(resolveHandler, rejectHandler) {
            return this.getPromise().then(resolveHandler, rejectHandler);
          },
          'catch': function(handler) {
            return this.getPromise()['catch'](handler);
          },
          'finally': function(handler) {
            return this.getPromise()['finally'](handler);
          },
          pause: function() {
            if (this.host.pause) {
              this.host.pause();
            }
          },
          resume: function() {
            if (this.host.resume) {
              this.host.resume();
            }
          },
          end: function() {
            if (this.host.end) {
              this.host.end();
            }
            this._resolve(true);
          },
          cancel: function() {
            if (this.host.cancel) {
              this.host.cancel();
            }
            this._resolve(false);
          },
          complete: function(response) {
            var self = this;
            if (self._state === INITIAL_STATE) {
              self._state = DONE_PENDING_STATE;
              self._tick(function() {
                self._resolve(response);
              });
            }
          },
          _resolve: function(response) {
            if (this._state !== DONE_COMPLETE_STATE) {
              forEach(this._doneCallbacks, function(fn) {
                fn(response);
              });
              this._doneCallbacks.length = 0;
              this._state = DONE_COMPLETE_STATE;
            }
          }
        };
        return AnimateRunner;
      }
    ];
  };
  var $CoreAnimateCssProvider = function() {
    this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
      return function(element, initialOptions) {
        var options = initialOptions || {};
        if (!options.$$prepared) {
          options = copy(options);
        }
        if (options.cleanupStyles) {
          options.from = options.to = null;
        }
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
        var closed, runner = new $$AnimateRunner();
        return {
          start: run,
          end: run
        };

        function run() {
          $$rAF(function() {
            applyAnimationContents();
            if (!closed) {
              runner.complete();
            }
            closed = true;
          });
          return runner;
        }

        function applyAnimationContents() {
          if (options.addClass) {
            element.addClass(options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            element.removeClass(options.removeClass);
            options.removeClass = null;
          }
          if (options.to) {
            element.css(options.to);
            options.to = null;
          }
        }
      };
    }];
  };

  function Browser(window, document, $log, $sniffer) {
    var self = this,
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function() {
      outstandingRequestCount++;
    };

    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }

    function getHash(url) {
      var index = url.indexOf('#');
      return index === -1 ? '' : url.substr(index);
    }
    self.notifyWhenNoOutstandingRequests = function(callback) {
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var cachedState, lastHistoryState,
      lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      pendingLocation = null,
      getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
        try {
          return history.state;
        } catch (e) {}
      };
    cacheState();
    lastHistoryState = cachedState;
    self.url = function(url, replace, state) {
      if (isUndefined(state)) {
        state = null;
      }
      if (location !== window.location) location = window.location;
      if (history !== window.history) history = window.history;
      if (url) {
        var sameState = lastHistoryState === state;
        if (lastBrowserUrl === url &amp;&amp; (!$sniffer.history || sameState)) {
          return self;
        }
        var sameBase = lastBrowserUrl &amp;&amp; stripHash(lastBrowserUrl) === stripHash(url);
        lastBrowserUrl = url;
        lastHistoryState = state;
        if ($sniffer.history &amp;&amp; (!sameBase || !sameState)) {
          history[replace ? 'replaceState' : 'pushState'](state, '', url);
          cacheState();
          lastHistoryState = cachedState;
        } else {
          if (!sameBase || pendingLocation) {
            pendingLocation = url;
          }
          if (replace) {
            location.replace(url);
          } else if (!sameBase) {
            location.href = url;
          } else {
            location.hash = getHash(url);
          }
          if (location.href !== url) {
            pendingLocation = url;
          }
        }
        return self;
      } else {
        return pendingLocation || location.href.replace(/%27/g, "'");
      }
    };
    self.state = function() {
      return cachedState;
    };
    var urlChangeListeners = [],
      urlChangeInit = false;

    function cacheStateAndFireUrlChange() {
      pendingLocation = null;
      cacheState();
      fireUrlChange();
    }
    var lastCachedState = null;

    function cacheState() {
      cachedState = getCurrentState();
      cachedState = isUndefined(cachedState) ? null : cachedState;
      if (equals(cachedState, lastCachedState)) {
        cachedState = lastCachedState;
      }
      lastCachedState = cachedState;
    }

    function fireUrlChange() {
      if (lastBrowserUrl === self.url() &amp;&amp; lastHistoryState === cachedState) {
        return;
      }
      lastBrowserUrl = self.url();
      lastHistoryState = cachedState;
      forEach(urlChangeListeners, function(listener) {
        listener(self.url(), cachedState);
      });
    }
    self.onUrlChange = function(callback) {
      if (!urlChangeInit) {
        if ($sniffer.history) jqLite(window).on('popstate', cacheStateAndFireUrlChange);
        jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.$$applicationDestroyed = function() {
      jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
    };
    self.$$checkUrlChange = fireUrlChange;
    self.baseHref = function() {
      var href = baseElement.attr('href');
      return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
    };
    self.defer = function(fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function() {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function(deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }

  function $BrowserProvider() {
    this.$get = ['$window', '$log', '$sniffer', '$document',
      function($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }

  function $CacheFactoryProvider() {
    this.$get = function() {
      var caches = {};

      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
        }
        var size = 0,
          stats = extend({}, options, {
            id: cacheId
          }),
          data = createMap(),
          capacity = (options &amp;&amp; options.capacity) || Number.MAX_VALUE,
          lruHash = createMap(),
          freshEnd = null,
          staleEnd = null;
        return caches[cacheId] = {
          put: function(key, value) {
            if (isUndefined(value)) return;
            if (capacity &lt; Number.MAX_VALUE) {
              var lruEntry = lruHash[key] || (lruHash[key] = {
                key: key
              });
              refresh(lruEntry);
            }
            if (!(key in data)) size++;
            data[key] = value;
            if (size &gt; capacity) {
              this.remove(staleEnd.key);
            }
            return value;
          },
          get: function(key) {
            if (capacity &lt; Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              refresh(lruEntry);
            }
            return data[key];
          },
          remove: function(key) {
            if (capacity &lt; Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              if (lruEntry == freshEnd) freshEnd = lruEntry.p;
              if (lruEntry == staleEnd) staleEnd = lruEntry.n;
              link(lruEntry.n, lruEntry.p);
              delete lruHash[key];
            }
            if (!(key in data)) return;
            delete data[key];
            size--;
          },
          removeAll: function() {
            data = createMap();
            size = 0;
            lruHash = createMap();
            freshEnd = staleEnd = null;
          },
          destroy: function() {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function() {
            return extend({}, stats, {
              size: size
            });
          }
        };

        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }

        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function() {
        var info = {};
        forEach(caches, function(cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function(cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }

  function $TemplateCacheProvider() {
    this.$get = ['$cacheFactory', function($cacheFactory) {
      return $cacheFactory('templates');
    }];
  }
  var $compileMinErr = minErr('$compile');
  $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];

  function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
      ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
      REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    var bindingCache = createMap();

    function parseIsolateBindings(scope, directiveName, isController) {
      var LOCAL_REGEXP = /^\s*([@&amp;&lt;]|=(\*?))(\??)\s*(\w*)\s*$/;
      var bindings = {};
      forEach(scope, function(definition, scopeName) {
        if (definition in bindingCache) {
          bindings[scopeName] = bindingCache[definition];
          return;
        }
        var match = definition.match(LOCAL_REGEXP);
        if (!match) {
          throw $compileMinErr('iscp',
            "Invalid {3} for directive '{0}'." +
            " Definition: {... {1}: '{2}' ...}",
            directiveName, scopeName, definition,
            (isController ? "controller bindings definition" :
              "isolate scope definition"));
        }
        bindings[scopeName] = {
          mode: match[1][0],
          collection: match[2] === '*',
          optional: match[3] === '?',
          attrName: match[4] || scopeName
        };
        if (match[4]) {
          bindingCache[definition] = bindings[scopeName];
        }
      });
      return bindings;
    }

    function parseDirectiveBindings(directive, directiveName) {
      var bindings = {
        isolateScope: null,
        bindToController: null
      };
      if (isObject(directive.scope)) {
        if (directive.bindToController === true) {
          bindings.bindToController = parseIsolateBindings(directive.scope,
            directiveName, true);
          bindings.isolateScope = {};
        } else {
          bindings.isolateScope = parseIsolateBindings(directive.scope,
            directiveName, false);
        }
      }
      if (isObject(directive.bindToController)) {
        bindings.bindToController =
          parseIsolateBindings(directive.bindToController, directiveName, true);
      }
      if (isObject(bindings.bindToController)) {
        var controller = directive.controller;
        var controllerAs = directive.controllerAs;
        if (!controller) {
          throw $compileMinErr('noctrl',
            "Cannot bind to controller without directive '{0}'s controller.",
            directiveName);
        } else if (!identifierForController(controller, controllerAs)) {
          throw $compileMinErr('noident',
            "Cannot bind to controller without identifier for directive '{0}'.",
            directiveName);
        }
      }
      return bindings;
    }

    function assertValidDirectiveName(name) {
      var letter = name.charAt(0);
      if (!letter || letter !== lowercase(letter)) {
        throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
      }
      if (name !== name.trim()) {
        throw $compileMinErr('baddir',
          "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
          name);
      }
    }
    this.directive = function registerDirective(name, directiveFactory) {
      assertNotHasOwnProperty(name, 'directive');
      if (isString(name)) {
        assertValidDirectiveName(name);
        assertArg(directiveFactory, 'directiveFactory');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
            function($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function(directiveFactory, index) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = {
                      compile: valueFn(directive)
                    };
                  } else if (!directive.compile &amp;&amp; directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.index = index;
                  directive.name = directive.name || name;
                  directive.require = directive.require || (directive.controller &amp;&amp; directive.name);
                  directive.restrict = directive.restrict || 'EA';
                  directive.$$moduleName = directiveFactory.$$moduleName;
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.component = function registerComponent(name, options) {
      var controller = options.controller || noop;

      function factory($injector) {
        function makeInjectable(fn) {
          if (isFunction(fn) || isArray(fn)) {
            return function(tElement, tAttrs) {
              return $injector.invoke(fn, this, {
                $element: tElement,
                $attrs: tAttrs
              });
            };
          } else {
            return fn;
          }
        }
        var template = (!options.template &amp;&amp; !options.templateUrl ? '' : options.template);
        return {
          controller: controller,
          controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
          template: makeInjectable(template),
          templateUrl: makeInjectable(options.templateUrl),
          transclude: options.transclude,
          scope: {},
          bindToController: options.bindings || {},
          restrict: 'E',
          require: options.require
        };
      }
      forEach(options, function(val, key) {
        if (key.charAt(0) === '$') {
          factory[key] = val;
          controller[key] = val;
        }
      });
      factory.$inject = ['$injector'];
      return this.directive(name, factory);
    };
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
      }
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
      }
    };
    var debugInfoEnabled = true;
    this.debugInfoEnabled = function(enabled) {
      if (isDefined(enabled)) {
        debugInfoEnabled = enabled;
        return this;
      }
      return debugInfoEnabled;
    };
    var TTL = 10;
    this.onChangesTtl = function(value) {
      if (arguments.length) {
        TTL = value;
        return this;
      }
      return TTL;
    };
    this.$get = [
      '$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse',
      '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri',
      function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse,
        $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
        var SIMPLE_ATTR_NAME = /^\w/;
        var specialAttrHolder = document.createElement('div');
        var onChangesTtl = TTL;
        var onChangesQueue;

        function flushOnChangesQueue() {
          try {
            if (!(--onChangesTtl)) {
              onChangesQueue = undefined;
              throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
            }
            $rootScope.$apply(function() {
              for (var i = 0, ii = onChangesQueue.length; i &lt; ii; ++i) {
                onChangesQueue[i]();
              }
              onChangesQueue = undefined;
            });
          } finally {
            onChangesTtl++;
          }
        }

        function Attributes(element, attributesToCopy) {
          if (attributesToCopy) {
            var keys = Object.keys(attributesToCopy);
            var i, l, key;
            for (i = 0, l = keys.length; i &lt; l; i++) {
              key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$$element = element;
        }
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $addClass: function(classVal) {
            if (classVal &amp;&amp; classVal.length &gt; 0) {
              $animate.addClass(this.$$element, classVal);
            }
          },
          $removeClass: function(classVal) {
            if (classVal &amp;&amp; classVal.length &gt; 0) {
              $animate.removeClass(this.$$element, classVal);
            }
          },
          $updateClass: function(newClasses, oldClasses) {
            var toAdd = tokenDifference(newClasses, oldClasses);
            if (toAdd &amp;&amp; toAdd.length) {
              $animate.addClass(this.$$element, toAdd);
            }
            var toRemove = tokenDifference(oldClasses, newClasses);
            if (toRemove &amp;&amp; toRemove.length) {
              $animate.removeClass(this.$$element, toRemove);
            }
          },
          $set: function(key, value, writeAttr, attrName) {
            var node = this.$$element[0],
              booleanKey = getBooleanAttrName(node, key),
              aliasedKey = getAliasedAttrName(key),
              observer = key,
              nodeName;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            } else if (aliasedKey) {
              this[aliasedKey] = value;
              observer = aliasedKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            nodeName = nodeName_(this.$$element);
            if ((nodeName === 'a' &amp;&amp; (key === 'href' || key === 'xlinkHref')) ||
              (nodeName === 'img' &amp;&amp; key === 'src')) {
              this[key] = value = $$sanitizeUri(value, key === 'src');
            } else if (nodeName === 'img' &amp;&amp; key === 'srcset') {
              var result = "";
              var trimmedSrcset = trim(value);
              var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
              var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
              var rawUris = trimmedSrcset.split(pattern);
              var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
              for (var i = 0; i &lt; nbrUrisWith2parts; i++) {
                var innerIdx = i * 2;
                result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                result += (" " + trim(rawUris[innerIdx + 1]));
              }
              var lastTuple = trim(rawUris[i * 2]).split(/\s/);
              result += $$sanitizeUri(trim(lastTuple[0]), true);
              if (lastTuple.length === 2) {
                result += (" " + trim(lastTuple[1]));
              }
              this[key] = value = result;
            }
            if (writeAttr !== false) {
              if (value === null || isUndefined(value)) {
                this.$$element.removeAttr(attrName);
              } else {
                if (SIMPLE_ATTR_NAME.test(attrName)) {
                  this.$$element.attr(attrName, value);
                } else {
                  setSpecialAttr(this.$$element[0], attrName, value);
                }
              }
            }
            var $$observers = this.$$observers;
            $$observers &amp;&amp; forEach($$observers[observer], function(fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function(key, fn) {
            var attrs = this,
              $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
              listeners = ($$observers[key] || ($$observers[key] = []));
            listeners.push(fn);
            $rootScope.$evalAsync(function() {
              if (!listeners.$$inter &amp;&amp; attrs.hasOwnProperty(key) &amp;&amp; !isUndefined(attrs[key])) {
                fn(attrs[key]);
              }
            });
            return function() {
              arrayRemove(listeners, fn);
            };
          }
        };

        function setSpecialAttr(element, attrName, value) {
          specialAttrHolder.innerHTML = "&lt;span " + attrName + "&gt;";
          var attributes = specialAttrHolder.firstChild.attributes;
          var attribute = attributes[0];
          attributes.removeNamedItem(attribute.name);
          attribute.value = value;
          element.attributes.setNamedItem(attribute);
        }

        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {}
        }
        var startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          denormalizeTemplate = (startSymbol == '{{' &amp;&amp; endSymbol == '}}') ?
          identity :
          function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          },
          NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
        compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
          var bindings = $element.data('$binding') || [];
          if (isArray(binding)) {
            bindings = bindings.concat(binding);
          } else {
            bindings.push(binding);
          }
          $element.data('$binding', bindings);
        } : noop;
        compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
          safeAddClass($element, 'ng-binding');
        } : noop;
        compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
          var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
          $element.data(dataName, scope);
        } : noop;
        compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
          safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
        } : noop;
        compile.$$createComment = function(directiveName, comment) {
          var content = '';
          if (debugInfoEnabled) {
            content = ' ' + (directiveName || '') + ': ' + (comment || '') + ' ';
          }
          return document.createComment(content);
        };
        return compile;

        function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
          previousCompileContext) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          var NOT_EMPTY = /\S+/;
          for (var i = 0, len = $compileNodes.length; i &lt; len; i++) {
            var domNode = $compileNodes[i];
            if (domNode.nodeType === NODE_TYPE_TEXT &amp;&amp; domNode.nodeValue.match(NOT_EMPTY)) {
              jqLiteWrapNode(domNode, $compileNodes[i] = document.createElement('span'));
            }
          }
          var compositeLinkFn =
            compileNodes($compileNodes, transcludeFn, $compileNodes,
              maxPriority, ignoreDirective, previousCompileContext);
          compile.$$addScopeClass($compileNodes);
          var namespace = null;
          return function publicLinkFn(scope, cloneConnectFn, options) {
            assertArg(scope, 'scope');
            if (previousCompileContext &amp;&amp; previousCompileContext.needsNewScope) {
              scope = scope.$parent.$new();
            }
            options = options || {};
            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
              transcludeControllers = options.transcludeControllers,
              futureParentElement = options.futureParentElement;
            if (parentBoundTranscludeFn &amp;&amp; parentBoundTranscludeFn.$$boundTransclude) {
              parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
            }
            if (!namespace) {
              namespace = detectNamespaceForChildElements(futureParentElement);
            }
            var $linkNode;
            if (namespace !== 'html') {
              $linkNode = jqLite(
                wrapTemplate(namespace, jqLite('&lt;div&gt;').append($compileNodes).html())
              );
            } else if (cloneConnectFn) {
              $linkNode = JQLitePrototype.clone.call($compileNodes);
            } else {
              $linkNode = $compileNodes;
            }
            if (transcludeControllers) {
              for (var controllerName in transcludeControllers) {
                $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
              }
            }
            compile.$$addScopeInfo($linkNode, scope);
            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
            if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
            return $linkNode;
          };
        }

        function detectNamespaceForChildElements(parentElement) {
          var node = parentElement &amp;&amp; parentElement[0];
          if (!node) {
            return 'html';
          } else {
            return nodeName_(node) !== 'foreignobject' &amp;&amp; toString.call(node).match(/SVG/) ? 'svg' : 'html';
          }
        }

        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
          previousCompileContext) {
          var linkFns = [],
            attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
          for (var i = 0; i &lt; nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
              ignoreDirective);
            nodeLinkFn = (directives.length) ?
              applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                null, [], [], previousCompileContext) :
              null;
            if (nodeLinkFn &amp;&amp; nodeLinkFn.scope) {
              compile.$$addScopeClass(attrs.$$element);
            }
            childLinkFn = (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||
                !(childNodes = nodeList[i].childNodes) ||
                !childNodes.length) ?
              null :
              compileNodes(childNodes,
                nodeLinkFn ? (
                  (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) &amp;&amp;
                  nodeLinkFn.transclude) : transcludeFn);
            if (nodeLinkFn || childLinkFn) {
              linkFns.push(i, nodeLinkFn, childLinkFn);
              linkFnFound = true;
              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
            }
            previousCompileContext = null;
          }
          return linkFnFound ? compositeLinkFn : null;

          function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
            var stableNodeList;
            if (nodeLinkFnFound) {
              var nodeListLength = nodeList.length;
              stableNodeList = new Array(nodeListLength);
              for (i = 0; i &lt; linkFns.length; i += 3) {
                idx = linkFns[i];
                stableNodeList[idx] = nodeList[idx];
              }
            } else {
              stableNodeList = nodeList;
            }
            for (i = 0, ii = linkFns.length; i &lt; ii;) {
              node = stableNodeList[linkFns[i++]];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new();
                  compile.$$addScopeInfo(jqLite(node), childScope);
                } else {
                  childScope = scope;
                }
                if (nodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                } else if (!nodeLinkFn.templateOnThisElement &amp;&amp; parentBoundTranscludeFn) {
                  childBoundTranscludeFn = parentBoundTranscludeFn;
                } else if (!parentBoundTranscludeFn &amp;&amp; transcludeFn) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                } else {
                  childBoundTranscludeFn = null;
                }
                nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
              }
            }
          }
        }

        function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
          function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
            if (!transcludedScope) {
              transcludedScope = scope.$new(false, containingScope);
              transcludedScope.$$transcluded = true;
            }
            return transcludeFn(transcludedScope, cloneFn, {
              parentBoundTranscludeFn: previousBoundTranscludeFn,
              transcludeControllers: controllers,
              futureParentElement: futureParentElement
            });
          }
          var boundSlots = boundTranscludeFn.$$slots = createMap();
          for (var slotName in transcludeFn.$$slots) {
            if (transcludeFn.$$slots[slotName]) {
              boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
            } else {
              boundSlots[slotName] = null;
            }
          }
          return boundTranscludeFn;
        }

        function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
          var nodeType = node.nodeType,
            attrsMap = attrs.$attr,
            match,
            className;
          switch (nodeType) {
            case NODE_TYPE_ELEMENT:
              addDirective(directives,
                directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
              for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes,
                  j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {
                var attrStartName = false;
                var attrEndName = false;
                attr = nAttrs[j];
                name = attr.name;
                value = trim(attr.value);
                ngAttrName = directiveNormalize(name);
                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                  name = name.replace(PREFIX_REGEXP, '')
                    .substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                }
                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                if (multiElementMatch &amp;&amp; directiveIsMultiElement(multiElementMatch[1])) {
                  attrStartName = name;
                  attrEndName = name.substr(0, name.length - 5) + 'end';
                  name = name.substr(0, name.length - 6);
                }
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true;
                  }
                }
                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
                  attrEndName);
              }
              className = node.className;
              if (isObject(className)) {
                className = className.animVal;
              }
              if (isString(className) &amp;&amp; className !== '') {
                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                  nName = directiveNormalize(match[2]);
                  if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                    attrs[nName] = trim(match[3]);
                  }
                  className = className.substr(match.index + match[0].length);
                }
              }
              break;
            case NODE_TYPE_TEXT:
              if (msie === 11) {
                while (node.parentNode &amp;&amp; node.nextSibling &amp;&amp; node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                  node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                  node.parentNode.removeChild(node.nextSibling);
                }
              }
              addTextInterpolateDirective(directives, node.nodeValue);
              break;
            case NODE_TYPE_COMMENT:
              try {
                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                if (match) {
                  nName = directiveNormalize(match[1]);
                  if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                    attrs[nName] = trim(match[2]);
                  }
                }
              } catch (e) {}
              break;
          }
          directives.sort(byPriority);
          return directives;
        }

        function groupScan(node, attrStart, attrEnd) {
          var nodes = [];
          var depth = 0;
          if (attrStart &amp;&amp; node.hasAttribute &amp;&amp; node.hasAttribute(attrStart)) {
            do {
              if (!node) {
                throw $compileMinErr('uterdir',
                  "Unterminated attribute, found '{0}' but no matching '{1}' found.",
                  attrStart, attrEnd);
              }
              if (node.nodeType == NODE_TYPE_ELEMENT) {
                if (node.hasAttribute(attrStart)) depth++;
                if (node.hasAttribute(attrEnd)) depth--;
              }
              nodes.push(node);
              node = node.nextSibling;
            } while (depth &gt; 0);
          } else {
            nodes.push(node);
          }
          return jqLite(nodes);
        }

        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
          return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
            element = groupScan(element[0], attrStart, attrEnd);
            return linkFn(scope, element, attrs, controllers, transcludeFn);
          };
        }

        function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
          var compiled;
          if (eager) {
            return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
          }
          return function lazyCompilation() {
            if (!compiled) {
              compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
              $compileNodes = transcludeFn = previousCompileContext = null;
            }
            return compiled.apply(this, arguments);
          };
        }

        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
          jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
          previousCompileContext) {
          previousCompileContext = previousCompileContext || {};
          var terminalPriority = -Number.MAX_VALUE,
            newScopeDirective = previousCompileContext.newScopeDirective,
            controllerDirectives = previousCompileContext.controllerDirectives,
            newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
            templateDirective = previousCompileContext.templateDirective,
            nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
            hasTranscludeDirective = false,
            hasTemplate = false,
            hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
            $compileNode = templateAttrs.$$element = jqLite(compileNode),
            directive,
            directiveName,
            $template,
            replaceDirective = originalReplaceDirective,
            childTranscludeFn = transcludeFn,
            linkFn,
            didScanForMultipleTransclusion = false,
            mightHaveMultipleTransclusionError = false,
            directiveValue;
          for (var i = 0, ii = directives.length; i &lt; ii; i++) {
            directive = directives[i];
            var attrStart = directive.$$start;
            var attrEnd = directive.$$end;
            if (attrStart) {
              $compileNode = groupScan(compileNode, attrStart, attrEnd);
            }
            $template = undefined;
            if (terminalPriority &gt; directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              if (!directive.templateUrl) {
                if (isObject(directiveValue)) {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective,
                    directive, $compileNode);
                  newIsolateScopeDirective = directive;
                } else {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
                    $compileNode);
                }
              }
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (!didScanForMultipleTransclusion &amp;&amp; ((directive.replace &amp;&amp; (directive.templateUrl || directive.template)) ||
                (directive.transclude &amp;&amp; !directive.$$tlb))) {
              var candidateDirective;
              for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];) {
                if ((candidateDirective.transclude &amp;&amp; !candidateDirective.$$tlb) ||
                  (candidateDirective.replace &amp;&amp; (candidateDirective.templateUrl || candidateDirective.template))) {
                  mightHaveMultipleTransclusionError = true;
                  break;
                }
              }
              didScanForMultipleTransclusion = true;
            }
            if (!directive.templateUrl &amp;&amp; directive.controller) {
              directiveValue = directive.controller;
              controllerDirectives = controllerDirectives || createMap();
              assertNoDuplicate("'" + directiveName + "' controller",
                controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              hasTranscludeDirective = true;
              if (!directive.$$tlb) {
                assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                nonTlbTranscludeDirective = directive;
              }
              if (directiveValue == 'element') {
                hasElementTranscludeDirective = true;
                terminalPriority = directive.priority;
                $template = $compileNode;
                $compileNode = templateAttrs.$$element =
                  jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, sliceArgs($template), compileNode);
                $template[0].$$parentNode = $template[0].parentNode;
                childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority,
                  replaceDirective &amp;&amp; replaceDirective.name, {
                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                  });
              } else {
                var slots = createMap();
                $template = jqLite(jqLiteClone(compileNode)).contents();
                if (isObject(directiveValue)) {
                  $template = [];
                  var slotMap = createMap();
                  var filledSlots = createMap();
                  forEach(directiveValue, function(elementSelector, slotName) {
                    var optional = (elementSelector.charAt(0) === '?');
                    elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                    slotMap[elementSelector] = slotName;
                    slots[slotName] = null;
                    filledSlots[slotName] = optional;
                  });
                  forEach($compileNode.contents(), function(node) {
                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                    if (slotName) {
                      filledSlots[slotName] = true;
                      slots[slotName] = slots[slotName] || [];
                      slots[slotName].push(node);
                    } else {
                      $template.push(node);
                    }
                  });
                  forEach(filledSlots, function(filled, slotName) {
                    if (!filled) {
                      throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                    }
                  });
                  for (var slotName in slots) {
                    if (slots[slotName]) {
                      slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                    }
                  }
                }
                $compileNode.empty();
                childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined,
                  undefined, {
                    needsNewScope: directive.$$isolateScope || directive.$$newScope
                  });
                childTranscludeFn.$$slots = slots;
              }
            }
            if (directive.template) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = (isFunction(directive.template)) ?
                directive.template($compileNode, templateAttrs) :
                directive.template;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                replaceDirective = directive;
                if (jqLiteIsTextNode(directiveValue)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt',
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    directiveName, '');
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = {
                  $attr: {}
                };
                var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                if (newIsolateScopeDirective || newScopeDirective) {
                  markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                }
                directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              if (directive.replace) {
                replaceDirective = directive;
              }
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
                templateAttrs, jqCollection, hasTranscludeDirective &amp;&amp; childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) &amp;&amp; newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn, attrStart, attrEnd);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope === true;
          nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
          nodeLinkFn.templateOnThisElement = hasTemplate;
          nodeLinkFn.transclude = childTranscludeFn;
          previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
          return nodeLinkFn;

          function addLinkFns(pre, post, attrStart, attrEnd) {
            if (pre) {
              if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
              pre.require = directive.require;
              pre.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                pre = cloneAndAnnotateFn(pre, {
                  isolateScope: true
                });
              }
              preLinkFns.push(pre);
            }
            if (post) {
              if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
              post.require = directive.require;
              post.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                post = cloneAndAnnotateFn(post, {
                  isolateScope: true
                });
              }
              postLinkFns.push(post);
            }
          }

          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element,
              attrs, removeScopeBindingWatches, removeControllerBindingWatches;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
              $element = templateAttrs.$$element;
            } else {
              $element = jqLite(linkNode);
              attrs = new Attributes($element, templateAttrs);
            }
            controllerScope = scope;
            if (newIsolateScopeDirective) {
              isolateScope = scope.$new(true);
            } else if (newScopeDirective) {
              controllerScope = scope.$parent;
            }
            if (boundTranscludeFn) {
              transcludeFn = controllersBoundTransclude;
              transcludeFn.$$boundTransclude = boundTranscludeFn;
              transcludeFn.isSlotFilled = function(slotName) {
                return !!boundTranscludeFn.$$slots[slotName];
              };
            }
            if (controllerDirectives) {
              elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
            }
            if (newIsolateScopeDirective) {
              compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective &amp;&amp; (templateDirective === newIsolateScopeDirective ||
                templateDirective === newIsolateScopeDirective.$$originalDirective)));
              compile.$$addScopeClass($element, true);
              isolateScope.$$isolateBindings =
                newIsolateScopeDirective.$$isolateBindings;
              removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope,
                isolateScope.$$isolateBindings,
                newIsolateScopeDirective);
              if (removeScopeBindingWatches) {
                isolateScope.$on('$destroy', removeScopeBindingWatches);
              }
            }
            for (var name in elementControllers) {
              var controllerDirective = controllerDirectives[name];
              var controller = elementControllers[name];
              var bindings = controllerDirective.$$bindings.bindToController;
              if (controller.identifier &amp;&amp; bindings) {
                removeControllerBindingWatches =
                  initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
              }
              var controllerResult = controller();
              if (controllerResult !== controller.instance) {
                controller.instance = controllerResult;
                $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                removeControllerBindingWatches &amp;&amp; removeControllerBindingWatches();
                removeControllerBindingWatches =
                  initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
              }
            }
            forEach(controllerDirectives, function(controllerDirective, name) {
              var require = controllerDirective.require;
              if (controllerDirective.bindToController &amp;&amp; !isArray(require) &amp;&amp; isObject(require)) {
                extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
              }
            });
            forEach(elementControllers, function(controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$onInit)) {
                controllerInstance.$onInit();
              }
              if (isFunction(controllerInstance.$onDestroy)) {
                controllerScope.$on('$destroy', function callOnDestroyHook() {
                  controllerInstance.$onDestroy();
                });
              }
            });
            for (i = 0, ii = preLinkFns.length; i &lt; ii; i++) {
              linkFn = preLinkFns[i];
              invokeLinkFn(linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
                transcludeFn
              );
            }
            var scopeToChild = scope;
            if (newIsolateScopeDirective &amp;&amp; (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
              scopeToChild = isolateScope;
            }
            childLinkFn &amp;&amp; childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = postLinkFns.length - 1; i &gt;= 0; i--) {
              linkFn = postLinkFns[i];
              invokeLinkFn(linkFn,
                linkFn.isolateScope ? isolateScope : scope,
                $element,
                attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers),
                transcludeFn
              );
            }
            forEach(elementControllers, function(controller) {
              var controllerInstance = controller.instance;
              if (isFunction(controllerInstance.$postLink)) {
                controllerInstance.$postLink();
              }
            });

            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
              var transcludeControllers;
              if (!isScope(scope)) {
                slotName = futureParentElement;
                futureParentElement = cloneAttachFn;
                cloneAttachFn = scope;
                scope = undefined;
              }
              if (hasElementTranscludeDirective) {
                transcludeControllers = elementControllers;
              }
              if (!futureParentElement) {
                futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
              }
              if (slotName) {
                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                if (slotTranscludeFn) {
                  return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                } else if (isUndefined(slotTranscludeFn)) {
                  throw $compileMinErr('noslot',
                    'No parent directive that requires a transclusion with slot name "{0}". ' +
                    'Element: {1}',
                    slotName, startingTag($element));
                }
              } else {
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
        }

        function getControllers(directiveName, require, $element, elementControllers) {
          var value;
          if (isString(require)) {
            var match = require.match(REQUIRE_PREFIX_REGEXP);
            var name = require.substring(match[0].length);
            var inheritType = match[1] || match[3];
            var optional = match[2] === '?';
            if (inheritType === '^^') {
              $element = $element.parent();
            } else {
              value = elementControllers &amp;&amp; elementControllers[name];
              value = value &amp;&amp; value.instance;
            }
            if (!value) {
              var dataName = '$' + name + 'Controller';
              value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
            }
            if (!value &amp;&amp; !optional) {
              throw $compileMinErr('ctreq',
                "Controller '{0}', required by directive '{1}', can't be found!",
                name, directiveName);
            }
          } else if (isArray(require)) {
            value = [];
            for (var i = 0, ii = require.length; i &lt; ii; i++) {
              value[i] = getControllers(directiveName, require[i], $element, elementControllers);
            }
          } else if (isObject(require)) {
            value = {};
            forEach(require, function(controller, property) {
              value[property] = getControllers(directiveName, controller, $element, elementControllers);
            });
          }
          return value || null;
        }

        function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
          var elementControllers = createMap();
          for (var controllerKey in controllerDirectives) {
            var directive = controllerDirectives[controllerKey];
            var locals = {
              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn
            };
            var controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }
            var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
            elementControllers[directive.name] = controllerInstance;
            $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
          }
          return elementControllers;
        }

        function markDirectiveScope(directives, isolateScope, newScope) {
          for (var j = 0, jj = directives.length; j &lt; jj; j++) {
            directives[j] = inherit(directives[j], {
              $$isolateScope: isolateScope,
              $$newScope: newScope
            });
          }
        }

        function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
          endAttrName) {
          if (name === ignoreDirective) return null;
          var match = null;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix),
                i = 0, ii = directives.length; i &lt; ii; i++) {
              try {
                directive = directives[i];
                if ((isUndefined(maxPriority) || maxPriority &gt; directive.priority) &amp;&amp;
                  directive.restrict.indexOf(location) != -1) {
                  if (startAttrName) {
                    directive = inherit(directive, {
                      $$start: startAttrName,
                      $$end: endAttrName
                    });
                  }
                  if (!directive.$$bindings) {
                    var bindings = directive.$$bindings =
                      parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                  }
                  tDirectives.push(directive);
                  match = directive;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }

        function directiveIsMultiElement(name) {
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix),
                i = 0, ii = directives.length; i &lt; ii; i++) {
              directive = directives[i];
              if (directive.multiElement) {
                return true;
              }
            }
          }
          return false;
        }

        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr,
            dstAttr = dst.$attr,
            $element = dst.$$element;
          forEach(dst, function(value, key) {
            if (key.charAt(0) != '$') {
              if (src[key] &amp;&amp; src[key] !== value) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function(value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
              dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
            } else if (key.charAt(0) != '$' &amp;&amp; !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }

        function compileTemplateUrl(directives, $compileNode, tAttrs,
          $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
          var linkQueue = [],
            afterTemplateNodeLinkFn,
            afterTemplateChildLinkFn,
            beforeTemplateCompileNode = $compileNode[0],
            origAsyncDirective = directives.shift(),
            derivedSyncDirective = inherit(origAsyncDirective, {
              templateUrl: null,
              transclude: null,
              replace: null,
              $$originalDirective: origAsyncDirective
            }),
            templateUrl = (isFunction(origAsyncDirective.templateUrl)) ?
            origAsyncDirective.templateUrl($compileNode, tAttrs) :
            origAsyncDirective.templateUrl,
            templateNamespace = origAsyncDirective.templateNamespace;
          $compileNode.empty();
          $templateRequest(templateUrl)
            .then(function(content) {
              var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt',
                    "Template for directive '{0}' must have exactly one root element. {1}",
                    origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {
                  $attr: {}
                };
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
                childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
                previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                  beforeTemplateLinkNode = linkQueue.shift(),
                  linkRootElement = linkQueue.shift(),
                  boundTranscludeFn = linkQueue.shift(),
                  linkNode = $compileNode[0];
                if (scope.$$destroyed) continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective &amp;&amp;
                      origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
                  childBoundTranscludeFn);
              }
              linkQueue = null;
            });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
            var childBoundTranscludeFn = boundTranscludeFn;
            if (scope.$$destroyed) return;
            if (linkQueue) {
              linkQueue.push(scope,
                node,
                rootElement,
                childBoundTranscludeFn);
            } else {
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
              }
              afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
            }
          };
        }

        function byPriority(a, b) {
          var diff = b.priority - a.priority;
          if (diff !== 0) return diff;
          if (a.name !== b.name) return (a.name &lt; b.name) ? -1 : 1;
          return a.index - b.index;
        }

        function assertNoDuplicate(what, previousDirective, directive, element) {
          function wrapModuleNameIfDefined(moduleName) {
            return moduleName ?
              (' (module: ' + moduleName + ')') :
              '';
          }
          if (previousDirective) {
            throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}',
              previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName),
              directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
          }
        }

        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: function textInterpolateCompileFn(templateNode) {
                var templateNodeParent = templateNode.parent(),
                  hasCompileParent = !!templateNodeParent.length;
                if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                return function textInterpolateLinkFn(scope, node) {
                  var parent = node.parent();
                  if (!hasCompileParent) compile.$$addBindingClass(parent);
                  compile.$$addBindingInfo(parent, interpolateFn.expressions);
                  scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                    node[0].nodeValue = value;
                  });
                };
              }
            });
          }
        }

        function wrapTemplate(type, template) {
          type = lowercase(type || 'html');
          switch (type) {
            case 'svg':
            case 'math':
              var wrapper = document.createElement('div');
              wrapper.innerHTML = '&lt;' + type + '&gt;' + template + '&lt;/' + type + '&gt;';
              return wrapper.childNodes[0].childNodes;
            default:
              return template;
          }
        }

        function getTrustedContext(node, attrNormalizedName) {
          if (attrNormalizedName == "srcdoc") {
            return $sce.HTML;
          }
          var tag = nodeName_(node);
          if (attrNormalizedName == "xlinkHref" ||
            (tag == "form" &amp;&amp; attrNormalizedName == "action") ||
            (tag != "img" &amp;&amp; (attrNormalizedName == "src" ||
              attrNormalizedName == "ngSrc"))) {
            return $sce.RESOURCE_URL;
          }
        }

        function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
          var trustedContext = getTrustedContext(node, name);
          allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
          var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
          if (!interpolateFn) return;
          if (name === "multiple" &amp;&amp; nodeName_(node) === "select") {
            throw $compileMinErr("selmulti",
              "Binding to the 'multiple' attribute is not supported. Element: {0}",
              startingTag(node));
          }
          directives.push({
            priority: 100,
            compile: function() {
              return {
                pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                  var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                  if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr('nodomevents',
                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                      "ng- versions (such as ng-click instead of onclick) instead.");
                  }
                  var newValue = attr[name];
                  if (newValue !== value) {
                    interpolateFn = newValue &amp;&amp; $interpolate(newValue, true, trustedContext, allOrNothing);
                    value = newValue;
                  }
                  if (!interpolateFn) return;
                  attr[name] = interpolateFn(scope);
                  ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                  (attr.$$observers &amp;&amp; attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    if (name === 'class' &amp;&amp; newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
                }
              };
            }
          });
        }

        function replaceWith($rootElement, elementsToRemove, newNode) {
          var firstElementToRemove = elementsToRemove[0],
            removeCount = elementsToRemove.length,
            parent = firstElementToRemove.parentNode,
            i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i &lt; ii; i++) {
              if ($rootElement[i] == firstElementToRemove) {
                $rootElement[i++] = newNode;
                for (var j = i, j2 = j + removeCount - 1,
                    jj = $rootElement.length; j &lt; jj; j++, j2++) {
                  if (j2 &lt; jj) {
                    $rootElement[j] = $rootElement[j2];
                  } else {
                    delete $rootElement[j];
                  }
                }
                $rootElement.length -= removeCount - 1;
                if ($rootElement.context === firstElementToRemove) {
                  $rootElement.context = newNode;
                }
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, firstElementToRemove);
          }
          var fragment = document.createDocumentFragment();
          for (i = 0; i &lt; removeCount; i++) {
            fragment.appendChild(elementsToRemove[i]);
          }
          if (jqLite.hasData(firstElementToRemove)) {
            jqLite.data(newNode, jqLite.data(firstElementToRemove));
            jqLite(firstElementToRemove).off('$destroy');
          }
          jqLite.cleanData(fragment.querySelectorAll('*'));
          for (i = 1; i &lt; removeCount; i++) {
            delete elementsToRemove[i];
          }
          elementsToRemove[0] = newNode;
          elementsToRemove.length = 1;
        }

        function cloneAndAnnotateFn(fn, annotation) {
          return extend(function() {
            return fn.apply(null, arguments);
          }, fn, annotation);
        }

        function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
          try {
            linkFn(scope, $element, attrs, controllers, transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
          var removeWatchCollection = [];
          var changes;
          forEach(bindings, function initializeBinding(definition, scopeName) {
            var attrName = definition.attrName,
              optional = definition.optional,
              mode = definition.mode,
              lastValue,
              parentGet, parentSet, compare, removeWatch;
            switch (mode) {
              case '@':
                if (!optional &amp;&amp; !hasOwnProperty.call(attrs, attrName)) {
                  destination[scopeName] = attrs[attrName] = void 0;
                }
                attrs.$observe(attrName, function(value) {
                  if (isString(value)) {
                    var oldValue = destination[scopeName];
                    recordChanges(scopeName, value, oldValue);
                    destination[scopeName] = value;
                  }
                });
                attrs.$$observers[attrName].$$scope = scope;
                lastValue = attrs[attrName];
                if (isString(lastValue)) {
                  destination[scopeName] = $interpolate(lastValue)(scope);
                } else if (isBoolean(lastValue)) {
                  destination[scopeName] = lastValue;
                }
                break;
              case '=':
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = void 0;
                }
                if (optional &amp;&amp; !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function simpleCompare(a, b) {
                    return a === b || (a !== a &amp;&amp; b !== b);
                  };
                }
                parentSet = parentGet.assign || function() {
                  lastValue = destination[scopeName] = parentGet(scope);
                  throw $compileMinErr('nonassign',
                    "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                    attrs[attrName], attrName, directive.name);
                };
                lastValue = destination[scopeName] = parentGet(scope);
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      destination[scopeName] = parentValue;
                    } else {
                      parentSet(scope, parentValue = destination[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                };
                parentValueWatch.$stateful = true;
                if (definition.collection) {
                  removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                } else {
                  removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                }
                removeWatchCollection.push(removeWatch);
                break;
              case '&lt;':
                if (!hasOwnProperty.call(attrs, attrName)) {
                  if (optional) break;
                  attrs[attrName] = void 0;
                }
                if (optional &amp;&amp; !attrs[attrName]) break;
                parentGet = $parse(attrs[attrName]);
                destination[scopeName] = parentGet(scope);
                removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newParentValue) {
                  var oldValue = destination[scopeName];
                  recordChanges(scopeName, newParentValue, oldValue);
                  destination[scopeName] = newParentValue;
                }, parentGet.literal);
                removeWatchCollection.push(removeWatch);
                break;
              case '&amp;':
                parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                if (parentGet === noop &amp;&amp; optional) break;
                destination[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });

          function recordChanges(key, currentValue, previousValue) {
            if (isFunction(destination.$onChanges) &amp;&amp; currentValue !== previousValue) {
              if (!onChangesQueue) {
                scope.$$postDigest(flushOnChangesQueue);
                onChangesQueue = [];
              }
              if (!changes) {
                changes = {};
                onChangesQueue.push(triggerOnChangesHook);
              }
              if (changes[key]) {
                previousValue = changes[key].previousValue;
              }
              changes[key] = {
                previousValue: previousValue,
                currentValue: currentValue
              };
            }
          }

          function triggerOnChangesHook() {
            destination.$onChanges(changes);
            changes = undefined;
          }
          return removeWatchCollection.length &amp;&amp; function removeWatches() {
            for (var i = 0, ii = removeWatchCollection.length; i &lt; ii; ++i) {
              removeWatchCollection[i]();
            }
          };
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;

  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }

  function nodesetLinkingFn(
    scope,
    nodeList,
    rootElement,
    boundTranscludeFn
  ) {}

  function directiveLinkingFn(
    nodesetLinkingFn,
    scope,
    node,
    rootElement,
    boundTranscludeFn
  ) {}

  function tokenDifference(str1, str2) {
    var values = '',
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);
    outer:
      for (var i = 0; i &lt; tokens1.length; i++) {
        var token = tokens1[i];
        for (var j = 0; j &lt; tokens2.length; j++) {
          if (token == tokens2[j]) continue outer;
        }
        values += (values.length &gt; 0 ? ' ' : '') + token;
      }
    return values;
  }

  function removeComments(jqNodes) {
    jqNodes = jqLite(jqNodes);
    var i = jqNodes.length;
    if (i &lt;= 1) {
      return jqNodes;
    }
    while (i--) {
      var node = jqNodes[i];
      if (node.nodeType === NODE_TYPE_COMMENT) {
        splice.call(jqNodes, i, 1);
      }
    }
    return jqNodes;
  }
  var $controllerMinErr = minErr('$controller');
  var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;

  function identifierForController(controller, ident) {
    if (ident &amp;&amp; isString(ident)) return ident;
    if (isString(controller)) {
      var match = CNTRL_REG.exec(controller);
      if (match) return match[3];
    }
  }

  function $ControllerProvider() {
    var controllers = {},
      globals = false;
    this.has = function(name) {
      return controllers.hasOwnProperty(name);
    };
    this.register = function(name, constructor) {
      assertNotHasOwnProperty(name, 'controller');
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.allowGlobals = function() {
      globals = true;
    };
    this.$get = ['$injector', '$window', function($injector, $window) {
      return function $controller(expression, locals, later, ident) {
        var instance, match, constructor, identifier;
        later = later === true;
        if (ident &amp;&amp; isString(ident)) {
          identifier = ident;
        }
        if (isString(expression)) {
          match = expression.match(CNTRL_REG);
          if (!match) {
            throw $controllerMinErr('ctrlfmt',
              "Badly formed controller string '{0}'. " +
              "Must match `__name__ as __id__` or `__name__`.", expression);
          }
          constructor = match[1],
            identifier = identifier || match[3];
          expression = controllers.hasOwnProperty(constructor) ?
            controllers[constructor] :
            getter(locals.$scope, constructor, true) ||
            (globals ? getter($window, constructor, true) : undefined);
          assertArgFn(expression, constructor, true);
        }
        if (later) {
          var controllerPrototype = (isArray(expression) ?
            expression[expression.length - 1] : expression).prototype;
          instance = Object.create(controllerPrototype || null);
          if (identifier) {
            addIdentifier(locals, identifier, instance, constructor || expression.name);
          }
          var instantiate;
          return instantiate = extend(function $controllerInit() {
            var result = $injector.invoke(expression, instance, locals, constructor);
            if (result !== instance &amp;&amp; (isObject(result) || isFunction(result))) {
              instance = result;
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
            }
            return instance;
          }, {
            instance: instance,
            identifier: identifier
          });
        }
        instance = $injector.instantiate(expression, locals, constructor);
        if (identifier) {
          addIdentifier(locals, identifier, instance, constructor || expression.name);
        }
        return instance;
      };

      function addIdentifier(locals, identifier, instance, name) {
        if (!(locals &amp;&amp; isObject(locals.$scope))) {
          throw minErr('$controller')('noscp',
            "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
            name, identifier);
        }
        locals.$scope[identifier] = instance;
      }
    }];
  }

  function $DocumentProvider() {
    this.$get = ['$window', function(window) {
      return jqLite(window.document);
    }];
  }

  function $ExceptionHandlerProvider() {
    this.$get = ['$log', function($log) {
      return function(exception, cause) {
        $log.error.apply($log, arguments);
      };
    }];
  }
  var $$ForceReflowProvider = function() {
    this.$get = ['$document', function($document) {
      return function(domNode) {
        if (domNode) {
          if (!domNode.nodeType &amp;&amp; domNode instanceof jqLite) {
            domNode = domNode[0];
          }
        } else {
          domNode = $document[0].body;
        }
        return domNode.offsetWidth + 1;
      };
    }];
  };
  var APPLICATION_JSON = 'application/json';
  var CONTENT_TYPE_APPLICATION_JSON = {
    'Content-Type': APPLICATION_JSON + ';charset=utf-8'
  };
  var JSON_START = /^\[|^\{(?!\{)/;
  var JSON_ENDS = {
    '[': /]$/,
    '{': /}$/
  };
  var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
  var $httpMinErr = minErr('$http');
  var $httpMinErrLegacyFn = function(method) {
    return function() {
      throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
    };
  };

  function serializeValue(v) {
    if (isObject(v)) {
      return isDate(v) ? v.toISOString() : toJson(v);
    }
    return v;
  }

  function $HttpParamSerializerProvider() {
    this.$get = function() {
      return function ngParamSerializer(params) {
        if (!params) return '';
        var parts = [];
        forEachSorted(params, function(value, key) {
          if (value === null || isUndefined(value)) return;
          if (isArray(value)) {
            forEach(value, function(v) {
              parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
            });
          } else {
            parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
          }
        });
        return parts.join('&amp;');
      };
    };
  }

  function $HttpParamSerializerJQLikeProvider() {
    this.$get = function() {
      return function jQueryLikeParamSerializer(params) {
        if (!params) return '';
        var parts = [];
        serialize(params, '', true);
        return parts.join('&amp;');

        function serialize(toSerialize, prefix, topLevel) {
          if (toSerialize === null || isUndefined(toSerialize)) return;
          if (isArray(toSerialize)) {
            forEach(toSerialize, function(value, index) {
              serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
            });
          } else if (isObject(toSerialize) &amp;&amp; !isDate(toSerialize)) {
            forEachSorted(toSerialize, function(value, key) {
              serialize(value, prefix +
                (topLevel ? '' : '[') +
                key +
                (topLevel ? '' : ']'));
            });
          } else {
            parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
          }
        }
      };
    };
  }

  function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
      var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
      if (tempData) {
        var contentType = headers('Content-Type');
        if ((contentType &amp;&amp; (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
          data = fromJson(tempData);
        }
      }
    }
    return data;
  }

  function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart &amp;&amp; JSON_ENDS[jsonStart[0]].test(str);
  }

  function parseHeaders(headers) {
    var parsed = createMap(),
      i;

    function fillInParsed(key, val) {
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
    if (isString(headers)) {
      forEach(headers.split('\n'), function(line) {
        i = line.indexOf(':');
        fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
      });
    } else if (isObject(headers)) {
      forEach(headers, function(headerVal, headerKey) {
        fillInParsed(lowercase(headerKey), trim(headerVal));
      });
    }
    return parsed;
  }

  function headersGetter(headers) {
    var headersObj;
    return function(name) {
      if (!headersObj) headersObj = parseHeaders(headers);
      if (name) {
        var value = headersObj[lowercase(name)];
        if (value === void 0) {
          value = null;
        }
        return value;
      }
      return headersObj;
    };
  }

  function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
      return fns(data, headers, status);
    }
    forEach(fns, function(fn) {
      data = fn(data, headers, status);
    });
    return data;
  }

  function isSuccess(status) {
    return 200 &lt;= status &amp;&amp; status &lt; 300;
  }

  function $HttpProvider() {
    var defaults = this.defaults = {
      transformResponse: [defaultHttpResponseTransform],
      transformRequest: [function(d) {
        return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) &amp;&amp; !isFormData(d) ? toJson(d) : d;
      }],
      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*'
        },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
      },
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      paramSerializer: '$httpParamSerializer'
    };
    var useApplyAsync = false;
    this.useApplyAsync = function(value) {
      if (isDefined(value)) {
        useApplyAsync = !!value;
        return this;
      }
      return useApplyAsync;
    };
    var useLegacyPromise = true;
    this.useLegacyPromiseExtensions = function(value) {
      if (isDefined(value)) {
        useLegacyPromise = !!value;
        return this;
      }
      return useLegacyPromise;
    };
    var interceptorFactories = this.interceptors = [];
    this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector',
      function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http');
        defaults.paramSerializer = isString(defaults.paramSerializer) ?
          $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function(interceptorFactory) {
          reversedInterceptors.unshift(isString(interceptorFactory) ?
            $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
        });

        function $http(requestConfig) {
          if (!isObject(requestConfig)) {
            throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
          }
          if (!isString(requestConfig.url)) {
            throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
          }
          var config = extend({
            method: 'get',
            transformRequest: defaults.transformRequest,
            transformResponse: defaults.transformResponse,
            paramSerializer: defaults.paramSerializer
          }, requestConfig);
          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer) ?
            $injector.get(config.paramSerializer) : config.paramSerializer;
          var serverRequest = function(config) {
            var headers = config.headers;
            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
            if (isUndefined(reqData)) {
              forEach(headers, function(value, header) {
                if (lowercase(header) === 'content-type') {
                  delete headers[header];
                }
              });
            }
            if (isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials)) {
              config.withCredentials = defaults.withCredentials;
            }
            return sendReq(config, reqData).then(transformResponse, transformResponse);
          };
          var chain = [serverRequest, undefined];
          var promise = $q.when(config);
          forEach(reversedInterceptors, function(interceptor) {
            if (interceptor.request || interceptor.requestError) {
              chain.unshift(interceptor.request, interceptor.requestError);
            }
            if (interceptor.response || interceptor.responseError) {
              chain.push(interceptor.response, interceptor.responseError);
            }
          });
          while (chain.length) {
            var thenFn = chain.shift();
            var rejectFn = chain.shift();
            promise = promise.then(thenFn, rejectFn);
          }
          if (useLegacyPromise) {
            promise.success = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
            promise.error = function(fn) {
              assertArgFn(fn, 'fn');
              promise.then(null, function(response) {
                fn(response.data, response.status, response.headers, config);
              });
              return promise;
            };
          } else {
            promise.success = $httpMinErrLegacyFn('success');
            promise.error = $httpMinErrLegacyFn('error');
          }
          return promise;

          function transformResponse(response) {
            var resp = extend({}, response);
            resp.data = transformData(response.data, response.headers, response.status,
              config.transformResponse);
            return (isSuccess(response.status)) ?
              resp :
              $q.reject(resp);
          }

          function executeHeaderFns(headers, config) {
            var headerContent, processedHeaders = {};
            forEach(headers, function(headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn(config);
                if (headerContent != null) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });
            return processedHeaders;
          }

          function mergeHeaders(config) {
            var defHeaders = defaults.headers,
              reqHeaders = extend({}, config.headers),
              defHeaderName, lowercaseDefHeaderName, reqHeaderName;
            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
            defaultHeadersIteration:
              for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
            return executeHeaderFns(reqHeaders, shallowCopy(config));
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put', 'patch');
        $http.defaults = defaults;
        return $http;

        function createShortMethods(names) {
          forEach(arguments, function(name) {
            $http[name] = function(url, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }

        function createShortMethodsWithData(name) {
          forEach(arguments, function(name) {
            $http[name] = function(url, data, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }

        function sendReq(config, reqData) {
          var deferred = $q.defer(),
            promise = deferred.promise,
            cache,
            cachedResp,
            reqHeaders = config.headers,
            url = buildUrl(config.url, config.paramSerializer(config.params));
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if ((config.cache || defaults.cache) &amp;&amp; config.cache !== false &amp;&amp;
            (config.method === 'GET' || config.method === 'JSONP')) {
            cache = isObject(config.cache) ? config.cache :
              isObject(defaults.cache) ? defaults.cache :
              defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                } else {
                  resolvePromise(cachedResp, 200, {}, 'OK');
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (isUndefined(cachedResp)) {
            var xsrfValue = urlIsSameOrigin(config.url) ?
              $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] :
              undefined;
            if (xsrfValue) {
              reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
            }
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
              config.withCredentials, config.responseType);
          }
          return promise;

          function done(status, response, headersString, statusText) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [status, response, parseHeaders(headersString), statusText]);
              } else {
                cache.remove(url);
              }
            }

            function resolveHttpPromise() {
              resolvePromise(response, status, headersString, statusText);
            }
            if (useApplyAsync) {
              $rootScope.$applyAsync(resolveHttpPromise);
            } else {
              resolveHttpPromise();
              if (!$rootScope.$$phase) $rootScope.$apply();
            }
          }

          function resolvePromise(response, status, headers, statusText) {
            status = status &gt;= -1 ? status : 0;
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config,
              statusText: statusText
            });
          }

          function resolvePromiseWithResult(result) {
            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
          }

          function removePendingReq() {
            var idx = $http.pendingRequests.indexOf(config);
            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
          }
        }

        function buildUrl(url, serializedParams) {
          if (serializedParams.length &gt; 0) {
            url += ((url.indexOf('?') == -1) ? '?' : '&amp;') + serializedParams;
          }
          return url;
        }
      }
    ];
  }

  function $xhrFactoryProvider() {
    this.$get = function() {
      return function createXhr() {
        return new window.XMLHttpRequest();
      };
    };
  }

  function $HttpBackendProvider() {
    this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
      return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
    }];
  }

  function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
    return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function(data) {
          callbacks[callbackId].data = data;
          callbacks[callbackId].called = true;
        };
        var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
          callbackId,
          function(status, text) {
            completeRequest(callback, status, callbacks[callbackId].data, "", text);
            callbacks[callbackId] = noop;
          });
      } else {
        var xhr = createXhr(method, url);
        xhr.open(method, url, true);
        forEach(headers, function(value, key) {
          if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
          }
        });
        xhr.onload = function requestLoaded() {
          var statusText = xhr.statusText || '';
          var response = ('response' in xhr) ? xhr.response : xhr.responseText;
          var status = xhr.status === 1223 ? 204 : xhr.status;
          if (status === 0) {
            status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
          }
          completeRequest(callback,
            status,
            response,
            xhr.getAllResponseHeaders(),
            statusText);
        };
        var requestError = function() {
          completeRequest(callback, -1, null, null, '');
        };
        xhr.onerror = requestError;
        xhr.onabort = requestError;
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        if (responseType) {
          try {
            xhr.responseType = responseType;
          } catch (e) {
            if (responseType !== 'json') {
              throw e;
            }
          }
        }
        xhr.send(isUndefined(post) ? null : post);
      }
      if (timeout &gt; 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
      } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
      }

      function timeoutRequest() {
        jsonpDone &amp;&amp; jsonpDone();
        xhr &amp;&amp; xhr.abort();
      }

      function completeRequest(callback, status, response, headersString, statusText) {
        if (isDefined(timeoutId)) {
          $browserDefer.cancel(timeoutId);
        }
        jsonpDone = xhr = null;
        callback(status, response, headersString, statusText);
        $browser.$$completeOutstandingRequest(noop);
      }
    };

    function jsonpReq(url, callbackId, done) {
      var script = rawDocument.createElement('script'),
        callback = null;
      script.type = "text/javascript";
      script.src = url;
      script.async = true;
      callback = function(event) {
        removeEventListenerFn(script, "load", callback);
        removeEventListenerFn(script, "error", callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = "unknown";
        if (event) {
          if (event.type === "load" &amp;&amp; !callbacks[callbackId].called) {
            event = {
              type: "error"
            };
          }
          text = event.type;
          status = event.type === "error" ? 404 : 200;
        }
        if (done) {
          done(status, text);
        }
      };
      addEventListenerFn(script, "load", callback);
      addEventListenerFn(script, "error", callback);
      rawDocument.body.appendChild(script);
      return callback;
    }
  }
  var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
  $interpolateMinErr.throwNoconcat = function(text) {
    throw $interpolateMinErr('noconcat',
      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
      "interpolations that concatenate multiple expressions when a trusted value is " +
      "required.  See http://docs.angularjs.org/api/ng.$sce", text);
  };
  $interpolateMinErr.interr = function(text, err) {
    return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
  };

  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function(value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function(value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
      var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length,
        escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
        escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');

      function escape(ch) {
        return '\\\\\\' + ch;
      }

      function unescapeText(text) {
        return text.replace(escapedStartRegexp, startSymbol).
        replace(escapedEndRegexp, endSymbol);
      }

      function stringify(value) {
        if (value == null) {
          return '';
        }
        switch (typeof value) {
          case 'string':
            break;
          case 'number':
            value = '' + value;
            break;
          default:
            value = toJson(value);
        }
        return value;
      }

      function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
        var unwatch;
        return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
          unwatch();
          return constantInterp(scope);
        }, listener, objectEquality);
      }

      function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
        if (!text.length || text.indexOf(startSymbol) === -1) {
          var constantInterp;
          if (!mustHaveExpression) {
            var unescapedText = unescapeText(text);
            constantInterp = valueFn(unescapedText);
            constantInterp.exp = text;
            constantInterp.expressions = [];
            constantInterp.$$watchDelegate = constantWatchDelegate;
          }
          return constantInterp;
        }
        allOrNothing = !!allOrNothing;
        var startIndex,
          endIndex,
          index = 0,
          expressions = [],
          parseFns = [],
          textLength = text.length,
          exp,
          concat = [],
          expressionPositions = [];
        while (index &lt; textLength) {
          if (((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;
            ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
            if (index !== startIndex) {
              concat.push(unescapeText(text.substring(index, startIndex)));
            }
            exp = text.substring(startIndex + startSymbolLength, endIndex);
            expressions.push(exp);
            parseFns.push($parse(exp, parseStringifyInterceptor));
            index = endIndex + endSymbolLength;
            expressionPositions.push(concat.length);
            concat.push('');
          } else {
            if (index !== textLength) {
              concat.push(unescapeText(text.substring(index)));
            }
            break;
          }
        }
        if (trustedContext &amp;&amp; concat.length &gt; 1) {
          $interpolateMinErr.throwNoconcat(text);
        }
        if (!mustHaveExpression || expressions.length) {
          var compute = function(values) {
            for (var i = 0, ii = expressions.length; i &lt; ii; i++) {
              if (allOrNothing &amp;&amp; isUndefined(values[i])) return;
              concat[expressionPositions[i]] = values[i];
            }
            return concat.join('');
          };
          var getValue = function(value) {
            return trustedContext ?
              $sce.getTrusted(trustedContext, value) :
              $sce.valueOf(value);
          };
          return extend(function interpolationFn(context) {
            var i = 0;
            var ii = expressions.length;
            var values = new Array(ii);
            try {
              for (; i &lt; ii; i++) {
                values[i] = parseFns[i](context);
              }
              return compute(values);
            } catch (err) {
              $exceptionHandler($interpolateMinErr.interr(text, err));
            }
          }, {
            exp: text,
            expressions: expressions,
            $$watchDelegate: function(scope, listener) {
              var lastValue;
              return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                var currValue = compute(values);
                if (isFunction(listener)) {
                  listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                }
                lastValue = currValue;
              });
            }
          });
        }

        function parseStringifyInterceptor(value) {
          try {
            value = getValue(value);
            return allOrNothing &amp;&amp; !isDefined(value) ? value : stringify(value);
          } catch (err) {
            $exceptionHandler($interpolateMinErr.interr(text, err));
          }
        }
      }
      $interpolate.startSymbol = function() {
        return startSymbol;
      };
      $interpolate.endSymbol = function() {
        return endSymbol;
      };
      return $interpolate;
    }];
  }

  function $IntervalProvider() {
    this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser',
      function($rootScope, $window, $q, $$q, $browser) {
        var intervals = {};

        function interval(fn, delay, count, invokeApply) {
          var hasParams = arguments.length &gt; 4,
            args = hasParams ? sliceArgs(arguments, 4) : [],
            setInterval = $window.setInterval,
            clearInterval = $window.clearInterval,
            iteration = 0,
            skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise;
          count = isDefined(count) ? count : 0;
          promise.$$intervalId = setInterval(function tick() {
            if (skipApply) {
              $browser.defer(callback);
            } else {
              $rootScope.$evalAsync(callback);
            }
            deferred.notify(iteration++);
            if (count &gt; 0 &amp;&amp; iteration &gt;= count) {
              deferred.resolve(iteration);
              clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          intervals[promise.$$intervalId] = deferred;
          return promise;

          function callback() {
            if (!hasParams) {
              fn(iteration);
            } else {
              fn.apply(null, args);
            }
          }
        }
        interval.cancel = function(promise) {
          if (promise &amp;&amp; promise.$$intervalId in intervals) {
            intervals[promise.$$intervalId].reject('canceled');
            $window.clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
            return true;
          }
          return false;
        };
        return interval;
      }
    ];
  }
  var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  var $locationMinErr = minErr('$location');

  function encodePath(path) {
    var segments = path.split('/'),
      i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }

  function parseAbsoluteUrl(absoluteUrl, locationObj) {
    var parsedUrl = urlResolve(absoluteUrl);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
  }

  function parseAppUrl(relativeUrl, locationObj) {
    var prefixed = (relativeUrl.charAt(0) !== '/');
    if (prefixed) {
      relativeUrl = '/' + relativeUrl;
    }
    var match = urlResolve(relativeUrl);
    locationObj.$$path = decodeURIComponent(prefixed &amp;&amp; match.pathname.charAt(0) === '/' ?
      match.pathname.substring(1) : match.pathname);
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) != '/') {
      locationObj.$$path = '/' + locationObj.$$path;
    }
  }

  function beginsWith(begin, whole) {
    if (whole.indexOf(begin) === 0) {
      return whole.substr(begin.length);
    }
  }

  function stripHash(url) {
    var index = url.indexOf('#');
    return index == -1 ? url : url.substr(0, index);
  }

  function trimEmptyHash(url) {
    return url.replace(/(#.+)|#$/, '$1');
  }

  function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
  }

  function serverBase(url) {
    return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
  }

  function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || '';
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function(url) {
      var pathUrl = beginsWith(appBaseNoFile, url);
      if (!isString(pathUrl)) {
        throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
          appBaseNoFile);
      }
      parseAppUrl(pathUrl, this);
      if (!this.$$path) {
        this.$$path = '/';
      }
      this.$$compose();
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    };
    this.$$parseLinkUrl = function(url, relHref) {
      if (relHref &amp;&amp; relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
      }
      var appUrl, prevAppUrl;
      var rewrittenUrl;
      if (isDefined(appUrl = beginsWith(appBase, url))) {
        prevAppUrl = appUrl;
        if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
          rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
        } else {
          rewrittenUrl = appBase + prevAppUrl;
        }
      } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
        rewrittenUrl = appBaseNoFile + appUrl;
      } else if (appBaseNoFile == url + '/') {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
  }

  function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function(url) {
      var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
      var withoutHashUrl;
      if (!isUndefined(withoutBaseUrl) &amp;&amp; withoutBaseUrl.charAt(0) === '#') {
        withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
        if (isUndefined(withoutHashUrl)) {
          withoutHashUrl = withoutBaseUrl;
        }
      } else {
        if (this.$$html5) {
          withoutHashUrl = withoutBaseUrl;
        } else {
          withoutHashUrl = '';
          if (isUndefined(withoutBaseUrl)) {
            appBase = url;
            this.replace();
          }
        }
      }
      parseAppUrl(withoutHashUrl, this);
      this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
      this.$$compose();

      function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (url.indexOf(base) === 0) {
          url = url.replace(base, '');
        }
        if (windowsFilePathExp.exec(url)) {
          return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
      }
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
    };
    this.$$parseLinkUrl = function(url, relHref) {
      if (stripHash(appBase) == stripHash(url)) {
        this.$$parse(url);
        return true;
      }
      return false;
    };
  }

  function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    this.$$parseLinkUrl = function(url, relHref) {
      if (relHref &amp;&amp; relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
      }
      var rewrittenUrl;
      var appUrl;
      if (appBase == stripHash(url)) {
        rewrittenUrl = url;
      } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
        rewrittenUrl = appBase + hashPrefix + appUrl;
      } else if (appBaseNoFile === url + '/') {
        rewrittenUrl = appBaseNoFile;
      }
      if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
      }
      return !!rewrittenUrl;
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = appBase + hashPrefix + this.$$url;
    };
  }
  var locationPrototype = {
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function(url) {
      if (isUndefined(url)) {
        return this.$$url;
      }
      var match = PATH_MATCH.exec(url);
      if (match[1] || url === '') this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1] || url === '') this.search(match[3] || '');
      this.hash(match[5] || '');
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function(path) {
      path = path !== null ? path.toString() : '';
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function(search, paramValue) {
      switch (arguments.length) {
        case 0:
          return this.$$search;
        case 1:
          if (isString(search) || isNumber(search)) {
            search = search.toString();
            this.$$search = parseKeyValue(search);
          } else if (isObject(search)) {
            search = copy(search, {});
            forEach(search, function(value, key) {
              if (value == null) delete search[key];
            });
            this.$$search = search;
          } else {
            throw $locationMinErr('isrcharg',
              'The first argument of the `$location#search()` call must be a string or an object.');
          }
          break;
        default:
          if (isUndefined(paramValue) || paramValue === null) {
            delete this.$$search[search];
          } else {
            this.$$search[search] = paramValue;
          }
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', function(hash) {
      return hash !== null ? hash.toString() : '';
    }),
    replace: function() {
      this.$$replace = true;
      return this;
    }
  };
  forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
    Location.prototype = Object.create(locationPrototype);
    Location.prototype.state = function(state) {
      if (!arguments.length) {
        return this.$$state;
      }
      if (Location !== LocationHtml5Url || !this.$$html5) {
        throw $locationMinErr('nostate', 'History API state support is available only ' +
          'in HTML5 mode and only in browsers supporting HTML5 History API');
      }
      this.$$state = isUndefined(state) ? null : state;
      return this;
    };
  });

  function locationGetter(property) {
    return function() {
      return this[property];
    };
  }

  function locationGetterSetter(property, preprocess) {
    return function(value) {
      if (isUndefined(value)) {
        return this[property];
      }
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }

  function $LocationProvider() {
    var hashPrefix = '',
      html5Mode = {
        enabled: false,
        requireBase: true,
        rewriteLinks: true
      };
    this.hashPrefix = function(prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function(mode) {
      if (isBoolean(mode)) {
        html5Mode.enabled = mode;
        return this;
      } else if (isObject(mode)) {
        if (isBoolean(mode.enabled)) {
          html5Mode.enabled = mode.enabled;
        }
        if (isBoolean(mode.requireBase)) {
          html5Mode.requireBase = mode.requireBase;
        }
        if (isBoolean(mode.rewriteLinks)) {
          html5Mode.rewriteLinks = mode.rewriteLinks;
        }
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window',
      function($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location,
          LocationMode,
          baseHref = $browser.baseHref(),
          initialUrl = $browser.url(),
          appBase;
        if (html5Mode.enabled) {
          if (!baseHref &amp;&amp; html5Mode.requireBase) {
            throw $locationMinErr('nobase',
              "$location in HTML5 mode requires a &lt;base&gt; tag to be present!");
          }
          appBase = serverBase(initialUrl) + (baseHref || '/');
          LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
        } else {
          appBase = stripHash(initialUrl);
          LocationMode = LocationHashbangUrl;
        }
        var appBaseNoFile = stripFile(appBase);
        $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;

        function setBrowserUrlWithFallback(url, replace, state) {
          var oldUrl = $location.url();
          var oldState = $location.$$state;
          try {
            $browser.url(url, replace, state);
            $location.$$state = $browser.state();
          } catch (e) {
            $location.url(oldUrl);
            $location.$$state = oldState;
            throw e;
          }
        }
        $rootElement.on('click', function(event) {
          if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2) return;
          var elm = jqLite(event.target);
          while (nodeName_(elm[0]) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
          }
          var absHref = elm.prop('href');
          var relHref = elm.attr('href') || elm.attr('xlink:href');
          if (isObject(absHref) &amp;&amp; absHref.toString() === '[object SVGAnimatedString]') {
            absHref = urlResolve(absHref.animVal).href;
          }
          if (IGNORE_URI_REGEXP.test(absHref)) return;
          if (absHref &amp;&amp; !elm.attr('target') &amp;&amp; !event.isDefaultPrevented()) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              event.preventDefault();
              if ($location.absUrl() != $browser.url()) {
                $rootScope.$apply();
                $window.angular['ff-684208-preventDefault'] = true;
              }
            }
          }
        });
        if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
          $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function(newUrl, newState) {
          if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
            $window.location.href = newUrl;
            return;
          }
          $rootScope.$evalAsync(function() {
            var oldUrl = $location.absUrl();
            var oldState = $location.$$state;
            var defaultPrevented;
            newUrl = trimEmptyHash(newUrl);
            $location.$$parse(newUrl);
            $location.$$state = newState;
            defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
              newState, oldState).defaultPrevented;
            if ($location.absUrl() !== newUrl) return;
            if (defaultPrevented) {
              $location.$$parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, false, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
          if (!$rootScope.$$phase) $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = trimEmptyHash($browser.url());
          var newUrl = trimEmptyHash($location.absUrl());
          var oldState = $browser.state();
          var currentReplace = $location.$$replace;
          var urlOrStateChanged = oldUrl !== newUrl ||
            ($location.$$html5 &amp;&amp; $sniffer.history &amp;&amp; oldState !== $location.$$state);
          if (initializing || urlOrStateChanged) {
            initializing = false;
            $rootScope.$evalAsync(function() {
              var newUrl = $location.absUrl();
              var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,
                $location.$$state, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl) return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(newUrl, currentReplace,
                    oldState === $location.$$state ? null : $location.$$state);
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
          $location.$$replace = false;
        });
        return $location;

        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl,
            $location.$$state, oldState);
        }
      }
    ];
  }

  function $LogProvider() {
    var debug = true,
      self = this;
    this.debugEnabled = function(flag) {
      if (isDefined(flag)) {
        debug = flag;
        return this;
      } else {
        return debug;
      }
    };
    this.$get = ['$window', function($window) {
      return {
        log: consoleLog('log'),
        info: consoleLog('info'),
        warn: consoleLog('warn'),
        error: consoleLog('error'),
        debug: (function() {
          var fn = consoleLog('debug');
          return function() {
            if (debug) {
              fn.apply(self, arguments);
            }
          };
        }())
      };

      function formatError(arg) {
        if (arg instanceof Error) {
          if (arg.stack) {
            arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1) ?
              'Error: ' + arg.message + '\n' + arg.stack :
              arg.stack;
          } else if (arg.sourceURL) {
            arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
          }
        }
        return arg;
      }

      function consoleLog(type) {
        var console = $window.console || {},
          logFn = console[type] || console.log || noop,
          hasApply = false;
        try {
          hasApply = !!logFn.apply;
        } catch (e) {}
        if (hasApply) {
          return function() {
            var args = [];
            forEach(arguments, function(arg) {
              args.push(formatError(arg));
            });
            return logFn.apply(console, args);
          };
        }
        return function(arg1, arg2) {
          logFn(arg1, arg2 == null ? '' : arg2);
        };
      }
    }];
  }
  var $parseMinErr = minErr('$parse');

  function ensureSafeMemberName(name, fullExpression) {
    if (name === "__defineGetter__" || name === "__defineSetter__" ||
      name === "__lookupGetter__" || name === "__lookupSetter__" ||
      name === "__proto__") {
      throw $parseMinErr('isecfld',
        'Attempting to access a disallowed field in Angular expressions! ' +
        'Expression: {0}', fullExpression);
    }
    return name;
  }

  function getStringValue(name) {
    return name + '';
  }

  function ensureSafeObject(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj.window === obj) {
        throw $parseMinErr('isecwindow',
          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj.children &amp;&amp; (obj.nodeName || (obj.prop &amp;&amp; obj.attr &amp;&amp; obj.find))) {
        throw $parseMinErr('isecdom',
          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (
        obj === Object) {
        throw $parseMinErr('isecobj',
          'Referencing Object in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      }
    }
    return obj;
  }
  var CALL = Function.prototype.call;
  var APPLY = Function.prototype.apply;
  var BIND = Function.prototype.bind;

  function ensureSafeFunction(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      } else if (obj === CALL || obj === APPLY || obj === BIND) {
        throw $parseMinErr('isecff',
          'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
      }
    }
  }

  function ensureSafeAssignContext(obj, fullExpression) {
    if (obj) {
      if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor ||
        obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
        throw $parseMinErr('isecaf',
          'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
      }
    }
  }
  var OPERATORS = createMap();
  forEach('+ - * / % === !== == != &lt; &gt; &lt;= &gt;= &amp;&amp; || ! = |'.split(' '), function(operator) {
    OPERATORS[operator] = true;
  });
  var ESCAPE = {
    "n": "\n",
    "f": "\f",
    "r": "\r",
    "t": "\t",
    "v": "\v",
    "'": "'",
    '"': '"'
  };
  var Lexer = function(options) {
    this.options = options;
  };
  Lexer.prototype = {
    constructor: Lexer,
    lex: function(text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index &lt; this.text.length) {
        var ch = this.text.charAt(this.index);
        if (ch === '"' || ch === "'") {
          this.readString(ch);
        } else if (this.isNumber(ch) || ch === '.' &amp;&amp; this.isNumber(this.peek())) {
          this.readNumber();
        } else if (this.isIdent(ch)) {
          this.readIdent();
        } else if (this.is(ch, '(){}[].,;:?')) {
          this.tokens.push({
            index: this.index,
            text: ch
          });
          this.index++;
        } else if (this.isWhitespace(ch)) {
          this.index++;
        } else {
          var ch2 = ch + this.peek();
          var ch3 = ch2 + this.peek(2);
          var op1 = OPERATORS[ch];
          var op2 = OPERATORS[ch2];
          var op3 = OPERATORS[ch3];
          if (op1 || op2 || op3) {
            var token = op3 ? ch3 : (op2 ? ch2 : ch);
            this.tokens.push({
              index: this.index,
              text: token,
              operator: true
            });
            this.index += token.length;
          } else {
            this.throwError('Unexpected next character ', this.index, this.index + 1);
          }
        }
      }
      return this.tokens;
    },
    is: function(ch, chars) {
      return chars.indexOf(ch) !== -1;
    },
    peek: function(i) {
      var num = i || 1;
      return (this.index + num &lt; this.text.length) ? this.text.charAt(this.index + num) : false;
    },
    isNumber: function(ch) {
      return ('0' &lt;= ch &amp;&amp; ch &lt;= '9') &amp;&amp; typeof ch === "string";
    },
    isWhitespace: function(ch) {
      return (ch === ' ' || ch === '\r' || ch === '\t' ||
        ch === '\n' || ch === '\v' || ch === '\u00A0');
    },
    isIdent: function(ch) {
      return ('a' &lt;= ch &amp;&amp; ch &lt;= 'z' ||
        'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' ||
        '_' === ch || ch === '$');
    },
    isExpOperator: function(ch) {
      return (ch === '-' || ch === '+' || this.isNumber(ch));
    },
    throwError: function(error, start, end) {
      end = end || this.index;
      var colStr = (isDefined(start) ?
        's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' :
        ' ' + end);
      throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
        error, colStr, this.text);
    },
    readNumber: function() {
      var number = '';
      var start = this.index;
      while (this.index &lt; this.text.length) {
        var ch = lowercase(this.text.charAt(this.index));
        if (ch == '.' || this.isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = this.peek();
          if (ch == 'e' &amp;&amp; this.isExpOperator(peekCh)) {
            number += ch;
          } else if (this.isExpOperator(ch) &amp;&amp;
            peekCh &amp;&amp; this.isNumber(peekCh) &amp;&amp;
            number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (this.isExpOperator(ch) &amp;&amp;
            (!peekCh || !this.isNumber(peekCh)) &amp;&amp;
            number.charAt(number.length - 1) == 'e') {
            this.throwError('Invalid exponent');
          } else {
            break;
          }
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: number,
        constant: true,
        value: Number(number)
      });
    },
    readIdent: function() {
      var start = this.index;
      while (this.index &lt; this.text.length) {
        var ch = this.text.charAt(this.index);
        if (!(this.isIdent(ch) || this.isNumber(ch))) {
          break;
        }
        this.index++;
      }
      this.tokens.push({
        index: start,
        text: this.text.slice(start, this.index),
        identifier: true
      });
    },
    readString: function(quote) {
      var start = this.index;
      this.index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (this.index &lt; this.text.length) {
        var ch = this.text.charAt(this.index);
        rawString += ch;
        if (escape) {
          if (ch === 'u') {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
              this.throwError('Invalid unicode escape [\\u' + hex + ']');
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            string = string + (rep || ch);
          }
          escape = false;
        } else if (ch === '\\') {
          escape = true;
        } else if (ch === quote) {
          this.index++;
          this.tokens.push({
            index: start,
            text: rawString,
            constant: true,
            value: string
          });
          return;
        } else {
          string += ch;
        }
        this.index++;
      }
      this.throwError('Unterminated quote', start);
    }
  };
  var AST = function(lexer, options) {
    this.lexer = lexer;
    this.options = options;
  };
  AST.Program = 'Program';
  AST.ExpressionStatement = 'ExpressionStatement';
  AST.AssignmentExpression = 'AssignmentExpression';
  AST.ConditionalExpression = 'ConditionalExpression';
  AST.LogicalExpression = 'LogicalExpression';
  AST.BinaryExpression = 'BinaryExpression';
  AST.UnaryExpression = 'UnaryExpression';
  AST.CallExpression = 'CallExpression';
  AST.MemberExpression = 'MemberExpression';
  AST.Identifier = 'Identifier';
  AST.Literal = 'Literal';
  AST.ArrayExpression = 'ArrayExpression';
  AST.Property = 'Property';
  AST.ObjectExpression = 'ObjectExpression';
  AST.ThisExpression = 'ThisExpression';
  AST.LocalsExpression = 'LocalsExpression';
  AST.NGValueParameter = 'NGValueParameter';
  AST.prototype = {
    ast: function(text) {
      this.text = text;
      this.tokens = this.lexer.lex(text);
      var value = this.program();
      if (this.tokens.length !== 0) {
        this.throwError('is an unexpected token', this.tokens[0]);
      }
      return value;
    },
    program: function() {
      var body = [];
      while (true) {
        if (this.tokens.length &gt; 0 &amp;&amp; !this.peek('}', ')', ';', ']'))
          body.push(this.expressionStatement());
        if (!this.expect(';')) {
          return {
            type: AST.Program,
            body: body
          };
        }
      }
    },
    expressionStatement: function() {
      return {
        type: AST.ExpressionStatement,
        expression: this.filterChain()
      };
    },
    filterChain: function() {
      var left = this.expression();
      var token;
      while ((token = this.expect('|'))) {
        left = this.filter(left);
      }
      return left;
    },
    expression: function() {
      return this.assignment();
    },
    assignment: function() {
      var result = this.ternary();
      if (this.expect('=')) {
        result = {
          type: AST.AssignmentExpression,
          left: result,
          right: this.assignment(),
          operator: '='
        };
      }
      return result;
    },
    ternary: function() {
      var test = this.logicalOR();
      var alternate;
      var consequent;
      if (this.expect('?')) {
        alternate = this.expression();
        if (this.consume(':')) {
          consequent = this.expression();
          return {
            type: AST.ConditionalExpression,
            test: test,
            alternate: alternate,
            consequent: consequent
          };
        }
      }
      return test;
    },
    logicalOR: function() {
      var left = this.logicalAND();
      while (this.expect('||')) {
        left = {
          type: AST.LogicalExpression,
          operator: '||',
          left: left,
          right: this.logicalAND()
        };
      }
      return left;
    },
    logicalAND: function() {
      var left = this.equality();
      while (this.expect('&amp;&amp;')) {
        left = {
          type: AST.LogicalExpression,
          operator: '&amp;&amp;',
          left: left,
          right: this.equality()
        };
      }
      return left;
    },
    equality: function() {
      var left = this.relational();
      var token;
      while ((token = this.expect('==', '!=', '===', '!=='))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.relational()
        };
      }
      return left;
    },
    relational: function() {
      var left = this.additive();
      var token;
      while ((token = this.expect('&lt;', '&gt;', '&lt;=', '&gt;='))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.additive()
        };
      }
      return left;
    },
    additive: function() {
      var left = this.multiplicative();
      var token;
      while ((token = this.expect('+', '-'))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.multiplicative()
        };
      }
      return left;
    },
    multiplicative: function() {
      var left = this.unary();
      var token;
      while ((token = this.expect('*', '/', '%'))) {
        left = {
          type: AST.BinaryExpression,
          operator: token.text,
          left: left,
          right: this.unary()
        };
      }
      return left;
    },
    unary: function() {
      var token;
      if ((token = this.expect('+', '-', '!'))) {
        return {
          type: AST.UnaryExpression,
          operator: token.text,
          prefix: true,
          argument: this.unary()
        };
      } else {
        return this.primary();
      }
    },
    primary: function() {
      var primary;
      if (this.expect('(')) {
        primary = this.filterChain();
        this.consume(')');
      } else if (this.expect('[')) {
        primary = this.arrayDeclaration();
      } else if (this.expect('{')) {
        primary = this.object();
      } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
        primary = copy(this.selfReferential[this.consume().text]);
      } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
        primary = {
          type: AST.Literal,
          value: this.options.literals[this.consume().text]
        };
      } else if (this.peek().identifier) {
        primary = this.identifier();
      } else if (this.peek().constant) {
        primary = this.constant();
      } else {
        this.throwError('not a primary expression', this.peek());
      }
      var next;
      while ((next = this.expect('(', '[', '.'))) {
        if (next.text === '(') {
          primary = {
            type: AST.CallExpression,
            callee: primary,
            arguments: this.parseArguments()
          };
          this.consume(')');
        } else if (next.text === '[') {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.expression(),
            computed: true
          };
          this.consume(']');
        } else if (next.text === '.') {
          primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.identifier(),
            computed: false
          };
        } else {
          this.throwError('IMPOSSIBLE');
        }
      }
      return primary;
    },
    filter: function(baseExpression) {
      var args = [baseExpression];
      var result = {
        type: AST.CallExpression,
        callee: this.identifier(),
        arguments: args,
        filter: true
      };
      while (this.expect(':')) {
        args.push(this.expression());
      }
      return result;
    },
    parseArguments: function() {
      var args = [];
      if (this.peekToken().text !== ')') {
        do {
          args.push(this.expression());
        } while (this.expect(','));
      }
      return args;
    },
    identifier: function() {
      var token = this.consume();
      if (!token.identifier) {
        this.throwError('is not a valid identifier', token);
      }
      return {
        type: AST.Identifier,
        name: token.text
      };
    },
    constant: function() {
      return {
        type: AST.Literal,
        value: this.consume().value
      };
    },
    arrayDeclaration: function() {
      var elements = [];
      if (this.peekToken().text !== ']') {
        do {
          if (this.peek(']')) {
            break;
          }
          elements.push(this.expression());
        } while (this.expect(','));
      }
      this.consume(']');
      return {
        type: AST.ArrayExpression,
        elements: elements
      };
    },
    object: function() {
      var properties = [],
        property;
      if (this.peekToken().text !== '}') {
        do {
          if (this.peek('}')) {
            break;
          }
          property = {
            type: AST.Property,
            kind: 'init'
          };
          if (this.peek().constant) {
            property.key = this.constant();
          } else if (this.peek().identifier) {
            property.key = this.identifier();
          } else {
            this.throwError("invalid key", this.peek());
          }
          this.consume(':');
          property.value = this.expression();
          properties.push(property);
        } while (this.expect(','));
      }
      this.consume('}');
      return {
        type: AST.ObjectExpression,
        properties: properties
      };
    },
    throwError: function(msg, token) {
      throw $parseMinErr('syntax',
        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
        token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
    },
    consume: function(e1) {
      if (this.tokens.length === 0) {
        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
      }
      var token = this.expect(e1);
      if (!token) {
        this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
      }
      return token;
    },
    peekToken: function() {
      if (this.tokens.length === 0) {
        throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
      }
      return this.tokens[0];
    },
    peek: function(e1, e2, e3, e4) {
      return this.peekAhead(0, e1, e2, e3, e4);
    },
    peekAhead: function(i, e1, e2, e3, e4) {
      if (this.tokens.length &gt; i) {
        var token = this.tokens[i];
        var t = token.text;
        if (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {
          return token;
        }
      }
      return false;
    },
    expect: function(e1, e2, e3, e4) {
      var token = this.peek(e1, e2, e3, e4);
      if (token) {
        this.tokens.shift();
        return token;
      }
      return false;
    },
    selfReferential: {
      'this': {
        type: AST.ThisExpression
      },
      '$locals': {
        type: AST.LocalsExpression
      }
    }
  };

  function ifDefined(v, d) {
    return typeof v !== 'undefined' ? v : d;
  }

  function plusFn(l, r) {
    if (typeof l === 'undefined') return r;
    if (typeof r === 'undefined') return l;
    return l + r;
  }

  function isStateless($filter, filterName) {
    var fn = $filter(filterName);
    return !fn.$stateful;
  }

  function findConstantAndWatchExpressions(ast, $filter) {
    var allConstants;
    var argsToWatch;
    switch (ast.type) {
      case AST.Program:
        allConstants = true;
        forEach(ast.body, function(expr) {
          findConstantAndWatchExpressions(expr.expression, $filter);
          allConstants = allConstants &amp;&amp; expr.expression.constant;
        });
        ast.constant = allConstants;
        break;
      case AST.Literal:
        ast.constant = true;
        ast.toWatch = [];
        break;
      case AST.UnaryExpression:
        findConstantAndWatchExpressions(ast.argument, $filter);
        ast.constant = ast.argument.constant;
        ast.toWatch = ast.argument.toWatch;
        break;
      case AST.BinaryExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant &amp;&amp; ast.right.constant;
        ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
        break;
      case AST.LogicalExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant &amp;&amp; ast.right.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.ConditionalExpression:
        findConstantAndWatchExpressions(ast.test, $filter);
        findConstantAndWatchExpressions(ast.alternate, $filter);
        findConstantAndWatchExpressions(ast.consequent, $filter);
        ast.constant = ast.test.constant &amp;&amp; ast.alternate.constant &amp;&amp; ast.consequent.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
      case AST.Identifier:
        ast.constant = false;
        ast.toWatch = [ast];
        break;
      case AST.MemberExpression:
        findConstantAndWatchExpressions(ast.object, $filter);
        if (ast.computed) {
          findConstantAndWatchExpressions(ast.property, $filter);
        }
        ast.constant = ast.object.constant &amp;&amp; (!ast.computed || ast.property.constant);
        ast.toWatch = [ast];
        break;
      case AST.CallExpression:
        allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
        argsToWatch = [];
        forEach(ast.arguments, function(expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants &amp;&amp; expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = ast.filter &amp;&amp; isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
        break;
      case AST.AssignmentExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant &amp;&amp; ast.right.constant;
        ast.toWatch = [ast];
        break;
      case AST.ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.elements, function(expr) {
          findConstantAndWatchExpressions(expr, $filter);
          allConstants = allConstants &amp;&amp; expr.constant;
          if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.properties, function(property) {
          findConstantAndWatchExpressions(property.value, $filter);
          allConstants = allConstants &amp;&amp; property.value.constant;
          if (!property.value.constant) {
            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
          }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
      case AST.ThisExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
      case AST.LocalsExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    }
  }

  function getInputs(body) {
    if (body.length != 1) return;
    var lastExpression = body[0].expression;
    var candidate = lastExpression.toWatch;
    if (candidate.length !== 1) return candidate;
    return candidate[0] !== lastExpression ? candidate : undefined;
  }

  function isAssignable(ast) {
    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
  }

  function assignableAST(ast) {
    if (ast.body.length === 1 &amp;&amp; isAssignable(ast.body[0].expression)) {
      return {
        type: AST.AssignmentExpression,
        left: ast.body[0].expression,
        right: {
          type: AST.NGValueParameter
        },
        operator: '='
      };
    }
  }

  function isLiteral(ast) {
    return ast.body.length === 0 ||
      ast.body.length === 1 &amp;&amp; (
        ast.body[0].expression.type === AST.Literal ||
        ast.body[0].expression.type === AST.ArrayExpression ||
        ast.body[0].expression.type === AST.ObjectExpression);
  }

  function isConstant(ast) {
    return ast.constant;
  }

  function ASTCompiler(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTCompiler.prototype = {
    compile: function(expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.state = {
        nextId: 0,
        filters: {},
        expensiveChecks: expensiveChecks,
        fn: {
          vars: [],
          body: [],
          own: {}
        },
        assign: {
          vars: [],
          body: [],
          own: {}
        },
        inputs: []
      };
      findConstantAndWatchExpressions(ast, self.$filter);
      var extra = '';
      var assignable;
      this.stage = 'assign';
      if ((assignable = assignableAST(ast))) {
        this.state.computing = 'assign';
        var result = this.nextId();
        this.recurse(assignable, result);
        this.return_(result);
        extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
      }
      var toWatch = getInputs(ast.body);
      self.stage = 'inputs';
      forEach(toWatch, function(watch, key) {
        var fnKey = 'fn' + key;
        self.state[fnKey] = {
          vars: [],
          body: [],
          own: {}
        };
        self.state.computing = fnKey;
        var intoId = self.nextId();
        self.recurse(watch, intoId);
        self.return_(intoId);
        self.state.inputs.push(fnKey);
        watch.watchId = key;
      });
      this.state.computing = 'fn';
      this.stage = 'main';
      this.recurse(ast);
      var fnString =
        '"' + this.USE + ' ' + this.STRICT + '";\n' +
        this.filterPrefix() +
        'var fn=' + this.generateFunction('fn', 's,l,a,i') +
        extra +
        this.watchFns() +
        'return fn;';
      var fn = (new Function('$filter',
        'ensureSafeMemberName',
        'ensureSafeObject',
        'ensureSafeFunction',
        'getStringValue',
        'ensureSafeAssignContext',
        'ifDefined',
        'plus',
        'text',
        fnString))(
        this.$filter,
        ensureSafeMemberName,
        ensureSafeObject,
        ensureSafeFunction,
        getStringValue,
        ensureSafeAssignContext,
        ifDefined,
        plusFn,
        expression);
      this.state = this.stage = undefined;
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    USE: 'use',
    STRICT: 'strict',
    watchFns: function() {
      var result = [];
      var fns = this.state.inputs;
      var self = this;
      forEach(fns, function(name) {
        result.push('var ' + name + '=' + self.generateFunction(name, 's'));
      });
      if (fns.length) {
        result.push('fn.inputs=[' + fns.join(',') + '];');
      }
      return result.join('');
    },
    generateFunction: function(name, params) {
      return 'function(' + params + '){' +
        this.varsPrefix(name) +
        this.body(name) +
        '};';
    },
    filterPrefix: function() {
      var parts = [];
      var self = this;
      forEach(this.state.filters, function(id, filter) {
        parts.push(id + '=$filter(' + self.escape(filter) + ')');
      });
      if (parts.length) return 'var ' + parts.join(',') + ';';
      return '';
    },
    varsPrefix: function(section) {
      return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
    },
    body: function(section) {
      return this.state[section].body.join('');
    },
    recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
      var left, right, self = this,
        args, expression;
      recursionFn = recursionFn || noop;
      if (!skipWatchIdCheck &amp;&amp; isDefined(ast.watchId)) {
        intoId = intoId || this.nextId();
        this.if_('i',
          this.lazyAssign(intoId, this.computedMember('i', ast.watchId)),
          this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)
        );
        return;
      }
      switch (ast.type) {
        case AST.Program:
          forEach(ast.body, function(expression, pos) {
            self.recurse(expression.expression, undefined, undefined, function(expr) {
              right = expr;
            });
            if (pos !== ast.body.length - 1) {
              self.current().body.push(right, ';');
            } else {
              self.return_(right);
            }
          });
          break;
        case AST.Literal:
          expression = this.escape(ast.value);
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.UnaryExpression:
          this.recurse(ast.argument, undefined, undefined, function(expr) {
            right = expr;
          });
          expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.BinaryExpression:
          this.recurse(ast.left, undefined, undefined, function(expr) {
            left = expr;
          });
          this.recurse(ast.right, undefined, undefined, function(expr) {
            right = expr;
          });
          if (ast.operator === '+') {
            expression = this.plus(left, right);
          } else if (ast.operator === '-') {
            expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
          } else {
            expression = '(' + left + ')' + ast.operator + '(' + right + ')';
          }
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.LogicalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.left, intoId);
          self.if_(ast.operator === '&amp;&amp;' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
          recursionFn(intoId);
          break;
        case AST.ConditionalExpression:
          intoId = intoId || this.nextId();
          self.recurse(ast.test, intoId);
          self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
          recursionFn(intoId);
          break;
        case AST.Identifier:
          intoId = intoId || this.nextId();
          if (nameId) {
            nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
            nameId.computed = false;
            nameId.name = ast.name;
          }
          ensureSafeMemberName(ast.name);
          self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)),
            function() {
              self.if_(self.stage === 'inputs' || 's', function() {
                if (create &amp;&amp; create !== 1) {
                  self.if_(
                    self.not(self.nonComputedMember('s', ast.name)),
                    self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                }
                self.assign(intoId, self.nonComputedMember('s', ast.name));
              });
            }, intoId &amp;&amp; self.lazyAssign(intoId, self.nonComputedMember('l', ast.name))
          );
          if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
            self.addEnsureSafeObject(intoId);
          }
          recursionFn(intoId);
          break;
        case AST.MemberExpression:
          left = nameId &amp;&amp; (nameId.context = this.nextId()) || this.nextId();
          intoId = intoId || this.nextId();
          self.recurse(ast.object, left, undefined, function() {
            self.if_(self.notNull(left), function() {
              if (create &amp;&amp; create !== 1) {
                self.addEnsureSafeAssignContext(left);
              }
              if (ast.computed) {
                right = self.nextId();
                self.recurse(ast.property, right);
                self.getStringValue(right);
                self.addEnsureSafeMemberName(right);
                if (create &amp;&amp; create !== 1) {
                  self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                }
                expression = self.ensureSafeObject(self.computedMember(left, right));
                self.assign(intoId, expression);
                if (nameId) {
                  nameId.computed = true;
                  nameId.name = right;
                }
              } else {
                ensureSafeMemberName(ast.property.name);
                if (create &amp;&amp; create !== 1) {
                  self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                }
                expression = self.nonComputedMember(left, ast.property.name);
                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                  expression = self.ensureSafeObject(expression);
                }
                self.assign(intoId, expression);
                if (nameId) {
                  nameId.computed = false;
                  nameId.name = ast.property.name;
                }
              }
            }, function() {
              self.assign(intoId, 'undefined');
            });
            recursionFn(intoId);
          }, !!create);
          break;
        case AST.CallExpression:
          intoId = intoId || this.nextId();
          if (ast.filter) {
            right = self.filter(ast.callee.name);
            args = [];
            forEach(ast.arguments, function(expr) {
              var argument = self.nextId();
              self.recurse(expr, argument);
              args.push(argument);
            });
            expression = right + '(' + args.join(',') + ')';
            self.assign(intoId, expression);
            recursionFn(intoId);
          } else {
            right = self.nextId();
            left = {};
            args = [];
            self.recurse(ast.callee, right, left, function() {
              self.if_(self.notNull(right), function() {
                self.addEnsureSafeFunction(right);
                forEach(ast.arguments, function(expr) {
                  self.recurse(expr, self.nextId(), undefined, function(argument) {
                    args.push(self.ensureSafeObject(argument));
                  });
                });
                if (left.name) {
                  if (!self.state.expensiveChecks) {
                    self.addEnsureSafeObject(left.context);
                  }
                  expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                } else {
                  expression = right + '(' + args.join(',') + ')';
                }
                expression = self.ensureSafeObject(expression);
                self.assign(intoId, expression);
              }, function() {
                self.assign(intoId, 'undefined');
              });
              recursionFn(intoId);
            });
          }
          break;
        case AST.AssignmentExpression:
          right = this.nextId();
          left = {};
          if (!isAssignable(ast.left)) {
            throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
          }
          this.recurse(ast.left, undefined, left, function() {
            self.if_(self.notNull(left.context), function() {
              self.recurse(ast.right, right);
              self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
              self.addEnsureSafeAssignContext(left.context);
              expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
              self.assign(intoId, expression);
              recursionFn(intoId || expression);
            });
          }, 1);
          break;
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function(expr) {
            self.recurse(expr, self.nextId(), undefined, function(argument) {
              args.push(argument);
            });
          });
          expression = '[' + args.join(',') + ']';
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function(property) {
            self.recurse(property.value, self.nextId(), undefined, function(expr) {
              args.push(self.escape(
                  property.key.type === AST.Identifier ? property.key.name :
                  ('' + property.key.value)) +
                ':' + expr);
            });
          });
          expression = '{' + args.join(',') + '}';
          this.assign(intoId, expression);
          recursionFn(expression);
          break;
        case AST.ThisExpression:
          this.assign(intoId, 's');
          recursionFn('s');
          break;
        case AST.LocalsExpression:
          this.assign(intoId, 'l');
          recursionFn('l');
          break;
        case AST.NGValueParameter:
          this.assign(intoId, 'v');
          recursionFn('v');
          break;
      }
    },
    getHasOwnProperty: function(element, property) {
      var key = element + '.' + property;
      var own = this.current().own;
      if (!own.hasOwnProperty(key)) {
        own[key] = this.nextId(false, element + '&amp;&amp;(' + this.escape(property) + ' in ' + element + ')');
      }
      return own[key];
    },
    assign: function(id, value) {
      if (!id) return;
      this.current().body.push(id, '=', value, ';');
      return id;
    },
    filter: function(filterName) {
      if (!this.state.filters.hasOwnProperty(filterName)) {
        this.state.filters[filterName] = this.nextId(true);
      }
      return this.state.filters[filterName];
    },
    ifDefined: function(id, defaultValue) {
      return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
    },
    plus: function(left, right) {
      return 'plus(' + left + ',' + right + ')';
    },
    return_: function(id) {
      this.current().body.push('return ', id, ';');
    },
    if_: function(test, alternate, consequent) {
      if (test === true) {
        alternate();
      } else {
        var body = this.current().body;
        body.push('if(', test, '){');
        alternate();
        body.push('}');
        if (consequent) {
          body.push('else{');
          consequent();
          body.push('}');
        }
      }
    },
    not: function(expression) {
      return '!(' + expression + ')';
    },
    notNull: function(expression) {
      return expression + '!=null';
    },
    nonComputedMember: function(left, right) {
      return left + '.' + right;
    },
    computedMember: function(left, right) {
      return left + '[' + right + ']';
    },
    member: function(left, right, computed) {
      if (computed) return this.computedMember(left, right);
      return this.nonComputedMember(left, right);
    },
    addEnsureSafeObject: function(item) {
      this.current().body.push(this.ensureSafeObject(item), ';');
    },
    addEnsureSafeMemberName: function(item) {
      this.current().body.push(this.ensureSafeMemberName(item), ';');
    },
    addEnsureSafeFunction: function(item) {
      this.current().body.push(this.ensureSafeFunction(item), ';');
    },
    addEnsureSafeAssignContext: function(item) {
      this.current().body.push(this.ensureSafeAssignContext(item), ';');
    },
    ensureSafeObject: function(item) {
      return 'ensureSafeObject(' + item + ',text)';
    },
    ensureSafeMemberName: function(item) {
      return 'ensureSafeMemberName(' + item + ',text)';
    },
    ensureSafeFunction: function(item) {
      return 'ensureSafeFunction(' + item + ',text)';
    },
    getStringValue: function(item) {
      this.assign(item, 'getStringValue(' + item + ')');
    },
    ensureSafeAssignContext: function(item) {
      return 'ensureSafeAssignContext(' + item + ',text)';
    },
    lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
      var self = this;
      return function() {
        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
      };
    },
    lazyAssign: function(id, value) {
      var self = this;
      return function() {
        self.assign(id, value);
      };
    },
    stringEscapeRegex: /[^ a-zA-Z0-9]/g,
    stringEscapeFn: function(c) {
      return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
    },
    escape: function(value) {
      if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
      if (isNumber(value)) return value.toString();
      if (value === true) return 'true';
      if (value === false) return 'false';
      if (value === null) return 'null';
      if (typeof value === 'undefined') return 'undefined';
      throw $parseMinErr('esc', 'IMPOSSIBLE');
    },
    nextId: function(skip, init) {
      var id = 'v' + (this.state.nextId++);
      if (!skip) {
        this.current().vars.push(id + (init ? '=' + init : ''));
      }
      return id;
    },
    current: function() {
      return this.state[this.state.computing];
    }
  };

  function ASTInterpreter(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
  }
  ASTInterpreter.prototype = {
    compile: function(expression, expensiveChecks) {
      var self = this;
      var ast = this.astBuilder.ast(expression);
      this.expression = expression;
      this.expensiveChecks = expensiveChecks;
      findConstantAndWatchExpressions(ast, self.$filter);
      var assignable;
      var assign;
      if ((assignable = assignableAST(ast))) {
        assign = this.recurse(assignable);
      }
      var toWatch = getInputs(ast.body);
      var inputs;
      if (toWatch) {
        inputs = [];
        forEach(toWatch, function(watch, key) {
          var input = self.recurse(watch);
          watch.input = input;
          inputs.push(input);
          watch.watchId = key;
        });
      }
      var expressions = [];
      forEach(ast.body, function(expression) {
        expressions.push(self.recurse(expression.expression));
      });
      var fn = ast.body.length === 0 ? noop :
        ast.body.length === 1 ? expressions[0] :
        function(scope, locals) {
          var lastValue;
          forEach(expressions, function(exp) {
            lastValue = exp(scope, locals);
          });
          return lastValue;
        };
      if (assign) {
        fn.assign = function(scope, value, locals) {
          return assign(scope, locals, value);
        };
      }
      if (inputs) {
        fn.inputs = inputs;
      }
      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);
      return fn;
    },
    recurse: function(ast, context, create) {
      var left, right, self = this,
        args, expression;
      if (ast.input) {
        return this.inputs(ast.input, ast.watchId);
      }
      switch (ast.type) {
        case AST.Literal:
          return this.value(ast.value, context);
        case AST.UnaryExpression:
          right = this.recurse(ast.argument);
          return this['unary' + ast.operator](right, context);
        case AST.BinaryExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this['binary' + ast.operator](left, right, context);
        case AST.LogicalExpression:
          left = this.recurse(ast.left);
          right = this.recurse(ast.right);
          return this['binary' + ast.operator](left, right, context);
        case AST.ConditionalExpression:
          return this['ternary?:'](
            this.recurse(ast.test),
            this.recurse(ast.alternate),
            this.recurse(ast.consequent),
            context
          );
        case AST.Identifier:
          ensureSafeMemberName(ast.name, self.expression);
          return self.identifier(ast.name,
            self.expensiveChecks || isPossiblyDangerousMemberName(ast.name),
            context, create, self.expression);
        case AST.MemberExpression:
          left = this.recurse(ast.object, false, !!create);
          if (!ast.computed) {
            ensureSafeMemberName(ast.property.name, self.expression);
            right = ast.property.name;
          }
          if (ast.computed) right = this.recurse(ast.property);
          return ast.computed ?
            this.computedMember(left, right, context, create, self.expression) :
            this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
        case AST.CallExpression:
          args = [];
          forEach(ast.arguments, function(expr) {
            args.push(self.recurse(expr));
          });
          if (ast.filter) right = this.$filter(ast.callee.name);
          if (!ast.filter) right = this.recurse(ast.callee, true);
          return ast.filter ?
            function(scope, locals, assign, inputs) {
              var values = [];
              for (var i = 0; i &lt; args.length; ++i) {
                values.push(args[i](scope, locals, assign, inputs));
              }
              var value = right.apply(undefined, values, inputs);
              return context ? {
                context: undefined,
                name: undefined,
                value: value
              } : value;
            } :
            function(scope, locals, assign, inputs) {
              var rhs = right(scope, locals, assign, inputs);
              var value;
              if (rhs.value != null) {
                ensureSafeObject(rhs.context, self.expression);
                ensureSafeFunction(rhs.value, self.expression);
                var values = [];
                for (var i = 0; i &lt; args.length; ++i) {
                  values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                }
                value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
              }
              return context ? {
                value: value
              } : value;
            };
        case AST.AssignmentExpression:
          left = this.recurse(ast.left, true, 1);
          right = this.recurse(ast.right);
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            ensureSafeObject(lhs.value, self.expression);
            ensureSafeAssignContext(lhs.context);
            lhs.context[lhs.name] = rhs;
            return context ? {
              value: rhs
            } : rhs;
          };
        case AST.ArrayExpression:
          args = [];
          forEach(ast.elements, function(expr) {
            args.push(self.recurse(expr));
          });
          return function(scope, locals, assign, inputs) {
            var value = [];
            for (var i = 0; i &lt; args.length; ++i) {
              value.push(args[i](scope, locals, assign, inputs));
            }
            return context ? {
              value: value
            } : value;
          };
        case AST.ObjectExpression:
          args = [];
          forEach(ast.properties, function(property) {
            args.push({
              key: property.key.type === AST.Identifier ?
                property.key.name :
                ('' + property.key.value),
              value: self.recurse(property.value)
            });
          });
          return function(scope, locals, assign, inputs) {
            var value = {};
            for (var i = 0; i &lt; args.length; ++i) {
              value[args[i].key] = args[i].value(scope, locals, assign, inputs);
            }
            return context ? {
              value: value
            } : value;
          };
        case AST.ThisExpression:
          return function(scope) {
            return context ? {
              value: scope
            } : scope;
          };
        case AST.LocalsExpression:
          return function(scope, locals) {
            return context ? {
              value: locals
            } : locals;
          };
        case AST.NGValueParameter:
          return function(scope, locals, assign) {
            return context ? {
              value: assign
            } : assign;
          };
      }
    },
    'unary+': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = +arg;
        } else {
          arg = 0;
        }
        return context ? {
          value: arg
        } : arg;
      };
    },
    'unary-': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = argument(scope, locals, assign, inputs);
        if (isDefined(arg)) {
          arg = -arg;
        } else {
          arg = 0;
        }
        return context ? {
          value: arg
        } : arg;
      };
    },
    'unary!': function(argument, context) {
      return function(scope, locals, assign, inputs) {
        var arg = !argument(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary+': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = plusFn(lhs, rhs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary-': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary*': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary/': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary%': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary===': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary!==': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary==': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary!=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&lt;': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) &lt; right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&gt;': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) &gt; right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&lt;=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) &lt;= right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&gt;=': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) &gt;= right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary&amp;&amp;': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) &amp;&amp; right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'binary||': function(left, right, context) {
      return function(scope, locals, assign, inputs) {
        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    'ternary?:': function(test, alternate, consequent, context) {
      return function(scope, locals, assign, inputs) {
        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
        return context ? {
          value: arg
        } : arg;
      };
    },
    value: function(value, context) {
      return function() {
        return context ? {
          context: undefined,
          name: undefined,
          value: value
        } : value;
      };
    },
    identifier: function(name, expensiveChecks, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var base = locals &amp;&amp; (name in locals) ? locals : scope;
        if (create &amp;&amp; create !== 1 &amp;&amp; base &amp;&amp; !(base[name])) {
          base[name] = {};
        }
        var value = base ? base[name] : undefined;
        if (expensiveChecks) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: base,
            name: name,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    computedMember: function(left, right, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs;
        var value;
        if (lhs != null) {
          rhs = right(scope, locals, assign, inputs);
          rhs = getStringValue(rhs);
          ensureSafeMemberName(rhs, expression);
          if (create &amp;&amp; create !== 1) {
            ensureSafeAssignContext(lhs);
            if (lhs &amp;&amp; !(lhs[rhs])) {
              lhs[rhs] = {};
            }
          }
          value = lhs[rhs];
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: lhs,
            name: rhs,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
      return function(scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        if (create &amp;&amp; create !== 1) {
          ensureSafeAssignContext(lhs);
          if (lhs &amp;&amp; !(lhs[right])) {
            lhs[right] = {};
          }
        }
        var value = lhs != null ? lhs[right] : undefined;
        if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
          ensureSafeObject(value, expression);
        }
        if (context) {
          return {
            context: lhs,
            name: right,
            value: value
          };
        } else {
          return value;
        }
      };
    },
    inputs: function(input, watchId) {
      return function(scope, value, locals, inputs) {
        if (inputs) return inputs[watchId];
        return input(scope, value, locals);
      };
    }
  };
  var Parser = function(lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
    this.ast = new AST(lexer, options);
    this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) :
      new ASTCompiler(this.ast, $filter);
  };
  Parser.prototype = {
    constructor: Parser,
    parse: function(text) {
      return this.astCompiler.compile(text, this.options.expensiveChecks);
    }
  };

  function isPossiblyDangerousMemberName(name) {
    return name == 'constructor';
  }
  var objectValueOf = Object.prototype.valueOf;

  function getValueOf(value) {
    return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
  }

  function $ParseProvider() {
    var cacheDefault = createMap();
    var cacheExpensive = createMap();
    var literals = {
      'true': true,
      'false': false,
      'null': null,
      'undefined': undefined
    };
    this.addLiteral = function(literalName, literalValue) {
      literals[literalName] = literalValue;
    };
    this.$get = ['$filter', function($filter) {
      var noUnsafeEval = csp().noUnsafeEval;
      var $parseOptions = {
          csp: noUnsafeEval,
          expensiveChecks: false,
          literals: copy(literals)
        },
        $parseOptionsExpensive = {
          csp: noUnsafeEval,
          expensiveChecks: true,
          literals: copy(literals)
        };
      var runningChecksEnabled = false;
      $parse.$$runningExpensiveChecks = function() {
        return runningChecksEnabled;
      };
      return $parse;

      function $parse(exp, interceptorFn, expensiveChecks) {
        var parsedExpression, oneTime, cacheKey;
        expensiveChecks = expensiveChecks || runningChecksEnabled;
        switch (typeof exp) {
          case 'string':
            exp = exp.trim();
            cacheKey = exp;
            var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
            parsedExpression = cache[cacheKey];
            if (!parsedExpression) {
              if (exp.charAt(0) === ':' &amp;&amp; exp.charAt(1) === ':') {
                oneTime = true;
                exp = exp.substring(2);
              }
              var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
              var lexer = new Lexer(parseOptions);
              var parser = new Parser(lexer, $filter, parseOptions);
              parsedExpression = parser.parse(exp);
              if (parsedExpression.constant) {
                parsedExpression.$$watchDelegate = constantWatchDelegate;
              } else if (oneTime) {
                parsedExpression.$$watchDelegate = parsedExpression.literal ?
                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
              } else if (parsedExpression.inputs) {
                parsedExpression.$$watchDelegate = inputsWatchDelegate;
              }
              if (expensiveChecks) {
                parsedExpression = expensiveChecksInterceptor(parsedExpression);
              }
              cache[cacheKey] = parsedExpression;
            }
            return addInterceptor(parsedExpression, interceptorFn);
          case 'function':
            return addInterceptor(exp, interceptorFn);
          default:
            return addInterceptor(noop, interceptorFn);
        }
      }

      function expensiveChecksInterceptor(fn) {
        if (!fn) return fn;
        expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
        expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
        expensiveCheckFn.constant = fn.constant;
        expensiveCheckFn.literal = fn.literal;
        for (var i = 0; fn.inputs &amp;&amp; i &lt; fn.inputs.length; ++i) {
          fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
        }
        expensiveCheckFn.inputs = fn.inputs;
        return expensiveCheckFn;

        function expensiveCheckFn(scope, locals, assign, inputs) {
          var expensiveCheckOldValue = runningChecksEnabled;
          runningChecksEnabled = true;
          try {
            return fn(scope, locals, assign, inputs);
          } finally {
            runningChecksEnabled = expensiveCheckOldValue;
          }
        }
      }

      function expressionInputDirtyCheck(newValue, oldValueOfValue) {
        if (newValue == null || oldValueOfValue == null) {
          return newValue === oldValueOfValue;
        }
        if (typeof newValue === 'object') {
          newValue = getValueOf(newValue);
          if (typeof newValue === 'object') {
            return false;
          }
        }
        return newValue === oldValueOfValue || (newValue !== newValue &amp;&amp; oldValueOfValue !== oldValueOfValue);
      }

      function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
        var inputExpressions = parsedExpression.inputs;
        var lastResult;
        if (inputExpressions.length === 1) {
          var oldInputValueOf = expressionInputDirtyCheck;
          inputExpressions = inputExpressions[0];
          return scope.$watch(function expressionInputWatch(scope) {
            var newInputValue = inputExpressions(scope);
            if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
              lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
              oldInputValueOf = newInputValue &amp;&amp; getValueOf(newInputValue);
            }
            return lastResult;
          }, listener, objectEquality, prettyPrintExpression);
        }
        var oldInputValueOfValues = [];
        var oldInputValues = [];
        for (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {
          oldInputValueOfValues[i] = expressionInputDirtyCheck;
          oldInputValues[i] = null;
        }
        return scope.$watch(function expressionInputsWatch(scope) {
          var changed = false;
          for (var i = 0, ii = inputExpressions.length; i &lt; ii; i++) {
            var newInputValue = inputExpressions[i](scope);
            if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
              oldInputValues[i] = newInputValue;
              oldInputValueOfValues[i] = newInputValue &amp;&amp; getValueOf(newInputValue);
            }
          }
          if (changed) {
            lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
          }
          return lastResult;
        }, listener, objectEquality, prettyPrintExpression);
      }

      function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch, lastValue;
        return unwatch = scope.$watch(function oneTimeWatch(scope) {
          return parsedExpression(scope);
        }, function oneTimeListener(value, old, scope) {
          lastValue = value;
          if (isFunction(listener)) {
            listener.apply(this, arguments);
          }
          if (isDefined(value)) {
            scope.$$postDigest(function() {
              if (isDefined(lastValue)) {
                unwatch();
              }
            });
          }
        }, objectEquality);
      }

      function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch, lastValue;
        return unwatch = scope.$watch(function oneTimeWatch(scope) {
          return parsedExpression(scope);
        }, function oneTimeListener(value, old, scope) {
          lastValue = value;
          if (isFunction(listener)) {
            listener.call(this, value, old, scope);
          }
          if (isAllDefined(value)) {
            scope.$$postDigest(function() {
              if (isAllDefined(lastValue)) unwatch();
            });
          }
        }, objectEquality);

        function isAllDefined(value) {
          var allDefined = true;
          forEach(value, function(val) {
            if (!isDefined(val)) allDefined = false;
          });
          return allDefined;
        }
      }

      function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        var unwatch;
        return unwatch = scope.$watch(function constantWatch(scope) {
          unwatch();
          return parsedExpression(scope);
        }, listener, objectEquality);
      }

      function addInterceptor(parsedExpression, interceptorFn) {
        if (!interceptorFn) return parsedExpression;
        var watchDelegate = parsedExpression.$$watchDelegate;
        var useInputs = false;
        var regularWatch =
          watchDelegate !== oneTimeLiteralWatchDelegate &amp;&amp;
          watchDelegate !== oneTimeWatchDelegate;
        var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
          var value = useInputs &amp;&amp; inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
          return interceptorFn(value, scope, locals);
        } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
          var value = parsedExpression(scope, locals, assign, inputs);
          var result = interceptorFn(value, scope, locals);
          return isDefined(value) ? result : value;
        };
        if (parsedExpression.$$watchDelegate &amp;&amp;
          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
          fn.$$watchDelegate = parsedExpression.$$watchDelegate;
        } else if (!interceptorFn.$stateful) {
          fn.$$watchDelegate = inputsWatchDelegate;
          useInputs = !parsedExpression.inputs;
          fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
        }
        return fn;
      }
    }];
  }

  function $QProvider() {
    this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
      return qFactory(function(callback) {
        $rootScope.$evalAsync(callback);
      }, $exceptionHandler);
    }];
  }

  function $$QProvider() {
    this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
      return qFactory(function(callback) {
        $browser.defer(callback);
      }, $exceptionHandler);
    }];
  }

  function qFactory(nextTick, exceptionHandler) {
    var $qMinErr = minErr('$q', TypeError);
    var defer = function() {
      var d = new Deferred();
      d.resolve = simpleBind(d, d.resolve);
      d.reject = simpleBind(d, d.reject);
      d.notify = simpleBind(d, d.notify);
      return d;
    };

    function Promise() {
      this.$$state = {
        status: 0
      };
    }
    extend(Promise.prototype, {
      then: function(onFulfilled, onRejected, progressBack) {
        if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) &amp;&amp; isUndefined(progressBack)) {
          return this;
        }
        var result = new Deferred();
        this.$$state.pending = this.$$state.pending || [];
        this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
        if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);
        return result.promise;
      },
      "catch": function(callback) {
        return this.then(null, callback);
      },
      "finally": function(callback, progressBack) {
        return this.then(function(value) {
          return handleCallback(value, true, callback);
        }, function(error) {
          return handleCallback(error, false, callback);
        }, progressBack);
      }
    });

    function simpleBind(context, fn) {
      return function(value) {
        fn.call(context, value);
      };
    }

    function processQueue(state) {
      var fn, deferred, pending;
      pending = state.pending;
      state.processScheduled = false;
      state.pending = undefined;
      for (var i = 0, ii = pending.length; i &lt; ii; ++i) {
        deferred = pending[i][0];
        fn = pending[i][state.status];
        try {
          if (isFunction(fn)) {
            deferred.resolve(fn(state.value));
          } else if (state.status === 1) {
            deferred.resolve(state.value);
          } else {
            deferred.reject(state.value);
          }
        } catch (e) {
          deferred.reject(e);
          exceptionHandler(e);
        }
      }
    }

    function scheduleProcessQueue(state) {
      if (state.processScheduled || !state.pending) return;
      state.processScheduled = true;
      nextTick(function() {
        processQueue(state);
      });
    }

    function Deferred() {
      this.promise = new Promise();
    }
    extend(Deferred.prototype, {
      resolve: function(val) {
        if (this.promise.$$state.status) return;
        if (val === this.promise) {
          this.$$reject($qMinErr(
            'qcycle',
            "Expected promise to be resolved with value other than itself '{0}'",
            val));
        } else {
          this.$$resolve(val);
        }
      },
      $$resolve: function(val) {
        var then;
        var that = this;
        var done = false;
        try {
          if ((isObject(val) || isFunction(val))) then = val &amp;&amp; val.then;
          if (isFunction(then)) {
            this.promise.$$state.status = -1;
            then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
          } else {
            this.promise.$$state.value = val;
            this.promise.$$state.status = 1;
            scheduleProcessQueue(this.promise.$$state);
          }
        } catch (e) {
          rejectPromise(e);
          exceptionHandler(e);
        }

        function resolvePromise(val) {
          if (done) return;
          done = true;
          that.$$resolve(val);
        }

        function rejectPromise(val) {
          if (done) return;
          done = true;
          that.$$reject(val);
        }
      },
      reject: function(reason) {
        if (this.promise.$$state.status) return;
        this.$$reject(reason);
      },
      $$reject: function(reason) {
        this.promise.$$state.value = reason;
        this.promise.$$state.status = 2;
        scheduleProcessQueue(this.promise.$$state);
      },
      notify: function(progress) {
        var callbacks = this.promise.$$state.pending;
        if ((this.promise.$$state.status &lt;= 0) &amp;&amp; callbacks &amp;&amp; callbacks.length) {
          nextTick(function() {
            var callback, result;
            for (var i = 0, ii = callbacks.length; i &lt; ii; i++) {
              result = callbacks[i][0];
              callback = callbacks[i][3];
              try {
                result.notify(isFunction(callback) ? callback(progress) : progress);
              } catch (e) {
                exceptionHandler(e);
              }
            }
          });
        }
      }
    });
    var reject = function(reason) {
      var result = new Deferred();
      result.reject(reason);
      return result.promise;
    };
    var makePromise = function makePromise(value, resolved) {
      var result = new Deferred();
      if (resolved) {
        result.resolve(value);
      } else {
        result.reject(value);
      }
      return result.promise;
    };
    var handleCallback = function handleCallback(value, isResolved, callback) {
      var callbackOutput = null;
      try {
        if (isFunction(callback)) callbackOutput = callback();
      } catch (e) {
        return makePromise(e, false);
      }
      if (isPromiseLike(callbackOutput)) {
        return callbackOutput.then(function() {
          return makePromise(value, isResolved);
        }, function(error) {
          return makePromise(error, false);
        });
      } else {
        return makePromise(value, isResolved);
      }
    };
    var when = function(value, callback, errback, progressBack) {
      var result = new Deferred();
      result.resolve(value);
      return result.promise.then(callback, errback, progressBack);
    };
    var resolve = when;

    function all(promises) {
      var deferred = new Deferred(),
        counter = 0,
        results = isArray(promises) ? [] : {};
      forEach(promises, function(promise, key) {
        counter++;
        when(promise).then(function(value) {
          if (results.hasOwnProperty(key)) return;
          results[key] = value;
          if (!(--counter)) deferred.resolve(results);
        }, function(reason) {
          if (results.hasOwnProperty(key)) return;
          deferred.reject(reason);
        });
      });
      if (counter === 0) {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    var $Q = function Q(resolver) {
      if (!isFunction(resolver)) {
        throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
      }
      var deferred = new Deferred();

      function resolveFn(value) {
        deferred.resolve(value);
      }

      function rejectFn(reason) {
        deferred.reject(reason);
      }
      resolver(resolveFn, rejectFn);
      return deferred.promise;
    };
    $Q.prototype = Promise.prototype;
    $Q.defer = defer;
    $Q.reject = reject;
    $Q.when = when;
    $Q.resolve = resolve;
    $Q.all = all;
    return $Q;
  }

  function $$RAFProvider() {
    this.$get = ['$window', '$timeout', function($window, $timeout) {
      var requestAnimationFrame = $window.requestAnimationFrame ||
        $window.webkitRequestAnimationFrame;
      var cancelAnimationFrame = $window.cancelAnimationFrame ||
        $window.webkitCancelAnimationFrame ||
        $window.webkitCancelRequestAnimationFrame;
      var rafSupported = !!requestAnimationFrame;
      var raf = rafSupported ?
        function(fn) {
          var id = requestAnimationFrame(fn);
          return function() {
            cancelAnimationFrame(id);
          };
        } :
        function(fn) {
          var timer = $timeout(fn, 16.66, false);
          return function() {
            $timeout.cancel(timer);
          };
        };
      raf.supported = rafSupported;
      return raf;
    }];
  }

  function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr('$rootScope');
    var lastDirtyWatch = null;
    var applyAsyncId = null;
    this.digestTtl = function(value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };

    function createChildScopeClass(parent) {
      function ChildScope() {
        this.$$watchers = this.$$nextSibling =
          this.$$childHead = this.$$childTail = null;
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$watchersCount = 0;
        this.$id = nextUid();
        this.$$ChildScope = null;
      }
      ChildScope.prototype = parent;
      return ChildScope;
    }
    this.$get = ['$exceptionHandler', '$parse', '$browser',
      function($exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
          $event.currentScope.$$destroyed = true;
        }

        function cleanUpScope($scope) {
          if (msie === 9) {
            $scope.$$childHead &amp;&amp; cleanUpScope($scope.$$childHead);
            $scope.$$nextSibling &amp;&amp; cleanUpScope($scope.$$nextSibling);
          }
          $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead =
            $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
        }

        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers =
            this.$$nextSibling = this.$$prevSibling =
            this.$$childHead = this.$$childTail = null;
          this.$root = this;
          this.$$destroyed = false;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$$isolateBindings = null;
        }
        Scope.prototype = {
          constructor: Scope,
          $new: function(isolate, parent) {
            var child;
            parent = parent || this;
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              if (!this.$$ChildScope) {
                this.$$ChildScope = createChildScopeClass(this);
              }
              child = new this.$$ChildScope();
            }
            child.$parent = parent;
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = child;
              parent.$$childTail = child;
            } else {
              parent.$$childHead = parent.$$childTail = child;
            }
            if (isolate || parent != this) child.$on('$destroy', destroyChildScope);
            return child;
          },
          $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
            var get = $parse(watchExp);
            if (get.$$watchDelegate) {
              return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
            }
            var scope = this,
              array = scope.$$watchers,
              watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: prettyPrintExpression || watchExp,
                eq: !!objectEquality
              };
            lastDirtyWatch = null;
            if (!isFunction(listener)) {
              watcher.fn = noop;
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            incrementWatchersCount(this, 1);
            return function deregisterWatch() {
              if (arrayRemove(array, watcher) &gt;= 0) {
                incrementWatchersCount(scope, -1);
              }
              lastDirtyWatch = null;
            };
          },
          $watchGroup: function(watchExpressions, listener) {
            var oldValues = new Array(watchExpressions.length);
            var newValues = new Array(watchExpressions.length);
            var deregisterFns = [];
            var self = this;
            var changeReactionScheduled = false;
            var firstRun = true;
            if (!watchExpressions.length) {
              var shouldCall = true;
              self.$evalAsync(function() {
                if (shouldCall) listener(newValues, newValues, self);
              });
              return function deregisterWatchGroup() {
                shouldCall = false;
              };
            }
            if (watchExpressions.length === 1) {
              return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                newValues[0] = value;
                oldValues[0] = oldValue;
                listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
              });
            }
            forEach(watchExpressions, function(expr, i) {
              var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                newValues[i] = value;
                oldValues[i] = oldValue;
                if (!changeReactionScheduled) {
                  changeReactionScheduled = true;
                  self.$evalAsync(watchGroupAction);
                }
              });
              deregisterFns.push(unwatchFn);
            });

            function watchGroupAction() {
              changeReactionScheduled = false;
              if (firstRun) {
                firstRun = false;
                listener(newValues, newValues, self);
              } else {
                listener(newValues, oldValues, self);
              }
            }
            return function deregisterWatchGroup() {
              while (deregisterFns.length) {
                deregisterFns.shift()();
              }
            };
          },
          $watchCollection: function(obj, listener) {
            $watchCollectionInterceptor.$stateful = true;
            var self = this;
            var newValue;
            var oldValue;
            var veryOldValue;
            var trackVeryOldValue = (listener.length &gt; 1);
            var changeDetected = 0;
            var changeDetector = $parse(obj, $watchCollectionInterceptor);
            var internalArray = [];
            var internalObject = {};
            var initRun = true;
            var oldLength = 0;

            function $watchCollectionInterceptor(_value) {
              newValue = _value;
              var newLength, key, bothNaN, newItem, oldItem;
              if (isUndefined(newValue)) return;
              if (!isObject(newValue)) {
                if (oldValue !== newValue) {
                  oldValue = newValue;
                  changeDetected++;
                }
              } else if (isArrayLike(newValue)) {
                if (oldValue !== internalArray) {
                  oldValue = internalArray;
                  oldLength = oldValue.length = 0;
                  changeDetected++;
                }
                newLength = newValue.length;
                if (oldLength !== newLength) {
                  changeDetected++;
                  oldValue.length = oldLength = newLength;
                }
                for (var i = 0; i &lt; newLength; i++) {
                  oldItem = oldValue[i];
                  newItem = newValue[i];
                  bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);
                  if (!bothNaN &amp;&amp; (oldItem !== newItem)) {
                    changeDetected++;
                    oldValue[i] = newItem;
                  }
                }
              } else {
                if (oldValue !== internalObject) {
                  oldValue = internalObject = {};
                  oldLength = 0;
                  changeDetected++;
                }
                newLength = 0;
                for (key in newValue) {
                  if (hasOwnProperty.call(newValue, key)) {
                    newLength++;
                    newItem = newValue[key];
                    oldItem = oldValue[key];
                    if (key in oldValue) {
                      bothNaN = (oldItem !== oldItem) &amp;&amp; (newItem !== newItem);
                      if (!bothNaN &amp;&amp; (oldItem !== newItem)) {
                        changeDetected++;
                        oldValue[key] = newItem;
                      }
                    } else {
                      oldLength++;
                      oldValue[key] = newItem;
                      changeDetected++;
                    }
                  }
                }
                if (oldLength &gt; newLength) {
                  changeDetected++;
                  for (key in oldValue) {
                    if (!hasOwnProperty.call(newValue, key)) {
                      oldLength--;
                      delete oldValue[key];
                    }
                  }
                }
              }
              return changeDetected;
            }

            function $watchCollectionAction() {
              if (initRun) {
                initRun = false;
                listener(newValue, newValue, self);
              } else {
                listener(newValue, veryOldValue, self);
              }
              if (trackVeryOldValue) {
                if (!isObject(newValue)) {
                  veryOldValue = newValue;
                } else if (isArrayLike(newValue)) {
                  veryOldValue = new Array(newValue.length);
                  for (var i = 0; i &lt; newValue.length; i++) {
                    veryOldValue[i] = newValue[i];
                  }
                } else {
                  veryOldValue = {};
                  for (var key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      veryOldValue[key] = newValue[key];
                    }
                  }
                }
              }
            }
            return this.$watch(changeDetector, $watchCollectionAction);
          },
          $digest: function() {
            var watch, value, last, fn, get,
              watchers,
              length,
              dirty, ttl = TTL,
              next, current, target = this,
              watchLog = [],
              logIdx, asyncTask;
            beginPhase('$digest');
            $browser.$$checkUrlChange();
            if (this === $rootScope &amp;&amp; applyAsyncId !== null) {
              $browser.defer.cancel(applyAsyncId);
              flushApplyAsync();
            }
            lastDirtyWatch = null;
            do {
              dirty = false;
              current = target;
              while (asyncQueue.length) {
                try {
                  asyncTask = asyncQueue.shift();
                  asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                } catch (e) {
                  $exceptionHandler(e);
                }
                lastDirtyWatch = null;
              }
              traverseScopesLoop:
                do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) &amp;&amp;
                            !(watch.eq ?
                              equals(value, last) :
                              (typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp;
                                isNaN(value) &amp;&amp; isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl &lt; 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx]) watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||
                      (current !== target &amp;&amp; current.$$nextSibling)))) {
                    while (current !== target &amp;&amp; !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
              if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {
                clearPhase();
                throw $rootScopeMinErr('infdig',
                  '{0} $digest() iterations reached. Aborting!\n' +
                  'Watchers fired in the last 5 iterations: {1}',
                  TTL, watchLog);
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
            while (postDigestQueue.length) {
              try {
                postDigestQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          },
          $destroy: function() {
            if (this.$$destroyed) return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (this === $rootScope) {
              $browser.$$applicationDestroyed();
            }
            incrementWatchersCount(this, -this.$$watchersCount);
            for (var eventName in this.$$listenerCount) {
              decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
            }
            if (parent &amp;&amp; parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
            if (parent &amp;&amp; parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
            this.$on = this.$watch = this.$watchGroup = function() {
              return noop;
            };
            this.$$listeners = {};
            this.$$nextSibling = null;
            cleanUpScope(this);
          },
          $eval: function(expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function(expr, locals) {
            if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) {
              $browser.defer(function() {
                if (asyncQueue.length) {
                  $rootScope.$digest();
                }
              });
            }
            asyncQueue.push({
              scope: this,
              expression: $parse(expr),
              locals: locals
            });
          },
          $$postDigest: function(fn) {
            postDigestQueue.push(fn);
          },
          $apply: function(expr) {
            try {
              beginPhase('$apply');
              try {
                return this.$eval(expr);
              } finally {
                clearPhase();
              }
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $applyAsync: function(expr) {
            var scope = this;
            expr &amp;&amp; applyAsyncQueue.push($applyAsyncExpression);
            expr = $parse(expr);
            scheduleApplyAsync();

            function $applyAsyncExpression() {
              scope.$eval(expr);
            }
          },
          $on: function(name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            var current = this;
            do {
              if (!current.$$listenerCount[name]) {
                current.$$listenerCount[name] = 0;
              }
              current.$$listenerCount[name]++;
            } while ((current = current.$parent));
            var self = this;
            return function() {
              var indexOfListener = namedListeners.indexOf(listener);
              if (indexOfListener !== -1) {
                namedListeners[indexOfListener] = null;
                decrementListenerCount(self, 1, name);
              }
            };
          },
          $emit: function(name, args) {
            var empty = [],
              namedListeners,
              scope = this,
              stopPropagation = false,
              event = {
                name: name,
                targetScope: scope,
                stopPropagation: function() {
                  stopPropagation = true;
                },
                preventDefault: function() {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              },
              listenerArgs = concat([event], arguments, 1),
              i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i &lt; length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (stopPropagation) {
                event.currentScope = null;
                return event;
              }
              scope = scope.$parent;
            } while (scope);
            event.currentScope = null;
            return event;
          },
          $broadcast: function(name, args) {
            var target = this,
              current = target,
              next = target,
              event = {
                name: name,
                targetScope: target,
                preventDefault: function() {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              };
            if (!target.$$listenerCount[name]) return event;
            var listenerArgs = concat([event], arguments, 1),
              listeners, i, length;
            while ((current = next)) {
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i &lt; length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = ((current.$$listenerCount[name] &amp;&amp; current.$$childHead) ||
                  (current !== target &amp;&amp; current.$$nextSibling)))) {
                while (current !== target &amp;&amp; !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            }
            event.currentScope = null;
            return event;
          }
        };
        var $rootScope = new Scope();
        var asyncQueue = $rootScope.$$asyncQueue = [];
        var postDigestQueue = $rootScope.$$postDigestQueue = [];
        var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
        return $rootScope;

        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
          }
          $rootScope.$$phase = phase;
        }

        function clearPhase() {
          $rootScope.$$phase = null;
        }

        function incrementWatchersCount(current, count) {
          do {
            current.$$watchersCount += count;
          } while ((current = current.$parent));
        }

        function decrementListenerCount(current, count, name) {
          do {
            current.$$listenerCount[name] -= count;
            if (current.$$listenerCount[name] === 0) {
              delete current.$$listenerCount[name];
            }
          } while ((current = current.$parent));
        }

        function initWatchVal() {}

        function flushApplyAsync() {
          while (applyAsyncQueue.length) {
            try {
              applyAsyncQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          applyAsyncId = null;
        }

        function scheduleApplyAsync() {
          if (applyAsyncId === null) {
            applyAsyncId = $browser.defer(function() {
              $rootScope.$apply(flushApplyAsync);
            });
          }
        }
      }
    ];
  }

  function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
      imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
      }
      return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
      }
      return imgSrcSanitizationWhitelist;
    };
    this.$get = function() {
      return function sanitizeUri(uri, isImage) {
        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
        var normalizedVal;
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== '' &amp;&amp; !normalizedVal.match(regex)) {
          return 'unsafe:' + normalizedVal;
        }
        return uri;
      };
    };
  }
  var $sceMinErr = minErr('$sce');
  var SCE_CONTEXTS = {
    HTML: 'html',
    CSS: 'css',
    URL: 'url',
    RESOURCE_URL: 'resourceUrl',
    JS: 'js'
  };

  function adjustMatcher(matcher) {
    if (matcher === 'self') {
      return matcher;
    } else if (isString(matcher)) {
      if (matcher.indexOf('***') &gt; -1) {
        throw $sceMinErr('iwcard',
          'Illegal sequence *** in string matcher.  String: {0}', matcher);
      }
      matcher = escapeForRegexp(matcher).
      replace('\\*\\*', '.*').
      replace('\\*', '[^:/.?&amp;;]*');
      return new RegExp('^' + matcher + '$');
    } else if (isRegExp(matcher)) {
      return new RegExp('^' + matcher.source + '$');
    } else {
      throw $sceMinErr('imatcher',
        'Matchers may only be "self", string patterns or RegExp objects');
    }
  }

  function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
      forEach(matchers, function(matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
      });
    }
    return adjustedMatchers;
  }

  function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = ['self'],
      resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function(value) {
      if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
      }
      return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function(value) {
      if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
      }
      return resourceUrlBlacklist;
    };
    this.$get = ['$injector', function($injector) {
      var htmlSanitizer = function htmlSanitizer(html) {
        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
      };
      if ($injector.has('$sanitize')) {
        htmlSanitizer = $injector.get('$sanitize');
      }

      function matchUrl(matcher, parsedUrl) {
        if (matcher === 'self') {
          return urlIsSameOrigin(parsedUrl);
        } else {
          return !!matcher.exec(parsedUrl.href);
        }
      }

      function isResourceUrlAllowedByPolicy(url) {
        var parsedUrl = urlResolve(url.toString());
        var i, n, allowed = false;
        for (i = 0, n = resourceUrlWhitelist.length; i &lt; n; i++) {
          if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
            allowed = true;
            break;
          }
        }
        if (allowed) {
          for (i = 0, n = resourceUrlBlacklist.length; i &lt; n; i++) {
            if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
              allowed = false;
              break;
            }
          }
        }
        return allowed;
      }

      function generateHolderType(Base) {
        var holderType = function TrustedValueHolderType(trustedValue) {
          this.$$unwrapTrustedValue = function() {
            return trustedValue;
          };
        };
        if (Base) {
          holderType.prototype = new Base();
        }
        holderType.prototype.valueOf = function sceValueOf() {
          return this.$$unwrapTrustedValue();
        };
        holderType.prototype.toString = function sceToString() {
          return this.$$unwrapTrustedValue().toString();
        };
        return holderType;
      }
      var trustedValueHolderBase = generateHolderType(),
        byType = {};
      byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);

      function trustAs(type, trustedValue) {
        var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
        if (!Constructor) {
          throw $sceMinErr('icontext',
            'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
            type, trustedValue);
        }
        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
          return trustedValue;
        }
        if (typeof trustedValue !== 'string') {
          throw $sceMinErr('itype',
            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
            type);
        }
        return new Constructor(trustedValue);
      }

      function valueOf(maybeTrusted) {
        if (maybeTrusted instanceof trustedValueHolderBase) {
          return maybeTrusted.$$unwrapTrustedValue();
        } else {
          return maybeTrusted;
        }
      }

      function getTrusted(type, maybeTrusted) {
        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
          return maybeTrusted;
        }
        var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
        if (constructor &amp;&amp; maybeTrusted instanceof constructor) {
          return maybeTrusted.$$unwrapTrustedValue();
        }
        if (type === SCE_CONTEXTS.RESOURCE_URL) {
          if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
            return maybeTrusted;
          } else {
            throw $sceMinErr('insecurl',
              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
              maybeTrusted.toString());
          }
        } else if (type === SCE_CONTEXTS.HTML) {
          return htmlSanitizer(maybeTrusted);
        }
        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
      }
      return {
        trustAs: trustAs,
        getTrusted: getTrusted,
        valueOf: valueOf
      };
    }];
  }

  function $SceProvider() {
    var enabled = true;
    this.enabled = function(value) {
      if (arguments.length) {
        enabled = !!value;
      }
      return enabled;
    };
    this.$get = ['$parse', '$sceDelegate', function(
      $parse, $sceDelegate) {
      if (enabled &amp;&amp; msie &lt; 8) {
        throw $sceMinErr('iequirks',
          'Strict Contextual Escaping does not support Internet Explorer version &lt; 11 in quirks ' +
          'mode.  You can fix this by adding the text &lt;!doctype html&gt; to the top of your HTML ' +
          'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
      }
      var sce = shallowCopy(SCE_CONTEXTS);
      sce.isEnabled = function() {
        return enabled;
      };
      sce.trustAs = $sceDelegate.trustAs;
      sce.getTrusted = $sceDelegate.getTrusted;
      sce.valueOf = $sceDelegate.valueOf;
      if (!enabled) {
        sce.trustAs = sce.getTrusted = function(type, value) {
          return value;
        };
        sce.valueOf = identity;
      }
      sce.parseAs = function sceParseAs(type, expr) {
        var parsed = $parse(expr);
        if (parsed.literal &amp;&amp; parsed.constant) {
          return parsed;
        } else {
          return $parse(expr, function(value) {
            return sce.getTrusted(type, value);
          });
        }
      };
      var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;
      forEach(SCE_CONTEXTS, function(enumValue, name) {
        var lName = lowercase(name);
        sce[camelCase("parse_as_" + lName)] = function(expr) {
          return parse(enumValue, expr);
        };
        sce[camelCase("get_trusted_" + lName)] = function(value) {
          return getTrusted(enumValue, value);
        };
        sce[camelCase("trust_as_" + lName)] = function(value) {
          return trustAs(enumValue, value);
        };
      });
      return sce;
    }];
  }

  function $SnifferProvider() {
    this.$get = ['$window', '$document', function($window, $document) {
      var eventSupport = {},
        isChromePackagedApp = $window.chrome &amp;&amp; $window.chrome.app &amp;&amp; $window.chrome.app.runtime,
        hasHistoryPushState = !isChromePackagedApp &amp;&amp; $window.history &amp;&amp; $window.history.pushState,
        android =
        toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
        document = $document[0] || {},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
        bodyStyle = document.body &amp;&amp; document.body.style,
        transitions = false,
        animations = false,
        match;
      if (bodyStyle) {
        for (var prop in bodyStyle) {
          if (match = vendorRegex.exec(prop)) {
            vendorPrefix = match[0];
            vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
            break;
          }
        }
        if (!vendorPrefix) {
          vendorPrefix = ('WebkitOpacity' in bodyStyle) &amp;&amp; 'webkit';
        }
        transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
        animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
        if (android &amp;&amp; (!transitions || !animations)) {
          transitions = isString(bodyStyle.webkitTransition);
          animations = isString(bodyStyle.webkitAnimation);
        }
      }
      return {
        history: !!(hasHistoryPushState &amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),
        hasEvent: function(event) {
          if (event === 'input' &amp;&amp; msie &lt;= 11) return false;
          if (isUndefined(eventSupport[event])) {
            var divElm = document.createElement('div');
            eventSupport[event] = 'on' + event in divElm;
          }
          return eventSupport[event];
        },
        csp: csp(),
        vendorPrefix: vendorPrefix,
        transitions: transitions,
        animations: animations,
        android: android
      };
    }];
  }
  var $templateRequestMinErr = minErr('$compile');

  function $TemplateRequestProvider() {
    var httpOptions;
    this.httpOptions = function(val) {
      if (val) {
        httpOptions = val;
        return this;
      }
      return httpOptions;
    };
    this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
      function handleRequestFn(tpl, ignoreRequestError) {
        handleRequestFn.totalPendingRequests++;
        if (!isString(tpl) || !$templateCache.get(tpl)) {
          tpl = $sce.getTrustedResourceUrl(tpl);
        }
        var transformResponse = $http.defaults &amp;&amp; $http.defaults.transformResponse;
        if (isArray(transformResponse)) {
          transformResponse = transformResponse.filter(function(transformer) {
            return transformer !== defaultHttpResponseTransform;
          });
        } else if (transformResponse === defaultHttpResponseTransform) {
          transformResponse = null;
        }
        return $http.get(tpl, extend({
            cache: $templateCache,
            transformResponse: transformResponse
          }, httpOptions))['finally'](function() {
            handleRequestFn.totalPendingRequests--;
          })
          .then(function(response) {
            $templateCache.put(tpl, response.data);
            return response.data;
          }, handleError);

        function handleError(resp) {
          if (!ignoreRequestError) {
            throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})',
              tpl, resp.status, resp.statusText);
          }
          return $q.reject(resp);
        }
      }
      handleRequestFn.totalPendingRequests = 0;
      return handleRequestFn;
    }];
  }

  function $$TestabilityProvider() {
    this.$get = ['$rootScope', '$browser', '$location',
      function($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function(element, expression, opt_exactMatch) {
          var bindings = element.getElementsByClassName('ng-binding');
          var matches = [];
          forEach(bindings, function(binding) {
            var dataBinding = angular.element(binding).data('$binding');
            if (dataBinding) {
              forEach(dataBinding, function(bindingName) {
                if (opt_exactMatch) {
                  var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                  if (matcher.test(bindingName)) {
                    matches.push(binding);
                  }
                } else {
                  if (bindingName.indexOf(expression) != -1) {
                    matches.push(binding);
                  }
                }
              });
            }
          });
          return matches;
        };
        testability.findModels = function(element, expression, opt_exactMatch) {
          var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
          for (var p = 0; p &lt; prefixes.length; ++p) {
            var attributeEquals = opt_exactMatch ? '=' : '*=';
            var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
            var elements = element.querySelectorAll(selector);
            if (elements.length) {
              return elements;
            }
          }
        };
        testability.getLocation = function() {
          return $location.url();
        };
        testability.setLocation = function(url) {
          if (url !== $location.url()) {
            $location.url(url);
            $rootScope.$digest();
          }
        };
        testability.whenStable = function(callback) {
          $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
      }
    ];
  }

  function $TimeoutProvider() {
    this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler',
      function($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};

        function timeout(fn, delay, invokeApply) {
          if (!isFunction(fn)) {
            invokeApply = delay;
            delay = fn;
            fn = noop;
          }
          var args = sliceArgs(arguments, 3),
            skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),
            deferred = (skipApply ? $$q : $q).defer(),
            promise = deferred.promise,
            timeoutId;
          timeoutId = $browser.defer(function() {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply) $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function(promise) {
          if (promise &amp;&amp; promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  var urlParsingNode = document.createElement("a");
  var originUrl = urlResolve(window.location.href);

  function urlResolve(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
        urlParsingNode.pathname :
        '/' + urlParsingNode.pathname
    };
  }

  function urlIsSameOrigin(requestUrl) {
    var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
    return (parsed.protocol === originUrl.protocol &amp;&amp;
      parsed.host === originUrl.host);
  }

  function $WindowProvider() {
    this.$get = valueFn(window);
  }

  function $$CookieReader($document) {
    var rawDocument = $document[0] || {};
    var lastCookies = {};
    var lastCookieString = '';

    function safeDecodeURIComponent(str) {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    return function() {
      var cookieArray, cookie, i, index, name;
      var currentCookieString = rawDocument.cookie || '';
      if (currentCookieString !== lastCookieString) {
        lastCookieString = currentCookieString;
        cookieArray = lastCookieString.split('; ');
        lastCookies = {};
        for (i = 0; i &lt; cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index &gt; 0) {
            name = safeDecodeURIComponent(cookie.substring(0, index));
            if (isUndefined(lastCookies[name])) {
              lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    };
  }
  $$CookieReader.$inject = ['$document'];

  function $$CookieReaderProvider() {
    this.$get = $$CookieReader;
  }
  $FilterProvider.$inject = ['$provide'];

  function $FilterProvider($provide) {
    var suffix = 'Filter';

    function register(name, factory) {
      if (isObject(name)) {
        var filters = {};
        forEach(name, function(filter, key) {
          filters[key] = register(key, filter);
        });
        return filters;
      } else {
        return $provide.factory(name + suffix, factory);
      }
    }
    this.register = register;
    this.$get = ['$injector', function($injector) {
      return function(name) {
        return $injector.get(name + suffix);
      };
    }];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }

  function filterFilter() {
    return function(array, expression, comparator) {
      if (!isArrayLike(array)) {
        if (array == null) {
          return array;
        } else {
          throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
        }
      }
      var expressionType = getTypeForFilter(expression);
      var predicateFn;
      var matchAgainstAnyProp;
      switch (expressionType) {
        case 'function':
          predicateFn = expression;
          break;
        case 'boolean':
        case 'null':
        case 'number':
        case 'string':
          matchAgainstAnyProp = true;
        case 'object':
          predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
          break;
        default:
          return array;
      }
      return Array.prototype.filter.call(array, predicateFn);
    };
  }

  function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
    var shouldMatchPrimitives = isObject(expression) &amp;&amp; ('$' in expression);
    var predicateFn;
    if (comparator === true) {
      comparator = equals;
    } else if (!isFunction(comparator)) {
      comparator = function(actual, expected) {
        if (isUndefined(actual)) {
          return false;
        }
        if ((actual === null) || (expected === null)) {
          return actual === expected;
        }
        if (isObject(expected) || (isObject(actual) &amp;&amp; !hasCustomToString(actual))) {
          return false;
        }
        actual = lowercase('' + actual);
        expected = lowercase('' + expected);
        return actual.indexOf(expected) !== -1;
      };
    }
    predicateFn = function(item) {
      if (shouldMatchPrimitives &amp;&amp; !isObject(item)) {
        return deepCompare(item, expression.$, comparator, false);
      }
      return deepCompare(item, expression, comparator, matchAgainstAnyProp);
    };
    return predicateFn;
  }

  function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
    var actualType = getTypeForFilter(actual);
    var expectedType = getTypeForFilter(expected);
    if ((expectedType === 'string') &amp;&amp; (expected.charAt(0) === '!')) {
      return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
    } else if (isArray(actual)) {
      return actual.some(function(item) {
        return deepCompare(item, expected, comparator, matchAgainstAnyProp);
      });
    }
    switch (actualType) {
      case 'object':
        var key;
        if (matchAgainstAnyProp) {
          for (key in actual) {
            if ((key.charAt(0) !== '$') &amp;&amp; deepCompare(actual[key], expected, comparator, true)) {
              return true;
            }
          }
          return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
        } else if (expectedType === 'object') {
          for (key in expected) {
            var expectedVal = expected[key];
            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
              continue;
            }
            var matchAnyProperty = key === '$';
            var actualVal = matchAnyProperty ? actual : actual[key];
            if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
              return false;
            }
          }
          return true;
        } else {
          return comparator(actual, expected);
        }
        break;
      case 'function':
        return false;
      default:
        return comparator(actual, expected);
    }
  }

  function getTypeForFilter(val) {
    return (val === null) ? 'null' : typeof val;
  }
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = '.';
  var ZERO_CHAR = '0';
  currencyFilter.$inject = ['$locale'];

  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(amount, currencySymbol, fractionSize) {
      if (isUndefined(currencySymbol)) {
        currencySymbol = formats.CURRENCY_SYM;
      }
      if (isUndefined(fractionSize)) {
        fractionSize = formats.PATTERNS[1].maxFrac;
      }
      return (amount == null) ?
        amount :
        formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
      replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];

  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(number, fractionSize) {
      return (number == null) ?
        number :
        formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
          fractionSize);
    };
  }

  function parse(numStr) {
    var exponent = 0,
      digits, numberOfIntegerDigits;
    var i, j, zeros;
    if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) &gt; -1) {
      numStr = numStr.replace(DECIMAL_SEP, '');
    }
    if ((i = numStr.search(/e/i)) &gt; 0) {
      if (numberOfIntegerDigits &lt; 0) numberOfIntegerDigits = i;
      numberOfIntegerDigits += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (numberOfIntegerDigits &lt; 0) {
      numberOfIntegerDigits = numStr.length;
    }
    for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
    if (i == (zeros = numStr.length)) {
      digits = [0];
      numberOfIntegerDigits = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) == ZERO_CHAR) zeros--;
      numberOfIntegerDigits -= i;
      digits = [];
      for (j = 0; i &lt;= zeros; i++, j++) {
        digits[j] = +numStr.charAt(i);
      }
    }
    if (numberOfIntegerDigits &gt; MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = numberOfIntegerDigits - 1;
      numberOfIntegerDigits = 1;
    }
    return {
      d: digits,
      e: exponent,
      i: numberOfIntegerDigits
    };
  }

  function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
    var digits = parsedNumber.d;
    var fractionLen = digits.length - parsedNumber.i;
    fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
    var roundAt = fractionSize + parsedNumber.i;
    var digit = digits[roundAt];
    if (roundAt &gt; 0) {
      digits.splice(Math.max(parsedNumber.i, roundAt));
      for (var j = roundAt; j &lt; digits.length; j++) {
        digits[j] = 0;
      }
    } else {
      fractionLen = Math.max(0, fractionLen);
      parsedNumber.i = 1;
      digits.length = Math.max(1, roundAt = fractionSize + 1);
      digits[0] = 0;
      for (var i = 1; i &lt; roundAt; i++) digits[i] = 0;
    }
    if (digit &gt;= 5) {
      if (roundAt - 1 &lt; 0) {
        for (var k = 0; k &gt; roundAt; k--) {
          digits.unshift(0);
          parsedNumber.i++;
        }
        digits.unshift(1);
        parsedNumber.i++;
      } else {
        digits[roundAt - 1]++;
      }
    }
    for (; fractionLen &lt; Math.max(0, fractionSize); fractionLen++) digits.push(0);
    var carry = digits.reduceRight(function(carry, d, i, digits) {
      d = d + carry;
      digits[i] = d % 10;
      return Math.floor(d / 10);
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.i++;
    }
  }

  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (!(isString(number) || isNumber(number)) || isNaN(number)) return '';
    var isInfinity = !isFinite(number);
    var isZero = false;
    var numStr = Math.abs(number) + '',
      formattedText = '',
      parsedNumber;
    if (isInfinity) {
      formattedText = '\u221e';
    } else {
      parsedNumber = parse(numStr);
      roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
      var digits = parsedNumber.d;
      var integerLen = parsedNumber.i;
      var exponent = parsedNumber.e;
      var decimals = [];
      isZero = digits.reduce(function(isZero, d) {
        return isZero &amp;&amp; !d;
      }, true);
      while (integerLen &lt; 0) {
        digits.unshift(0);
        integerLen++;
      }
      if (integerLen &gt; 0) {
        decimals = digits.splice(integerLen);
      } else {
        decimals = digits;
        digits = [0];
      }
      var groups = [];
      if (digits.length &gt;= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize).join(''));
      }
      while (digits.length &gt; pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize).join(''));
      }
      if (digits.length) {
        groups.unshift(digits.join(''));
      }
      formattedText = groups.join(groupSep);
      if (decimals.length) {
        formattedText += decimalSep + decimals.join('');
      }
      if (exponent) {
        formattedText += 'e+' + exponent;
      }
    }
    if (number &lt; 0 &amp;&amp; !isZero) {
      return pattern.negPre + formattedText + pattern.negSuf;
    } else {
      return pattern.posPre + formattedText + pattern.posSuf;
    }
  }

  function padNumber(num, digits, trim, negWrap) {
    var neg = '';
    if (num &lt; 0 || (negWrap &amp;&amp; num &lt;= 0)) {
      if (negWrap) {
        num = -num + 1;
      } else {
        num = -num;
        neg = '-';
      }
    }
    num = '' + num;
    while (num.length &lt; digits) num = ZERO_CHAR + num;
    if (trim) {
      num = num.substr(num.length - digits);
    }
    return neg + num;
  }

  function dateGetter(name, size, offset, trim, negWrap) {
    offset = offset || 0;
    return function(date) {
      var value = date['get' + name]();
      if (offset &gt; 0 || value &gt; -offset) {
        value += offset;
      }
      if (value === 0 &amp;&amp; offset == -12) value = 12;
      return padNumber(value, size, trim, negWrap);
    };
  }

  function dateStrGetter(name, shortForm, standAlone) {
    return function(date, formats) {
      var value = date['get' + name]();
      var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
      var get = uppercase(propPrefix + name);
      return formats[get][value];
    };
  }

  function timeZoneGetter(date, formats, offset) {
    var zone = -1 * offset;
    var paddedZone = (zone &gt;= 0) ? "+" : "";
    paddedZone += padNumber(Math[zone &gt; 0 ? 'floor' : 'ceil'](zone / 60), 2) +
      padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }

  function getFirstThursdayOfYear(year) {
    var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
    return new Date(year, 0, ((dayOfWeekOnFirst &lt;= 4) ? 5 : 12) - dayOfWeekOnFirst);
  }

  function getThursdayThisWeek(datetime) {
    return new Date(datetime.getFullYear(), datetime.getMonth(),
      datetime.getDate() + (4 - datetime.getDay()));
  }

  function weekGetter(size) {
    return function(date) {
      var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
        thisThurs = getThursdayThisWeek(date);
      var diff = +thisThurs - +firstThurs,
        result = 1 + Math.round(diff / 6.048e8);
      return padNumber(result, size);
    };
  }

  function ampmGetter(date, formats) {
    return date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }

  function eraGetter(date, formats) {
    return date.getFullYear() &lt;= 0 ? formats.ERAS[0] : formats.ERAS[1];
  }

  function longEraGetter(date, formats) {
    return date.getFullYear() &lt;= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
  }
  var DATE_FORMATS = {
    yyyy: dateGetter('FullYear', 4, 0, false, true),
    yy: dateGetter('FullYear', 2, 0, true, true),
    y: dateGetter('FullYear', 1, 0, false, true),
    MMMM: dateStrGetter('Month'),
    MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
    M: dateGetter('Month', 1, 1),
    LLLL: dateStrGetter('Month', false, true),
    dd: dateGetter('Date', 2),
    d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
    H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
    h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
    m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
    s: dateGetter('Seconds', 1),
    sss: dateGetter('Milliseconds', 3),
    EEEE: dateStrGetter('Day'),
    EEE: dateStrGetter('Day', true),
    a: ampmGetter,
    Z: timeZoneGetter,
    ww: weekGetter(2),
    w: weekGetter(1),
    G: eraGetter,
    GG: eraGetter,
    GGG: eraGetter,
    GGGG: longEraGetter
  };
  var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;
  dateFilter.$inject = ['$locale'];

  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;

    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0),
          tzHour = 0,
          tzMin = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
          tzHour = toInt(match[9] + match[10]);
          tzMin = toInt(match[9] + match[11]);
        }
        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
        var h = toInt(match[4] || 0) - tzHour;
        var m = toInt(match[5] || 0) - tzMin;
        var s = toInt(match[6] || 0);
        var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
        timeSetter.call(date, h, m, s, ms);
        return date;
      }
      return string;
    }
    return function(date, format, timezone) {
      var text = '',
        parts = [],
        fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date) || !isFinite(date.getTime())) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      var dateTimezoneOffset = date.getTimezoneOffset();
      if (timezone) {
        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        date = convertTimezoneToLocal(date, timezone, true);
      }
      forEach(parts, function(value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) :
          value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
      });
      return text;
    };
  }

  function jsonFilter() {
    return function(object, spacing) {
      if (isUndefined(spacing)) {
        spacing = 2;
      }
      return toJson(object, spacing);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);

  function limitToFilter() {
    return function(input, limit, begin) {
      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = toInt(limit);
      }
      if (isNaN(limit)) return input;
      if (isNumber(input)) input = input.toString();
      if (!isArray(input) &amp;&amp; !isString(input)) return input;
      begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
      begin = (begin &lt; 0) ? Math.max(0, input.length + begin) : begin;
      if (limit &gt;= 0) {
        return input.slice(begin, begin + limit);
      } else {
        if (begin === 0) {
          return input.slice(limit, input.length);
        } else {
          return input.slice(Math.max(0, begin + limit), begin);
        }
      }
    };
  }
  orderByFilter.$inject = ['$parse'];

  function orderByFilter($parse) {
    return function(array, sortPredicate, reverseOrder) {
      if (array == null) return array;
      if (!isArrayLike(array)) {
        throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
      }
      if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
      }
      if (sortPredicate.length === 0) {
        sortPredicate = ['+'];
      }
      var predicates = processPredicates(sortPredicate, reverseOrder);
      predicates.push({
        get: function() {
          return {};
        },
        descending: reverseOrder ? -1 : 1
      });
      var compareValues = Array.prototype.map.call(array, getComparisonObject);
      compareValues.sort(doComparison);
      array = compareValues.map(function(item) {
        return item.value;
      });
      return array;

      function getComparisonObject(value, index) {
        return {
          value: value,
          predicateValues: predicates.map(function(predicate) {
            return getPredicateValue(predicate.get(value), index);
          })
        };
      }

      function doComparison(v1, v2) {
        var result = 0;
        for (var index = 0, length = predicates.length; index &lt; length; ++index) {
          result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
          if (result) break;
        }
        return result;
      }
    };

    function processPredicates(sortPredicate, reverseOrder) {
      reverseOrder = reverseOrder ? -1 : 1;
      return sortPredicate.map(function(predicate) {
        var descending = 1,
          get = identity;
        if (isFunction(predicate)) {
          get = predicate;
        } else if (isString(predicate)) {
          if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
            descending = predicate.charAt(0) == '-' ? -1 : 1;
            predicate = predicate.substring(1);
          }
          if (predicate !== '') {
            get = $parse(predicate);
            if (get.constant) {
              var key = get();
              get = function(value) {
                return value[key];
              };
            }
          }
        }
        return {
          get: get,
          descending: descending * reverseOrder
        };
      });
    }

    function isPrimitive(value) {
      switch (typeof value) {
        case 'number':
        case 'boolean':
        case 'string':
          return true;
        default:
          return false;
      }
    }

    function objectValue(value, index) {
      if (typeof value.valueOf === 'function') {
        value = value.valueOf();
        if (isPrimitive(value)) return value;
      }
      if (hasCustomToString(value)) {
        value = value.toString();
        if (isPrimitive(value)) return value;
      }
      return index;
    }

    function getPredicateValue(value, index) {
      var type = typeof value;
      if (value === null) {
        type = 'string';
        value = 'null';
      } else if (type === 'string') {
        value = value.toLowerCase();
      } else if (type === 'object') {
        value = objectValue(value, index);
      }
      return {
        value: value,
        type: type
      };
    }

    function compare(v1, v2) {
      var result = 0;
      if (v1.type === v2.type) {
        if (v1.value !== v2.value) {
          result = v1.value &lt; v2.value ? -1 : 1;
        }
      } else {
        result = v1.type &lt; v2.type ? -1 : 1;
      }
      return result;
    }
  }

  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = {
        link: directive
      };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
    restrict: 'E',
    compile: function(element, attr) {
      if (!attr.href &amp;&amp; !attr.xlinkHref) {
        return function(scope, element) {
          if (element[0].nodeName.toLowerCase() !== 'a') return;
          var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?
            'xlink:href' : 'href';
          element.on('click', function(event) {
            if (!element.attr(href)) {
              event.preventDefault();
            }
          });
        };
      }
    }
  });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function(propName, attrName) {
    if (propName == "multiple") return;

    function defaultLinkFn(scope, element, attr) {
      scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
        attr.$set(attrName, !!value);
      });
    }
    var normalized = directiveNormalize('ng-' + attrName);
    var linkFn = defaultLinkFn;
    if (propName === 'checked') {
      linkFn = function(scope, element, attr) {
        if (attr.ngModel !== attr[normalized]) {
          defaultLinkFn(scope, element, attr);
        }
      };
    }
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        restrict: 'A',
        priority: 100,
        link: linkFn
      };
    };
  });
  forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
    ngAttributeAliasDirectives[ngAttr] = function() {
      return {
        priority: 100,
        link: function(scope, element, attr) {
          if (ngAttr === "ngPattern" &amp;&amp; attr.ngPattern.charAt(0) == "/") {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
              attr.$set("ngPattern", new RegExp(match[1], match[2]));
              return;
            }
          }
          scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
          });
        }
      };
    };
  });
  forEach(['src', 'srcset', 'href'], function(attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        priority: 99,
        link: function(scope, element, attr) {
          var propName = attrName,
            name = attrName;
          if (attrName === 'href' &amp;&amp;
            toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
            name = 'xlinkHref';
            attr.$attr[name] = 'xlink:href';
            propName = null;
          }
          attr.$observe(normalized, function(value) {
            if (!value) {
              if (attrName === 'href') {
                attr.$set(name, null);
              }
              return;
            }
            attr.$set(name, value);
            if (msie &amp;&amp; propName) element.prop(propName, attr[name]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $$renameControl: nullFormRenameControl,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop,
      $setPristine: noop,
      $setSubmitted: noop
    },
    SUBMITTED_CLASS = 'ng-submitted';

  function nullFormRenameControl(control, name) {
    control.$name = name;
  }
  FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];

  function FormController(element, attrs, $scope, $animate, $interpolate) {
    var form = this,
      controls = [];
    form.$error = {};
    form.$$success = {};
    form.$pending = undefined;
    form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    form.$submitted = false;
    form.$$parentForm = nullFormCtrl;
    form.$rollbackViewValue = function() {
      forEach(controls, function(control) {
        control.$rollbackViewValue();
      });
    };
    form.$commitViewValue = function() {
      forEach(controls, function(control) {
        control.$commitViewValue();
      });
    };
    form.$addControl = function(control) {
      assertNotHasOwnProperty(control.$name, 'input');
      controls.push(control);
      if (control.$name) {
        form[control.$name] = control;
      }
      control.$$parentForm = form;
    };
    form.$$renameControl = function(control, newName) {
      var oldName = control.$name;
      if (form[oldName] === control) {
        delete form[oldName];
      }
      form[newName] = control;
      control.$name = newName;
    };
    form.$removeControl = function(control) {
      if (control.$name &amp;&amp; form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(form.$pending, function(value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$error, function(value, name) {
        form.$setValidity(name, null, control);
      });
      forEach(form.$$success, function(value, name) {
        form.$setValidity(name, null, control);
      });
      arrayRemove(controls, control);
      control.$$parentForm = nullFormCtrl;
    };
    addSetValidityMethod({
      ctrl: this,
      $element: element,
      set: function(object, property, controller) {
        var list = object[property];
        if (!list) {
          object[property] = [controller];
        } else {
          var index = list.indexOf(controller);
          if (index === -1) {
            list.push(controller);
          }
        }
      },
      unset: function(object, property, controller) {
        var list = object[property];
        if (!list) {
          return;
        }
        arrayRemove(list, controller);
        if (list.length === 0) {
          delete object[property];
        }
      },
      $animate: $animate
    });
    form.$setDirty = function() {
      $animate.removeClass(element, PRISTINE_CLASS);
      $animate.addClass(element, DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      form.$$parentForm.$setDirty();
    };
    form.$setPristine = function() {
      $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
      form.$dirty = false;
      form.$pristine = true;
      form.$submitted = false;
      forEach(controls, function(control) {
        control.$setPristine();
      });
    };
    form.$setUntouched = function() {
      forEach(controls, function(control) {
        control.$setUntouched();
      });
    };
    form.$setSubmitted = function() {
      $animate.addClass(element, SUBMITTED_CLASS);
      form.$submitted = true;
      form.$$parentForm.$setSubmitted();
    };
  }
  var formDirectiveFactory = function(isNgForm) {
    return ['$timeout', '$parse', function($timeout, $parse) {
      var formDirective = {
        name: 'form',
        restrict: isNgForm ? 'EAC' : 'E',
        require: ['form', '^^?form'],
        controller: FormController,
        compile: function ngFormCompile(formElement, attr) {
          formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
          var nameAttr = attr.name ? 'name' : (isNgForm &amp;&amp; attr.ngForm ? 'ngForm' : false);
          return {
            pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
              var controller = ctrls[0];
              if (!('action' in attr)) {
                var handleFormSubmission = function(event) {
                  scope.$apply(function() {
                    controller.$commitViewValue();
                    controller.$setSubmitted();
                  });
                  event.preventDefault();
                };
                addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                formElement.on('$destroy', function() {
                  $timeout(function() {
                    removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                  }, 0, false);
                });
              }
              var parentFormCtrl = ctrls[1] || controller.$$parentForm;
              parentFormCtrl.$addControl(controller);
              var setter = nameAttr ? getSetter(controller.$name) : noop;
              if (nameAttr) {
                setter(scope, controller);
                attr.$observe(nameAttr, function(newValue) {
                  if (controller.$name === newValue) return;
                  setter(scope, undefined);
                  controller.$$parentForm.$$renameControl(controller, newValue);
                  setter = getSetter(controller.$name);
                  setter(scope, controller);
                });
              }
              formElement.on('$destroy', function() {
                controller.$$parentForm.$removeControl(controller);
                setter(scope, undefined);
                extend(controller, nullFormCtrl);
              });
            }
          };
        }
      };
      return formDirective;

      function getSetter(expression) {
        if (expression === '') {
          return $parse('this[""]').assign;
        }
        return $parse(expression).assign || noop;
      }
    }];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
  var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
  var EMAIL_REGEXP = /^[a-z0-9!#$%&amp;'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
  var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
  var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
  var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
  var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
  var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
  var PARTIAL_VALIDATION_TYPES = createMap();
  forEach('date,datetime-local,month,time,week'.split(','), function(type) {
    PARTIAL_VALIDATION_TYPES[type] = true;
  });
  var inputType = {
    'text': textInputType,
    'date': createDateInputType('date', DATE_REGEXP,
      createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),
      'yyyy-MM-dd'),
    'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP,
      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']),
      'yyyy-MM-ddTHH:mm:ss.sss'),
    'time': createDateInputType('time', TIME_REGEXP,
      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),
      'HH:mm:ss.sss'),
    'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
    'month': createDateInputType('month', MONTH_REGEXP,
      createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),
      'yyyy-MM'),
    'number': numberInputType,
    'url': urlInputType,
    'email': emailInputType,
    'radio': radioInputType,
    'checkbox': checkboxInputType,
    'hidden': noop,
    'button': noop,
    'submit': noop,
    'reset': noop,
    'file': noop
  };

  function stringBasedInputType(ctrl) {
    ctrl.$formatters.push(function(value) {
      return ctrl.$isEmpty(value) ? value : value.toString();
    });
  }

  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
  }

  function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var type = lowercase(element[0].type);
    if (!$sniffer.android) {
      var composing = false;
      element.on('compositionstart', function() {
        composing = true;
      });
      element.on('compositionend', function() {
        composing = false;
        listener();
      });
    }
    var timeout;
    var listener = function(ev) {
      if (timeout) {
        $browser.defer.cancel(timeout);
        timeout = null;
      }
      if (composing) return;
      var value = element.val(),
        event = ev &amp;&amp; ev.type;
      if (type !== 'password' &amp;&amp; (!attr.ngTrim || attr.ngTrim !== 'false')) {
        value = trim(value);
      }
      if (ctrl.$viewValue !== value || (value === '' &amp;&amp; ctrl.$$hasNativeValidators)) {
        ctrl.$setViewValue(value, event);
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.on('input', listener);
    } else {
      var deferListener = function(ev, input, origValue) {
        if (!timeout) {
          timeout = $browser.defer(function() {
            timeout = null;
            if (!input || input.value !== origValue) {
              listener(ev);
            }
          });
        }
      };
      element.on('keydown', function(event) {
        var key = event.keyCode;
        if (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) return;
        deferListener(event, this, this.value);
      });
      if ($sniffer.hasEvent('paste')) {
        element.on('paste cut', deferListener);
      }
    }
    element.on('change', listener);
    if (PARTIAL_VALIDATION_TYPES[type] &amp;&amp; ctrl.$$hasNativeValidators &amp;&amp; type === attr.type) {
      element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
        if (!timeout) {
          var validity = this[VALIDITY_STATE_PROPERTY];
          var origBadInput = validity.badInput;
          var origTypeMismatch = validity.typeMismatch;
          timeout = $browser.defer(function() {
            timeout = null;
            if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
              listener(ev);
            }
          });
        }
      });
    }
    ctrl.$render = function() {
      var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
      if (element.val() !== value) {
        element.val(value);
      }
    };
  }

  function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
      return isoWeek;
    }
    if (isString(isoWeek)) {
      WEEK_REGEXP.lastIndex = 0;
      var parts = WEEK_REGEXP.exec(isoWeek);
      if (parts) {
        var year = +parts[1],
          week = +parts[2],
          hours = 0,
          minutes = 0,
          seconds = 0,
          milliseconds = 0,
          firstThurs = getFirstThursdayOfYear(year),
          addDays = (week - 1) * 7;
        if (existingDate) {
          hours = existingDate.getHours();
          minutes = existingDate.getMinutes();
          seconds = existingDate.getSeconds();
          milliseconds = existingDate.getMilliseconds();
        }
        return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
      }
    }
    return NaN;
  }

  function createDateParser(regexp, mapping) {
    return function(iso, date) {
      var parts, map;
      if (isDate(iso)) {
        return iso;
      }
      if (isString(iso)) {
        if (iso.charAt(0) == '"' &amp;&amp; iso.charAt(iso.length - 1) == '"') {
          iso = iso.substring(1, iso.length - 1);
        }
        if (ISO_DATE_REGEXP.test(iso)) {
          return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);
        if (parts) {
          parts.shift();
          if (date) {
            map = {
              yyyy: date.getFullYear(),
              MM: date.getMonth() + 1,
              dd: date.getDate(),
              HH: date.getHours(),
              mm: date.getMinutes(),
              ss: date.getSeconds(),
              sss: date.getMilliseconds() / 1000
            };
          } else {
            map = {
              yyyy: 1970,
              MM: 1,
              dd: 1,
              HH: 0,
              mm: 0,
              ss: 0,
              sss: 0
            };
          }
          forEach(parts, function(part, index) {
            if (index &lt; mapping.length) {
              map[mapping[index]] = +part;
            }
          });
          return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
        }
      }
      return NaN;
    };
  }

  function createDateInputType(type, regexp, parseDate, format) {
    return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
      badInputChecker(scope, element, attr, ctrl);
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      var timezone = ctrl &amp;&amp; ctrl.$options &amp;&amp; ctrl.$options.timezone;
      var previousDate;
      ctrl.$$parserName = type;
      ctrl.$parsers.push(function(value) {
        if (ctrl.$isEmpty(value)) return null;
        if (regexp.test(value)) {
          var parsedDate = parseDate(value, previousDate);
          if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
          }
          return parsedDate;
        }
        return undefined;
      });
      ctrl.$formatters.push(function(value) {
        if (value &amp;&amp; !isDate(value)) {
          throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
        }
        if (isValidDate(value)) {
          previousDate = value;
          if (previousDate &amp;&amp; timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
          }
          return $filter('date')(value, format, timezone);
        } else {
          previousDate = null;
          return '';
        }
      });
      if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function(value) {
          return !isValidDate(value) || isUndefined(minVal) || parseDate(value) &gt;= minVal;
        };
        attr.$observe('min', function(val) {
          minVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }
      if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function(value) {
          return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) &lt;= maxVal;
        };
        attr.$observe('max', function(val) {
          maxVal = parseObservedDateValue(val);
          ctrl.$validate();
        });
      }

      function isValidDate(value) {
        return value &amp;&amp; !(value.getTime &amp;&amp; value.getTime() !== value.getTime());
      }

      function parseObservedDateValue(val) {
        return isDefined(val) &amp;&amp; !isDate(val) ? parseDate(val) || undefined : val;
      }
    };
  }

  function badInputChecker(scope, element, attr, ctrl) {
    var node = element[0];
    var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
    if (nativeValidation) {
      ctrl.$parsers.push(function(value) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
        return validity.badInput || validity.typeMismatch ? undefined : value;
      });
    }
  }

  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$$parserName = 'number';
    ctrl.$parsers.push(function(value) {
      if (ctrl.$isEmpty(value)) return null;
      if (NUMBER_REGEXP.test(value)) return parseFloat(value);
      return undefined;
    });
    ctrl.$formatters.push(function(value) {
      if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
          throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
        }
        value = value.toString();
      }
      return value;
    });
    if (isDefined(attr.min) || attr.ngMin) {
      var minVal;
      ctrl.$validators.min = function(value) {
        return ctrl.$isEmpty(value) || isUndefined(minVal) || value &gt;= minVal;
      };
      attr.$observe('min', function(val) {
        if (isDefined(val) &amp;&amp; !isNumber(val)) {
          val = parseFloat(val, 10);
        }
        minVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
    if (isDefined(attr.max) || attr.ngMax) {
      var maxVal;
      ctrl.$validators.max = function(value) {
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value &lt;= maxVal;
      };
      attr.$observe('max', function(val) {
        if (isDefined(val) &amp;&amp; !isNumber(val)) {
          val = parseFloat(val, 10);
        }
        maxVal = isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;
        ctrl.$validate();
      });
    }
  }

  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'url';
    ctrl.$validators.url = function(modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
  }

  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'email';
    ctrl.$validators.email = function(modelValue, viewValue) {
      var value = modelValue || viewValue;
      return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
  }

  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    var listener = function(ev) {
      if (element[0].checked) {
        ctrl.$setViewValue(attr.value, ev &amp;&amp; ev.type);
      }
    };
    element.on('click', listener);
    ctrl.$render = function() {
      var value = attr.value;
      element[0].checked = (value == ctrl.$viewValue);
    };
    attr.$observe('value', ctrl.$render);
  }

  function parseConstantExpr($parse, context, name, expression, fallback) {
    var parseFn;
    if (isDefined(expression)) {
      parseFn = $parse(expression);
      if (!parseFn.constant) {
        throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' +
          '`{1}`.', name, expression);
      }
      return parseFn(context);
    }
    return fallback;
  }

  function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
    var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
    var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
    var listener = function(ev) {
      ctrl.$setViewValue(element[0].checked, ev &amp;&amp; ev.type);
    };
    element.on('click', listener);
    ctrl.$render = function() {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function(value) {
      return value === false;
    };
    ctrl.$formatters.push(function(value) {
      return equals(value, trueValue);
    });
    ctrl.$parsers.push(function(value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = ['$browser', '$sniffer', '$filter', '$parse',
    function($browser, $sniffer, $filter, $parse) {
      return {
        restrict: 'E',
        require: ['?ngModel'],
        link: {
          pre: function(scope, element, attr, ctrls) {
            if (ctrls[0]) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer,
                $browser, $filter, $parse);
            }
          }
        }
      };
    }
  ];
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function() {
    return {
      restrict: 'A',
      priority: 100,
      compile: function(tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function ngValueConstantLink(scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function ngValueLink(scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ['$compile', function($compile) {
    return {
      restrict: 'AC',
      compile: function ngBindCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindLink(scope, element, attr) {
          $compile.$$addBindingInfo(element, attr.ngBind);
          element = element[0];
          scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
            element.textContent = isUndefined(value) ? '' : value;
          });
        };
      }
    };
  }];
  var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
    return {
      compile: function ngBindTemplateCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindTemplateLink(scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          $compile.$$addBindingInfo(element, interpolateFn.expressions);
          element = element[0];
          attr.$observe('ngBindTemplate', function(value) {
            element.textContent = isUndefined(value) ? '' : value;
          });
        };
      }
    };
  }];
  var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
    return {
      restrict: 'A',
      compile: function ngBindHtmlCompile(tElement, tAttrs) {
        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
          return (value || '').toString();
        });
        $compile.$$addBindingClass(tElement);
        return function ngBindHtmlLink(scope, element, attr) {
          $compile.$$addBindingInfo(element, attr.ngBindHtml);
          scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
            element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
          });
        };
      }
    };
  }];
  var ngChangeDirective = valueFn({
    restrict: 'A',
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      ctrl.$viewChangeListeners.push(function() {
        scope.$eval(attr.ngChange);
      });
    }
  });

  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ['$animate', function($animate) {
      return {
        restrict: 'AC',
        link: function(scope, element, attr) {
          var oldVal;
          scope.$watch(attr[name], ngClassWatchAction, true);
          attr.$observe('class', function(value) {
            ngClassWatchAction(scope.$eval(attr[name]));
          });
          if (name !== 'ngClass') {
            scope.$watch('$index', function($index, old$index) {
              var mod = $index &amp; 1;
              if (mod !== (old$index &amp; 1)) {
                var classes = arrayClasses(scope.$eval(attr[name]));
                mod === selector ?
                  addClasses(classes) :
                  removeClasses(classes);
              }
            });
          }

          function addClasses(classes) {
            var newClasses = digestClassCounts(classes, 1);
            attr.$addClass(newClasses);
          }

          function removeClasses(classes) {
            var newClasses = digestClassCounts(classes, -1);
            attr.$removeClass(newClasses);
          }

          function digestClassCounts(classes, count) {
            var classCounts = element.data('$classCounts') || createMap();
            var classesToUpdate = [];
            forEach(classes, function(className) {
              if (count &gt; 0 || classCounts[className]) {
                classCounts[className] = (classCounts[className] || 0) + count;
                if (classCounts[className] === +(count &gt; 0)) {
                  classesToUpdate.push(className);
                }
              }
            });
            element.data('$classCounts', classCounts);
            return classesToUpdate.join(' ');
          }

          function updateClasses(oldClasses, newClasses) {
            var toAdd = arrayDifference(newClasses, oldClasses);
            var toRemove = arrayDifference(oldClasses, newClasses);
            toAdd = digestClassCounts(toAdd, 1);
            toRemove = digestClassCounts(toRemove, -1);
            if (toAdd &amp;&amp; toAdd.length) {
              $animate.addClass(element, toAdd);
            }
            if (toRemove &amp;&amp; toRemove.length) {
              $animate.removeClass(element, toRemove);
            }
          }

          function ngClassWatchAction(newVal) {
            if (selector === true || scope.$index % 2 === selector) {
              var newClasses = arrayClasses(newVal || []);
              if (!oldVal) {
                addClasses(newClasses);
              } else if (!equals(newVal, oldVal)) {
                var oldClasses = arrayClasses(oldVal);
                updateClasses(oldClasses, newClasses);
              }
            }
            oldVal = shallowCopy(newVal);
          }
        }
      };

      function arrayDifference(tokens1, tokens2) {
        var values = [];
        outer:
          for (var i = 0; i &lt; tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j &lt; tokens2.length; j++) {
              if (token == tokens2[j]) continue outer;
            }
            values.push(token);
          }
        return values;
      }

      function arrayClasses(classVal) {
        var classes = [];
        if (isArray(classVal)) {
          forEach(classVal, function(v) {
            classes = classes.concat(arrayClasses(v));
          });
          return classes;
        } else if (isString(classVal)) {
          return classVal.split(' ');
        } else if (isObject(classVal)) {
          forEach(classVal, function(v, k) {
            if (v) {
              classes = classes.concat(k.split(' '));
            }
          });
          return classes;
        }
        return classVal;
      }
    }];
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
    compile: function(element, attr) {
      attr.$set('ngCloak', undefined);
      element.removeClass('ng-cloak');
    }
  });
  var ngControllerDirective = [function() {
    return {
      restrict: 'A',
      scope: true,
      controller: '@',
      priority: 500
    };
  }];
  var ngEventDirectives = {};
  var forceAsyncEvents = {
    'blur': true,
    'focus': true
  };
  forEach(
    'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
    function(eventName) {
      var directiveName = directiveNormalize('ng-' + eventName);
      ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
        return {
          restrict: 'A',
          compile: function($element, attr) {
            var fn = $parse(attr[directiveName], null, true);
            return function ngEventHandler(scope, element) {
              element.on(eventName, function(event) {
                var callback = function() {
                  fn(scope, {
                    $event: event
                  });
                };
                if (forceAsyncEvents[eventName] &amp;&amp; $rootScope.$$phase) {
                  scope.$evalAsync(callback);
                } else {
                  scope.$apply(callback);
                }
              });
            };
          }
        };
      }];
    }
  );
  var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
    return {
      multiElement: true,
      transclude: 'element',
      priority: 600,
      terminal: true,
      restrict: 'A',
      $$tlb: true,
      link: function($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (value) {
            if (!childScope) {
              $transclude(function(clone, newScope) {
                childScope = newScope;
                clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {
            if (previousElements) {
              previousElements.remove();
              previousElements = null;
            }
            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }
            if (block) {
              previousElements = getBlockNodes(block.clone);
              $animate.leave(previousElements).then(function() {
                previousElements = null;
              });
              block = null;
            }
          }
        });
      }
    };
  }];
  var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate',
    function($templateRequest, $anchorScroll, $animate) {
      return {
        restrict: 'ECA',
        priority: 400,
        terminal: true,
        transclude: 'element',
        controller: angular.noop,
        compile: function(element, attr) {
          var srcExp = attr.ngInclude || attr.src,
            onloadExp = attr.onload || '',
            autoScrollExp = attr.autoscroll;
          return function(scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
            var cleanupLastIncludeContent = function() {
              if (previousElement) {
                previousElement.remove();
                previousElement = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                $animate.leave(currentElement).then(function() {
                  previousElement = null;
                });
                previousElement = currentElement;
                currentElement = null;
              }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
              var afterAnimation = function() {
                if (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              };
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(function(response) {
                  if (scope.$$destroyed) return;
                  if (thisChangeId !== changeCounter) return;
                  var newScope = scope.$new();
                  ctrl.template = response;
                  var clone = $transclude(newScope, function(clone) {
                    cleanupLastIncludeContent();
                    $animate.enter(clone, null, $element).then(afterAnimation);
                  });
                  currentScope = newScope;
                  currentElement = clone;
                  currentScope.$emit('$includeContentLoaded', src);
                  scope.$eval(onloadExp);
                }, function() {
                  if (scope.$$destroyed) return;
                  if (thisChangeId === changeCounter) {
                    cleanupLastIncludeContent();
                    scope.$emit('$includeContentError', src);
                  }
                });
                scope.$emit('$includeContentRequested', src);
              } else {
                cleanupLastIncludeContent();
                ctrl.template = null;
              }
            });
          };
        }
      };
    }
  ];
  var ngIncludeFillContentDirective = ['$compile',
    function($compile) {
      return {
        restrict: 'ECA',
        priority: -400,
        require: 'ngInclude',
        link: function(scope, $element, $attr, ctrl) {
          if (toString.call($element[0]).match(/SVG/)) {
            $element.empty();
            $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope,
              function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {
                futureParentElement: $element
              });
            return;
          }
          $element.html(ctrl.template);
          $compile($element.contents())(scope);
        }
      };
    }
  ];
  var ngInitDirective = ngDirective({
    priority: 450,
    compile: function() {
      return {
        pre: function(scope, element, attrs) {
          scope.$eval(attrs.ngInit);
        }
      };
    }
  });
  var ngListDirective = function() {
    return {
      restrict: 'A',
      priority: 100,
      require: 'ngModel',
      link: function(scope, element, attr, ctrl) {
        var ngList = element.attr(attr.$attr.ngList) || ', ';
        var trimValues = attr.ngTrim !== 'false';
        var separator = trimValues ? trim(ngList) : ngList;
        var parse = function(viewValue) {
          if (isUndefined(viewValue)) return;
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function(value) {
              if (value) list.push(trimValues ? trim(value) : value);
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function(value) {
          if (isArray(value)) {
            return value.join(ngList);
          }
          return undefined;
        });
        ctrl.$isEmpty = function(value) {
          return !value || !value.length;
        };
      }
    };
  };
  var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty',
    UNTOUCHED_CLASS = 'ng-untouched',
    TOUCHED_CLASS = 'ng-touched',
    PENDING_CLASS = 'ng-pending',
    EMPTY_CLASS = 'ng-empty',
    NOT_EMPTY_CLASS = 'ng-not-empty';
  var ngModelMinErr = minErr('ngModel');
  var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate',
    function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
      this.$viewValue = Number.NaN;
      this.$modelValue = Number.NaN;
      this.$$rawModelValue = undefined;
      this.$validators = {};
      this.$asyncValidators = {};
      this.$parsers = [];
      this.$formatters = [];
      this.$viewChangeListeners = [];
      this.$untouched = true;
      this.$touched = false;
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$error = {};
      this.$$success = {};
      this.$pending = undefined;
      this.$name = $interpolate($attr.name || '', false)($scope);
      this.$$parentForm = nullFormCtrl;
      var parsedNgModel = $parse($attr.ngModel),
        parsedNgModelAssign = parsedNgModel.assign,
        ngModelGet = parsedNgModel,
        ngModelSet = parsedNgModelAssign,
        pendingDebounce = null,
        parserValid,
        ctrl = this;
      this.$$setOptions = function(options) {
        ctrl.$options = options;
        if (options &amp;&amp; options.getterSetter) {
          var invokeModelGetter = $parse($attr.ngModel + '()'),
            invokeModelSetter = $parse($attr.ngModel + '($$$p)');
          ngModelGet = function($scope) {
            var modelValue = parsedNgModel($scope);
            if (isFunction(modelValue)) {
              modelValue = invokeModelGetter($scope);
            }
            return modelValue;
          };
          ngModelSet = function($scope, newValue) {
            if (isFunction(parsedNgModel($scope))) {
              invokeModelSetter($scope, {
                $$$p: newValue
              });
            } else {
              parsedNgModelAssign($scope, newValue);
            }
          };
        } else if (!parsedNgModel.assign) {
          throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
            $attr.ngModel, startingTag($element));
        }
      };
      this.$render = noop;
      this.$isEmpty = function(value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
      };
      this.$$updateEmptyClasses = function(value) {
        if (ctrl.$isEmpty(value)) {
          $animate.removeClass($element, NOT_EMPTY_CLASS);
          $animate.addClass($element, EMPTY_CLASS);
        } else {
          $animate.removeClass($element, EMPTY_CLASS);
          $animate.addClass($element, NOT_EMPTY_CLASS);
        }
      };
      var currentValidationRunId = 0;
      addSetValidityMethod({
        ctrl: this,
        $element: $element,
        set: function(object, property) {
          object[property] = true;
        },
        unset: function(object, property) {
          delete object[property];
        },
        $animate: $animate
      });
      this.$setPristine = function() {
        ctrl.$dirty = false;
        ctrl.$pristine = true;
        $animate.removeClass($element, DIRTY_CLASS);
        $animate.addClass($element, PRISTINE_CLASS);
      };
      this.$setDirty = function() {
        ctrl.$dirty = true;
        ctrl.$pristine = false;
        $animate.removeClass($element, PRISTINE_CLASS);
        $animate.addClass($element, DIRTY_CLASS);
        ctrl.$$parentForm.$setDirty();
      };
      this.$setUntouched = function() {
        ctrl.$touched = false;
        ctrl.$untouched = true;
        $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
      };
      this.$setTouched = function() {
        ctrl.$touched = true;
        ctrl.$untouched = false;
        $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
      };
      this.$rollbackViewValue = function() {
        $timeout.cancel(pendingDebounce);
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
        ctrl.$render();
      };
      this.$validate = function() {
        if (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {
          return;
        }
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = ctrl.$$rawModelValue;
        var prevValid = ctrl.$valid;
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;
        ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
          if (!allowInvalid &amp;&amp; prevValid !== allValid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        });
      };
      this.$$runValidators = function(modelValue, viewValue, doneCallback) {
        currentValidationRunId++;
        var localValidationRunId = currentValidationRunId;
        if (!processParseErrors()) {
          validationDone(false);
          return;
        }
        if (!processSyncValidators()) {
          validationDone(false);
          return;
        }
        processAsyncValidators();

        function processParseErrors() {
          var errorKey = ctrl.$$parserName || 'parse';
          if (isUndefined(parserValid)) {
            setValidity(errorKey, null);
          } else {
            if (!parserValid) {
              forEach(ctrl.$validators, function(v, name) {
                setValidity(name, null);
              });
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
            }
            setValidity(errorKey, parserValid);
            return parserValid;
          }
          return true;
        }

        function processSyncValidators() {
          var syncValidatorsValid = true;
          forEach(ctrl.$validators, function(validator, name) {
            var result = validator(modelValue, viewValue);
            syncValidatorsValid = syncValidatorsValid &amp;&amp; result;
            setValidity(name, result);
          });
          if (!syncValidatorsValid) {
            forEach(ctrl.$asyncValidators, function(v, name) {
              setValidity(name, null);
            });
            return false;
          }
          return true;
        }

        function processAsyncValidators() {
          var validatorPromises = [];
          var allValid = true;
          forEach(ctrl.$asyncValidators, function(validator, name) {
            var promise = validator(modelValue, viewValue);
            if (!isPromiseLike(promise)) {
              throw ngModelMinErr('nopromise',
                "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
            }
            setValidity(name, undefined);
            validatorPromises.push(promise.then(function() {
              setValidity(name, true);
            }, function() {
              allValid = false;
              setValidity(name, false);
            }));
          });
          if (!validatorPromises.length) {
            validationDone(true);
          } else {
            $q.all(validatorPromises).then(function() {
              validationDone(allValid);
            }, noop);
          }
        }

        function setValidity(name, isValid) {
          if (localValidationRunId === currentValidationRunId) {
            ctrl.$setValidity(name, isValid);
          }
        }

        function validationDone(allValid) {
          if (localValidationRunId === currentValidationRunId) {
            doneCallback(allValid);
          }
        }
      };
      this.$commitViewValue = function() {
        var viewValue = ctrl.$viewValue;
        $timeout.cancel(pendingDebounce);
        if (ctrl.$$lastCommittedViewValue === viewValue &amp;&amp; (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
          return;
        }
        ctrl.$$updateEmptyClasses(viewValue);
        ctrl.$$lastCommittedViewValue = viewValue;
        if (ctrl.$pristine) {
          this.$setDirty();
        }
        this.$$parseAndValidate();
      };
      this.$$parseAndValidate = function() {
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = viewValue;
        parserValid = isUndefined(modelValue) ? undefined : true;
        if (parserValid) {
          for (var i = 0; i &lt; ctrl.$parsers.length; i++) {
            modelValue = ctrl.$parsers[i](modelValue);
            if (isUndefined(modelValue)) {
              parserValid = false;
              break;
            }
          }
        }
        if (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {
          ctrl.$modelValue = ngModelGet($scope);
        }
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options &amp;&amp; ctrl.$options.allowInvalid;
        ctrl.$$rawModelValue = modelValue;
        if (allowInvalid) {
          ctrl.$modelValue = modelValue;
          writeToModelIfNeeded();
        }
        ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
          if (!allowInvalid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            writeToModelIfNeeded();
          }
        });

        function writeToModelIfNeeded() {
          if (ctrl.$modelValue !== prevModelValue) {
            ctrl.$$writeModelToScope();
          }
        }
      };
      this.$$writeModelToScope = function() {
        ngModelSet($scope, ctrl.$modelValue);
        forEach(ctrl.$viewChangeListeners, function(listener) {
          try {
            listener();
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      };
      this.$setViewValue = function(value, trigger) {
        ctrl.$viewValue = value;
        if (!ctrl.$options || ctrl.$options.updateOnDefault) {
          ctrl.$$debounceViewValueCommit(trigger);
        }
      };
      this.$$debounceViewValueCommit = function(trigger) {
        var debounceDelay = 0,
          options = ctrl.$options,
          debounce;
        if (options &amp;&amp; isDefined(options.debounce)) {
          debounce = options.debounce;
          if (isNumber(debounce)) {
            debounceDelay = debounce;
          } else if (isNumber(debounce[trigger])) {
            debounceDelay = debounce[trigger];
          } else if (isNumber(debounce['default'])) {
            debounceDelay = debounce['default'];
          }
        }
        $timeout.cancel(pendingDebounce);
        if (debounceDelay) {
          pendingDebounce = $timeout(function() {
            ctrl.$commitViewValue();
          }, debounceDelay);
        } else if ($rootScope.$$phase) {
          ctrl.$commitViewValue();
        } else {
          $scope.$apply(function() {
            ctrl.$commitViewValue();
          });
        }
      };
      $scope.$watch(function ngModelWatch() {
        var modelValue = ngModelGet($scope);
        if (modelValue !== ctrl.$modelValue &amp;&amp;
          (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)
        ) {
          ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
          parserValid = undefined;
          var formatters = ctrl.$formatters,
            idx = formatters.length;
          var viewValue = modelValue;
          while (idx--) {
            viewValue = formatters[idx](viewValue);
          }
          if (ctrl.$viewValue !== viewValue) {
            ctrl.$$updateEmptyClasses(viewValue);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
            ctrl.$render();
            ctrl.$$runValidators(modelValue, viewValue, noop);
          }
        }
        return modelValue;
      });
    }
  ];
  var ngModelDirective = ['$rootScope', function($rootScope) {
    return {
      restrict: 'A',
      require: ['ngModel', '^?form', '^?ngModelOptions'],
      controller: NgModelController,
      priority: 1,
      compile: function ngModelCompile(element) {
        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
        return {
          pre: function ngModelPreLink(scope, element, attr, ctrls) {
            var modelCtrl = ctrls[0],
              formCtrl = ctrls[1] || modelCtrl.$$parentForm;
            modelCtrl.$$setOptions(ctrls[2] &amp;&amp; ctrls[2].$options);
            formCtrl.$addControl(modelCtrl);
            attr.$observe('name', function(newValue) {
              if (modelCtrl.$name !== newValue) {
                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
              }
            });
            scope.$on('$destroy', function() {
              modelCtrl.$$parentForm.$removeControl(modelCtrl);
            });
          },
          post: function ngModelPostLink(scope, element, attr, ctrls) {
            var modelCtrl = ctrls[0];
            if (modelCtrl.$options &amp;&amp; modelCtrl.$options.updateOn) {
              element.on(modelCtrl.$options.updateOn, function(ev) {
                modelCtrl.$$debounceViewValueCommit(ev &amp;&amp; ev.type);
              });
            }
            element.on('blur', function() {
              if (modelCtrl.$touched) return;
              if ($rootScope.$$phase) {
                scope.$evalAsync(modelCtrl.$setTouched);
              } else {
                scope.$apply(modelCtrl.$setTouched);
              }
            });
          }
        };
      }
    };
  }];
  var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
  var ngModelOptionsDirective = function() {
    return {
      restrict: 'A',
      controller: ['$scope', '$attrs', function($scope, $attrs) {
        var that = this;
        this.$options = copy($scope.$eval($attrs.ngModelOptions));
        if (isDefined(this.$options.updateOn)) {
          this.$options.updateOnDefault = false;
          this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
            that.$options.updateOnDefault = true;
            return ' ';
          }));
        } else {
          this.$options.updateOnDefault = true;
        }
      }]
    };
  };

  function addSetValidityMethod(context) {
    var ctrl = context.ctrl,
      $element = context.$element,
      classCache = {},
      set = context.set,
      unset = context.unset,
      $animate = context.$animate;
    classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
    ctrl.$setValidity = setValidity;

    function setValidity(validationErrorKey, state, controller) {
      if (isUndefined(state)) {
        createAndSet('$pending', validationErrorKey, controller);
      } else {
        unsetAndCleanup('$pending', validationErrorKey, controller);
      }
      if (!isBoolean(state)) {
        unset(ctrl.$error, validationErrorKey, controller);
        unset(ctrl.$$success, validationErrorKey, controller);
      } else {
        if (state) {
          unset(ctrl.$error, validationErrorKey, controller);
          set(ctrl.$$success, validationErrorKey, controller);
        } else {
          set(ctrl.$error, validationErrorKey, controller);
          unset(ctrl.$$success, validationErrorKey, controller);
        }
      }
      if (ctrl.$pending) {
        cachedToggleClass(PENDING_CLASS, true);
        ctrl.$valid = ctrl.$invalid = undefined;
        toggleValidationCss('', null);
      } else {
        cachedToggleClass(PENDING_CLASS, false);
        ctrl.$valid = isObjectEmpty(ctrl.$error);
        ctrl.$invalid = !ctrl.$valid;
        toggleValidationCss('', ctrl.$valid);
      }
      var combinedState;
      if (ctrl.$pending &amp;&amp; ctrl.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (ctrl.$error[validationErrorKey]) {
        combinedState = false;
      } else if (ctrl.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }
      toggleValidationCss(validationErrorKey, combinedState);
      ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
    }

    function createAndSet(name, value, controller) {
      if (!ctrl[name]) {
        ctrl[name] = {};
      }
      set(ctrl[name], value, controller);
    }

    function unsetAndCleanup(name, value, controller) {
      if (ctrl[name]) {
        unset(ctrl[name], value, controller);
      }
      if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
      }
    }

    function cachedToggleClass(className, switchValue) {
      if (switchValue &amp;&amp; !classCache[className]) {
        $animate.addClass($element, className);
        classCache[className] = true;
      } else if (!switchValue &amp;&amp; classCache[className]) {
        $animate.removeClass($element, className);
        classCache[className] = false;
      }
    }

    function toggleValidationCss(validationErrorKey, isValid) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
      cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
    }
  }

  function isObjectEmpty(obj) {
    if (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
    }
    return true;
  }
  var ngNonBindableDirective = ngDirective({
    terminal: true,
    priority: 1000
  });
  var ngOptionsMinErr = minErr('ngOptions');
  var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
  var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
    function parseOptionsExpression(optionsExp, selectElement, scope) {
      var match = optionsExp.match(NG_OPTIONS_REGEXP);
      if (!(match)) {
        throw ngOptionsMinErr('iexp',
          "Expected expression in form of " +
          "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
          " but got '{0}'. Element: {1}",
          optionsExp, startingTag(selectElement));
      }
      var valueName = match[5] || match[7];
      var keyName = match[6];
      var selectAs = / as /.test(match[0]) &amp;&amp; match[1];
      var trackBy = match[9];
      var valueFn = $parse(match[2] ? match[1] : valueName);
      var selectAsFn = selectAs &amp;&amp; $parse(selectAs);
      var viewValueFn = selectAsFn || valueFn;
      var trackByFn = trackBy &amp;&amp; $parse(trackBy);
      var getTrackByValueFn = trackBy ?
        function(value, locals) {
          return trackByFn(scope, locals);
        } :
        function getHashOfValue(value) {
          return hashKey(value);
        };
      var getTrackByValue = function(value, key) {
        return getTrackByValueFn(value, getLocals(value, key));
      };
      var displayFn = $parse(match[2] || match[1]);
      var groupByFn = $parse(match[3] || '');
      var disableWhenFn = $parse(match[4] || '');
      var valuesFn = $parse(match[8]);
      var locals = {};
      var getLocals = keyName ? function(value, key) {
        locals[keyName] = key;
        locals[valueName] = value;
        return locals;
      } : function(value) {
        locals[valueName] = value;
        return locals;
      };

      function Option(selectValue, viewValue, label, group, disabled) {
        this.selectValue = selectValue;
        this.viewValue = viewValue;
        this.label = label;
        this.group = group;
        this.disabled = disabled;
      }

      function getOptionValuesKeys(optionValues) {
        var optionValuesKeys;
        if (!keyName &amp;&amp; isArrayLike(optionValues)) {
          optionValuesKeys = optionValues;
        } else {
          optionValuesKeys = [];
          for (var itemKey in optionValues) {
            if (optionValues.hasOwnProperty(itemKey) &amp;&amp; itemKey.charAt(0) !== '$') {
              optionValuesKeys.push(itemKey);
            }
          }
        }
        return optionValuesKeys;
      }
      return {
        trackBy: trackBy,
        getTrackByValue: getTrackByValue,
        getWatchables: $parse(valuesFn, function(optionValues) {
          var watchedArray = [];
          optionValues = optionValues || [];
          var optionValuesKeys = getOptionValuesKeys(optionValues);
          var optionValuesLength = optionValuesKeys.length;
          for (var index = 0; index &lt; optionValuesLength; index++) {
            var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
            var value = optionValues[key];
            var locals = getLocals(value, key);
            var selectValue = getTrackByValueFn(value, locals);
            watchedArray.push(selectValue);
            if (match[2] || match[1]) {
              var label = displayFn(scope, locals);
              watchedArray.push(label);
            }
            if (match[4]) {
              var disableWhen = disableWhenFn(scope, locals);
              watchedArray.push(disableWhen);
            }
          }
          return watchedArray;
        }),
        getOptions: function() {
          var optionItems = [];
          var selectValueMap = {};
          var optionValues = valuesFn(scope) || [];
          var optionValuesKeys = getOptionValuesKeys(optionValues);
          var optionValuesLength = optionValuesKeys.length;
          for (var index = 0; index &lt; optionValuesLength; index++) {
            var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
            var value = optionValues[key];
            var locals = getLocals(value, key);
            var viewValue = viewValueFn(scope, locals);
            var selectValue = getTrackByValueFn(viewValue, locals);
            var label = displayFn(scope, locals);
            var group = groupByFn(scope, locals);
            var disabled = disableWhenFn(scope, locals);
            var optionItem = new Option(selectValue, viewValue, label, group, disabled);
            optionItems.push(optionItem);
            selectValueMap[selectValue] = optionItem;
          }
          return {
            items: optionItems,
            selectValueMap: selectValueMap,
            getOptionFromViewValue: function(value) {
              return selectValueMap[getTrackByValue(value)];
            },
            getViewValueFromOption: function(option) {
              return trackBy ? angular.copy(option.viewValue) : option.viewValue;
            }
          };
        }
      };
    }
    var optionTemplate = document.createElement('option'),
      optGroupTemplate = document.createElement('optgroup');

    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
      var selectCtrl = ctrls[0];
      var ngModelCtrl = ctrls[1];
      var multiple = attr.multiple;
      var emptyOption;
      for (var i = 0, children = selectElement.children(), ii = children.length; i &lt; ii; i++) {
        if (children[i].value === '') {
          emptyOption = children.eq(i);
          break;
        }
      }
      var providedEmptyOption = !!emptyOption;
      var unknownOption = jqLite(optionTemplate.cloneNode(false));
      unknownOption.val('?');
      var options;
      var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
      var renderEmptyOption = function() {
        if (!providedEmptyOption) {
          selectElement.prepend(emptyOption);
        }
        selectElement.val('');
        emptyOption.prop('selected', true);
        emptyOption.attr('selected', true);
      };
      var removeEmptyOption = function() {
        if (!providedEmptyOption) {
          emptyOption.remove();
        }
      };
      var renderUnknownOption = function() {
        selectElement.prepend(unknownOption);
        selectElement.val('?');
        unknownOption.prop('selected', true);
        unknownOption.attr('selected', true);
      };
      var removeUnknownOption = function() {
        unknownOption.remove();
      };
      if (!multiple) {
        selectCtrl.writeValue = function writeNgOptionsValue(value) {
          var option = options.getOptionFromViewValue(value);
          if (option &amp;&amp; !option.disabled) {
            if (selectElement[0].value !== option.selectValue) {
              removeUnknownOption();
              removeEmptyOption();
              selectElement[0].value = option.selectValue;
              option.element.selected = true;
            }
            option.element.setAttribute('selected', 'selected');
          } else {
            if (value === null || providedEmptyOption) {
              removeUnknownOption();
              renderEmptyOption();
            } else {
              removeEmptyOption();
              renderUnknownOption();
            }
          }
        };
        selectCtrl.readValue = function readNgOptionsValue() {
          var selectedOption = options.selectValueMap[selectElement.val()];
          if (selectedOption &amp;&amp; !selectedOption.disabled) {
            removeEmptyOption();
            removeUnknownOption();
            return options.getViewValueFromOption(selectedOption);
          }
          return null;
        };
        if (ngOptions.trackBy) {
          scope.$watch(
            function() {
              return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            },
            function() {
              ngModelCtrl.$render();
            }
          );
        }
      } else {
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
        selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
          options.items.forEach(function(option) {
            option.element.selected = false;
          });
          if (value) {
            value.forEach(function(item) {
              var option = options.getOptionFromViewValue(item);
              if (option &amp;&amp; !option.disabled) option.element.selected = true;
            });
          }
        };
        selectCtrl.readValue = function readNgOptionsMultiple() {
          var selectedValues = selectElement.val() || [],
            selections = [];
          forEach(selectedValues, function(value) {
            var option = options.selectValueMap[value];
            if (option &amp;&amp; !option.disabled) selections.push(options.getViewValueFromOption(option));
          });
          return selections;
        };
        if (ngOptions.trackBy) {
          scope.$watchCollection(function() {
            if (isArray(ngModelCtrl.$viewValue)) {
              return ngModelCtrl.$viewValue.map(function(value) {
                return ngOptions.getTrackByValue(value);
              });
            }
          }, function() {
            ngModelCtrl.$render();
          });
        }
      }
      if (providedEmptyOption) {
        emptyOption.remove();
        $compile(emptyOption)(scope);
        emptyOption.removeClass('ng-scope');
      } else {
        emptyOption = jqLite(optionTemplate.cloneNode(false));
      }
      updateOptions();
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);

      function updateOptionElement(option, element) {
        option.element = element;
        element.disabled = option.disabled;
        if (option.label !== element.label) {
          element.label = option.label;
          element.textContent = option.label;
        }
        if (option.value !== element.value) element.value = option.selectValue;
      }

      function addOrReuseElement(parent, current, type, templateElement) {
        var element;
        if (current &amp;&amp; lowercase(current.nodeName) === type) {
          element = current;
        } else {
          element = templateElement.cloneNode(false);
          if (!current) {
            parent.appendChild(element);
          } else {
            parent.insertBefore(element, current);
          }
        }
        return element;
      }

      function removeExcessElements(current) {
        var next;
        while (current) {
          next = current.nextSibling;
          jqLiteRemove(current);
          current = next;
        }
      }

      function skipEmptyAndUnknownOptions(current) {
        var emptyOption_ = emptyOption &amp;&amp; emptyOption[0];
        var unknownOption_ = unknownOption &amp;&amp; unknownOption[0];
        if (emptyOption_ || unknownOption_) {
          while (current &amp;&amp;
            (current === emptyOption_ ||
              current === unknownOption_ ||
              current.nodeType === NODE_TYPE_COMMENT ||
              (nodeName_(current) === 'option' &amp;&amp; current.value === ''))) {
            current = current.nextSibling;
          }
        }
        return current;
      }

      function updateOptions() {
        var previousValue = options &amp;&amp; selectCtrl.readValue();
        options = ngOptions.getOptions();
        var groupMap = {};
        var currentElement = selectElement[0].firstChild;
        if (providedEmptyOption) {
          selectElement.prepend(emptyOption);
        }
        currentElement = skipEmptyAndUnknownOptions(currentElement);
        options.items.forEach(function updateOption(option) {
          var group;
          var groupElement;
          var optionElement;
          if (isDefined(option.group)) {
            group = groupMap[option.group];
            if (!group) {
              groupElement = addOrReuseElement(selectElement[0],
                currentElement,
                'optgroup',
                optGroupTemplate);
              currentElement = groupElement.nextSibling;
              groupElement.label = option.group;
              group = groupMap[option.group] = {
                groupElement: groupElement,
                currentOptionElement: groupElement.firstChild
              };
            }
            optionElement = addOrReuseElement(group.groupElement,
              group.currentOptionElement,
              'option',
              optionTemplate);
            updateOptionElement(option, optionElement);
            group.currentOptionElement = optionElement.nextSibling;
          } else {
            optionElement = addOrReuseElement(selectElement[0],
              currentElement,
              'option',
              optionTemplate);
            updateOptionElement(option, optionElement);
            currentElement = optionElement.nextSibling;
          }
        });
        Object.keys(groupMap).forEach(function(key) {
          removeExcessElements(groupMap[key].currentOptionElement);
        });
        removeExcessElements(currentElement);
        ngModelCtrl.$render();
        if (!ngModelCtrl.$isEmpty(previousValue)) {
          var nextValue = selectCtrl.readValue();
          var isNotPrimitive = ngOptions.trackBy || multiple;
          if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          }
        }
      }
    }
    return {
      restrict: 'A',
      terminal: true,
      require: ['select', 'ngModel'],
      link: {
        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
          ctrls[0].registerOption = noop;
        },
        post: ngOptionsPostLink
      }
    };
  }];
  var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
    var BRACE = /{}/g,
      IS_WHEN = /^when(Minus)?(.+)$/;
    return {
      link: function(scope, element, attr) {
        var numberExp = attr.count,
          whenExp = attr.$attr.when &amp;&amp; element.attr(attr.$attr.when),
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || {},
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
          watchRemover = angular.noop,
          lastCount;
        forEach(attr, function(expression, attributeName) {
          var tmpMatch = IS_WHEN.exec(attributeName);
          if (tmpMatch) {
            var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
            whens[whenKey] = element.attr(attr.$attr[attributeName]);
          }
        });
        forEach(whens, function(expression, key) {
          whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
        });
        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
          var count = parseFloat(newVal);
          var countIsNaN = isNaN(count);
          if (!countIsNaN &amp;&amp; !(count in whens)) {
            count = $locale.pluralCat(count - offset);
          }
          if ((count !== lastCount) &amp;&amp; !(countIsNaN &amp;&amp; isNumber(lastCount) &amp;&amp; isNaN(lastCount))) {
            watchRemover();
            var whenExpFn = whensExpFns[count];
            if (isUndefined(whenExpFn)) {
              if (newVal != null) {
                $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
              }
              watchRemover = noop;
              updateElementText();
            } else {
              watchRemover = scope.$watch(whenExpFn, updateElementText);
            }
            lastCount = count;
          }
        });

        function updateElementText(newText) {
          element.text(newText || '');
        }
      }
    };
  }];
  var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
    var NG_REMOVED = '$$NG_REMOVED';
    var ngRepeatMinErr = minErr('ngRepeat');
    var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
      scope[valueIdentifier] = value;
      if (keyIdentifier) scope[keyIdentifier] = key;
      scope.$index = index;
      scope.$first = (index === 0);
      scope.$last = (index === (arrayLength - 1));
      scope.$middle = !(scope.$first || scope.$last);
      scope.$odd = !(scope.$even = (index &amp; 1) === 0);
    };
    var getBlockStart = function(block) {
      return block.clone[0];
    };
    var getBlockEnd = function(block) {
      return block.clone[block.clone.length - 1];
    };
    return {
      restrict: 'A',
      multiElement: true,
      transclude: 'element',
      priority: 1000,
      terminal: true,
      $$tlb: true,
      compile: function ngRepeatCompile($element, $attr) {
        var expression = $attr.ngRepeat;
        var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }
        var lhs = match[1];
        var rhs = match[2];
        var aliasAs = match[3];
        var trackByExp = match[4];
        match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
            lhs);
        }
        var valueIdentifier = match[3] || match[1];
        var keyIdentifier = match[2];
        if (aliasAs &amp;&amp; (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
            /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
          throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
            aliasAs);
        }
        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
        var hashFnLocals = {
          $id: hashKey
        };
        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }
        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
          if (trackByExpGetter) {
            trackByIdExpFn = function(key, value, index) {
              if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
              hashFnLocals[valueIdentifier] = value;
              hashFnLocals.$index = index;
              return trackByExpGetter($scope, hashFnLocals);
            };
          }
          var lastBlockMap = createMap();
          $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
            var index, length,
              previousNode = $element[0],
              nextNode,
              nextBlockMap = createMap(),
              collectionLength,
              key, value,
              trackById,
              trackByIdFn,
              collectionKeys,
              block,
              nextBlockOrder,
              elementsToRemove;
            if (aliasAs) {
              $scope[aliasAs] = collection;
            }
            if (isArrayLike(collection)) {
              collectionKeys = collection;
              trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
            } else {
              trackByIdFn = trackByIdExpFn || trackByIdObjFn;
              collectionKeys = [];
              for (var itemKey in collection) {
                if (hasOwnProperty.call(collection, itemKey) &amp;&amp; itemKey.charAt(0) !== '$') {
                  collectionKeys.push(itemKey);
                }
              }
            }
            collectionLength = collectionKeys.length;
            nextBlockOrder = new Array(collectionLength);
            for (index = 0; index &lt; collectionLength; index++) {
              key = (collection === collectionKeys) ? index : collectionKeys[index];
              value = collection[key];
              trackById = trackByIdFn(key, value, index);
              if (lastBlockMap[trackById]) {
                block = lastBlockMap[trackById];
                delete lastBlockMap[trackById];
                nextBlockMap[trackById] = block;
                nextBlockOrder[index] = block;
              } else if (nextBlockMap[trackById]) {
                forEach(nextBlockOrder, function(block) {
                  if (block &amp;&amp; block.scope) lastBlockMap[block.id] = block;
                });
                throw ngRepeatMinErr('dupes',
                  "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}",
                  expression, trackById, value);
              } else {
                nextBlockOrder[index] = {
                  id: trackById,
                  scope: undefined,
                  clone: undefined
                };
                nextBlockMap[trackById] = true;
              }
            }
            for (var blockKey in lastBlockMap) {
              block = lastBlockMap[blockKey];
              elementsToRemove = getBlockNodes(block.clone);
              $animate.leave(elementsToRemove);
              if (elementsToRemove[0].parentNode) {
                for (index = 0, length = elementsToRemove.length; index &lt; length; index++) {
                  elementsToRemove[index][NG_REMOVED] = true;
                }
              }
              block.scope.$destroy();
            }
            for (index = 0; index &lt; collectionLength; index++) {
              key = (collection === collectionKeys) ? index : collectionKeys[index];
              value = collection[key];
              block = nextBlockOrder[index];
              if (block.scope) {
                nextNode = previousNode;
                do {
                  nextNode = nextNode.nextSibling;
                } while (nextNode &amp;&amp; nextNode[NG_REMOVED]);
                if (getBlockStart(block) != nextNode) {
                  $animate.move(getBlockNodes(block.clone), null, previousNode);
                }
                previousNode = getBlockEnd(block);
                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
              } else {
                $transclude(function ngRepeatTransclude(clone, scope) {
                  block.scope = scope;
                  var endNode = ngRepeatEndComment.cloneNode(false);
                  clone[clone.length++] = endNode;
                  $animate.enter(clone, null, previousNode);
                  previousNode = endNode;
                  block.clone = clone;
                  nextBlockMap[block.id] = block;
                  updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                });
              }
            }
            lastBlockMap = nextBlockMap;
          });
        };
      }
    };
  }];
  var NG_HIDE_CLASS = 'ng-hide';
  var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
  var ngShowDirective = ['$animate', function($animate) {
    return {
      restrict: 'A',
      multiElement: true,
      link: function(scope, element, attr) {
        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
          $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
          });
        });
      }
    };
  }];
  var ngHideDirective = ['$animate', function($animate) {
    return {
      restrict: 'A',
      multiElement: true,
      link: function(scope, element, attr) {
        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
          $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {
            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
          });
        });
      }
    };
  }];
  var ngStyleDirective = ngDirective(function(scope, element, attr) {
    scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
      if (oldStyles &amp;&amp; (newStyles !== oldStyles)) {
        forEach(oldStyles, function(val, style) {
          element.css(style, '');
        });
      }
      if (newStyles) element.css(newStyles);
    }, true);
  });
  var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
    return {
      require: 'ngSwitch',
      controller: ['$scope', function ngSwitchController() {
        this.cases = {};
      }],
      link: function(scope, element, attr, ngSwitchController) {
        var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes = [],
          selectedElements = [],
          previousLeaveAnimations = [],
          selectedScopes = [];
        var spliceFactory = function(array, index) {
          return function() {
            array.splice(index, 1);
          };
        };
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          var i, ii;
          for (i = 0, ii = previousLeaveAnimations.length; i &lt; ii; ++i) {
            $animate.cancel(previousLeaveAnimations[i]);
          }
          previousLeaveAnimations.length = 0;
          for (i = 0, ii = selectedScopes.length; i &lt; ii; ++i) {
            var selected = getBlockNodes(selectedElements[i].clone);
            selectedScopes[i].$destroy();
            var promise = previousLeaveAnimations[i] = $animate.leave(selected);
            promise.then(spliceFactory(previousLeaveAnimations, i));
          }
          selectedElements.length = 0;
          selectedScopes.length = 0;
          if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
            forEach(selectedTranscludes, function(selectedTransclude) {
              selectedTransclude.transclude(function(caseElement, selectedScope) {
                selectedScopes.push(selectedScope);
                var anchor = selectedTransclude.element;
                caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                var block = {
                  clone: caseElement
                };
                selectedElements.push(block);
                $animate.enter(caseElement, anchor.parent(), anchor);
              });
            });
          }
        });
      }
    };
  }];
  var ngSwitchWhenDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function(scope, element, attrs, ctrl, $transclude) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngSwitchDefaultDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function(scope, element, attr, ctrl, $transclude) {
      ctrl.cases['?'] = (ctrl.cases['?'] || []);
      ctrl.cases['?'].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngTranscludeMinErr = minErr('ngTransclude');
  var ngTranscludeDirective = ngDirective({
    restrict: 'EAC',
    link: function($scope, $element, $attrs, controller, $transclude) {
      if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
        $attrs.ngTransclude = '';
      }

      function ngTranscludeCloneAttachFn(clone) {
        if (clone.length) {
          $element.empty();
          $element.append(clone);
        }
      }
      if (!$transclude) {
        throw ngTranscludeMinErr('orphan',
          'Illegal use of ngTransclude directive in the template! ' +
          'No parent directive that requires a transclusion found. ' +
          'Element: {0}',
          startingTag($element));
      }
      var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
      $transclude(ngTranscludeCloneAttachFn, null, slotName);
    }
  });
  var scriptDirective = ['$templateCache', function($templateCache) {
    return {
      restrict: 'E',
      terminal: true,
      compile: function(element, attr) {
        if (attr.type == 'text/ng-template') {
          var templateUrl = attr.id,
            text = element[0].text;
          $templateCache.put(templateUrl, text);
        }
      }
    };
  }];
  var noopNgModelController = {
    $setViewValue: noop,
    $render: noop
  };

  function chromeHack(optionElement) {
    if (optionElement[0].hasAttribute('selected')) {
      optionElement[0].selected = true;
    }
  }
  var SelectController = ['$element', '$scope', function($element, $scope) {
    var self = this,
      optionsMap = new HashMap();
    self.ngModelCtrl = noopNgModelController;
    self.unknownOption = jqLite(document.createElement('option'));
    self.renderUnknownOption = function(val) {
      var unknownVal = '? ' + hashKey(val) + ' ?';
      self.unknownOption.val(unknownVal);
      $element.prepend(self.unknownOption);
      $element.val(unknownVal);
    };
    $scope.$on('$destroy', function() {
      self.renderUnknownOption = noop;
    });
    self.removeUnknownOption = function() {
      if (self.unknownOption.parent()) self.unknownOption.remove();
    };
    self.readValue = function readSingleValue() {
      self.removeUnknownOption();
      return $element.val();
    };
    self.writeValue = function writeSingleValue(value) {
      if (self.hasOption(value)) {
        self.removeUnknownOption();
        $element.val(value);
        if (value === '') self.emptyOption.prop('selected', true);
      } else {
        if (value == null &amp;&amp; self.emptyOption) {
          self.removeUnknownOption();
          $element.val('');
        } else {
          self.renderUnknownOption(value);
        }
      }
    };
    self.addOption = function(value, element) {
      if (element[0].nodeType === NODE_TYPE_COMMENT) return;
      assertNotHasOwnProperty(value, '"option value"');
      if (value === '') {
        self.emptyOption = element;
      }
      var count = optionsMap.get(value) || 0;
      optionsMap.put(value, count + 1);
      self.ngModelCtrl.$render();
      chromeHack(element);
    };
    self.removeOption = function(value) {
      var count = optionsMap.get(value);
      if (count) {
        if (count === 1) {
          optionsMap.remove(value);
          if (value === '') {
            self.emptyOption = undefined;
          }
        } else {
          optionsMap.put(value, count - 1);
        }
      }
    };
    self.hasOption = function(value) {
      return !!optionsMap.get(value);
    };
    self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
      if (interpolateValueFn) {
        var oldVal;
        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
          if (isDefined(oldVal)) {
            self.removeOption(oldVal);
          }
          oldVal = newVal;
          self.addOption(newVal, optionElement);
        });
      } else if (interpolateTextFn) {
        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
          optionAttrs.$set('value', newVal);
          if (oldVal !== newVal) {
            self.removeOption(oldVal);
          }
          self.addOption(newVal, optionElement);
        });
      } else {
        self.addOption(optionAttrs.value, optionElement);
      }
      optionElement.on('$destroy', function() {
        self.removeOption(optionAttrs.value);
        self.ngModelCtrl.$render();
      });
    };
  }];
  var selectDirective = function() {
    return {
      restrict: 'E',
      require: ['select', '?ngModel'],
      controller: SelectController,
      priority: 1,
      link: {
        pre: selectPreLink,
        post: selectPostLink
      }
    };

    function selectPreLink(scope, element, attr, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      selectCtrl.ngModelCtrl = ngModelCtrl;
      element.on('change', function() {
        scope.$apply(function() {
          ngModelCtrl.$setViewValue(selectCtrl.readValue());
        });
      });
      if (attr.multiple) {
        selectCtrl.readValue = function readMultipleValue() {
          var array = [];
          forEach(element.find('option'), function(option) {
            if (option.selected) {
              array.push(option.value);
            }
          });
          return array;
        };
        selectCtrl.writeValue = function writeMultipleValue(value) {
          var items = new HashMap(value);
          forEach(element.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };
        var lastView, lastViewRef = NaN;
        scope.$watch(function selectMultipleWatch() {
          if (lastViewRef === ngModelCtrl.$viewValue &amp;&amp; !equals(lastView, ngModelCtrl.$viewValue)) {
            lastView = shallowCopy(ngModelCtrl.$viewValue);
            ngModelCtrl.$render();
          }
          lastViewRef = ngModelCtrl.$viewValue;
        });
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      }
    }

    function selectPostLink(scope, element, attrs, ctrls) {
      var ngModelCtrl = ctrls[1];
      if (!ngModelCtrl) return;
      var selectCtrl = ctrls[0];
      ngModelCtrl.$render = function() {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      };
    }
  };
  var optionDirective = ['$interpolate', function($interpolate) {
    return {
      restrict: 'E',
      priority: 100,
      compile: function(element, attr) {
        if (isDefined(attr.value)) {
          var interpolateValueFn = $interpolate(attr.value, true);
        } else {
          var interpolateTextFn = $interpolate(element.text(), true);
          if (!interpolateTextFn) {
            attr.$set('value', element.text());
          }
        }
        return function(scope, element, attr) {
          var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
            parent.parent().data(selectCtrlName);
          if (selectCtrl) {
            selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
          }
        };
      }
    };
  }];
  var styleDirective = valueFn({
    restrict: 'E',
    terminal: false
  });
  var requiredDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        attr.required = true;
        ctrl.$validators.required = function(modelValue, viewValue) {
          return !attr.required || !ctrl.$isEmpty(viewValue);
        };
        attr.$observe('required', function() {
          ctrl.$validate();
        });
      }
    };
  };
  var patternDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var regexp, patternExp = attr.ngPattern || attr.pattern;
        attr.$observe('pattern', function(regex) {
          if (isString(regex) &amp;&amp; regex.length &gt; 0) {
            regex = new RegExp('^' + regex + '$');
          }
          if (regex &amp;&amp; !regex.test) {
            throw minErr('ngPattern')('noregexp',
              'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp,
              regex, startingTag(elm));
          }
          regexp = regex || undefined;
          ctrl.$validate();
        });
        ctrl.$validators.pattern = function(modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
        };
      }
    };
  };
  var maxlengthDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var maxlength = -1;
        attr.$observe('maxlength', function(value) {
          var intVal = toInt(value);
          maxlength = isNaN(intVal) ? -1 : intVal;
          ctrl.$validate();
        });
        ctrl.$validators.maxlength = function(modelValue, viewValue) {
          return (maxlength &lt; 0) || ctrl.$isEmpty(viewValue) || (viewValue.length &lt;= maxlength);
        };
      }
    };
  };
  var minlengthDirective = function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        var minlength = 0;
        attr.$observe('minlength', function(value) {
          minlength = toInt(value) || 0;
          ctrl.$validate();
        });
        ctrl.$validators.minlength = function(modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || viewValue.length &gt;= minlength;
        };
      }
    };
  };
  if (window.angular.bootstrap) {
    if (window.console) {
      console.log('WARNING: Tried to load angular more than once.');
    }
    return;
  }
  bindJQuery();
  publishExternalAPI(angular);
  angular.module("ngLocale", [], ["$provide", function($provide) {
    var PLURAL_CATEGORY = {
      ZERO: "zero",
      ONE: "one",
      TWO: "two",
      FEW: "few",
      MANY: "many",
      OTHER: "other"
    };

    function getDecimals(n) {
      n = n + '';
      var i = n.indexOf('.');
      return (i == -1) ? 0 : n.length - i - 1;
    }

    function getVF(n, opt_precision) {
      var v = opt_precision;
      if (undefined === v) {
        v = Math.min(getDecimals(n), 3);
      }
      var base = Math.pow(10, v);
      var f = ((n * base) | 0) % base;
      return {
        v: v,
        f: f
      };
    }
    $provide.value("$locale", {
      "DATETIME_FORMATS": {
        "AMPMS": [
          "AM",
          "PM"
        ],
        "DAY": [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ],
        "ERANAMES": [
          "Before Christ",
          "Anno Domini"
        ],
        "ERAS": [
          "BC",
          "AD"
        ],
        "FIRSTDAYOFWEEK": 6,
        "MONTH": [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        "SHORTDAY": [
          "Sun",
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat"
        ],
        "SHORTMONTH": [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        "STANDALONEMONTH": [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ],
        "WEEKENDRANGE": [
          5,
          6
        ],
        "fullDate": "EEEE, MMMM d, y",
        "longDate": "MMMM d, y",
        "medium": "MMM d, y h:mm:ss a",
        "mediumDate": "MMM d, y",
        "mediumTime": "h:mm:ss a",
        "short": "M/d/yy h:mm a",
        "shortDate": "M/d/yy",
        "shortTime": "h:mm a"
      },
      "NUMBER_FORMATS": {
        "CURRENCY_SYM": "$",
        "DECIMAL_SEP": ".",
        "GROUP_SEP": ",",
        "PATTERNS": [{
            "gSize": 3,
            "lgSize": 3,
            "maxFrac": 3,
            "minFrac": 0,
            "minInt": 1,
            "negPre": "-",
            "negSuf": "",
            "posPre": "",
            "posSuf": ""
          },
          {
            "gSize": 3,
            "lgSize": 3,
            "maxFrac": 2,
            "minFrac": 2,
            "minInt": 1,
            "negPre": "-\u00a4",
            "negSuf": "",
            "posPre": "\u00a4",
            "posSuf": ""
          }
        ]
      },
      "id": "en-us",
      "localeID": "en_US",
      "pluralCat": function(n, opt_precision) {
        var i = n | 0;
        var vf = getVF(n, opt_precision);
        if (i == 1 &amp;&amp; vf.v == 0) {
          return PLURAL_CATEGORY.ONE;
        }
        return PLURAL_CATEGORY.OTHER;
      }
    });
  }]);
  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });
})(window, document);
!window.angular.$$csp().noInlineStyle &amp;&amp; window.angular.element(document.head).prepend('&lt;style type="text/css"&gt;@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}&lt;/style&gt;');;
/*! RESOURCE: /scripts/angular_1.5.3/angular-sanitize.js */
(function(window, angular, undefined) {
  'use strict';
  var $sanitizeMinErr = angular.$$minErr('$sanitize');

  function $SanitizeProvider() {
    var svgEnabled = false;
    this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
      if (svgEnabled) {
        angular.extend(validElements, svgElements);
      }
      return function(html) {
        var buf = [];
        htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
          return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
        }));
        return buf.join('');
      };
    }];
    this.enableSvg = function(enableSvg) {
      if (angular.isDefined(enableSvg)) {
        svgEnabled = enableSvg;
        return this;
      } else {
        return svgEnabled;
      }
    };
  }

  function sanitizeText(chars) {
    var buf = [];
    var writer = htmlSanitizeWriter(buf, angular.noop);
    writer.chars(chars);
    return buf.join('');
  }
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
    NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  var voidElements = toMap("area,br,col,hr,img,wbr");
  var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = toMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
      optionalEndTagInlineElements,
      optionalEndTagBlockElements);
  var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," +
    "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
    "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
  var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
    "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
    "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
  var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
    "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
    "radialGradient,rect,stop,svg,switch,text,title,tspan");
  var blockedElements = toMap("script,style");
  var validElements = angular.extend({},
    voidElements,
    blockElements,
    inlineElements,
    optionalEndTagElements);
  var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
  var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
    'valign,value,vspace,width');
  var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
  var validAttrs = angular.extend({},
    uriAttrs,
    svgAttrs,
    htmlAttrs);

  function toMap(str, lowercaseKeys) {
    var obj = {},
      items = str.split(','),
      i;
    for (i = 0; i &lt; items.length; i++) {
      obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
    }
    return obj;
  }
  var inertBodyElement;
  (function(window) {
    var doc;
    if (window.document &amp;&amp; window.document.implementation) {
      doc = window.document.implementation.createHTMLDocument("inert");
    } else {
      throw $sanitizeMinErr('noinert', "Can't create an inert html document");
    }
    var docElement = doc.documentElement || doc.getDocumentElement();
    var bodyElements = docElement.getElementsByTagName('body');
    if (bodyElements.length === 1) {
      inertBodyElement = bodyElements[0];
    } else {
      var html = doc.createElement('html');
      inertBodyElement = doc.createElement('body');
      html.appendChild(inertBodyElement);
      doc.appendChild(html);
    }
  })(window);

  function htmlParser(html, handler) {
    if (html === null || html === undefined) {
      html = '';
    } else if (typeof html !== 'string') {
      html = '' + html;
    }
    inertBodyElement.innerHTML = html;
    var mXSSAttempts = 5;
    do {
      if (mXSSAttempts === 0) {
        throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      if (document.documentMode &lt;= 11) {
        stripCustomNsAttrs(inertBodyElement);
      }
      html = inertBodyElement.innerHTML;
      inertBodyElement.innerHTML = html;
    } while (html !== inertBodyElement.innerHTML);
    var node = inertBodyElement.firstChild;
    while (node) {
      switch (node.nodeType) {
        case 1:
          handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
          break;
        case 3:
          handler.chars(node.textContent);
          break;
      }
      var nextNode;
      if (!(nextNode = node.firstChild)) {
        if (node.nodeType == 1) {
          handler.end(node.nodeName.toLowerCase());
        }
        nextNode = node.nextSibling;
        if (!nextNode) {
          while (nextNode == null) {
            node = node.parentNode;
            if (node === inertBodyElement) break;
            nextNode = node.nextSibling;
            if (node.nodeType == 1) {
              handler.end(node.nodeName.toLowerCase());
            }
          }
        }
      }
      node = nextNode;
    }
    while (node = inertBodyElement.firstChild) {
      inertBodyElement.removeChild(node);
    }
  }

  function attrToMap(attrs) {
    var map = {};
    for (var i = 0, ii = attrs.length; i &lt; ii; i++) {
      var attr = attrs[i];
      map[attr.name] = attr.value;
    }
    return map;
  }

  function encodeEntities(value) {
    return value.
    replace(/&amp;/g, '&amp;amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&amp;#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&amp;#' + value.charCodeAt(0) + ';';
    }).
    replace(/&lt;/g, '&amp;lt;').
    replace(/&gt;/g, '&amp;gt;');
  }

  function htmlSanitizeWriter(buf, uriValidator) {
    var ignoreCurrentElement = false;
    var out = angular.bind(buf, buf.push);
    return {
      start: function(tag, attrs) {
        tag = angular.lowercase(tag);
        if (!ignoreCurrentElement &amp;&amp; blockedElements[tag]) {
          ignoreCurrentElement = tag;
        }
        if (!ignoreCurrentElement &amp;&amp; validElements[tag] === true) {
          out('&lt;');
          out(tag);
          angular.forEach(attrs, function(value, key) {
            var lkey = angular.lowercase(key);
            var isImage = (tag === 'img' &amp;&amp; lkey === 'src') || (lkey === 'background');
            if (validAttrs[lkey] === true &amp;&amp;
              (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
              out(' ');
              out(key);
              out('="');
              out(encodeEntities(value));
              out('"');
            }
          });
          out('&gt;');
        }
      },
      end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignoreCurrentElement &amp;&amp; validElements[tag] === true &amp;&amp; voidElements[tag] !== true) {
          out('&lt;/');
          out(tag);
          out('&gt;');
        }
        if (tag == ignoreCurrentElement) {
          ignoreCurrentElement = false;
        }
      },
      chars: function(chars) {
        if (!ignoreCurrentElement) {
          out(encodeEntities(chars));
        }
      }
    };
  }

  function stripCustomNsAttrs(node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      var attrs = node.attributes;
      for (var i = 0, l = attrs.length; i &lt; l; i++) {
        var attrNode = attrs[i];
        var attrName = attrNode.name.toLowerCase();
        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
          node.removeAttributeNode(attrNode);
          i--;
          l--;
        }
      }
    }
    var nextNode = node.firstChild;
    if (nextNode) {
      stripCustomNsAttrs(nextNode);
    }
    nextNode = node.nextSibling;
    if (nextNode) {
      stripCustomNsAttrs(nextNode);
    }
  }
  angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
  angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
    var LINKY_URL_REGEXP =
      /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}&lt;&gt;"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;
    var linkyMinErr = angular.$$minErr('linky');
    var isString = angular.isString;
    return function(text, target, attributes) {
      if (text == null || text === '') return text;
      if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
      var match;
      var raw = text;
      var html = [];
      var url;
      var i;
      while ((match = raw.match(LINKY_URL_REGEXP))) {
        url = match[0];
        if (!match[2] &amp;&amp; !match[4]) {
          url = (match[3] ? 'http://' : 'mailto:') + url;
        }
        i = match.index;
        addText(raw.substr(0, i));
        addLink(url, match[0].replace(MAILTO_REGEXP, ''));
        raw = raw.substring(i + match[0].length);
      }
      addText(raw);
      return $sanitize(html.join(''));

      function addText(text) {
        if (!text) {
          return;
        }
        html.push(sanitizeText(text));
      }

      function addLink(url, text) {
        var key;
        html.push('&lt;a ');
        if (angular.isFunction(attributes)) {
          attributes = attributes(url);
        }
        if (angular.isObject(attributes)) {
          for (key in attributes) {
            html.push(key + '="' + attributes[key] + '" ');
          }
        } else {
          attributes = {};
        }
        if (angular.isDefined(target) &amp;&amp; !('target' in attributes)) {
          html.push('target="',
            target,
            '" ');
        }
        html.push('href="',
          url.replace(/"/g, '&amp;quot;'),
          '"&gt;');
        addText(text);
        html.push('&lt;/a&gt;');
      }
    };
  }]);
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-animate.js */
(function(window, angular, undefined) {
  'use strict';
  var noop = angular.noop;
  var copy = angular.copy;
  var extend = angular.extend;
  var jqLite = angular.element;
  var forEach = angular.forEach;
  var isArray = angular.isArray;
  var isString = angular.isString;
  var isObject = angular.isObject;
  var isUndefined = angular.isUndefined;
  var isDefined = angular.isDefined;
  var isFunction = angular.isFunction;
  var isElement = angular.isElement;
  var ELEMENT_NODE = 1;
  var COMMENT_NODE = 8;
  var ADD_CLASS_SUFFIX = '-add';
  var REMOVE_CLASS_SUFFIX = '-remove';
  var EVENT_CLASS_PREFIX = 'ng-';
  var ACTIVE_CLASS_SUFFIX = '-active';
  var PREPARE_CLASS_SUFFIX = '-prepare';
  var NG_ANIMATE_CLASSNAME = 'ng-animate';
  var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
  var CSS_PREFIX = '',
    TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
  if (isUndefined(window.ontransitionend) &amp;&amp; isDefined(window.onwebkittransitionend)) {
    CSS_PREFIX = '-webkit-';
    TRANSITION_PROP = 'WebkitTransition';
    TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
  } else {
    TRANSITION_PROP = 'transition';
    TRANSITIONEND_EVENT = 'transitionend';
  }
  if (isUndefined(window.onanimationend) &amp;&amp; isDefined(window.onwebkitanimationend)) {
    CSS_PREFIX = '-webkit-';
    ANIMATION_PROP = 'WebkitAnimation';
    ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
  } else {
    ANIMATION_PROP = 'animation';
    ANIMATIONEND_EVENT = 'animationend';
  }
  var DURATION_KEY = 'Duration';
  var PROPERTY_KEY = 'Property';
  var DELAY_KEY = 'Delay';
  var TIMING_KEY = 'TimingFunction';
  var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
  var ANIMATION_PLAYSTATE_KEY = 'PlayState';
  var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
  var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
  var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
  var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
  var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
  var isPromiseLike = function(p) {
    return p &amp;&amp; p.then ? true : false;
  };
  var ngMinErr = angular.$$minErr('ng');

  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
    }
    return arg;
  }

  function mergeClasses(a, b) {
    if (!a &amp;&amp; !b) return '';
    if (!a) return b;
    if (!b) return a;
    if (isArray(a)) a = a.join(' ');
    if (isArray(b)) b = b.join(' ');
    return a + ' ' + b;
  }

  function packageStyles(options) {
    var styles = {};
    if (options &amp;&amp; (options.to || options.from)) {
      styles.to = options.to;
      styles.from = options.from;
    }
    return styles;
  }

  function pendClasses(classes, fix, isPrefix) {
    var className = '';
    classes = isArray(classes) ?
      classes :
      classes &amp;&amp; isString(classes) &amp;&amp; classes.length ?
      classes.split(/\s+/) :
      [];
    forEach(classes, function(klass, i) {
      if (klass &amp;&amp; klass.length &gt; 0) {
        className += (i &gt; 0) ? ' ' : '';
        className += isPrefix ? fix + klass :
          klass + fix;
      }
    });
    return className;
  }

  function removeFromArray(arr, val) {
    var index = arr.indexOf(val);
    if (val &gt;= 0) {
      arr.splice(index, 1);
    }
  }

  function stripCommentsFromElement(element) {
    if (element instanceof jqLite) {
      switch (element.length) {
        case 0:
          return [];
          break;
        case 1:
          if (element[0].nodeType === ELEMENT_NODE) {
            return element;
          }
          break;
        default:
          return jqLite(extractElementNode(element));
          break;
      }
    }
    if (element.nodeType === ELEMENT_NODE) {
      return jqLite(element);
    }
  }

  function extractElementNode(element) {
    if (!element[0]) return element;
    for (var i = 0; i &lt; element.length; i++) {
      var elm = element[i];
      if (elm.nodeType == ELEMENT_NODE) {
        return elm;
      }
    }
  }

  function $$addClass($$jqLite, element, className) {
    forEach(element, function(elm) {
      $$jqLite.addClass(elm, className);
    });
  }

  function $$removeClass($$jqLite, element, className) {
    forEach(element, function(elm) {
      $$jqLite.removeClass(elm, className);
    });
  }

  function applyAnimationClassesFactory($$jqLite) {
    return function(element, options) {
      if (options.addClass) {
        $$addClass($$jqLite, element, options.addClass);
        options.addClass = null;
      }
      if (options.removeClass) {
        $$removeClass($$jqLite, element, options.removeClass);
        options.removeClass = null;
      }
    }
  }

  function prepareAnimationOptions(options) {
    options = options || {};
    if (!options.$$prepared) {
      var domOperation = options.domOperation || noop;
      options.domOperation = function() {
        options.$$domOperationFired = true;
        domOperation();
        domOperation = noop;
      };
      options.$$prepared = true;
    }
    return options;
  }

  function applyAnimationStyles(element, options) {
    applyAnimationFromStyles(element, options);
    applyAnimationToStyles(element, options);
  }

  function applyAnimationFromStyles(element, options) {
    if (options.from) {
      element.css(options.from);
      options.from = null;
    }
  }

  function applyAnimationToStyles(element, options) {
    if (options.to) {
      element.css(options.to);
      options.to = null;
    }
  }

  function mergeAnimationDetails(element, oldAnimation, newAnimation) {
    var target = oldAnimation.options || {};
    var newOptions = newAnimation.options || {};
    var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
    var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
    var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
    if (newOptions.preparationClasses) {
      target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
      delete newOptions.preparationClasses;
    }
    var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
    extend(target, newOptions);
    if (realDomOperation) {
      target.domOperation = realDomOperation;
    }
    if (classes.addClass) {
      target.addClass = classes.addClass;
    } else {
      target.addClass = null;
    }
    if (classes.removeClass) {
      target.removeClass = classes.removeClass;
    } else {
      target.removeClass = null;
    }
    oldAnimation.addClass = target.addClass;
    oldAnimation.removeClass = target.removeClass;
    return target;
  }

  function resolveElementClasses(existing, toAdd, toRemove) {
    var ADD_CLASS = 1;
    var REMOVE_CLASS = -1;
    var flags = {};
    existing = splitClassesToLookup(existing);
    toAdd = splitClassesToLookup(toAdd);
    forEach(toAdd, function(value, key) {
      flags[key] = ADD_CLASS;
    });
    toRemove = splitClassesToLookup(toRemove);
    forEach(toRemove, function(value, key) {
      flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
    });
    var classes = {
      addClass: '',
      removeClass: ''
    };
    forEach(flags, function(val, klass) {
      var prop, allow;
      if (val === ADD_CLASS) {
        prop = 'addClass';
        allow = !existing[klass];
      } else if (val === REMOVE_CLASS) {
        prop = 'removeClass';
        allow = existing[klass];
      }
      if (allow) {
        if (classes[prop].length) {
          classes[prop] += ' ';
        }
        classes[prop] += klass;
      }
    });

    function splitClassesToLookup(classes) {
      if (isString(classes)) {
        classes = classes.split(' ');
      }
      var obj = {};
      forEach(classes, function(klass) {
        if (klass.length) {
          obj[klass] = true;
        }
      });
      return obj;
    }
    return classes;
  }

  function getDomNode(element) {
    return (element instanceof angular.element) ? element[0] : element;
  }

  function applyGeneratedPreparationClasses(element, event, options) {
    var classes = '';
    if (event) {
      classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
    }
    if (options.addClass) {
      classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
    }
    if (options.removeClass) {
      classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
    }
    if (classes.length) {
      options.preparationClasses = classes;
      element.addClass(classes);
    }
  }

  function clearGeneratedClasses(element, options) {
    if (options.preparationClasses) {
      element.removeClass(options.preparationClasses);
      options.preparationClasses = null;
    }
    if (options.activeClasses) {
      element.removeClass(options.activeClasses);
      options.activeClasses = null;
    }
  }

  function blockTransitions(node, duration) {
    var value = duration ? '-' + duration + 's' : '';
    applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
    return [TRANSITION_DELAY_PROP, value];
  }

  function blockKeyframeAnimations(node, applyBlock) {
    var value = applyBlock ? 'paused' : '';
    var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
    applyInlineStyle(node, [key, value]);
    return [key, value];
  }

  function applyInlineStyle(node, styleTuple) {
    var prop = styleTuple[0];
    var value = styleTuple[1];
    node.style[prop] = value;
  }

  function concatWithSpace(a, b) {
    if (!a) return b;
    if (!b) return a;
    return a + ' ' + b;
  }
  var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
    var queue, cancelFn;

    function scheduler(tasks) {
      queue = queue.concat(tasks);
      nextTick();
    }
    queue = scheduler.queue = [];
    scheduler.waitUntilQuiet = function(fn) {
      if (cancelFn) cancelFn();
      cancelFn = $$rAF(function() {
        cancelFn = null;
        fn();
        nextTick();
      });
    };
    return scheduler;

    function nextTick() {
      if (!queue.length) return;
      var items = queue.shift();
      for (var i = 0; i &lt; items.length; i++) {
        items[i]();
      }
      if (!cancelFn) {
        $$rAF(function() {
          if (!cancelFn) nextTick();
        });
      }
    }
  }];
  var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
    return {
      link: function(scope, element, attrs) {
        var val = attrs.ngAnimateChildren;
        if (angular.isString(val) &amp;&amp; val.length === 0) {
          element.data(NG_ANIMATE_CHILDREN_DATA, true);
        } else {
          setData($interpolate(val)(scope));
          attrs.$observe('ngAnimateChildren', setData);
        }

        function setData(value) {
          value = value === 'on' || value === 'true';
          element.data(NG_ANIMATE_CHILDREN_DATA, value);
        }
      }
    };
  }];
  var ANIMATE_TIMER_KEY = '$$animateCss';
  var ONE_SECOND = 1000;
  var BASE_TEN = 10;
  var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
  var CLOSING_TIME_BUFFER = 1.5;
  var DETECT_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP,
    animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
  };
  var DETECT_STAGGER_CSS_PROPERTIES = {
    transitionDuration: TRANSITION_DURATION_PROP,
    transitionDelay: TRANSITION_DELAY_PROP,
    animationDuration: ANIMATION_DURATION_PROP,
    animationDelay: ANIMATION_DELAY_PROP
  };

  function getCssKeyframeDurationStyle(duration) {
    return [ANIMATION_DURATION_PROP, duration + 's'];
  }

  function getCssDelayStyle(delay, isKeyframeAnimation) {
    var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
    return [prop, delay + 's'];
  }

  function computeCssStyles($window, element, properties) {
    var styles = Object.create(null);
    var detectedStyles = $window.getComputedStyle(element) || {};
    forEach(properties, function(formalStyleName, actualStyleName) {
      var val = detectedStyles[formalStyleName];
      if (val) {
        var c = val.charAt(0);
        if (c === '-' || c === '+' || c &gt;= 0) {
          val = parseMaxTime(val);
        }
        if (val === 0) {
          val = null;
        }
        styles[actualStyleName] = val;
      }
    });
    return styles;
  }

  function parseMaxTime(str) {
    var maxValue = 0;
    var values = str.split(/\s*,\s*/);
    forEach(values, function(value) {
      if (value.charAt(value.length - 1) == 's') {
        value = value.substring(0, value.length - 1);
      }
      value = parseFloat(value) || 0;
      maxValue = maxValue ? Math.max(value, maxValue) : value;
    });
    return maxValue;
  }

  function truthyTimingValue(val) {
    return val === 0 || val != null;
  }

  function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
    var style = TRANSITION_PROP;
    var value = duration + 's';
    if (applyOnlyDuration) {
      style += DURATION_KEY;
    } else {
      value += ' linear all';
    }
    return [style, value];
  }

  function createLocalCacheLookup() {
    var cache = Object.create(null);
    return {
      flush: function() {
        cache = Object.create(null);
      },
      count: function(key) {
        var entry = cache[key];
        return entry ? entry.total : 0;
      },
      get: function(key) {
        var entry = cache[key];
        return entry &amp;&amp; entry.value;
      },
      put: function(key, value) {
        if (!cache[key]) {
          cache[key] = {
            total: 1,
            value: value
          };
        } else {
          cache[key].total++;
        }
      }
    };
  }

  function registerRestorableStyles(backup, node, properties) {
    forEach(properties, function(prop) {
      backup[prop] = isDefined(backup[prop]) ?
        backup[prop] :
        node.style.getPropertyValue(prop);
    });
  }
  var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
    var gcsLookup = createLocalCacheLookup();
    var gcsStaggerLookup = createLocalCacheLookup();
    this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
      '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
      function($window, $$jqLite, $$AnimateRunner, $timeout,
        $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        var parentCounter = 0;

        function gcsHashFn(node, extraClasses) {
          var KEY = "$$ngAnimateParentKey";
          var parentNode = node.parentNode;
          var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
          return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
        }

        function computeCachedCssStyles(node, className, cacheKey, properties) {
          var timings = gcsLookup.get(cacheKey);
          if (!timings) {
            timings = computeCssStyles($window, node, properties);
            if (timings.animationIterationCount === 'infinite') {
              timings.animationIterationCount = 1;
            }
          }
          gcsLookup.put(cacheKey, timings);
          return timings;
        }

        function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
          var stagger;
          if (gcsLookup.count(cacheKey) &gt; 0) {
            stagger = gcsStaggerLookup.get(cacheKey);
            if (!stagger) {
              var staggerClassName = pendClasses(className, '-stagger');
              $$jqLite.addClass(node, staggerClassName);
              stagger = computeCssStyles($window, node, properties);
              stagger.animationDuration = Math.max(stagger.animationDuration, 0);
              stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
              $$jqLite.removeClass(node, staggerClassName);
              gcsStaggerLookup.put(cacheKey, stagger);
            }
          }
          return stagger || {};
        }
        var cancelLastRAFRequest;
        var rafWaitQueue = [];

        function waitUntilQuiet(callback) {
          rafWaitQueue.push(callback);
          $$rAFScheduler.waitUntilQuiet(function() {
            gcsLookup.flush();
            gcsStaggerLookup.flush();
            var pageWidth = $$forceReflow();
            for (var i = 0; i &lt; rafWaitQueue.length; i++) {
              rafWaitQueue[i](pageWidth);
            }
            rafWaitQueue.length = 0;
          });
        }

        function computeTimings(node, className, cacheKey) {
          var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
          var aD = timings.animationDelay;
          var tD = timings.transitionDelay;
          timings.maxDelay = aD &amp;&amp; tD ?
            Math.max(aD, tD) :
            (aD || tD);
          timings.maxDuration = Math.max(
            timings.animationDuration * timings.animationIterationCount,
            timings.transitionDuration);
          return timings;
        }
        return function init(element, initialOptions) {
          var options = initialOptions || {};
          if (!options.$$prepared) {
            options = prepareAnimationOptions(copy(options));
          }
          var restoreStyles = {};
          var node = getDomNode(element);
          if (!node ||
            !node.parentNode ||
            !$$animateQueue.enabled()) {
            return closeAndReturnNoopAnimator();
          }
          var temporaryStyles = [];
          var classes = element.attr('class');
          var styles = packageStyles(options);
          var animationClosed;
          var animationPaused;
          var animationCompleted;
          var runner;
          var runnerHost;
          var maxDelay;
          var maxDelayTime;
          var maxDuration;
          var maxDurationTime;
          var startTime;
          var events = [];
          if (options.duration === 0 || (!$sniffer.animations &amp;&amp; !$sniffer.transitions)) {
            return closeAndReturnNoopAnimator();
          }
          var method = options.event &amp;&amp; isArray(options.event) ?
            options.event.join(' ') :
            options.event;
          var isStructural = method &amp;&amp; options.structural;
          var structuralClassName = '';
          var addRemoveClassName = '';
          if (isStructural) {
            structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
          } else if (method) {
            structuralClassName = method;
          }
          if (options.addClass) {
            addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
          }
          if (options.removeClass) {
            if (addRemoveClassName.length) {
              addRemoveClassName += ' ';
            }
            addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
          }
          if (options.applyClassesEarly &amp;&amp; addRemoveClassName.length) {
            applyAnimationClasses(element, options);
          }
          var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
          var fullClassName = classes + ' ' + preparationClasses;
          var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
          var hasToStyles = styles.to &amp;&amp; Object.keys(styles.to).length &gt; 0;
          var containsKeyframeAnimation = (options.keyframeStyle || '').length &gt; 0;
          if (!containsKeyframeAnimation &amp;&amp;
            !hasToStyles &amp;&amp;
            !preparationClasses) {
            return closeAndReturnNoopAnimator();
          }
          var cacheKey, stagger;
          if (options.stagger &gt; 0) {
            var staggerVal = parseFloat(options.stagger);
            stagger = {
              transitionDelay: staggerVal,
              animationDelay: staggerVal,
              transitionDuration: 0,
              animationDuration: 0
            };
          } else {
            cacheKey = gcsHashFn(node, fullClassName);
            stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
          }
          if (!options.$$skipPreparationClasses) {
            $$jqLite.addClass(element, preparationClasses);
          }
          var applyOnlyDuration;
          if (options.transitionStyle) {
            var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
            applyInlineStyle(node, transitionStyle);
            temporaryStyles.push(transitionStyle);
          }
          if (options.duration &gt;= 0) {
            applyOnlyDuration = node.style[TRANSITION_PROP].length &gt; 0;
            var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
            applyInlineStyle(node, durationStyle);
            temporaryStyles.push(durationStyle);
          }
          if (options.keyframeStyle) {
            var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
            applyInlineStyle(node, keyframeStyle);
            temporaryStyles.push(keyframeStyle);
          }
          var itemIndex = stagger ?
            options.staggerIndex &gt;= 0 ?
            options.staggerIndex :
            gcsLookup.count(cacheKey) :
            0;
          var isFirst = itemIndex === 0;
          if (isFirst &amp;&amp; !options.skipBlocking) {
            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
          }
          var timings = computeTimings(node, fullClassName, cacheKey);
          var relativeDelay = timings.maxDelay;
          maxDelay = Math.max(relativeDelay, 0);
          maxDuration = timings.maxDuration;
          var flags = {};
          flags.hasTransitions = timings.transitionDuration &gt; 0;
          flags.hasAnimations = timings.animationDuration &gt; 0;
          flags.hasTransitionAll = flags.hasTransitions &amp;&amp; timings.transitionProperty == 'all';
          flags.applyTransitionDuration = hasToStyles &amp;&amp; (
            (flags.hasTransitions &amp;&amp; !flags.hasTransitionAll) ||
            (flags.hasAnimations &amp;&amp; !flags.hasTransitions));
          flags.applyAnimationDuration = options.duration &amp;&amp; flags.hasAnimations;
          flags.applyTransitionDelay = truthyTimingValue(options.delay) &amp;&amp; (flags.applyTransitionDuration || flags.hasTransitions);
          flags.applyAnimationDelay = truthyTimingValue(options.delay) &amp;&amp; flags.hasAnimations;
          flags.recalculateTimingStyles = addRemoveClassName.length &gt; 0;
          if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
            maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
            if (flags.applyTransitionDuration) {
              flags.hasTransitions = true;
              timings.transitionDuration = maxDuration;
              applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length &gt; 0;
              temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
            }
            if (flags.applyAnimationDuration) {
              flags.hasAnimations = true;
              timings.animationDuration = maxDuration;
              temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
            }
          }
          if (maxDuration === 0 &amp;&amp; !flags.recalculateTimingStyles) {
            return closeAndReturnNoopAnimator();
          }
          if (options.delay != null) {
            var delayStyle;
            if (typeof options.delay !== "boolean") {
              delayStyle = parseFloat(options.delay);
              maxDelay = Math.max(delayStyle, 0);
            }
            if (flags.applyTransitionDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle));
            }
            if (flags.applyAnimationDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle, true));
            }
          }
          if (options.duration == null &amp;&amp; timings.transitionDuration &gt; 0) {
            flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
          }
          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;
          if (!options.skipBlocking) {
            flags.blockTransition = timings.transitionDuration &gt; 0;
            flags.blockKeyframeAnimation = timings.animationDuration &gt; 0 &amp;&amp;
              stagger.animationDelay &gt; 0 &amp;&amp;
              stagger.animationDuration === 0;
          }
          if (options.from) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
            }
            applyAnimationFromStyles(element, options);
          }
          if (flags.blockTransition || flags.blockKeyframeAnimation) {
            applyBlocking(maxDuration);
          } else if (!options.skipBlocking) {
            blockTransitions(node, false);
          }
          return {
            $$willAnimate: true,
            end: endFn,
            start: function() {
              if (animationClosed) return;
              runnerHost = {
                end: endFn,
                cancel: cancelFn,
                resume: null,
                pause: null
              };
              runner = new $$AnimateRunner(runnerHost);
              waitUntilQuiet(start);
              return runner;
            }
          };

          function endFn() {
            close();
          }

          function cancelFn() {
            close(true);
          }

          function close(rejected) {
            if (animationClosed || (animationCompleted &amp;&amp; animationPaused)) return;
            animationClosed = true;
            animationPaused = false;
            if (!options.$$skipPreparationClasses) {
              $$jqLite.removeClass(element, preparationClasses);
            }
            $$jqLite.removeClass(element, activeClasses);
            blockKeyframeAnimations(node, false);
            blockTransitions(node, false);
            forEach(temporaryStyles, function(entry) {
              node.style[entry[0]] = '';
            });
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            if (Object.keys(restoreStyles).length) {
              forEach(restoreStyles, function(value, prop) {
                value ? node.style.setProperty(prop, value) :
                  node.style.removeProperty(prop);
              });
            }
            if (options.onDone) {
              options.onDone();
            }
            if (events &amp;&amp; events.length) {
              element.off(events.join(' '), onAnimationProgress);
            }
            var animationTimerData = element.data(ANIMATE_TIMER_KEY);
            if (animationTimerData) {
              $timeout.cancel(animationTimerData[0].timer);
              element.removeData(ANIMATE_TIMER_KEY);
            }
            if (runner) {
              runner.complete(!rejected);
            }
          }

          function applyBlocking(duration) {
            if (flags.blockTransition) {
              blockTransitions(node, duration);
            }
            if (flags.blockKeyframeAnimation) {
              blockKeyframeAnimations(node, !!duration);
            }
          }

          function closeAndReturnNoopAnimator() {
            runner = new $$AnimateRunner({
              end: endFn,
              cancel: cancelFn
            });
            waitUntilQuiet(noop);
            close();
            return {
              $$willAnimate: false,
              start: function() {
                return runner;
              },
              end: endFn
            };
          }

          function onAnimationProgress(event) {
            event.stopPropagation();
            var ev = event.originalEvent || event;
            var timeStamp = ev.$manualTimeStamp || Date.now();
            var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
            if (Math.max(timeStamp - startTime, 0) &gt;= maxDelayTime &amp;&amp; elapsedTime &gt;= maxDuration) {
              animationCompleted = true;
              close();
            }
          }

          function start() {
            if (animationClosed) return;
            if (!node.parentNode) {
              close();
              return;
            }
            var playPause = function(playAnimation) {
              if (!animationCompleted) {
                animationPaused = !playAnimation;
                if (timings.animationDuration) {
                  var value = blockKeyframeAnimations(node, animationPaused);
                  animationPaused
                    ?
                    temporaryStyles.push(value) :
                    removeFromArray(temporaryStyles, value);
                }
              } else if (animationPaused &amp;&amp; playAnimation) {
                animationPaused = false;
                close();
              }
            };
            var maxStagger = itemIndex &gt; 0 &amp;&amp;
              ((timings.transitionDuration &amp;&amp; stagger.transitionDuration === 0) ||
                (timings.animationDuration &amp;&amp; stagger.animationDuration === 0)) &amp;&amp;
              Math.max(stagger.animationDelay, stagger.transitionDelay);
            if (maxStagger) {
              $timeout(triggerAnimationStart,
                Math.floor(maxStagger * itemIndex * ONE_SECOND),
                false);
            } else {
              triggerAnimationStart();
            }
            runnerHost.resume = function() {
              playPause(true);
            };
            runnerHost.pause = function() {
              playPause(false);
            };

            function triggerAnimationStart() {
              if (animationClosed) return;
              applyBlocking(false);
              forEach(temporaryStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[key] = value;
              });
              applyAnimationClasses(element, options);
              $$jqLite.addClass(element, activeClasses);
              if (flags.recalculateTimingStyles) {
                fullClassName = node.className + ' ' + preparationClasses;
                cacheKey = gcsHashFn(node, fullClassName);
                timings = computeTimings(node, fullClassName, cacheKey);
                relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0);
                maxDuration = timings.maxDuration;
                if (maxDuration === 0) {
                  close();
                  return;
                }
                flags.hasTransitions = timings.transitionDuration &gt; 0;
                flags.hasAnimations = timings.animationDuration &gt; 0;
              }
              if (flags.applyAnimationDelay) {
                relativeDelay = typeof options.delay !== "boolean" &amp;&amp; truthyTimingValue(options.delay) ?
                  parseFloat(options.delay) :
                  relativeDelay;
                maxDelay = Math.max(relativeDelay, 0);
                timings.animationDelay = relativeDelay;
                delayStyle = getCssDelayStyle(relativeDelay, true);
                temporaryStyles.push(delayStyle);
                node.style[delayStyle[0]] = delayStyle[1];
              }
              maxDelayTime = maxDelay * ONE_SECOND;
              maxDurationTime = maxDuration * ONE_SECOND;
              if (options.easing) {
                var easeProp, easeVal = options.easing;
                if (flags.hasTransitions) {
                  easeProp = TRANSITION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
                if (flags.hasAnimations) {
                  easeProp = ANIMATION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
              }
              if (timings.transitionDuration) {
                events.push(TRANSITIONEND_EVENT);
              }
              if (timings.animationDuration) {
                events.push(ANIMATIONEND_EVENT);
              }
              startTime = Date.now();
              var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
              var endTime = startTime + timerTime;
              var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
              var setupFallbackTimer = true;
              if (animationsData.length) {
                var currentTimerData = animationsData[0];
                setupFallbackTimer = endTime &gt; currentTimerData.expectedEndTime;
                if (setupFallbackTimer) {
                  $timeout.cancel(currentTimerData.timer);
                } else {
                  animationsData.push(close);
                }
              }
              if (setupFallbackTimer) {
                var timer = $timeout(onAnimationExpired, timerTime, false);
                animationsData[0] = {
                  timer: timer,
                  expectedEndTime: endTime
                };
                animationsData.push(close);
                element.data(ANIMATE_TIMER_KEY, animationsData);
              }
              if (events.length) {
                element.on(events.join(' '), onAnimationProgress);
              }
              if (options.to) {
                if (options.cleanupStyles) {
                  registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                }
                applyAnimationToStyles(element, options);
              }
            }

            function onAnimationExpired() {
              var animationsData = element.data(ANIMATE_TIMER_KEY);
              if (animationsData) {
                for (var i = 1; i &lt; animationsData.length; i++) {
                  animationsData[i]();
                }
                element.removeData(ANIMATE_TIMER_KEY);
              }
            }
          }
        };
      }
    ];
  }];
  var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
    $$animationProvider.drivers.push('$$animateCssDriver');
    var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
    var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
    var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
    var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

    function isDocumentFragment(node) {
      return node.parentNode &amp;&amp; node.parentNode.nodeType === 11;
    }
    this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
      function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
        if (!$sniffer.animations &amp;&amp; !$sniffer.transitions) return noop;
        var bodyNode = $document[0].body;
        var rootNode = getDomNode($rootElement);
        var rootBodyElement = jqLite(
          isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
        );
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        return function initDriverFn(animationDetails) {
          return animationDetails.from &amp;&amp; animationDetails.to ?
            prepareFromToAnchorAnimation(animationDetails.from,
              animationDetails.to,
              animationDetails.classes,
              animationDetails.anchors) :
            prepareRegularAnimation(animationDetails);
        };

        function filterCssClasses(classes) {
          return classes.replace(/\bng-\S+\b/g, '');
        }

        function getUniqueValues(a, b) {
          if (isString(a)) a = a.split(' ');
          if (isString(b)) b = b.split(' ');
          return a.filter(function(val) {
            return b.indexOf(val) === -1;
          }).join(' ');
        }

        function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
          var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
          var startingClasses = filterCssClasses(getClassVal(clone));
          outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
          rootBodyElement.append(clone);
          var animatorIn, animatorOut = prepareOutAnimation();
          if (!animatorOut) {
            animatorIn = prepareInAnimation();
            if (!animatorIn) {
              return end();
            }
          }
          var startingAnimator = animatorOut || animatorIn;
          return {
            start: function() {
              var runner;
              var currentAnimation = startingAnimator.start();
              currentAnimation.done(function() {
                currentAnimation = null;
                if (!animatorIn) {
                  animatorIn = prepareInAnimation();
                  if (animatorIn) {
                    currentAnimation = animatorIn.start();
                    currentAnimation.done(function() {
                      currentAnimation = null;
                      end();
                      runner.complete();
                    });
                    return currentAnimation;
                  }
                }
                end();
                runner.complete();
              });
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              return runner;

              function endFn() {
                if (currentAnimation) {
                  currentAnimation.end();
                }
              }
            }
          };

          function calculateAnchorStyles(anchor) {
            var styles = {};
            var coords = getDomNode(anchor).getBoundingClientRect();
            forEach(['width', 'height', 'top', 'left'], function(key) {
              var value = coords[key];
              switch (key) {
                case 'top':
                  value += bodyNode.scrollTop;
                  break;
                case 'left':
                  value += bodyNode.scrollLeft;
                  break;
              }
              styles[key] = Math.floor(value) + 'px';
            });
            return styles;
          }

          function prepareOutAnimation() {
            var animator = $animateCss(clone, {
              addClass: NG_OUT_ANCHOR_CLASS_NAME,
              delay: true,
              from: calculateAnchorStyles(outAnchor)
            });
            return animator.$$willAnimate ? animator : null;
          }

          function getClassVal(element) {
            return element.attr('class') || '';
          }

          function prepareInAnimation() {
            var endingClasses = filterCssClasses(getClassVal(inAnchor));
            var toAdd = getUniqueValues(endingClasses, startingClasses);
            var toRemove = getUniqueValues(startingClasses, endingClasses);
            var animator = $animateCss(clone, {
              to: calculateAnchorStyles(inAnchor),
              addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
              removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
              delay: true
            });
            return animator.$$willAnimate ? animator : null;
          }

          function end() {
            clone.remove();
            outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
          }
        }

        function prepareFromToAnchorAnimation(from, to, classes, anchors) {
          var fromAnimation = prepareRegularAnimation(from, noop);
          var toAnimation = prepareRegularAnimation(to, noop);
          var anchorAnimations = [];
          forEach(anchors, function(anchor) {
            var outElement = anchor['out'];
            var inElement = anchor['in'];
            var animator = prepareAnchoredAnimation(classes, outElement, inElement);
            if (animator) {
              anchorAnimations.push(animator);
            }
          });
          if (!fromAnimation &amp;&amp; !toAnimation &amp;&amp; anchorAnimations.length === 0) return;
          return {
            start: function() {
              var animationRunners = [];
              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }
              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }
              forEach(anchorAnimations, function(animation) {
                animationRunners.push(animation.start());
              });
              var runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              $$AnimateRunner.all(animationRunners, function(status) {
                runner.complete(status);
              });
              return runner;

              function endFn() {
                forEach(animationRunners, function(runner) {
                  runner.end();
                });
              }
            }
          };
        }

        function prepareRegularAnimation(animationDetails) {
          var element = animationDetails.element;
          var options = animationDetails.options || {};
          if (animationDetails.structural) {
            options.event = animationDetails.event;
            options.structural = true;
            options.applyClassesEarly = true;
            if (animationDetails.event === 'leave') {
              options.onDone = options.domOperation;
            }
          }
          if (options.preparationClasses) {
            options.event = concatWithSpace(options.event, options.preparationClasses);
          }
          var animator = $animateCss(element, options);
          return animator.$$willAnimate ? animator : null;
        }
      }
    ];
  }];
  var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
    this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
      function($injector, $$AnimateRunner, $$jqLite) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        return function(element, event, classes, options) {
          var animationClosed = false;
          if (arguments.length === 3 &amp;&amp; isObject(classes)) {
            options = classes;
            classes = null;
          }
          options = prepareAnimationOptions(options);
          if (!classes) {
            classes = element.attr('class') || '';
            if (options.addClass) {
              classes += ' ' + options.addClass;
            }
            if (options.removeClass) {
              classes += ' ' + options.removeClass;
            }
          }
          var classesToAdd = options.addClass;
          var classesToRemove = options.removeClass;
          var animations = lookupAnimations(classes);
          var before, after;
          if (animations.length) {
            var afterFn, beforeFn;
            if (event == 'leave') {
              beforeFn = 'leave';
              afterFn = 'afterLeave';
            } else {
              beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
              afterFn = event;
            }
            if (event !== 'enter' &amp;&amp; event !== 'move') {
              before = packageAnimations(element, event, options, animations, beforeFn);
            }
            after = packageAnimations(element, event, options, animations, afterFn);
          }
          if (!before &amp;&amp; !after) return;

          function applyOptions() {
            options.domOperation();
            applyAnimationClasses(element, options);
          }

          function close() {
            animationClosed = true;
            applyOptions();
            applyAnimationStyles(element, options);
          }
          var runner;
          return {
            $$willAnimate: true,
            end: function() {
              if (runner) {
                runner.end();
              } else {
                close();
                runner = new $$AnimateRunner();
                runner.complete(true);
              }
              return runner;
            },
            start: function() {
              if (runner) {
                return runner;
              }
              runner = new $$AnimateRunner();
              var closeActiveAnimations;
              var chain = [];
              if (before) {
                chain.push(function(fn) {
                  closeActiveAnimations = before(fn);
                });
              }
              if (chain.length) {
                chain.push(function(fn) {
                  applyOptions();
                  fn(true);
                });
              } else {
                applyOptions();
              }
              if (after) {
                chain.push(function(fn) {
                  closeActiveAnimations = after(fn);
                });
              }
              runner.setHost({
                end: function() {
                  endAnimations();
                },
                cancel: function() {
                  endAnimations(true);
                }
              });
              $$AnimateRunner.chain(chain, onComplete);
              return runner;

              function onComplete(success) {
                close(success);
                runner.complete(success);
              }

              function endAnimations(cancelled) {
                if (!animationClosed) {
                  (closeActiveAnimations || noop)(cancelled);
                  onComplete(cancelled);
                }
              }
            }
          };

          function executeAnimationFn(fn, element, event, options, onDone) {
            var args;
            switch (event) {
              case 'animate':
                args = [element, options.from, options.to, onDone];
                break;
              case 'setClass':
                args = [element, classesToAdd, classesToRemove, onDone];
                break;
              case 'addClass':
                args = [element, classesToAdd, onDone];
                break;
              case 'removeClass':
                args = [element, classesToRemove, onDone];
                break;
              default:
                args = [element, onDone];
                break;
            }
            args.push(options);
            var value = fn.apply(fn, args);
            if (value) {
              if (isFunction(value.start)) {
                value = value.start();
              }
              if (value instanceof $$AnimateRunner) {
                value.done(onDone);
              } else if (isFunction(value)) {
                return value;
              }
            }
            return noop;
          }

          function groupEventedAnimations(element, event, options, animations, fnName) {
            var operations = [];
            forEach(animations, function(ani) {
              var animation = ani[fnName];
              if (!animation) return;
              operations.push(function() {
                var runner;
                var endProgressCb;
                var resolved = false;
                var onAnimationComplete = function(rejected) {
                  if (!resolved) {
                    resolved = true;
                    (endProgressCb || noop)(rejected);
                    runner.complete(!rejected);
                  }
                };
                runner = new $$AnimateRunner({
                  end: function() {
                    onAnimationComplete();
                  },
                  cancel: function() {
                    onAnimationComplete(true);
                  }
                });
                endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                  var cancelled = result === false;
                  onAnimationComplete(cancelled);
                });
                return runner;
              });
            });
            return operations;
          }

          function packageAnimations(element, event, options, animations, fnName) {
            var operations = groupEventedAnimations(element, event, options, animations, fnName);
            if (operations.length === 0) {
              var a, b;
              if (fnName === 'beforeSetClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
              } else if (fnName === 'setClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
              }
              if (a) {
                operations = operations.concat(a);
              }
              if (b) {
                operations = operations.concat(b);
              }
            }
            if (operations.length === 0) return;
            return function startAnimation(callback) {
              var runners = [];
              if (operations.length) {
                forEach(operations, function(animateFn) {
                  runners.push(animateFn());
                });
              }
              runners.length ? $$AnimateRunner.all(runners, callback) : callback();
              return function endFn(reject) {
                forEach(runners, function(runner) {
                  reject ? runner.cancel() : runner.end();
                });
              };
            };
          }
        };

        function lookupAnimations(classes) {
          classes = isArray(classes) ? classes : classes.split(' ');
          var matches = [],
            flagMap = {};
          for (var i = 0; i &lt; classes.length; i++) {
            var klass = classes[i],
              animationFactory = $animateProvider.$$registeredAnimations[klass];
            if (animationFactory &amp;&amp; !flagMap[klass]) {
              matches.push($injector.get(animationFactory));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }
    ];
  }];
  var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
    $$animationProvider.drivers.push('$$animateJsDriver');
    this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
      return function initDriverFn(animationDetails) {
        if (animationDetails.from &amp;&amp; animationDetails.to) {
          var fromAnimation = prepareAnimation(animationDetails.from);
          var toAnimation = prepareAnimation(animationDetails.to);
          if (!fromAnimation &amp;&amp; !toAnimation) return;
          return {
            start: function() {
              var animationRunners = [];
              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }
              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }
              $$AnimateRunner.all(animationRunners, done);
              var runner = new $$AnimateRunner({
                end: endFnFactory(),
                cancel: endFnFactory()
              });
              return runner;

              function endFnFactory() {
                return function() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                };
              }

              function done(status) {
                runner.complete(status);
              }
            }
          };
        } else {
          return prepareAnimation(animationDetails);
        }
      };

      function prepareAnimation(animationDetails) {
        var element = animationDetails.element;
        var event = animationDetails.event;
        var options = animationDetails.options;
        var classes = animationDetails.classes;
        return $$animateJs(element, event, classes, options);
      }
    }];
  }];
  var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
  var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
  var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
    var PRE_DIGEST_STATE = 1;
    var RUNNING_STATE = 2;
    var ONE_SPACE = ' ';
    var rules = this.rules = {
      skip: [],
      cancel: [],
      join: []
    };

    function makeTruthyCssClassMap(classString) {
      if (!classString) {
        return null;
      }
      var keys = classString.split(ONE_SPACE);
      var map = Object.create(null);
      forEach(keys, function(key) {
        map[key] = true;
      });
      return map;
    }

    function hasMatchingClasses(newClassString, currentClassString) {
      if (newClassString &amp;&amp; currentClassString) {
        var currentClassMap = makeTruthyCssClassMap(currentClassString);
        return newClassString.split(ONE_SPACE).some(function(className) {
          return currentClassMap[className];
        });
      }
    }

    function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
      return rules[ruleType].some(function(fn) {
        return fn(element, currentAnimation, previousAnimation);
      });
    }

    function hasAnimationClasses(animation, and) {
      var a = (animation.addClass || '').length &gt; 0;
      var b = (animation.removeClass || '').length &gt; 0;
      return and ? a &amp;&amp; b : a || b;
    }
    rules.join.push(function(element, newAnimation, currentAnimation) {
      return !newAnimation.structural &amp;&amp; hasAnimationClasses(newAnimation);
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return !newAnimation.structural &amp;&amp; !hasAnimationClasses(newAnimation);
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.event == 'leave' &amp;&amp; newAnimation.structural;
    });
    rules.skip.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.structural &amp;&amp; currentAnimation.state === RUNNING_STATE &amp;&amp; !newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.structural &amp;&amp; newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      return currentAnimation.state === RUNNING_STATE &amp;&amp; newAnimation.structural;
    });
    rules.cancel.push(function(element, newAnimation, currentAnimation) {
      if (currentAnimation.structural) return false;
      var nA = newAnimation.addClass;
      var nR = newAnimation.removeClass;
      var cA = currentAnimation.addClass;
      var cR = currentAnimation.removeClass;
      if ((isUndefined(nA) &amp;&amp; isUndefined(nR)) || (isUndefined(cA) &amp;&amp; isUndefined(cR))) {
        return false;
      }
      return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
    });
    this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
      '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
      function($$rAF, $rootScope, $rootElement, $document, $$HashMap,
        $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
        var activeAnimationsLookup = new $$HashMap();
        var disabledElementsLookup = new $$HashMap();
        var animationsEnabled = null;

        function postDigestTaskFactory() {
          var postDigestCalled = false;
          return function(fn) {
            if (postDigestCalled) {
              fn();
            } else {
              $rootScope.$$postDigest(function() {
                postDigestCalled = true;
                fn();
              });
            }
          };
        }
        var deregisterWatch = $rootScope.$watch(
          function() {
            return $templateRequest.totalPendingRequests === 0;
          },
          function(isEmpty) {
            if (!isEmpty) return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          }
        );
        var callbackRegistry = {};
        var classNameFilter = $animateProvider.classNameFilter();
        var isAnimatableClassName = !classNameFilter ?
          function() {
            return true;
          } :
          function(className) {
            return classNameFilter.test(className);
          };
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

        function normalizeAnimationDetails(element, animation) {
          return mergeAnimationDetails(element, animation, {});
        }
        var contains = Node.prototype.contains || function(arg) {
          return this === arg || !!(this.compareDocumentPosition(arg) &amp; 16);
        };

        function findCallbacks(parent, element, event) {
          var targetNode = getDomNode(element);
          var targetParentNode = getDomNode(parent);
          var matches = [];
          var entries = callbackRegistry[event];
          if (entries) {
            forEach(entries, function(entry) {
              if (contains.call(entry.node, targetNode)) {
                matches.push(entry.callback);
              } else if (event === 'leave' &amp;&amp; contains.call(entry.node, targetParentNode)) {
                matches.push(entry.callback);
              }
            });
          }
          return matches;
        }
        var $animate = {
          on: function(event, container, callback) {
            var node = extractElementNode(container);
            callbackRegistry[event] = callbackRegistry[event] || [];
            callbackRegistry[event].push({
              node: node,
              callback: callback
            });
            jqLite(container).on('$destroy', function() {
              $animate.off(event, container, callback);
            });
          },
          off: function(event, container, callback) {
            var entries = callbackRegistry[event];
            if (!entries) return;
            callbackRegistry[event] = arguments.length === 1 ?
              null :
              filterFromRegistry(entries, container, callback);

            function filterFromRegistry(list, matchContainer, matchCallback) {
              var containerNode = extractElementNode(matchContainer);
              return list.filter(function(entry) {
                var isMatch = entry.node === containerNode &amp;&amp;
                  (!matchCallback || entry.callback === matchCallback);
                return !isMatch;
              });
            }
          },
          pin: function(element, parentElement) {
            assertArg(isElement(element), 'element', 'not an element');
            assertArg(isElement(parentElement), 'parentElement', 'not an element');
            element.data(NG_ANIMATE_PIN_DATA, parentElement);
          },
          push: function(element, event, options, domOperation) {
            options = options || {};
            options.domOperation = domOperation;
            return queueAnimation(element, event, options);
          },
          enabled: function(element, bool) {
            var argCount = arguments.length;
            if (argCount === 0) {
              bool = !!animationsEnabled;
            } else {
              var hasElement = isElement(element);
              if (!hasElement) {
                bool = animationsEnabled = !!element;
              } else {
                var node = getDomNode(element);
                var recordExists = disabledElementsLookup.get(node);
                if (argCount === 1) {
                  bool = !recordExists;
                } else {
                  disabledElementsLookup.put(node, !bool);
                }
              }
            }
            return bool;
          }
        };
        return $animate;

        function queueAnimation(element, event, initialOptions) {
          var options = copy(initialOptions);
          var node, parent;
          element = stripCommentsFromElement(element);
          if (element) {
            node = getDomNode(element);
            parent = element.parent();
          }
          options = prepareAnimationOptions(options);
          var runner = new $$AnimateRunner();
          var runInNextPostDigestOrNow = postDigestTaskFactory();
          if (isArray(options.addClass)) {
            options.addClass = options.addClass.join(' ');
          }
          if (options.addClass &amp;&amp; !isString(options.addClass)) {
            options.addClass = null;
          }
          if (isArray(options.removeClass)) {
            options.removeClass = options.removeClass.join(' ');
          }
          if (options.removeClass &amp;&amp; !isString(options.removeClass)) {
            options.removeClass = null;
          }
          if (options.from &amp;&amp; !isObject(options.from)) {
            options.from = null;
          }
          if (options.to &amp;&amp; !isObject(options.to)) {
            options.to = null;
          }
          if (!node) {
            close();
            return runner;
          }
          var className = [node.className, options.addClass, options.removeClass].join(' ');
          if (!isAnimatableClassName(className)) {
            close();
            return runner;
          }
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) &gt;= 0;
          var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);
          var existingAnimation = (!skipAnimations &amp;&amp; activeAnimationsLookup.get(node)) || {};
          var hasExistingAnimation = !!existingAnimation.state;
          if (!skipAnimations &amp;&amp; (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
            skipAnimations = !areAnimationsAllowed(element, parent, event);
          }
          if (skipAnimations) {
            close();
            return runner;
          }
          if (isStructural) {
            closeChildAnimations(element);
          }
          var newAnimation = {
            structural: isStructural,
            element: element,
            event: event,
            addClass: options.addClass,
            removeClass: options.removeClass,
            close: close,
            options: options,
            runner: runner
          };
          if (hasExistingAnimation) {
            var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
            if (skipAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                close();
                return runner;
              } else {
                mergeAnimationDetails(element, existingAnimation, newAnimation);
                return existingAnimation.runner;
              }
            }
            var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
            if (cancelAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                existingAnimation.runner.end();
              } else if (existingAnimation.structural) {
                existingAnimation.close();
              } else {
                mergeAnimationDetails(element, existingAnimation, newAnimation);
                return existingAnimation.runner;
              }
            } else {
              var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
              if (joinAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  normalizeAnimationDetails(element, newAnimation);
                } else {
                  applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                  event = newAnimation.event = existingAnimation.event;
                  options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
            }
          } else {
            normalizeAnimationDetails(element, newAnimation);
          }
          var isValidAnimation = newAnimation.structural;
          if (!isValidAnimation) {
            isValidAnimation = (newAnimation.event === 'animate' &amp;&amp; Object.keys(newAnimation.options.to || {}).length &gt; 0) ||
              hasAnimationClasses(newAnimation);
          }
          if (!isValidAnimation) {
            close();
            clearElementAnimationState(element);
            return runner;
          }
          var counter = (existingAnimation.counter || 0) + 1;
          newAnimation.counter = counter;
          markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
          $rootScope.$$postDigest(function() {
            var animationDetails = activeAnimationsLookup.get(node);
            var animationCancelled = !animationDetails;
            animationDetails = animationDetails || {};
            var parentElement = element.parent() || [];
            var isValidAnimation = parentElement.length &gt; 0 &amp;&amp;
              (animationDetails.event === 'animate' ||
                animationDetails.structural ||
                hasAnimationClasses(animationDetails));
            if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
              if (animationCancelled) {
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
              }
              if (animationCancelled || (isStructural &amp;&amp; animationDetails.event !== event)) {
                options.domOperation();
                runner.end();
              }
              if (!isValidAnimation) {
                clearElementAnimationState(element);
              }
              return;
            }
            event = !animationDetails.structural &amp;&amp; hasAnimationClasses(animationDetails, true) ?
              'setClass' :
              animationDetails.event;
            markElementAnimationState(element, RUNNING_STATE);
            var realRunner = $$animation(element, event, animationDetails.options);
            realRunner.done(function(status) {
              close(!status);
              var animationDetails = activeAnimationsLookup.get(node);
              if (animationDetails &amp;&amp; animationDetails.counter === counter) {
                clearElementAnimationState(getDomNode(element));
              }
              notifyProgress(runner, event, 'close', {});
            });
            runner.setHost(realRunner);
            notifyProgress(runner, event, 'start', {});
          });
          return runner;

          function notifyProgress(runner, event, phase, data) {
            runInNextPostDigestOrNow(function() {
              var callbacks = findCallbacks(parent, element, event);
              if (callbacks.length) {
                $$rAF(function() {
                  forEach(callbacks, function(callback) {
                    callback(element, phase, data);
                  });
                });
              }
            });
            runner.progress(event, phase, data);
          }

          function close(reject) {
            clearGeneratedClasses(element, options);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            runner.complete(!reject);
          }
        }

        function closeChildAnimations(element) {
          var node = getDomNode(element);
          var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
          forEach(children, function(child) {
            var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
            var animationDetails = activeAnimationsLookup.get(child);
            if (animationDetails) {
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                case PRE_DIGEST_STATE:
                  activeAnimationsLookup.remove(child);
                  break;
              }
            }
          });
        }

        function clearElementAnimationState(element) {
          var node = getDomNode(element);
          node.removeAttribute(NG_ANIMATE_ATTR_NAME);
          activeAnimationsLookup.remove(node);
        }

        function isMatchingElement(nodeOrElmA, nodeOrElmB) {
          return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
        }

        function areAnimationsAllowed(element, parentElement, event) {
          var bodyElement = jqLite($document[0].body);
          var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
          var rootElementDetected = isMatchingElement(element, $rootElement);
          var parentAnimationDetected = false;
          var animateChildren;
          var elementDisabled = disabledElementsLookup.get(getDomNode(element));
          var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            parentElement = parentHost;
          }
          parentElement = getDomNode(parentElement);
          while (parentElement) {
            if (!rootElementDetected) {
              rootElementDetected = isMatchingElement(parentElement, $rootElement);
            }
            if (parentElement.nodeType !== ELEMENT_NODE) {
              break;
            }
            var details = activeAnimationsLookup.get(parentElement) || {};
            if (!parentAnimationDetected) {
              var parentElementDisabled = disabledElementsLookup.get(parentElement);
              if (parentElementDisabled === true &amp;&amp; elementDisabled !== false) {
                elementDisabled = true;
                break;
              } else if (parentElementDisabled === false) {
                elementDisabled = false;
              }
              parentAnimationDetected = details.structural;
            }
            if (isUndefined(animateChildren) || animateChildren === true) {
              var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
              if (isDefined(value)) {
                animateChildren = value;
              }
            }
            if (parentAnimationDetected &amp;&amp; animateChildren === false) break;
            if (!bodyElementDetected) {
              bodyElementDetected = isMatchingElement(parentElement, bodyElement);
            }
            if (bodyElementDetected &amp;&amp; rootElementDetected) {
              break;
            }
            if (!rootElementDetected) {
              parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
              if (parentHost) {
                parentElement = getDomNode(parentHost);
                continue;
              }
            }
            parentElement = parentElement.parentNode;
          }
          var allowAnimation = (!parentAnimationDetected || animateChildren) &amp;&amp; elementDisabled !== true;
          return allowAnimation &amp;&amp; rootElementDetected &amp;&amp; bodyElementDetected;
        }

        function markElementAnimationState(element, state, details) {
          details = details || {};
          details.state = state;
          var node = getDomNode(element);
          node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
          var oldValue = activeAnimationsLookup.get(node);
          var newValue = oldValue ?
            extend(oldValue, details) :
            details;
          activeAnimationsLookup.put(node, newValue);
        }
      }
    ];
  }];
  var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
    var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
    var drivers = this.drivers = [];
    var RUNNER_STORAGE_KEY = '$$animationRunner';

    function setRunner(element, runner) {
      element.data(RUNNER_STORAGE_KEY, runner);
    }

    function removeRunner(element) {
      element.removeData(RUNNER_STORAGE_KEY);
    }

    function getRunner(element) {
      return element.data(RUNNER_STORAGE_KEY);
    }
    this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
      function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
        var animationQueue = [];
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

        function sortAnimations(animations) {
          var tree = {
            children: []
          };
          var i, lookup = new $$HashMap();
          for (i = 0; i &lt; animations.length; i++) {
            var animation = animations[i];
            lookup.put(animation.domNode, animations[i] = {
              domNode: animation.domNode,
              fn: animation.fn,
              children: []
            });
          }
          for (i = 0; i &lt; animations.length; i++) {
            processNode(animations[i]);
          }
          return flatten(tree);

          function processNode(entry) {
            if (entry.processed) return entry;
            entry.processed = true;
            var elementNode = entry.domNode;
            var parentNode = elementNode.parentNode;
            lookup.put(elementNode, entry);
            var parentEntry;
            while (parentNode) {
              parentEntry = lookup.get(parentNode);
              if (parentEntry) {
                if (!parentEntry.processed) {
                  parentEntry = processNode(parentEntry);
                }
                break;
              }
              parentNode = parentNode.parentNode;
            }
            (parentEntry || tree).children.push(entry);
            return entry;
          }

          function flatten(tree) {
            var result = [];
            var queue = [];
            var i;
            for (i = 0; i &lt; tree.children.length; i++) {
              queue.push(tree.children[i]);
            }
            var remainingLevelEntries = queue.length;
            var nextLevelEntries = 0;
            var row = [];
            for (i = 0; i &lt; queue.length; i++) {
              var entry = queue[i];
              if (remainingLevelEntries &lt;= 0) {
                remainingLevelEntries = nextLevelEntries;
                nextLevelEntries = 0;
                result.push(row);
                row = [];
              }
              row.push(entry.fn);
              entry.children.forEach(function(childEntry) {
                nextLevelEntries++;
                queue.push(childEntry);
              });
              remainingLevelEntries--;
            }
            if (row.length) {
              result.push(row);
            }
            return result;
          }
        }
        return function(element, event, options) {
          options = prepareAnimationOptions(options);
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) &gt;= 0;
          var runner = new $$AnimateRunner({
            end: function() {
              close();
            },
            cancel: function() {
              close(true);
            }
          });
          if (!drivers.length) {
            close();
            return runner;
          }
          setRunner(element, runner);
          var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
          var tempClasses = options.tempClasses;
          if (tempClasses) {
            classes += ' ' + tempClasses;
            options.tempClasses = null;
          }
          var prepareClassName;
          if (isStructural) {
            prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
            $$jqLite.addClass(element, prepareClassName);
          }
          animationQueue.push({
            element: element,
            classes: classes,
            event: event,
            structural: isStructural,
            options: options,
            beforeStart: beforeStart,
            close: close
          });
          element.on('$destroy', handleDestroyedElement);
          if (animationQueue.length &gt; 1) return runner;
          $rootScope.$$postDigest(function() {
            var animations = [];
            forEach(animationQueue, function(entry) {
              if (getRunner(entry.element)) {
                animations.push(entry);
              } else {
                entry.close();
              }
            });
            animationQueue.length = 0;
            var groupedAnimations = groupAnimations(animations);
            var toBeSortedAnimations = [];
            forEach(groupedAnimations, function(animationEntry) {
              toBeSortedAnimations.push({
                domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                fn: function triggerAnimationStart() {
                  animationEntry.beforeStart();
                  var startAnimationFn, closeFn = animationEntry.close;
                  var targetElement = animationEntry.anchors ?
                    (animationEntry.from.element || animationEntry.to.element) :
                    animationEntry.element;
                  if (getRunner(targetElement)) {
                    var operation = invokeFirstDriver(animationEntry);
                    if (operation) {
                      startAnimationFn = operation.start;
                    }
                  }
                  if (!startAnimationFn) {
                    closeFn();
                  } else {
                    var animationRunner = startAnimationFn();
                    animationRunner.done(function(status) {
                      closeFn(!status);
                    });
                    updateAnimationRunners(animationEntry, animationRunner);
                  }
                }
              });
            });
            $$rAFScheduler(sortAnimations(toBeSortedAnimations));
          });
          return runner;

          function getAnchorNodes(node) {
            var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
            var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ?
              [node] :
              node.querySelectorAll(SELECTOR);
            var anchors = [];
            forEach(items, function(node) {
              var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
              if (attr &amp;&amp; attr.length) {
                anchors.push(node);
              }
            });
            return anchors;
          }

          function groupAnimations(animations) {
            var preparedAnimations = [];
            var refLookup = {};
            forEach(animations, function(animation, index) {
              var element = animation.element;
              var node = getDomNode(element);
              var event = animation.event;
              var enterOrMove = ['enter', 'move'].indexOf(event) &gt;= 0;
              var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
              if (anchorNodes.length) {
                var direction = enterOrMove ? 'to' : 'from';
                forEach(anchorNodes, function(anchor) {
                  var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                  refLookup[key] = refLookup[key] || {};
                  refLookup[key][direction] = {
                    animationID: index,
                    element: jqLite(anchor)
                  };
                });
              } else {
                preparedAnimations.push(animation);
              }
            });
            var usedIndicesLookup = {};
            var anchorGroups = {};
            forEach(refLookup, function(operations, key) {
              var from = operations.from;
              var to = operations.to;
              if (!from || !to) {
                var index = from ? from.animationID : to.animationID;
                var indexKey = index.toString();
                if (!usedIndicesLookup[indexKey]) {
                  usedIndicesLookup[indexKey] = true;
                  preparedAnimations.push(animations[index]);
                }
                return;
              }
              var fromAnimation = animations[from.animationID];
              var toAnimation = animations[to.animationID];
              var lookupKey = from.animationID.toString();
              if (!anchorGroups[lookupKey]) {
                var group = anchorGroups[lookupKey] = {
                  structural: true,
                  beforeStart: function() {
                    fromAnimation.beforeStart();
                    toAnimation.beforeStart();
                  },
                  close: function() {
                    fromAnimation.close();
                    toAnimation.close();
                  },
                  classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                  from: fromAnimation,
                  to: toAnimation,
                  anchors: []
                };
                if (group.classes.length) {
                  preparedAnimations.push(group);
                } else {
                  preparedAnimations.push(fromAnimation);
                  preparedAnimations.push(toAnimation);
                }
              }
              anchorGroups[lookupKey].anchors.push({
                'out': from.element,
                'in': to.element
              });
            });
            return preparedAnimations;
          }

          function cssClassesIntersection(a, b) {
            a = a.split(' ');
            b = b.split(' ');
            var matches = [];
            for (var i = 0; i &lt; a.length; i++) {
              var aa = a[i];
              if (aa.substring(0, 3) === 'ng-') continue;
              for (var j = 0; j &lt; b.length; j++) {
                if (aa === b[j]) {
                  matches.push(aa);
                  break;
                }
              }
            }
            return matches.join(' ');
          }

          function invokeFirstDriver(animationDetails) {
            for (var i = drivers.length - 1; i &gt;= 0; i--) {
              var driverName = drivers[i];
              if (!$injector.has(driverName)) continue;
              var factory = $injector.get(driverName);
              var driver = factory(animationDetails);
              if (driver) {
                return driver;
              }
            }
          }

          function beforeStart() {
            element.addClass(NG_ANIMATE_CLASSNAME);
            if (tempClasses) {
              $$jqLite.addClass(element, tempClasses);
            }
            if (prepareClassName) {
              $$jqLite.removeClass(element, prepareClassName);
              prepareClassName = null;
            }
          }

          function updateAnimationRunners(animation, newRunner) {
            if (animation.from &amp;&amp; animation.to) {
              update(animation.from.element);
              update(animation.to.element);
            } else {
              update(animation.element);
            }

            function update(element) {
              getRunner(element).setHost(newRunner);
            }
          }

          function handleDestroyedElement() {
            var runner = getRunner(element);
            if (runner &amp;&amp; (event !== 'leave' || !options.$$domOperationFired)) {
              runner.end();
            }
          }

          function close(rejected) {
            element.off('$destroy', handleDestroyedElement);
            removeRunner(element);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            if (tempClasses) {
              $$jqLite.removeClass(element, tempClasses);
            }
            element.removeClass(NG_ANIMATE_CLASSNAME);
            runner.complete(!rejected);
          }
        };
      }
    ];
  }];
  var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
    return {
      restrict: 'A',
      transclude: 'element',
      terminal: true,
      priority: 600,
      link: function(scope, $element, attrs, ctrl, $transclude) {
        var previousElement, previousScope;
        scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
          if (previousElement) {
            $animate.leave(previousElement);
          }
          if (previousScope) {
            previousScope.$destroy();
            previousScope = null;
          }
          if (value || value === 0) {
            previousScope = scope.$new();
            $transclude(previousScope, function(element) {
              previousElement = element;
              $animate.enter(element, null, $element);
            });
          }
        });
      }
    };
  }];
  angular.module('ngAnimate', [])
    .directive('ngAnimateSwap', ngAnimateSwapDirective)
    .directive('ngAnimateChildren', $$AnimateChildrenDirective)
    .factory('$$rAFScheduler', $$rAFSchedulerFactory)
    .provider('$$animateQueue', $$AnimateQueueProvider)
    .provider('$$animation', $$AnimationProvider)
    .provider('$animateCss', $AnimateCssProvider)
    .provider('$$animateCssDriver', $$AnimateCssDriverProvider)
    .provider('$$animateJs', $$AnimateJsProvider)
    .provider('$$animateJsDriver', $$AnimateJsDriverProvider);
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-resource.js */
(function(window, angular, undefined) {
  'use strict';
  var $resourceMinErr = angular.$$minErr('$resource');
  var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;

  function isValidDottedPath(path) {
    return (path != null &amp;&amp; path !== '' &amp;&amp; path !== 'hasOwnProperty' &amp;&amp;
      MEMBER_NAME_REGEX.test('.' + path));
  }

  function lookupDottedPath(obj, path) {
    if (!isValidDottedPath(path)) {
      throw $resourceMinErr('badmember', 'Dotted member path "@{0}" is invalid.', path);
    }
    var keys = path.split('.');
    for (var i = 0, ii = keys.length; i &lt; ii &amp;&amp; angular.isDefined(obj); i++) {
      var key = keys[i];
      obj = (obj !== null) ? obj[key] : undefined;
    }
    return obj;
  }

  function shallowClearAndCopy(src, dst) {
    dst = dst || {};
    angular.forEach(dst, function(value, key) {
      delete dst[key];
    });
    for (var key in src) {
      if (src.hasOwnProperty(key) &amp;&amp; !(key.charAt(0) === '$' &amp;&amp; key.charAt(1) === '$')) {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  angular.module('ngResource', ['ng']).
  provider('$resource', function() {
    var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\/\/[^\/]*/;
    var provider = this;
    this.defaults = {
      stripTrailingSlashes: true,
      actions: {
        'get': {
          method: 'GET'
        },
        'save': {
          method: 'POST'
        },
        'query': {
          method: 'GET',
          isArray: true
        },
        'remove': {
          method: 'DELETE'
        },
        'delete': {
          method: 'DELETE'
        }
      }
    };
    this.$get = ['$http', '$log', '$q', '$timeout', function($http, $log, $q, $timeout) {
      var noop = angular.noop,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        isFunction = angular.isFunction;

      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).
        replace(/%26/gi, '&amp;').
        replace(/%3D/gi, '=').
        replace(/%2B/gi, '+');
      }

      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }

      function Route(template, defaults) {
        this.template = template;
        this.defaults = extend({}, provider.defaults, defaults);
        this.urlParams = {};
      }
      Route.prototype = {
        setUrlParams: function(config, params, actionUrl) {
          var self = this,
            url = actionUrl || self.template,
            val,
            encodedVal,
            protocolAndDomain = '';
          var urlParams = self.urlParams = {};
          forEach(url.split(/\W/), function(param) {
            if (param === 'hasOwnProperty') {
              throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
            }
            if (!(new RegExp("^\\d+$").test(param)) &amp;&amp; param &amp;&amp;
              (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
              urlParams[param] = {
                isQueryParamValue: (new RegExp("\\?.*=:" + param + "(?:\\W|$)")).test(url)
              };
            }
          });
          url = url.replace(/\\:/g, ':');
          url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function(match) {
            protocolAndDomain = match;
            return '';
          });
          params = params || {};
          forEach(self.urlParams, function(paramInfo, urlParam) {
            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
            if (angular.isDefined(val) &amp;&amp; val !== null) {
              if (paramInfo.isQueryParamValue) {
                encodedVal = encodeUriQuery(val, true);
              } else {
                encodedVal = encodeUriSegment(val);
              }
              url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                return encodedVal + p1;
              });
            } else {
              url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match,
                leadingSlashes, tail) {
                if (tail.charAt(0) == '/') {
                  return tail;
                } else {
                  return leadingSlashes + tail;
                }
              });
            }
          });
          if (self.defaults.stripTrailingSlashes) {
            url = url.replace(/\/+$/, '') || '/';
          }
          url = url.replace(/\/\.(?=\w+($|\?))/, '.');
          config.url = protocolAndDomain + url.replace(/\/\\\./, '/.');
          forEach(params, function(value, key) {
            if (!self.urlParams[key]) {
              config.params = config.params || {};
              config.params[key] = value;
            }
          });
        }
      };

      function resourceFactory(url, paramDefaults, actions, options) {
        var route = new Route(url, options);
        actions = extend({}, provider.defaults.actions, actions);

        function extractParams(data, actionParams) {
          var ids = {};
          actionParams = extend({}, paramDefaults, actionParams);
          forEach(actionParams, function(value, key) {
            if (isFunction(value)) {
              value = value();
            }
            ids[key] = value &amp;&amp; value.charAt &amp;&amp; value.charAt(0) == '@' ?
              lookupDottedPath(data, value.substr(1)) : value;
          });
          return ids;
        }

        function defaultResponseInterceptor(response) {
          return response.resource;
        }

        function Resource(value) {
          shallowClearAndCopy(value || {}, this);
        }
        Resource.prototype.toJSON = function() {
          var data = extend({}, this);
          delete data.$promise;
          delete data.$resolved;
          return data;
        };
        forEach(actions, function(action, name) {
          var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
          var numericTimeout = action.timeout;
          var cancellable = angular.isDefined(action.cancellable) ? action.cancellable :
            (options &amp;&amp; angular.isDefined(options.cancellable)) ? options.cancellable :
            provider.defaults.cancellable;
          if (numericTimeout &amp;&amp; !angular.isNumber(numericTimeout)) {
            $log.debug('ngResource:\n' +
              '  Only numeric values are allowed as `timeout`.\n' +
              '  Promises are not supported in $resource, because the same value would ' +
              'be used for multiple requests. If you are looking for a way to cancel ' +
              'requests, you should use the `cancellable` option.');
            delete action.timeout;
            numericTimeout = null;
          }
          Resource[name] = function(a1, a2, a3, a4) {
            var params = {},
              data, success, error;
            switch (arguments.length) {
              case 4:
                error = a4;
                success = a3;
              case 3:
              case 2:
                if (isFunction(a2)) {
                  if (isFunction(a1)) {
                    success = a1;
                    error = a2;
                    break;
                  }
                  success = a2;
                  error = a3;
                } else {
                  params = a1;
                  data = a2;
                  success = a3;
                  break;
                }
              case 1:
                if (isFunction(a1)) success = a1;
                else if (hasBody) data = a1;
                else params = a1;
                break;
              case 0:
                break;
              default:
                throw $resourceMinErr('badargs',
                  "Expected up to 4 arguments [params, data, success, error], got {0} arguments",
                  arguments.length);
            }
            var isInstanceCall = this instanceof Resource;
            var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));
            var httpConfig = {};
            var responseInterceptor = action.interceptor &amp;&amp; action.interceptor.response ||
              defaultResponseInterceptor;
            var responseErrorInterceptor = action.interceptor &amp;&amp; action.interceptor.responseError ||
              undefined;
            var timeoutDeferred;
            var numericTimeoutPromise;
            forEach(action, function(value, key) {
              switch (key) {
                default: httpConfig[key] = copy(value);
                break;
                case 'params':
                    case 'isArray':
                    case 'interceptor':
                    case 'cancellable':
                    break;
              }
            });
            if (!isInstanceCall &amp;&amp; cancellable) {
              timeoutDeferred = $q.defer();
              httpConfig.timeout = timeoutDeferred.promise;
              if (numericTimeout) {
                numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);
              }
            }
            if (hasBody) httpConfig.data = data;
            route.setUrlParams(httpConfig,
              extend({}, extractParams(data, action.params || {}), params),
              action.url);
            var promise = $http(httpConfig).then(function(response) {
              var data = response.data;
              if (data) {
                if (angular.isArray(data) !== (!!action.isArray)) {
                  throw $resourceMinErr('badcfg',
                    'Error in resource configuration for action `{0}`. Expected response to ' +
                    'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object',
                    angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);
                }
                if (action.isArray) {
                  value.length = 0;
                  forEach(data, function(item) {
                    if (typeof item === "object") {
                      value.push(new Resource(item));
                    } else {
                      value.push(item);
                    }
                  });
                } else {
                  var promise = value.$promise;
                  shallowClearAndCopy(data, value);
                  value.$promise = promise;
                }
              }
              response.resource = value;
              return response;
            }, function(response) {
              (error || noop)(response);
              return $q.reject(response);
            });
            promise['finally'](function() {
              value.$resolved = true;
              if (!isInstanceCall &amp;&amp; cancellable) {
                value.$cancelRequest = angular.noop;
                $timeout.cancel(numericTimeoutPromise);
                timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;
              }
            });
            promise = promise.then(
              function(response) {
                var value = responseInterceptor(response);
                (success || noop)(value, response.headers);
                return value;
              },
              responseErrorInterceptor);
            if (!isInstanceCall) {
              value.$promise = promise;
              value.$resolved = false;
              if (cancellable) value.$cancelRequest = timeoutDeferred.resolve;
              return value;
            }
            return promise;
          };
          Resource.prototype['$' + name] = function(params, success, error) {
            if (isFunction(params)) {
              error = success;
              success = params;
              params = {};
            }
            var result = Resource[name].call(this, params, this, success, error);
            return result.$promise || result;
          };
        });
        Resource.bind = function(additionalParamDefaults) {
          return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
        };
        return Resource;
      }
      return resourceFactory;
    }];
  });
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-route.js */
(function(window, angular, undefined) {
  'use strict';
  var ngRouteModule = angular.module('ngRoute', ['ng']).
  provider('$route', $RouteProvider).
  run(['$route', angular.noop]),
    $routeMinErr = angular.$$minErr('ngRoute');

  function $RouteProvider() {
    function inherit(parent, extra) {
      return angular.extend(Object.create(parent), extra);
    }
    var routes = {};
    this.when = function(path, route) {
      var routeCopy = angular.copy(route);
      if (angular.isUndefined(routeCopy.reloadOnSearch)) {
        routeCopy.reloadOnSearch = true;
      }
      if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
        routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
      }
      routes[path] = angular.extend(
        routeCopy,
        path &amp;&amp; pathRegExp(path, routeCopy)
      );
      if (path) {
        var redirectPath = (path[path.length - 1] == '/') ?
          path.substr(0, path.length - 1) :
          path + '/';
        routes[redirectPath] = angular.extend({
            redirectTo: path
          },
          pathRegExp(redirectPath, routeCopy)
        );
      }
      return this;
    };
    this.caseInsensitiveMatch = false;

    function pathRegExp(path, opts) {
      var insensitive = opts.caseInsensitiveMatch,
        ret = {
          originalPath: path,
          regexp: path
        },
        keys = ret.keys = [];
      path = path
        .replace(/([().])/g, '\\$1')
        .replace(/(\/)?:(\w+)(\*\?|[\?\*])?/g, function(_, slash, key, option) {
          var optional = (option === '?' || option === '*?') ? '?' : null;
          var star = (option === '*' || option === '*?') ? '*' : null;
          keys.push({
            name: key,
            optional: !!optional
          });
          slash = slash || '';
          return '' +
            (optional ? '' : slash) +
            '(?:' +
            (optional ? slash : '') +
            (star &amp;&amp; '(.+?)' || '([^/]+)') +
            (optional || '') +
            ')' +
            (optional || '');
        })
        .replace(/([\/$\*])/g, '\\$1');
      ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
      return ret;
    }
    this.otherwise = function(params) {
      if (typeof params === 'string') {
        params = {
          redirectTo: params
        };
      }
      this.when(null, params);
      return this;
    };
    this.$get = ['$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$templateRequest',
      '$sce',
      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
        var forceReload = false,
          preparedRoute,
          preparedRouteIsUpdateOnly,
          $route = {
            routes: routes,
            reload: function() {
              forceReload = true;
              var fakeLocationEvent = {
                defaultPrevented: false,
                preventDefault: function fakePreventDefault() {
                  this.defaultPrevented = true;
                  forceReload = false;
                }
              };
              $rootScope.$evalAsync(function() {
                prepareRoute(fakeLocationEvent);
                if (!fakeLocationEvent.defaultPrevented) commitRoute();
              });
            },
            updateParams: function(newParams) {
              if (this.current &amp;&amp; this.current.$$route) {
                newParams = angular.extend({}, this.current.params, newParams);
                $location.path(interpolate(this.current.$$route.originalPath, newParams));
                $location.search(newParams);
              } else {
                throw $routeMinErr('norout', 'Tried updating route when with no current route');
              }
            }
          };
        $rootScope.$on('$locationChangeStart', prepareRoute);
        $rootScope.$on('$locationChangeSuccess', commitRoute);
        return $route;

        function switchRouteMatcher(on, route) {
          var keys = route.keys,
            params = {};
          if (!route.regexp) return null;
          var m = route.regexp.exec(on);
          if (!m) return null;
          for (var i = 1, len = m.length; i &lt; len; ++i) {
            var key = keys[i - 1];
            var val = m[i];
            if (key &amp;&amp; val) {
              params[key.name] = val;
            }
          }
          return params;
        }

        function prepareRoute($locationEvent) {
          var lastRoute = $route.current;
          preparedRoute = parseRoute();
          preparedRouteIsUpdateOnly = preparedRoute &amp;&amp; lastRoute &amp;&amp; preparedRoute.$$route === lastRoute.$$route &amp;&amp;
            angular.equals(preparedRoute.pathParams, lastRoute.pathParams) &amp;&amp;
            !preparedRoute.reloadOnSearch &amp;&amp; !forceReload;
          if (!preparedRouteIsUpdateOnly &amp;&amp; (lastRoute || preparedRoute)) {
            if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
              if ($locationEvent) {
                $locationEvent.preventDefault();
              }
            }
          }
        }

        function commitRoute() {
          var lastRoute = $route.current;
          var nextRoute = preparedRoute;
          if (preparedRouteIsUpdateOnly) {
            lastRoute.params = nextRoute.params;
            angular.copy(lastRoute.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', lastRoute);
          } else if (nextRoute || lastRoute) {
            forceReload = false;
            $route.current = nextRoute;
            if (nextRoute) {
              if (nextRoute.redirectTo) {
                if (angular.isString(nextRoute.redirectTo)) {
                  $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)
                    .replace();
                } else {
                  $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))
                    .replace();
                }
              }
            }
            $q.when(nextRoute).
            then(function() {
              if (nextRoute) {
                var locals = angular.extend({}, nextRoute.resolve),
                  template, templateUrl;
                angular.forEach(locals, function(value, key) {
                  locals[key] = angular.isString(value) ?
                    $injector.get(value) : $injector.invoke(value, null, null, key);
                });
                if (angular.isDefined(template = nextRoute.template)) {
                  if (angular.isFunction(template)) {
                    template = template(nextRoute.params);
                  }
                } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {
                  if (angular.isFunction(templateUrl)) {
                    templateUrl = templateUrl(nextRoute.params);
                  }
                  if (angular.isDefined(templateUrl)) {
                    nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);
                    template = $templateRequest(templateUrl);
                  }
                }
                if (angular.isDefined(template)) {
                  locals['$template'] = template;
                }
                return $q.all(locals);
              }
            }).
            then(function(locals) {
              if (nextRoute == $route.current) {
                if (nextRoute) {
                  nextRoute.locals = locals;
                  angular.copy(nextRoute.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
              }
            }, function(error) {
              if (nextRoute == $route.current) {
                $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
              }
            });
          }
        }

        function parseRoute() {
          var params, match;
          angular.forEach(routes, function(route, path) {
            if (!match &amp;&amp; (params = switchRouteMatcher($location.path(), route))) {
              match = inherit(route, {
                params: angular.extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] &amp;&amp; inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }

        function interpolate(string, params) {
          var result = [];
          angular.forEach((string || '').split(':'), function(segment, i) {
            if (i === 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  ngRouteModule.provider('$routeParams', $RouteParamsProvider);

  function $RouteParamsProvider() {
    this.$get = function() {
      return {};
    };
  }
  ngRouteModule.directive('ngView', ngViewFactory);
  ngRouteModule.directive('ngView', ngViewFillContentFactory);
  ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];

  function ngViewFactory($route, $anchorScroll, $animate) {
    return {
      restrict: 'ECA',
      terminal: true,
      priority: 400,
      transclude: 'element',
      link: function(scope, $element, attr, ctrl, $transclude) {
        var currentScope,
          currentElement,
          previousLeaveAnimation,
          autoScrollExp = attr.autoscroll,
          onloadExp = attr.onload || '';
        scope.$on('$routeChangeSuccess', update);
        update();

        function cleanupLastView() {
          if (previousLeaveAnimation) {
            $animate.cancel(previousLeaveAnimation);
            previousLeaveAnimation = null;
          }
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if (currentElement) {
            previousLeaveAnimation = $animate.leave(currentElement);
            previousLeaveAnimation.then(function() {
              previousLeaveAnimation = null;
            });
            currentElement = null;
          }
        }

        function update() {
          var locals = $route.current &amp;&amp; $route.current.locals,
            template = locals &amp;&amp; locals.$template;
          if (angular.isDefined(template)) {
            var newScope = scope.$new();
            var current = $route.current;
            var clone = $transclude(newScope, function(clone) {
              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
                if (angular.isDefined(autoScrollExp) &amp;&amp;
                  (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              });
              cleanupLastView();
            });
            currentElement = clone;
            currentScope = current.scope = newScope;
            currentScope.$emit('$viewContentLoaded');
            currentScope.$eval(onloadExp);
          } else {
            cleanupLastView();
          }
        }
      }
    };
  }
  ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];

  function ngViewFillContentFactory($compile, $controller, $route) {
    return {
      restrict: 'ECA',
      priority: -400,
      link: function(scope, $element) {
        var current = $route.current,
          locals = current.locals;
        $element.html(locals.$template);
        var link = $compile($element.contents());
        if (current.controller) {
          locals.$scope = scope;
          var controller = $controller(current.controller, locals);
          if (current.controllerAs) {
            scope[current.controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }
        scope[current.resolveAs || '$resolve'] = locals;
        link(scope);
      }
    };
  }
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-touch.js */
(function(window, angular, undefined) {
  'use strict';
  var ngTouch = angular.module('ngTouch', []);
  ngTouch.provider('$touch', $TouchProvider);

  function nodeName_(element) {
    return angular.lowercase(element.nodeName || (element[0] &amp;&amp; element[0].nodeName));
  }
  $TouchProvider.$inject = ['$provide', '$compileProvider'];

  function $TouchProvider($provide, $compileProvider) {
    var ngClickOverrideEnabled = false;
    var ngClickDirectiveAdded = false;
    this.ngClickOverrideEnabled = function(enabled) {
      if (angular.isDefined(enabled)) {
        if (enabled &amp;&amp; !ngClickDirectiveAdded) {
          ngClickDirectiveAdded = true;
          ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';
          $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);
          $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
            if (ngClickOverrideEnabled) {
              $delegate.shift();
            } else {
              var i = $delegate.length - 1;
              while (i &gt;= 0) {
                if ($delegate[i].$$moduleName === 'ngTouch') {
                  $delegate.splice(i, 1);
                  break;
                }
                i--;
              }
            }
            return $delegate;
          }]);
        }
        ngClickOverrideEnabled = enabled;
        return this;
      }
      return ngClickOverrideEnabled;
    };
    this.$get = function() {
      return {
        ngClickOverrideEnabled: function() {
          return ngClickOverrideEnabled;
        }
      };
    };
  }
  ngTouch.factory('$swipe', [function() {
    var MOVE_BUFFER_RADIUS = 10;
    var POINTER_EVENTS = {
      'mouse': {
        start: 'mousedown',
        move: 'mousemove',
        end: 'mouseup'
      },
      'touch': {
        start: 'touchstart',
        move: 'touchmove',
        end: 'touchend',
        cancel: 'touchcancel'
      }
    };

    function getCoordinates(event) {
      var originalEvent = event.originalEvent || event;
      var touches = originalEvent.touches &amp;&amp; originalEvent.touches.length ? originalEvent.touches : [originalEvent];
      var e = (originalEvent.changedTouches &amp;&amp; originalEvent.changedTouches[0]) || touches[0];
      return {
        x: e.clientX,
        y: e.clientY
      };
    }

    function getEvents(pointerTypes, eventType) {
      var res = [];
      angular.forEach(pointerTypes, function(pointerType) {
        var eventName = POINTER_EVENTS[pointerType][eventType];
        if (eventName) {
          res.push(eventName);
        }
      });
      return res.join(' ');
    }
    return {
      bind: function(element, eventHandlers, pointerTypes) {
        var totalX, totalY;
        var startCoords;
        var lastPos;
        var active = false;
        pointerTypes = pointerTypes || ['mouse', 'touch'];
        element.on(getEvents(pointerTypes, 'start'), function(event) {
          startCoords = getCoordinates(event);
          active = true;
          totalX = 0;
          totalY = 0;
          lastPos = startCoords;
          eventHandlers['start'] &amp;&amp; eventHandlers['start'](startCoords, event);
        });
        var events = getEvents(pointerTypes, 'cancel');
        if (events) {
          element.on(events, function(event) {
            active = false;
            eventHandlers['cancel'] &amp;&amp; eventHandlers['cancel'](event);
          });
        }
        element.on(getEvents(pointerTypes, 'move'), function(event) {
          if (!active) return;
          if (!startCoords) return;
          var coords = getCoordinates(event);
          totalX += Math.abs(coords.x - lastPos.x);
          totalY += Math.abs(coords.y - lastPos.y);
          lastPos = coords;
          if (totalX &lt; MOVE_BUFFER_RADIUS &amp;&amp; totalY &lt; MOVE_BUFFER_RADIUS) {
            return;
          }
          if (totalY &gt; totalX) {
            active = false;
            eventHandlers['cancel'] &amp;&amp; eventHandlers['cancel'](event);
            return;
          } else {
            event.preventDefault();
            eventHandlers['move'] &amp;&amp; eventHandlers['move'](coords, event);
          }
        });
        element.on(getEvents(pointerTypes, 'end'), function(event) {
          if (!active) return;
          active = false;
          eventHandlers['end'] &amp;&amp; eventHandlers['end'](getCoordinates(event), event);
        });
      }
    };
  }]);
  var ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',
    function($parse, $timeout, $rootElement) {
      var TAP_DURATION = 750;
      var MOVE_TOLERANCE = 12;
      var PREVENT_DURATION = 2500;
      var CLICKBUSTER_THRESHOLD = 25;
      var ACTIVE_CLASS_NAME = 'ng-click-active';
      var lastPreventedTime;
      var touchCoordinates;
      var lastLabelClickCoordinates;

      function hit(x1, y1, x2, y2) {
        return Math.abs(x1 - x2) &lt; CLICKBUSTER_THRESHOLD &amp;&amp; Math.abs(y1 - y2) &lt; CLICKBUSTER_THRESHOLD;
      }

      function checkAllowableRegions(touchCoordinates, x, y) {
        for (var i = 0; i &lt; touchCoordinates.length; i += 2) {
          if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
            touchCoordinates.splice(i, i + 2);
            return true;
          }
        }
        return false;
      }

      function onClick(event) {
        if (Date.now() - lastPreventedTime &gt; PREVENT_DURATION) {
          return;
        }
        var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        if (x &lt; 1 &amp;&amp; y &lt; 1) {
          return;
        }
        if (lastLabelClickCoordinates &amp;&amp;
          lastLabelClickCoordinates[0] === x &amp;&amp; lastLabelClickCoordinates[1] === y) {
          return;
        }
        if (lastLabelClickCoordinates) {
          lastLabelClickCoordinates = null;
        }
        if (nodeName_(event.target) === 'label') {
          lastLabelClickCoordinates = [x, y];
        }
        if (checkAllowableRegions(touchCoordinates, x, y)) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        event.target &amp;&amp; event.target.blur &amp;&amp; event.target.blur();
      }

      function onTouchStart(event) {
        var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
        var x = touches[0].clientX;
        var y = touches[0].clientY;
        touchCoordinates.push(x, y);
        $timeout(function() {
          for (var i = 0; i &lt; touchCoordinates.length; i += 2) {
            if (touchCoordinates[i] == x &amp;&amp; touchCoordinates[i + 1] == y) {
              touchCoordinates.splice(i, i + 2);
              return;
            }
          }
        }, PREVENT_DURATION, false);
      }

      function preventGhostClick(x, y) {
        if (!touchCoordinates) {
          $rootElement[0].addEventListener('click', onClick, true);
          $rootElement[0].addEventListener('touchstart', onTouchStart, true);
          touchCoordinates = [];
        }
        lastPreventedTime = Date.now();
        checkAllowableRegions(touchCoordinates, x, y);
      }
      return function(scope, element, attr) {
        var clickHandler = $parse(attr.ngClick),
          tapping = false,
          tapElement,
          startTime,
          touchStartX,
          touchStartY;

        function resetState() {
          tapping = false;
          element.removeClass(ACTIVE_CLASS_NAME);
        }
        element.on('touchstart', function(event) {
          tapping = true;
          tapElement = event.target ? event.target : event.srcElement;
          if (tapElement.nodeType == 3) {
            tapElement = tapElement.parentNode;
          }
          element.addClass(ACTIVE_CLASS_NAME);
          startTime = Date.now();
          var originalEvent = event.originalEvent || event;
          var touches = originalEvent.touches &amp;&amp; originalEvent.touches.length ? originalEvent.touches : [originalEvent];
          var e = touches[0];
          touchStartX = e.clientX;
          touchStartY = e.clientY;
        });
        element.on('touchcancel', function(event) {
          resetState();
        });
        element.on('touchend', function(event) {
          var diff = Date.now() - startTime;
          var originalEvent = event.originalEvent || event;
          var touches = (originalEvent.changedTouches &amp;&amp; originalEvent.changedTouches.length) ?
            originalEvent.changedTouches :
            ((originalEvent.touches &amp;&amp; originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);
          var e = touches[0];
          var x = e.clientX;
          var y = e.clientY;
          var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
          if (tapping &amp;&amp; diff &lt; TAP_DURATION &amp;&amp; dist &lt; MOVE_TOLERANCE) {
            preventGhostClick(x, y);
            if (tapElement) {
              tapElement.blur();
            }
            if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
              element.triggerHandler('click', [event]);
            }
          }
          resetState();
        });
        element.onclick = function(event) {};
        element.on('click', function(event, touchend) {
          scope.$apply(function() {
            clickHandler(scope, {
              $event: (touchend || event)
            });
          });
        });
        element.on('mousedown', function(event) {
          element.addClass(ACTIVE_CLASS_NAME);
        });
        element.on('mousemove mouseup', function(event) {
          element.removeClass(ACTIVE_CLASS_NAME);
        });
      };
    }
  ];

  function makeSwipeDirective(directiveName, direction, eventName) {
    ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {
      var MAX_VERTICAL_DISTANCE = 75;
      var MAX_VERTICAL_RATIO = 0.3;
      var MIN_HORIZONTAL_DISTANCE = 30;
      return function(scope, element, attr) {
        var swipeHandler = $parse(attr[directiveName]);
        var startCoords, valid;

        function validSwipe(coords) {
          if (!startCoords) return false;
          var deltaY = Math.abs(coords.y - startCoords.y);
          var deltaX = (coords.x - startCoords.x) * direction;
          return valid &amp;&amp;
            deltaY &lt; MAX_VERTICAL_DISTANCE &amp;&amp;
            deltaX &gt; 0 &amp;&amp;
            deltaX &gt; MIN_HORIZONTAL_DISTANCE &amp;&amp;
            deltaY / deltaX &lt; MAX_VERTICAL_RATIO;
        }
        var pointerTypes = ['touch'];
        if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {
          pointerTypes.push('mouse');
        }
        $swipe.bind(element, {
          'start': function(coords, event) {
            startCoords = coords;
            valid = true;
          },
          'cancel': function(event) {
            valid = false;
          },
          'end': function(coords, event) {
            if (validSwipe(coords)) {
              scope.$apply(function() {
                element.triggerHandler(eventName);
                swipeHandler(scope, {
                  $event: event
                });
              });
            }
          }
        }, pointerTypes);
      };
    }]);
  }
  makeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');
  makeSwipeDirective('ngSwipeRight', 1, 'swiperight');
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-cookies.js */
(function(window, angular, undefined) {
  'use strict';
  angular.module('ngCookies', ['ng']).
  provider('$cookies', [function $CookiesProvider() {
    var defaults = this.defaults = {};

    function calcOptions(options) {
      return options ? angular.extend({}, defaults, options) : defaults;
    }
    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
      return {
        get: function(key) {
          return $$cookieReader()[key];
        },
        getObject: function(key) {
          var value = this.get(key);
          return value ? angular.fromJson(value) : value;
        },
        getAll: function() {
          return $$cookieReader();
        },
        put: function(key, value, options) {
          $$cookieWriter(key, value, calcOptions(options));
        },
        putObject: function(key, value, options) {
          this.put(key, angular.toJson(value), options);
        },
        remove: function(key, options) {
          $$cookieWriter(key, undefined, calcOptions(options));
        }
      };
    }];
  }]);
  angular.module('ngCookies').
  factory('$cookieStore', ['$cookies', function($cookies) {
    return {
      get: function(key) {
        return $cookies.getObject(key);
      },
      put: function(key, value) {
        $cookies.putObject(key, value);
      },
      remove: function(key) {
        $cookies.remove(key);
      }
    };
  }]);

  function $$CookieWriter($document, $log, $browser) {
    var cookiePath = $browser.baseHref();
    var rawDocument = $document[0];

    function buildCookieString(name, value, options) {
      var path, expires;
      options = options || {};
      expires = options.expires;
      path = angular.isDefined(options.path) ? options.path : cookiePath;
      if (angular.isUndefined(value)) {
        expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
        value = '';
      }
      if (angular.isString(expires)) {
        expires = new Date(expires);
      }
      var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
      str += path ? ';path=' + path : '';
      str += options.domain ? ';domain=' + options.domain : '';
      str += expires ? ';expires=' + expires.toUTCString() : '';
      str += options.secure ? ';secure' : '';
      var cookieLength = str.length + 1;
      if (cookieLength &gt; 4096) {
        $log.warn("Cookie '" + name +
          "' possibly not set or overflowed because it was too large (" +
          cookieLength + " &gt; 4096 bytes)!");
      }
      return str;
    }
    return function(name, value, options) {
      rawDocument.cookie = buildCookieString(name, value, options);
    };
  }
  $$CookieWriter.$inject = ['$document', '$log', '$browser'];
  angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
    this.$get = $$CookieWriter;
  });
})(window, window.angular);;
/*! RESOURCE: /scripts/angular_1.5.3/angular-aria.js */
(function(window, angular, undefined) {
  'use strict';
  var ngAriaModule = angular.module('ngAria', ['ng']).
  provider('$aria', $AriaProvider);
  var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];
  var isNodeOneOf = function(elem, nodeTypeArray) {
    if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
      return true;
    }
  };

  function $AriaProvider() {
    var config = {
      ariaHidden: true,
      ariaChecked: true,
      ariaDisabled: true,
      ariaRequired: true,
      ariaInvalid: true,
      ariaValue: true,
      tabindex: true,
      bindKeypress: true,
      bindRoleForClick: true
    };
    this.config = function(newConfig) {
      config = angular.extend(config, newConfig);
    };

    function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
      return function(scope, elem, attr) {
        var ariaCamelName = attr.$normalize(ariaAttr);
        if (config[ariaCamelName] &amp;&amp; !isNodeOneOf(elem, nodeBlackList) &amp;&amp; !attr[ariaCamelName]) {
          scope.$watch(attr[attrName], function(boolVal) {
            boolVal = negate ? !boolVal : !!boolVal;
            elem.attr(ariaAttr, boolVal);
          });
        }
      };
    }
    this.$get = function() {
      return {
        config: function(key) {
          return config[key];
        },
        $$watchExpr: watchExpr
      };
    };
  }
  ngAriaModule.directive('ngShow', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
    }])
    .directive('ngHide', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
    }])
    .directive('ngValue', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
    }])
    .directive('ngChecked', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
    }])
    .directive('ngRequired', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
    }])
    .directive('ngModel', ['$aria', function($aria) {
      function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
        return $aria.config(normalizedAttr) &amp;&amp; !elem.attr(attr) &amp;&amp; (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList));
      }

      function shouldAttachRole(role, elem) {
        return !elem.attr('role') &amp;&amp; (elem.attr('type') === role) &amp;&amp; (elem[0].nodeName !== 'INPUT');
      }

      function getShape(attr, elem) {
        var type = attr.type,
          role = attr.role;
        return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :
          ((type || role) === 'radio' || role === 'menuitemradio') ? 'radio' :
          (type === 'range' || role === 'progressbar' || role === 'slider') ? 'range' : '';
      }
      return {
        restrict: 'A',
        require: 'ngModel',
        priority: 200,
        compile: function(elem, attr) {
          var shape = getShape(attr, elem);
          return {
            pre: function(scope, elem, attr, ngModel) {
              if (shape === 'checkbox') {
                ngModel.$isEmpty = function(value) {
                  return value === false;
                };
              }
            },
            post: function(scope, elem, attr, ngModel) {
              var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);

              function ngAriaWatchModelValue() {
                return ngModel.$modelValue;
              }

              function getRadioReaction(newVal) {
                var boolVal = (attr.value == ngModel.$viewValue);
                elem.attr('aria-checked', boolVal);
              }

              function getCheckboxReaction() {
                elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
              }
              switch (shape) {
                case 'radio':
                case 'checkbox':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', shape);
                  }
                  if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                    scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?
                      getRadioReaction : getCheckboxReaction);
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
                case 'range':
                  if (shouldAttachRole(shape, elem)) {
                    elem.attr('role', 'slider');
                  }
                  if ($aria.config('ariaValue')) {
                    var needsAriaValuemin = !elem.attr('aria-valuemin') &amp;&amp;
                      (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                    var needsAriaValuemax = !elem.attr('aria-valuemax') &amp;&amp;
                      (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                    var needsAriaValuenow = !elem.attr('aria-valuenow');
                    if (needsAriaValuemin) {
                      attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemin', newVal);
                      });
                    }
                    if (needsAriaValuemax) {
                      attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                        elem.attr('aria-valuemax', newVal);
                      });
                    }
                    if (needsAriaValuenow) {
                      scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                        elem.attr('aria-valuenow', newVal);
                      });
                    }
                  }
                  if (needsTabIndex) {
                    elem.attr('tabindex', 0);
                  }
                  break;
              }
              if (!attr.hasOwnProperty('ngRequired') &amp;&amp; ngModel.$validators.required &amp;&amp;
                shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
                attr.$observe('required', function() {
                  elem.attr('aria-required', !!attr['required']);
                });
              }
              if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
                scope.$watch(function ngAriaInvalidWatch() {
                  return ngModel.$invalid;
                }, function ngAriaInvalidReaction(newVal) {
                  elem.attr('aria-invalid', !!newVal);
                });
              }
            }
          };
        }
      };
    }])
    .directive('ngDisabled', ['$aria', function($aria) {
      return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
    }])
    .directive('ngMessages', function() {
      return {
        restrict: 'A',
        require: '?ngMessages',
        link: function(scope, elem, attr, ngMessages) {
          if (!elem.attr('aria-live')) {
            elem.attr('aria-live', 'assertive');
          }
        }
      };
    })
    .directive('ngClick', ['$aria', '$parse', function($aria, $parse) {
      return {
        restrict: 'A',
        compile: function(elem, attr) {
          var fn = $parse(attr.ngClick, null, true);
          return function(scope, elem, attr) {
            if (!isNodeOneOf(elem, nodeBlackList)) {
              if ($aria.config('bindRoleForClick') &amp;&amp; !elem.attr('role')) {
                elem.attr('role', 'button');
              }
              if ($aria.config('tabindex') &amp;&amp; !elem.attr('tabindex')) {
                elem.attr('tabindex', 0);
              }
              if ($aria.config('bindKeypress') &amp;&amp; !attr.ngKeypress) {
                elem.on('keypress', function(event) {
                  var keyCode = event.which || event.keyCode;
                  if (keyCode === 32 || keyCode === 13) {
                    scope.$apply(callback);
                  }

                  function callback() {
                    fn(scope, {
                      $event: event
                    });
                  }
                });
              }
            }
          };
        }
      };
    }])
    .directive('ngDblclick', ['$aria', function($aria) {
      return function(scope, elem, attr) {
        if ($aria.config('tabindex') &amp;&amp; !elem.attr('tabindex') &amp;&amp; !isNodeOneOf(elem, nodeBlackList)) {
          elem.attr('tabindex', 0);
        }
      };
    }]);
})(window, window.angular);;
/*! RESOURCE: /scripts/app/base/_module.js */
angular.module('sn.base', ['sn.common.auth']);
window.countWatchers = window.countWatchers || function(root) {
  var watchers = [];
  var f = function(element) {
    angular.forEach(['$scope', '$isolateScope'], function(scopeProperty) {
      if (element.data() &amp;&amp; element.data().hasOwnProperty(scopeProperty)) {
        angular.forEach(element.data()[scopeProperty].$$watchers, function(watcher) {
          watchers.push(watcher);
        });
      }
    });
    angular.forEach(element.children(), function(childElement) {
      f(angular.element(childElement));
    });
  };
  f(root);
  var watchersWithoutDuplicates = [];
  angular.forEach(watchers, function(item) {
    if (watchersWithoutDuplicates.indexOf(item) &lt; 0) {
      watchersWithoutDuplicates.push(item);
    }
  });
  console.log(watchersWithoutDuplicates.length);
};;
/*! RESOURCE: /scripts/sn/common/auth/_module.js */
angular.module('sn.common.auth', []);
angular.module('sn.auth', ['sn.common.auth']);;
/*! RESOURCE: /scripts/sn/common/auth/service.authInterceptor.js */
angular.module('sn.common.auth').config(function($httpProvider) {
  $httpProvider.interceptors.push(function($rootScope, $q, $injector, $window, $log) {
    var LOG_PREFIX = '(authIntercepter) ';

    function error(response) {
      var status = response.status;
      if (status == 401) {
        var newPromise = handle401(response);
        if (newPromise)
          return newPromise;
      }
      return $q.reject(response);
    }

    function handle401(response) {
      if (canResendRequest(response)) {
        var deferredAgain = $q.defer();
        var $http = $injector.get('$http');
        $http(response.config).then(function success(newResponse) {
          deferredAgain.resolve(newResponse);
        }, function error(newResponse) {
          deferredAgain.reject(newResponse);
        });
        return deferredAgain.promise;
      }
      $log.info(LOG_PREFIX + 'User has been logged out');
      $rootScope.$broadcast("@page.login");
      return null;
    }

    function canResendRequest(response) {
      var headers = response.headers();
      var requestToken = response.config.headers['X-UserToken'];
      if (!requestToken) {
        requestToken = headers['x-usertoken-request'];
      }
      if ($window.g_ck &amp;&amp; (requestToken !== $window.g_ck)) {
        $log.info(LOG_PREFIX + 'Token refreshed since request -- retrying');
        response.config.headers['X-UserToken'] = $window.g_ck;
        return true;
      }
      if (headers['x-sessionloggedin'] != 'true')
        return false;
      if (headers['x-usertoken-allowresubmit'] == 'false')
        return false;
      var token = headers['x-usertoken-response'];
      if (token) {
        $log.info(LOG_PREFIX + 'Received new token -- retrying');
        response.config.headers['X-UserToken'] = token;
        setToken(token);
        return true;
      }
      return false;
    }

    function setToken(token) {
      $window.g_ck = token;
      if (!token) {
        $httpProvider.defaults.headers.common["X-UserToken"] = 'token_intentionally_left_blank';
      } else {
        $httpProvider.defaults.headers.common["X-UserToken"] = token;
      }
      if ($window.jQuery) {
        jQuery.ajaxSetup({
          headers: {
            'X-UserToken': token
          }
        });
      }
      if ($window.Zepto) {
        if (!Zepto.ajaxSettings.headers)
          Zepto.ajaxSettings.headers = {};
        Zepto.ajaxSettings.headers['X-UserToken'] = token;
      }
    }
    setToken($window.g_ck);
    return {
      responseError: error
    }
  });
});;;
/*! RESOURCE: /scripts/libs/angular-tooltips/angular-tooltips.min.js */
/*
 * angular-tooltips
 * 1.0.7
 *
 * Angular.js tooltips module.
 * http://720kb.github.io/angular-tooltips
 *
 * MIT license
 * Tue Jan 26 2016
 */
! function(t, o) {
  "use strict";
  var e = "tooltips",
    i = function() {
      var t = [],
        e = 0,
        i = function(i) {
          i - e &gt;= 15 ? (t.forEach(function(t) {
            t()
          }), e = i) : o.console.log("Skipped!")
        },
        r = function() {
          o.requestAnimationFrame(i)
        },
        l = function(o) {
          o &amp;&amp; t.push(o)
        };
      return {
        add: function(e) {
          t.length || o.addEventListener("resize", r), l(e)
        }
      }
    }(),
    r = function(t) {
      var o = {};
      return t.removeAttr(e), void 0 !== t.attr("tooltip-template") &amp;&amp; (o["tooltip-template"] = t.attr("tooltip-template"), t.removeAttr("tooltip-template")), void 0 !== t.attr("tooltip-template-url") &amp;&amp; (o["tooltip-template-url"] = t.attr("tooltip-template-url"), t.removeAttr("tooltip-template-url")), void 0 !== t.attr("tooltip-controller") &amp;&amp; (o["tooltip-controller"] = t.attr("tooltip-controller"), t.removeAttr("tooltip-controller")), void 0 !== t.attr("tooltip-side") &amp;&amp; (o["tooltip-side"] = t.attr("tooltip-side"), t.removeAttr("tooltip-side")), void 0 !== t.attr("tooltip-show-trigger") &amp;&amp; (o["tooltip-show-trigger"] = t.attr("tooltip-show-trigger"), t.removeAttr("tooltip-show-trigger")), void 0 !== t.attr("tooltip-hide-trigger") &amp;&amp; (o["tooltip-hide-trigger"] = t.attr("tooltip-hide-trigger"), t.removeAttr("tooltip-hide-trigger")), void 0 !== t.attr("tooltip-smart") &amp;&amp; (o["tooltip-smart"] = t.attr("tooltip-smart"), t.removeAttr("tooltip-smart")), void 0 !== t.attr("tooltip-class") &amp;&amp; (o["tooltip-class"] = t.attr("tooltip-class"), t.removeAttr("tooltip-class")), void 0 !== t.attr("tooltip-close-button") &amp;&amp; (o["tooltip-close-button"] = t.attr("tooltip-close-button"), t.removeAttr("tooltip-close-button")), void 0 !== t.attr("tooltip-size") &amp;&amp; (o["tooltip-size"] = t.attr("tooltip-size"), t.removeAttr("tooltip-size")), void 0 !== t.attr("tooltip-speed") &amp;&amp; (o["tooltip-speed"] = t.attr("tooltip-speed"), t.removeAttr("tooltip-speed")), o
    },
    l = function(t) {
      return o.getComputedStyle ? o.getComputedStyle(t, "") : t.currentStyle ? t.currentStyle : void 0
    },
    a = function(e) {
      for (var i, r, l = o.document.querySelectorAll("._exradicated-tooltip"), a = 0, n = l.length; n &gt; a; a += 1)
        if (i = l.item(a), i &amp;&amp; (r = t.element(i), r.data("_tooltip-parent") &amp;&amp; r.data("_tooltip-parent") === e)) return r
    },
    n = function(t) {
      var o = a(t);
      o &amp;&amp; o.remove()
    },
    s = function(t) {
      if (t) {
        var e = t[0].getBoundingClientRect();
        return e.top &lt; 0 || e.top &gt; o.document.body.offsetHeight || e.left &lt; 0 || e.left &gt; o.document.body.offsetWidth || e.bottom &lt; 0 || e.bottom &gt; o.document.body.offsetHeight || e.right &lt; 0 || e.right &gt; o.document.body.offsetWidth ? (t.css({
          top: "",
          left: "",
          bottom: "",
          right: ""
        }), !0) : !1
      }
      throw new Error("You must provide a position")
    },
    p = function() {
      var t = {
        side: "top",
        showTrigger: "mouseover",
        hideTrigger: "mouseleave",
        "class": "",
        smart: !1,
        closeButton: !1,
        size: "",
        speed: "steady"
      };
      return {
        configure: function(o) {
          var e, i = Object.keys(t),
            r = 0;
          if (o)
            for (; r &lt; i.length; r += 1) e = i[r], e &amp;&amp; o[e] &amp;&amp; (t[e] = o[e])
        },
        $get: function() {
          return t
        }
      }
    },
    d = ["$log", "$http", "$compile", "$timeout", "$controller", "$injector", "tooltipsConf", function(e, p, d, c, m, u, g) {
      var f = function(e, u, f, v, h) {
        if (f.tooltipTemplate &amp;&amp; f.tooltipTemplateUrl) throw new Error("You can not define tooltip-template and tooltip-url together");
        if (!f.tooltipTemplateUrl &amp;&amp; !f.tooltipTemplate &amp;&amp; f.tooltipController) throw new Error("You can not have a controller without a template or templateUrl defined");
        var C, _ = "_" + g.side,
          b = g.showTrigger,
          y = g.hideTrigger,
          w = g.size,
          S = "_" + g.speed;
        f.tooltipSide = f.tooltipSide || g.side, f.tooltipShowTrigger = f.tooltipShowTrigger || g.showTrigger, f.tooltipHideTrigger = f.tooltipHideTrigger || g.hideTrigger, f.tooltipClass = f.tooltipClass || g["class"], f.tooltipSmart = "true" === f.tooltipSmart || g.smart, f.tooltipCloseButton = f.tooltipCloseButton || g.closeButton.toString(), f.tooltipSize = f.tooltipSize || g.size, f.tooltipSpeed = f.tooltipSpeed || g.speed, f.tooltipAppendToBody = "true" === f.tooltipAppendToBody, h(e, function(e, g) {
          var v = r(e),
            h = t.element(o.document.createElement("tooltip")),
            T = t.element(o.document.createElement("tip-cont")),
            $ = t.element(o.document.createElement("tip")),
            A = t.element(o.document.createElement("tip-tip")),
            B = t.element(o.document.createElement("span")),
            z = t.element(o.document.createElement("tip-arrow")),
            E = function() {
              return T.html()
            },
            k = function(t) {
              void 0 !== t &amp;&amp; T[0].getClientRects().length &gt; 1 ? h.addClass("_multiline") : h.removeClass("_multiline")
            },
            P = function(e) {
              if ($.addClass("_hidden"), f.tooltipSmart) switch (f.tooltipSide) {
                case "top":
                  s($) &amp;&amp; (h.removeClass("_top"), h.addClass("_left"), s($) &amp;&amp; (h.removeClass("_left"), h.addClass("_bottom"), s($) &amp;&amp; (h.removeClass("_bottom"), h.addClass("_right"), s($) &amp;&amp; (h.removeClass("_right"), h.addClass("_top")))));
                  break;
                case "left":
                  s($) &amp;&amp; (h.removeClass("_left"), h.addClass("_bottom"), s($) &amp;&amp; (h.removeClass("_bottom"), h.addClass("_right"), s($) &amp;&amp; (h.removeClass("_right"), h.addClass("_top"), s($) &amp;&amp; (h.removeClass("_top"), h.addClass("_left")))));
                  break;
                case "bottom":
                  s($) &amp;&amp; (h.removeClass("_bottom"), h.addClass("_left"), s($) &amp;&amp; (h.removeClass("_left"), h.addClass("_top"), s($) &amp;&amp; (h.removeClass("_top"), h.addClass("_right"), s($) &amp;&amp; (h.removeClass("_right"), h.addClass("_bottom")))));
                  break;
                case "right":
                  s($) &amp;&amp; (h.removeClass("_right"), h.addClass("_top"), s($) &amp;&amp; (h.removeClass("_top"), h.addClass("_left"), s($) &amp;&amp; (h.removeClass("_left"), h.addClass("_bottom"), s($) &amp;&amp; (h.removeClass("_bottom"), h.addClass("_right")))));
                  break;
                default:
                  throw new Error("Position not supported")
              }
              if (f.tooltipAppendToBody) {
                var i, r, a, p, d, c = l(A[0]),
                  m = l(z[0]),
                  u = l($[0]),
                  g = $[0].getBoundingClientRect(),
                  v = t.copy($),
                  C = 0,
                  _ = c.length,
                  b = 0,
                  y = m.length,
                  w = 0,
                  S = u.length,
                  T = {},
                  B = {},
                  E = {};
                for ($.removeClass("_hidden"), v.removeClass("_hidden"), v.data("_tooltip-parent", h), n(h); _ &gt; C; C += 1) i = c[C], i &amp;&amp; c.getPropertyValue(i) &amp;&amp; (T[i] = c.getPropertyValue(i));
                for (; y &gt; b; b += 1) i = m[b], i &amp;&amp; m.getPropertyValue(i) &amp;&amp; (E[i] = m.getPropertyValue(i));
                for (; S &gt; w; w += 1) i = u[w], i &amp;&amp; "position" !== i &amp;&amp; "display" !== i &amp;&amp; "opacity" !== i &amp;&amp; "z-index" !== i &amp;&amp; "bottom" !== i &amp;&amp; "height" !== i &amp;&amp; "left" !== i &amp;&amp; "right" !== i &amp;&amp; "top" !== i &amp;&amp; "width" !== i &amp;&amp; u.getPropertyValue(i) &amp;&amp; (B[i] = u.getPropertyValue(i));
                r = o.parseInt(u.getPropertyValue("padding-top"), 10), a = o.parseInt(u.getPropertyValue("padding-bottom"), 10), p = o.parseInt(u.getPropertyValue("padding-left"), 10), d = o.parseInt(u.getPropertyValue("padding-right"), 10), B.top = g.top + o.scrollY + "px", B.left = g.left + o.scrollX + "px", B.height = g.height - (r + a) + "px", B.width = g.width - (p + d) + "px", v.css(B), v.children().css(T), v.children().next().css(E), e &amp;&amp; "true" !== f.tooltipHidden &amp;&amp; (v.addClass("_exradicated-tooltip"), t.element(o.document.body).append(v))
              } else $.removeClass("_hidden"), e &amp;&amp; "true" !== f.tooltipHidden &amp;&amp; h.addClass("active")
            },
            x = function() {
              f.tooltipAppendToBody ? n(h) : h.removeClass("active")
            },
            H = function it(t) {
              var o, e = t.parent();
              t[0] &amp;&amp; (t[0].scrollHeight &gt; t[0].clientHeight || t[0].scrollWidth &gt; t[0].clientWidth) &amp;&amp; t.on("scroll", function() {
                var t = this;
                o &amp;&amp; c.cancel(o), o = c(function() {
                  var o = a(h),
                    e = h[0].getBoundingClientRect(),
                    i = t.getBoundingClientRect();
                  e.top &lt; i.top || e.bottom &gt; i.bottom || e.left &lt; i.left || e.right &gt; i.right ? n(h) : o &amp;&amp; P(!0)
                })
              }), e &amp;&amp; e.length &amp;&amp; it(e)
            },
            V = function(t) {
              t &amp;&amp; (A.empty(), A.append(B), A.append(t), c(function() {
                P()
              }))
            },
            R = function(t) {
              t &amp;&amp; p.get(t).then(function(t) {
                t &amp;&amp; t.data &amp;&amp; (A.empty(), A.append(B), A.append(d(t.data)(g)), c(function() {
                  P()
                }))
              })
            },
            W = function(t) {
              t &amp;&amp; (_ &amp;&amp; h.removeAttr("_" + _), h.addClass("_" + t), _ = t)
            },
            I = function(t) {
              t &amp;&amp; (b &amp;&amp; h.off(b), h.on(t, P), b = t)
            },
            U = function(t) {
              t &amp;&amp; (y &amp;&amp; h.off(y), h.on(t, x), y = t)
            },
            Y = function(t) {
              t &amp;&amp; (C &amp;&amp; $.removeClass(C), $.addClass(t), C = t)
            },
            j = function() {
              "boolean" != typeof f.tooltipSmart &amp;&amp; (f.tooltipSmart = "true" === f.tooltipSmart)
            },
            q = function(t) {
              var o = "true" === t;
              o ? (B.on("click", x), B.css("display", "block")) : (B.off("click"), B.css("display", "none"))
            },
            O = function(o) {
              if (o) {
                var e, i = m(o, {
                    $scope: g
                  }),
                  r = g.$new(!1, g),
                  l = o.indexOf("as");
                l &gt;= 0 ? (e = o.substr(l + 3), r[e] = i) : t.extend(r, i), A.replaceWith(d(A)(r)), Z()
              }
            },
            F = function(t) {
              t &amp;&amp; (w &amp;&amp; A.removeClass("_" + w), A.addClass("_" + t), w = t)
            },
            L = function(t) {
              t &amp;&amp; (S &amp;&amp; h.removeClass("_" + S), h.addClass("_" + t), S = t)
            },
            X = f.$observe("tooltipTemplate", V),
            D = f.$observe("tooltipTemplateUrl", R),
            G = f.$observe("tooltipSide", W),
            J = f.$observe("tooltipShowTrigger", I),
            K = f.$observe("tooltipHideTrigger", U),
            M = f.$observe("tooltipClass", Y),
            N = f.$observe("tooltipSmart", j),
            Q = f.$observe("tooltipCloseButton", q),
            Z = f.$observe("tooltipController", O),
            tt = f.$observe("tooltipSize", F),
            ot = f.$observe("tooltipSpeed", L),
            et = g.$watch(E, k);
          B.attr({
            id: "close-button"
          }), B.html("&amp;times;"), $.addClass("_hidden"), A.append(B), A.append(f.tooltipTemplate), $.append(A), $.append(z), T.append(e), h.attr(v), h.addClass("tooltips"), h.append(T), h.append($), u.after(h), f.tooltipAppendToBody &amp;&amp; (i.add(function() {
            H(h)
          }), H(h)), i.add(function() {
            k(), P()
          }), c(function() {
            P(), $.removeClass("_hidden"), h.addClass("_ready")
          }), g.$on("$destroy", function() {
            X(), D(), G(), J(), K(), M(), N(), Q(), tt(), ot(), et(), e.off(f.tooltipShowTrigger + " " + f.tooltipHideTrigger)
          })
        })
      };
      return {
        restrict: "A",
        transclude: "element",
        priority: 1,
        terminal: !0,
        link: f
      }
    }];
  t.module("720kb.tooltips", []).provider(e + "Conf", p).directive(e, d)
}(angular, window);
/*! RESOURCE: /scripts/sn/common/js_includes_common.js */
/*! RESOURCE: /scripts/sn/common/_module.js */
angular.module('sn.common', [
  'ngSanitize',
  'ngAnimate',
  'sn.common.avatar',
  'sn.common.controls',
  'sn.common.datetime',
  'sn.common.glide',
  'sn.common.i18n',
  'sn.common.link',
  'sn.common.mention',
  'sn.common.messaging',
  'sn.common.notification',
  'sn.common.presence',
  'sn.common.stream',
  'sn.common.ui',
  'sn.common.user_profile',
  'sn.common.util'
]);
angular.module('ng.common', [
  'sn.common'
]);;
/*! RESOURCE: /scripts/sn/common/dist/templates.js */
angular.module('sn.common.dist.templates', []);;
/*! RESOURCE: /scripts/sn/common/datetime/js_includes_datetime.js */
/*! RESOURCE: /scripts/sn/common/datetime/_module.js */
angular.module('sn.common.datetime', [
  'sn.common.i18n'
]);
angular.module('sn.timeAgo', [
  'sn.common.datetime'
]);;
/*! RESOURCE: /scripts/sn/common/datetime/directive.snTimeAgo.js */
angular.module('sn.common.datetime').constant('DATE_GRANULARITY', {
  DATETIME: 1,
  DATE: 2
});
angular.module('sn.common.datetime').factory('timeAgoTimer', function($interval, $rootScope, DATE_GRANULARITY) {
  "use strict";
  var digestInterval;
  return function(displayGranularityType) {
    displayGranularityType = typeof displayGranularityType !== 'undefined' ? displayGranularityType : DATE_GRANULARITY.DATETIME;
    if (!digestInterval &amp;&amp; displayGranularityType == DATE_GRANULARITY.DATETIME)
      digestInterval = $interval(function() {
        $rootScope.$broadcast('sn.TimeAgo.tick');
      }, 30 * 1000);
    return Date.now();
  };
});
angular.module('sn.common.datetime').factory('timeAgo', function(timeAgoSettings, DATE_GRANULARITY) {
  var service = {
    settings: timeAgoSettings.get(),
    allowFuture: function allowFuture(bool) {
      this.settings.allowFuture = bool;
      return this;
    },
    toWords: function toWords(distanceMillis, messageGranularity) {
      messageGranularity = messageGranularity || DATE_GRANULARITY.DATETIME;
      var $l = service.settings.strings;
      var seconds = Math.abs(distanceMillis) / 1000;
      var minutes = seconds / 60;
      var hours = minutes / 60;
      var days = hours / 24;
      var years = days / 365;
      var prefix = $l.prefixAgo;
      var suffix = $l.suffixAgo;
      if ((seconds &lt; 45 &amp;&amp; messageGranularity == DATE_GRANULARITY.DATETIME) || (hours &lt; 24 &amp;&amp; messageGranularity == DATE_GRANULARITY.DATE))
        prefix = suffix = '';
      if (service.settings.allowFuture) {
        if (distanceMillis &lt; 0) {
          prefix = suffix = "";
        }
      }
      if (!service.settings.allowFuture &amp;&amp; distanceMillis &lt; 0)
        prefix = suffix = "";

      function substitute(stringOrFunction, number) {
        var string = angular.isFunction(stringOrFunction) ?
          stringOrFunction(number, distanceMillis) : stringOrFunction;
        if (!string)
          return "";
        var value = ($l.numbers &amp;&amp; $l.numbers[number]) || number;
        return string.replace(/%d/i, value);
      }
      var wantDate = messageGranularity == DATE_GRANULARITY.DATE;
      var wantDateTime = messageGranularity == DATE_GRANULARITY.DATETIME;
      var words = distanceMillis &lt;= 0 &amp;&amp; wantDateTime &amp;&amp; substitute($l.justNow, 0) ||
        distanceMillis &lt;= 0 &amp;&amp; wantDate &amp;&amp; substitute($l.today, 0) ||
        seconds &lt; 45 &amp;&amp; (distanceMillis &gt;= 0 || !service.settings.allowFuture) &amp;&amp; wantDateTime &amp;&amp; substitute($l.justNow, Math.round(seconds)) ||
        seconds &lt; 45 &amp;&amp; wantDateTime &amp;&amp; substitute($l.seconds, Math.round(seconds)) ||
        seconds &lt; 90 &amp;&amp; wantDateTime &amp;&amp; substitute($l.minute, 1) ||
        minutes &lt; 45 &amp;&amp; wantDateTime &amp;&amp; substitute($l.minutes, Math.round(minutes)) ||
        minutes &lt; 90 &amp;&amp; wantDateTime &amp;&amp; substitute($l.hour, 1) ||
        hours &lt; 24 &amp;&amp; wantDateTime &amp;&amp; substitute($l.hours, Math.round(hours)) ||
        hours &lt; 24 &amp;&amp; wantDate &amp;&amp; substitute($l.today, 0) ||
        hours &lt; 42 &amp;&amp; substitute($l.day, 1) ||
        days &lt; 30 &amp;&amp; substitute($l.days, Math.ceil(days)) ||
        days &lt; 45 &amp;&amp; substitute($l.month, 1) ||
        days &lt; 365 &amp;&amp; substitute($l.months, Math.round(days / 30)) ||
        years &lt; 1.5 &amp;&amp; substitute($l.year, 1) ||
        substitute($l.years, Math.round(years));
      var separator = $l.wordSeparator === undefined ? " " : $l.wordSeparator;
      return [prefix, words, suffix].join(separator).trim();
    },
    parse: function(iso8601) {
      if (angular.isNumber(iso8601))
        return new Date(parseInt(iso8601, 10));
      var s = iso8601.trim();
      s = s.replace(/\.\d+/, "");
      s = s.replace(/-/, "/").replace(/-/, "/");
      s = s.replace(/T/, " ").replace(/Z/, " UTC");
      s = s.replace(/([\+\-]\d\d)\:?(\d\d)/, " $1$2");
      return new Date(s);
    }
  };
  return service;
});
angular.module('sn.common.datetime').directive("snTimeAgo", function(timeAgoSettings, $rootScope, timeAgo, timeAgoTimer, DATE_GRANULARITY) {
  "use strict";
  return {
    restrict: "E",
    template: '&lt;time title="{{ ::titleTime }}"&gt;{{timeAgo}}&lt;/time&gt;',
    scope: {
      timestamp: "=",
      timezone: "@",
      local: "="
    },
    link: function(scope) {
      timeAgoSettings.ready.then(function() {
        timeAgoTimer(DATE_GRANULARITY.DATETIME)
        scope.$on('sn.TimeAgo.tick', setTimeAgo);
        setTimeAgo();
      });

      function setTimeAgo() {
        scope.timeAgo = timeAgoConverter(scope.timestamp, true);
      }

      function timeAgoConverter(input, noFuture) {
        if (!input)
          return;
        var allowFuture = !noFuture;
        var date = timeAgo.parse(input);
        if (scope.local) {
          scope.titleTime = input;
          return timeAgo.allowFuture(allowFuture).toWords(new Date() - date);
        }
        if (scope.timezone) {
          var clientOffset = new Date().getTimezoneOffset() * -60000;
          var sessionOffset = Number(scope.timezone.substring(scope.timezone.indexOf("offset=") + 7, scope.timezone.indexOf(",dstSavings")));
          if (clientOffset != sessionOffset)
            date = new Date(date - sessionOffset);
          else
            date = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
        }
        if (Object.prototype.toString.call(date) !== "[object Date]" &amp;&amp; Object.prototype.toString.call(date) !== "[object Number]")
          return input;
        else if (Object.prototype.toString.call(date) == "[object Date]" &amp;&amp; isNaN(date.getTime()))
          return input;
        setTitleTime(date);
        var currentDate = new Date();
        currentDate = new Date(currentDate.getUTCFullYear(), currentDate.getUTCMonth(), currentDate.getUTCDate(), currentDate.getUTCHours(), currentDate.getUTCMinutes(), currentDate.getUTCSeconds());
        var diff = currentDate - date;
        return timeAgo.allowFuture(allowFuture).toWords(diff);
      }

      function setTitleTime(date) {
        var t = date.getTime();
        var o = date.getTimezoneOffset();
        t -= o * 60 * 1000;
        scope.titleTime = new Date(t).toLocaleString();
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/datetime/directive.snDayAgo.js */
angular.module('sn.common.datetime').directive("snDayAgo", function(timeAgoSettings, $rootScope, timeAgo, timeAgoTimer, DATE_GRANULARITY) {
  "use strict";
  return {
    restrict: "E",
    template: '&lt;time&gt;{{dayAgo}}&lt;/time&gt;',
    scope: {
      date: "="
    },
    link: function(scope) {
      timeAgoSettings.ready.then(function() {
        setDayAgo();
      });

      function setDayAgo() {
        scope.dayAgo = dayAgoConverter(scope.date, "noFuture");
      }

      function dayAgoConverter(input, option) {
        if (!input) return;
        var allowFuture = !((option === 'noFuture') || (option === 'no_future'));
        var date = timeAgo.parse(input);
        if (Object.prototype.toString.call(date) !== "[object Date]")
          return input;
        else if (isNaN(date.getTime()))
          return input;
        var diff = timeAgoTimer(DATE_GRANULARITY.DATE) - date;
        return timeAgo.allowFuture(allowFuture).toWords(diff, DATE_GRANULARITY.DATE);
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/datetime/snTimeAgoSettings.js */
angular.module('sn.common.datetime').provider('snTimeAgoSettings', function() {
  "use strict";
  var INIT_NEVER = 'never';
  var INIT_AUTO = 'auto';
  var INIT_MANUAL = 'manual';
  var _initMethod = INIT_AUTO;
  this.setInitializationMethod = function(init) {
    switch (init) {
      default: init = INIT_AUTO;
      case INIT_NEVER:
          case INIT_AUTO:
          case INIT_MANUAL:
          _initMethod = init;
        break;
    }
  };
  this.$get = function(i18n, $q) {
    var settings = {
      allowFuture: true,
      dateOnly: false,
      strings: {}
    };
    var _initialized = false;
    var ready = $q.defer();

    function initialize() {
      if (_initMethod === INIT_NEVER) {
        return $q.reject();
      }
      if (!_initialized) {
        _initialized = true;
        i18n.getMessages(['prefix_ago', 'prefix_from now', 'suffix_ago', 'suffix_from now', 'just now',
          'less than a minute', 'about a minute', '%d minutes', 'about an hour', 'about %d hours', 'today', 'a day', '%d days',
          'about a month', '%d months', 'about a year', 'about a year', '%d years'
        ], function(msgs) {
          settings.strings = {
            prefixAgo: msgs['prefix_ago'],
            prefixFromNow: msgs['prefix_from now'],
            suffixAgo: msgs['suffix_ago'],
            suffixFromNow: msgs["suffix_from now"],
            justNow: msgs["just now"],
            seconds: msgs["less than a minute"],
            minute: msgs["about a minute"],
            minutes: msgs["%d minutes"],
            hour: msgs["about an hour"],
            hours: msgs["about %d hours"],
            day: msgs["a day"],
            days: msgs["%d days"],
            month: msgs["about a month"],
            months: msgs["%d months"],
            year: msgs["about a year"],
            years: msgs["%d years"],
            today: msgs["today"],
            wordSeparator: msgs["timeago_number_separator"],
            numbers: []
          };
          ready.resolve();
        });
      }
      return ready.promise;
    }
    if (_initMethod === INIT_AUTO) {
      initialize();
    }
    return {
      initialize: initialize,
      ready: ready.promise,
      get: function get() {
        return settings;
      },
      set: function set(translated) {
        settings = angular.extend(settings, translated);
      }
    };
  };
}).factory('timeAgoSettings', function(snTimeAgoSettings) {
  return snTimeAgoSettings;
});;;
/*! RESOURCE: /scripts/sn/common/glide/js_includes_glide.js */
/*! RESOURCE: /scripts/sn/common/glide/_module.js */
angular.module('sn.common.glide', [
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/sn/common/glide/factory.glideUrlBuilder.js */
angular.module('sn.common.glide').factory('glideUrlBuilder', ['$window', function($window) {
  "use strict";

  function GlideUrl(contextPath) {
    var objDef = {
      contextPath: '',
      params: {},
      encodedString: '',
      encode: true,
      setFromCurrent: function() {
        this.setFromString($window.location.href);
      },
      setFromString: function(href) {
        var pos = href.indexOf('?');
        if (pos &lt; 0) {
          this.contextPath = href;
          return;
        }
        this.contextPath = href.slice(0, pos);
        var hashes = href.slice(pos + 1).split('&amp;');
        var i = hashes.length;
        while (i--) {
          var pos = hashes[i].indexOf('=');
          this.params[hashes[i].substring(0, pos)] = hashes[i].substring(++pos);
        }
      },
      setContextPath: function(c) {
        this.contextPath = c;
      },
      getParam: function(p) {
        return this.params[p];
      },
      getParams: function() {
        return this.params;
      },
      addParam: function(name, value) {
        this.params[name] = value;
        return this;
      },
      addToken: function() {
        if (typeof g_ck != 'undefined' &amp;&amp; g_ck != "")
          this.addParam('sysparm_ck', g_ck);
        return this;
      },
      deleteParam: function(name) {
        delete this.params[name];
      },
      addEncodedString: function(s) {
        if (!s)
          return;
        if (s.substr(0, 1) != "&amp;")
          this.encodedString += "&amp;";
        this.encodedString += s;
        return this;
      },
      getQueryString: function(additionalParams) {
        var qs = this._getParamsForURL(this.params);
        qs += this._getParamsForURL(additionalParams);
        qs += this.encodedString;
        if (qs.length == 0)
          return "";
        return qs.substring(1);
      },
      _getParamsForURL: function(params) {
        if (!params)
          return '';
        var url = '';
        for (var n in params) {
          var p = params[n] || '';
          url += '&amp;' + n + '=' + (this.encode ? encodeURIComponent(p + '') : p);
        }
        return url;
      },
      getURL: function(additionalParams) {
        var url = this.contextPath;
        var qs = this.getQueryString(additionalParams);
        if (qs)
          url += "?" + qs;
        return url;
      },
      setEncode: function(b) {
        this.encode = b;
      },
      toString: function() {
        return 'GlideURL';
      }
    }
    return objDef;
  }
  return {
    newGlideUrl: function(contextPath) {
      var glideUrl = new GlideUrl();
      glideUrl.setFromString(contextPath ? contextPath : '');
      return glideUrl;
    },
    refresh: function() {
      $window.location.replace($window.location.href);
    },
    getCancelableLink: function(link) {
      if ($window.NOW &amp;&amp; $window.NOW.g_cancelPreviousTransaction) {
        var nextChar = link.indexOf('?') &gt; -1 ? '&amp;' : '?';
        link += nextChar + "sysparm_cancelable=true";
      }
      return link;
    }
  };
}]);;
/*! RESOURCE: /scripts/sn/common/glide/service.queryFilter.js */
angular.module('sn.common.glide').factory('queryFilter', function() {
  "use strict";
  return {
    create: function() {
      var that = {};
      that.conditions = [];

      function newCondition(field, operator, value, label, displayValue, type) {
        var condition = {
          field: field,
          operator: operator,
          value: value,
          displayValue: displayValue,
          label: label,
          left: null,
          right: null,
          type: null,
          setValue: function(value, displayValue) {
            this.value = value;
            this.displayValue = displayValue ? displayValue : value;
          }
        };
        if (type)
          condition.type = type;
        return condition;
      }

      function addCondition(condition) {
        that.conditions.push(condition);
        return condition;
      }

      function removeCondition(condition) {
        for (var i = that.conditions.length - 1; i &gt;= 0; i--) {
          if (that.conditions[i] === condition)
            that.conditions.splice(i, 1);
        }
      }

      function getConditionsByField(conditions, field) {
        var conditionsToReturn = [];
        for (var condition in conditions) {
          if (conditions.hasOwnProperty(condition)) {
            if (conditions[condition].field == field)
              conditionsToReturn.push(conditions[condition]);
          }
        }
        return conditionsToReturn;
      }

      function encodeCondition(condition) {
        var output = "";
        if (condition.hasOwnProperty("left") &amp;&amp; condition.left) {
          output += encodeCondition(condition.left);
        }
        if (condition.hasOwnProperty("right") &amp;&amp; condition.right) {
          var right = encodeCondition(condition.right);
          if (right.length &gt; 0) {
            output += "^" + condition.type + right;
          }
        }
        if (condition.field) {
          output += condition.field;
          output += condition.operator;
          if (condition.value !== null &amp;&amp; typeof condition.value !== "undefined")
            output += condition.value;
        }
        return output;
      }

      function createEncodedQuery() {
        var eq = "";
        var ca = that.conditions;
        for (var i = 0; i &lt; ca.length; i++) {
          var condition = ca[i];
          if (eq.length)
            eq += '^';
          eq += encodeCondition(condition);
        }
        eq += "^EQ";
        return eq;
      }
      that.addCondition = addCondition;
      that.newCondition = newCondition;
      that.createEncodedQuery = createEncodedQuery;
      that.getConditionsByField = getConditionsByField;
      that.removeCondition = removeCondition;
      return that;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.filterExpressionParser.js */
angular.module('sn.common.glide').factory('filterExpressionParser', function() {
  'use strict';
  var operatorExpressions = [{
    wildcardExp: '(.*)',
    operator: 'STARTSWITH',
    toExpression: function(filter) {
      return filter;
    }
  }, {
    wildcardExp: '^\\*(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return (filter === '*' ? filter : '*' + filter);
    }
  }, {
    wildcardExp: '^\\.(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return '.' + filter;
    }
  }, {
    wildcardExp: '^%(.*)',
    operator: 'ENDSWITH',
    toExpression: function(filter) {
      return (filter === '%' ? filter : '%' + filter);
    }
  }, {
    wildcardExp: '(.*)%',
    operator: 'LIKE',
    toExpression: function(filter) {
      return filter + '%';
    }
  }, {
    wildcardExp: '^=(.*)',
    operator: '=',
    toExpression: function(filter) {
      return (filter === '=' ? filter : '=' + filter);
    }
  }, {
    wildcardExp: '^!\\*(.*)',
    operator: 'NOT LIKE',
    toExpression: function(filter) {
      return (filter === '!*' || filter === '!' ? filter : '!*' + filter);
    }
  }, {
    wildcardExp: '^!=(.*)',
    operator: '!=',
    toExpression: function(filter) {
      return (filter === '!=' || filter === '!' ? filter : '!=' + filter);
    }
  }];
  return {
    getOperatorExpressionForOperator: function(operator) {
      for (var i = 0; i &lt; operatorExpressions.length; i++) {
        var item = operatorExpressions[i];
        if (item.operator === operator)
          return item;
      }
      throw {
        name: 'OperatorNotSupported',
        message: 'The operator ' + operator + ' is not in the list of operatorExpressions.'
      };
    },
    parse: function(val, defaultOperator) {
      var parsedValue = {
        filterText: val,
        operator: defaultOperator || 'STARTSWITH'
      };
      for (var i = 1; i &lt; operatorExpressions.length; i++) {
        var operatorItem = operatorExpressions[i];
        var match = val.match(operatorItem.wildcardExp);
        if (match &amp;&amp; match[1] !== '') {
          parsedValue.operator = operatorItem.operator;
          parsedValue.filterText = match[1];
        }
      }
      return parsedValue;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.userPreferences.js */
angular.module('sn.common.glide').factory("userPreferences", function($http, $q, unwrappedHTTPPromise, urlTools) {
  "use strict";
  var preferencesCache = {};

  function getPreference(preferenceName) {
    if (preferenceName in preferencesCache)
      return preferencesCache[preferenceName];
    var targetURL = urlTools.getURL('user_preference', {
        "sysparm_pref_name": preferenceName,
        "sysparm_action": "get"
      }),
      deferred = $q.defer();
    $http.get(targetURL).success(function(response) {
      deferred.resolve(response.sysparm_pref_value);
    }).error(function(data, status) {
      deferred.reject("Error getting preference " + preferenceName + ": " + status);
    });
    preferencesCache[preferenceName] = deferred.promise;
    return deferred.promise;
  }

  function setPreference(preferenceName, preferenceValue) {
    var targetURL = urlTools.getURL('user_preference', {
      "sysparm_pref_name": preferenceName,
      "sysparm_action": "set",
      "sysparm_pref_value": "" + preferenceValue
    });
    var httpPromise = $http.get(targetURL);
    addToCache(preferenceName, preferenceValue);
    return unwrappedHTTPPromise(httpPromise);
  }

  function addToCache(preferenceName, preferenceValue) {
    preferencesCache[preferenceName] = $q.when(preferenceValue);
  }
  var userPreferences = {
    getPreference: getPreference,
    setPreference: setPreference,
    addToCache: addToCache
  };
  return userPreferences;
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowStream.js */
angular.module('sn.common.glide').constant('nowStreamTimerInterval', 5000);
angular.module('sn.common.glide').factory('nowStream', function($q, $timeout, urlTools, nowStreamTimerInterval, snResource, $log) {
  'use strict';
  var Stream = function() {
    this.initialize.apply(this, arguments);
  };
  Stream.prototype = {
    initialize: function(table, query, sys_id, processor, interval, source, includeAttachments) {
      this.table = table;
      this.query = query;
      this.sysparmQuery = null;
      this.sys_id = sys_id;
      this.processor = processor;
      this.lastTimestamp = 0;
      this.inflightRequest = null;
      this.requestImmediateUpdate = false;
      this.interval = interval;
      this.source = source;
      this.includeAttachments = includeAttachments;
      this.stopped = true;
    },
    setQuery: function(sysparmQuery) {
      this.sysparmQuery = sysparmQuery;
    },
    poll: function(callback, preRequestCallback) {
      this.callback = callback;
      this.preRequestCallback = preRequestCallback;
      this._stopPolling();
      this._startPolling();
    },
    tap: function() {
      if (!this.inflightRequest) {
        this._stopPolling();
        this._startPolling();
      } else
        this.requestImmediateUpdate = true;
    },
    insert: function(field, text) {
      this.insertForEntry(field, text, this.table, this.sys_id);
    },
    insertForEntry: function(field, text, table, sys_id) {
      return this.insertEntries([{
        field: field,
        text: text
      }], table, sys_id);
    },
    expandMentions: function(entryText, mentionIDMap) {
      return entryText.replace(/@\[(.+?)\]/gi, function(mention) {
        var mentionedName = mention.substring(2, mention.length - 1);
        if (mentionIDMap[mentionedName]) {
          return "@[" + mentionIDMap[mentionedName] + ":" + mentionedName + "]";
        } else {
          return mention;
        }
      });
    },
    insertEntries: function(entries, table, sys_id, mentionIDMap) {
      mentionIDMap = mentionIDMap || {};
      var sanitizedEntries = [];
      for (var i = 0; i &lt; entries.length; i++) {
        var entryText = entries[i].text;
        if (entryText &amp;&amp; entryText.endsWith('\n'))
          entryText = entryText.substring(0, entryText.length - 1);
        if (!entryText)
          continue;
        entries[i].text = this.expandMentions(entryText, mentionIDMap);
        sanitizedEntries.push(entries[i]);
      }
      if (sanitizedEntries.length === 0)
        return;
      this._isInserting = true;
      var url = this._getInsertURL(table, sys_id);
      var that = this;
      return snResource().post(url, {
        entries: sanitizedEntries
      }).then(this._successCallback.bind(this), function() {
        $log.warn('Error submitting entries', sanitizedEntries);
      }).then(function() {
        that._isInserting = false;
      });
    },
    cancel: function() {
      this._stopPolling();
    },
    _startPolling: function() {
      var interval = this._getInterval();
      var that = this;
      var successCallback = this._successCallback.bind(this);
      that.stopped = false;

      function runPoll() {
        if (that._isInserting) {
          establishNextRequest();
          return;
        }
        if (!that.inflightRequest) {
          that.inflightRequest = that._executeRequest();
          that.inflightRequest.then(successCallback);
          that.inflightRequest.finally(function() {
            that.inflightRequest = null;
            if (that.requestImmediateUpdate) {
              that.requestImmediateUpdate = false;
              establishNextRequest(0);
            } else {
              establishNextRequest();
            }
          });
        }
      }

      function establishNextRequest(intervalOverride) {
        if (that.stopped)
          return;
        intervalOverride = (parseFloat(intervalOverride) &gt;= 0) ? intervalOverride : interval;
        $timeout.cancel(that.timer);
        that.timer = $timeout(runPoll, intervalOverride);
      }
      runPoll();
    },
    _stopPolling: function() {
      if (this.timer)
        $timeout.cancel(this.timer);
      this.stopped = true;
    },
    _executeRequest: function() {
      var url = this._getURL();
      if (this.preRequestCallback) {
        this.preRequestCallback();
      }
      return snResource().get(url);
    },
    _getURL: function() {
      var params = {
        table: this.table,
        action: this._getAction(),
        sysparm_silent_request: true,
        sysparm_auto_request: true,
        sysparm_timestamp: this.lastTimestamp,
        include_attachments: this.includeAttachments
      };
      if (this.sys_id) {
        params['sys_id'] = this.sys_id;
      } else if (this.sysparmQuery) {
        params['sysparm_query'] = this.sysparmQuery;
      }
      var url = urlTools.getURL(this.processor, params);
      if (!this.sys_id) {
        url += "&amp;p=" + this.query;
      }
      return url;
    },
    _getInsertURL: function(table, sys_id) {
      return urlTools.getURL(this.processor, {
        action: 'insert',
        table: table,
        sys_id: sys_id,
        sysparm_timestamp: this.timestamp || 0,
        sysparm_source: this.source
      });
    },
    _successCallback: function(response) {
      var response = response.data;
      if (response.entries &amp;&amp; response.entries.length) {
        response.entries = this._filterOld(response.entries);
        if (response.entries.length &gt; 0) {
          this.lastEntry = angular.copy(response.entries[0]);
          this.lastTimestamp = response.sys_timestamp || response.entries[0].sys_timestamp;
        }
      }
      this.callback.call(null, response);
    },
    _filterOld: function(entries) {
      for (var i = 0; i &lt; entries.length; i++) {
        if (entries[i].sys_timestamp == this.lastTimestamp) {
          if (!angular.equals(this._makeComparable(entries[i]), this._makeComparable(this.lastEntry)))
            continue;
        }
        if (entries[i].sys_timestamp &lt;= this.lastTimestamp)
          return entries.slice(0, i);
      }
      return entries;
    },
    _makeComparable: function(entry) {
      var copy = angular.copy(entry);
      delete copy.short_description;
      delete copy.display_value;
      return copy;
    },
    _getAction: function() {
      return this.sys_id ? 'get_new_entries' : 'get_set_entries';
    },
    _getInterval: function() {
      if (this.interval)
        return this.interval;
      else if (window.NOW &amp;&amp; NOW.stream_poll_interval)
        return NOW.stream_poll_interval * 1000;
      else
        return nowStreamTimerInterval;
    }
  };
  return {
    create: function(table, query, sys_id, processor, interval, source) {
      return new Stream(table, query, sys_id, processor, interval, source);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowServer.js */
angular.module('sn.common.glide').factory('nowServer', function($http, $q, userPreferences, angularProcessorUrl, urlTools) {
  return {
    getBaseURL: function() {
      return angularProcessorUrl;
    },
    getPartial: function(scope, partial, parms, callback) {
      var url = this.getPartialURL(partial, parms);
      if (url === scope.url) {
        callback.call();
        return;
      }
      var fn = scope.$on('$includeContentLoaded', function() {
        fn.call();
        callback.call();
      });
      scope.url = url;
    },
    replaceView: function($location, newView) {
      var p = $location.path();
      var a = p.split("/");
      a[1] = newView;
      p = a.join("/");
      return p;
    },
    getPartialURL: urlTools.getPartialURL,
    getURL: urlTools.getURL,
    urlFor: urlTools.urlFor,
    getPropertyURL: urlTools.getPropertyURL,
    setPreference: userPreferences.setPreference,
    getPreference: userPreferences.getPreference
  }
});;;
/*! RESOURCE: /scripts/sn/common/avatar/js_includes_avatar.js */
/*! RESOURCE: /scripts/sn/common/presence/js_includes_presence.js */
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0.min.js */
/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
! function(a, b) {
  "object" == typeof module &amp;&amp; "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = "".trim,
    l = {},
    m = "1.11.0",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return d.call(this)
    },
    get: function(a) {
      return null != a ? 0 &gt; a ? this[a + this.length] : this[a] : d.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a, b) {
      return n.each(this, a, b)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(d.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 &gt; a ? b : 0);
      return this.pushStack(c &gt;= 0 &amp;&amp; b &gt; c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor(null)
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g &amp;&amp; (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i &amp;&amp; (g = this, h--); i &gt; h; h++)
      if (null != (e = arguments[h]))
        for (d in e) a = g[d], c = e[d], g !== c &amp;&amp; (j &amp;&amp; c &amp;&amp; (n.isPlainObject(c) || (b = n.isArray(c))) ? (b ? (b = !1, f = a &amp;&amp; n.isArray(a) ? a : []) : f = a &amp;&amp; n.isPlainObject(a) ? a : {}, g[d] = n.extend(j, f, c)) : void 0 !== c &amp;&amp; (g[d] = c));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray || function(a) {
      return "array" === n.type(a)
    },
    isWindow: function(a) {
      return null != a &amp;&amp; a == a.window
    },
    isNumeric: function(a) {
      return a - parseFloat(a) &gt;= 0
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    isPlainObject: function(a) {
      var b;
      if (!a || "object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;
      try {
        if (a.constructor &amp;&amp; !j.call(a, "constructor") &amp;&amp; !j.call(a.constructor.prototype, "isPrototypeOf")) return !1
      } catch (c) {
        return !1
      }
      if (l.ownLast)
        for (b in a) return j.call(a, b);
      for (b in a);
      return void 0 === b || j.call(a, b)
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
    },
    globalEval: function(b) {
      b &amp;&amp; n.trim(b) &amp;&amp; (a.execScript || function(b) {
        a.eval.call(a, b)
      })(b)
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b, c) {
      var d, e = 0,
        f = a.length,
        g = s(a);
      if (c) {
        if (g) {
          for (; f &gt; e; e++)
            if (d = b.apply(a[e], c), d === !1) break
        } else
          for (e in a)
            if (d = b.apply(a[e], c), d === !1) break
      } else if (g) {
        for (; f &gt; e; e++)
          if (d = b.call(a[e], e, a[e]), d === !1) break
      } else
        for (e in a)
          if (d = b.call(a[e], e, a[e]), d === !1) break;
      return a
    },
    trim: k &amp;&amp; !k.call("\ufeff\xa0") ? function(a) {
      return null == a ? "" : k.call(a)
    } : function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a &amp;&amp; (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
    },
    inArray: function(a, b, c) {
      var d;
      if (b) {
        if (g) return g.call(b, a, c);
        for (d = b.length, c = c ? 0 &gt; c ? Math.max(0, d + c) : c : 0; d &gt; c; c++)
          if (c in b &amp;&amp; b[c] === a) return c
      }
      return -1
    },
    merge: function(a, b) {
      var c = +b.length,
        d = 0,
        e = a.length;
      while (c &gt; d) a[e++] = b[d++];
      if (c !== c)
        while (void 0 !== b[d]) a[e++] = b[d++];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g &gt; f; f++) d = !b(a[f], f), d !== h &amp;&amp; e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, f = 0,
        g = a.length,
        h = s(a),
        i = [];
      if (h)
        for (; g &gt; f; f++) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      else
        for (f in a) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      return e.apply([], i)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, e, f;
      return "string" == typeof b &amp;&amp; (f = a[b], b = a, a = f), n.isFunction(a) ? (c = d.call(arguments, 2), e = function() {
        return a.apply(b || this, c.concat(d.call(arguments)))
      }, e.guid = a.guid = a.guid || n.guid++, e) : void 0
    },
    now: function() {
      return +new Date
    },
    support: l
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
    h["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType &amp;&amp; b ? !0 : "array" === c || 0 === b || "number" == typeof b &amp;&amp; b &gt; 0 &amp;&amp; b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = "sizzle" + -new Date,
      t = a.document,
      u = 0,
      v = 0,
      w = eb(),
      x = eb(),
      y = eb(),
      z = function(a, b) {
        return a === b &amp;&amp; (j = !0), 0
      },
      A = "undefined",
      B = 1 &lt;&lt; 31,
      C = {}.hasOwnProperty,
      D = [],
      E = D.pop,
      F = D.push,
      G = D.push,
      H = D.slice,
      I = D.indexOf || function(a) {
        for (var b = 0, c = this.length; c &gt; b; b++)
          if (this[b] === a) return b;
        return -1
      },
      J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      K = "[\\x20\\t\\r\\n\\f]",
      L = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      M = L.replace("w", "w#"),
      N = "\\[" + K + "*(" + L + ")" + K + "*(?:([*^$|!~]?=)" + K + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + M + ")|)|)" + K + "*\\]",
      O = ":(" + L + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + N.replace(3, 8) + ")*)|.*)\\)|)",
      P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"),
      Q = new RegExp("^" + K + "*," + K + "*"),
      R = new RegExp("^" + K + "*([&gt;+~]|" + K + ")" + K + "*"),
      S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"),
      T = new RegExp(O),
      U = new RegExp("^" + M + "$"),
      V = {
        ID: new RegExp("^#(" + L + ")"),
        CLASS: new RegExp("^\\.(" + L + ")"),
        TAG: new RegExp("^(" + L.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + N),
        PSEUDO: new RegExp("^" + O),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + J + ")$", "i"),
        needsContext: new RegExp("^" + K + "*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
      },
      W = /^(?:input|select|textarea|button)$/i,
      X = /^h\d$/i,
      Y = /^[^{]+\{\s*\[native \w/,
      Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      $ = /[+~]/,
      _ = /'|\\/g,
      ab = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"),
      bb = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 &gt; d ? String.fromCharCode(d + 65536) : String.fromCharCode(d &gt;&gt; 10 | 55296, 1023 &amp; d | 56320)
      };
    try {
      G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType
    } catch (cb) {
      G = {
        apply: D.length ? function(a, b) {
          F.apply(a, H.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function db(a, b, d, e) {
      var f, g, h, i, j, m, p, q, u, v;
      if ((b ? b.ownerDocument || b : t) !== l &amp;&amp; k(b), b = b || l, d = d || [], !a || "string" != typeof a) return d;
      if (1 !== (i = b.nodeType) &amp;&amp; 9 !== i) return [];
      if (n &amp;&amp; !e) {
        if (f = Z.exec(a))
          if (h = f[1]) {
            if (9 === i) {
              if (g = b.getElementById(h), !g || !g.parentNode) return d;
              if (g.id === h) return d.push(g), d
            } else if (b.ownerDocument &amp;&amp; (g = b.ownerDocument.getElementById(h)) &amp;&amp; r(b, g) &amp;&amp; g.id === h) return d.push(g), d
          } else {
            if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;
            if ((h = f[3]) &amp;&amp; c.getElementsByClassName &amp;&amp; b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d
          }
        if (c.qsa &amp;&amp; (!o || !o.test(a))) {
          if (q = p = s, u = b, v = 9 === i &amp;&amp; a, 1 === i &amp;&amp; "object" !== b.nodeName.toLowerCase()) {
            m = ob(a), (p = b.getAttribute("id")) ? q = p.replace(_, "\\$&amp;") : b.setAttribute("id", q), q = "[id='" + q + "'] ", j = m.length;
            while (j--) m[j] = q + pb(m[j]);
            u = $.test(a) &amp;&amp; mb(b.parentNode) || b, v = m.join(",")
          }
          if (v) try {
            return G.apply(d, u.querySelectorAll(v)), d
          } catch (w) {} finally {
            p || b.removeAttribute("id")
          }
        }
      }
      return xb(a.replace(P, "$1"), b, d, e)
    }

    function eb() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") &gt; d.cacheLength &amp;&amp; delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function fb(a) {
      return a[s] = !0, a
    }

    function gb(a) {
      var b = l.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null
      }
    }

    function hb(a, b) {
      var c = a.split("|"),
        e = a.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function ib(a, b) {
      var c = b &amp;&amp; a,
        d = c &amp;&amp; 1 === a.nodeType &amp;&amp; 1 === b.nodeType &amp;&amp; (~b.sourceIndex || B) - (~a.sourceIndex || B);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function jb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c &amp;&amp; b.type === a
      }
    }

    function kb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) &amp;&amp; b.type === a
      }
    }

    function lb(a) {
      return fb(function(b) {
        return b = +b, fb(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] &amp;&amp; (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function mb(a) {
      return a &amp;&amp; typeof a.getElementsByTagName !== A &amp;&amp; a
    }
    c = db.support = {}, f = db.isXML = function(a) {
      var b = a &amp;&amp; (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, k = db.setDocument = function(a) {
      var b, e = a ? a.ownerDocument || a : t,
        g = e.defaultView;
      return e !== l &amp;&amp; 9 === e.nodeType &amp;&amp; e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g &amp;&amp; g !== g.top &amp;&amp; (g.addEventListener ? g.addEventListener("unload", function() {
        k()
      }, !1) : g.attachEvent &amp;&amp; g.attachEvent("onunload", function() {
        k()
      })), c.attributes = gb(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = gb(function(a) {
        return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = Y.test(e.getElementsByClassName) &amp;&amp; gb(function(a) {
        return a.innerHTML = "&lt;div class='a'&gt;&lt;/div&gt;&lt;div class='a i'&gt;&lt;/div&gt;", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length
      }), c.getById = gb(function(a) {
        return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if (typeof b.getElementById !== A &amp;&amp; n) {
          var c = b.getElementById(a);
          return c &amp;&amp; c.parentNode ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          var c = typeof a.getAttributeNode !== A &amp;&amp; a.getAttributeNode("id");
          return c &amp;&amp; c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType &amp;&amp; d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName &amp;&amp; function(a, b) {
        return typeof b.getElementsByClassName !== A &amp;&amp; n ? b.getElementsByClassName(a) : void 0
      }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) &amp;&amp; (gb(function(a) {
        a.innerHTML = "&lt;select t=''&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;", a.querySelectorAll("[t^='']").length &amp;&amp; o.push("[*^$]=" + K + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || o.push("\\[" + K + "*(?:value|" + J + ")"), a.querySelectorAll(":checked").length || o.push(":checked")
      }), gb(function(a) {
        var b = e.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length &amp;&amp; o.push("name" + K + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || o.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), o.push(",.*:")
      })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) &amp;&amp; gb(function(a) {
        c.disconnectedMatch = q.call(a, "div"), q.call(a, "[s!='']:x"), p.push("!=", O)
      }), o = o.length &amp;&amp; new RegExp(o.join("|")), p = p.length &amp;&amp; new RegExp(p.join("|")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b &amp;&amp; b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition &amp;&amp; 16 &amp; a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, z = b ? function(a, b) {
        if (a === b) return j = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 &amp; d || !c.sortDetached &amp;&amp; b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t &amp;&amp; r(t, a) ? -1 : b === e || b.ownerDocument === t &amp;&amp; r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 &amp; d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return j = !0, 0;
        var c, d = 0,
          f = a.parentNode,
          g = b.parentNode,
          h = [a],
          k = [b];
        if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;
        if (f === g) return ib(a, b);
        c = a;
        while (c = c.parentNode) h.unshift(c);
        c = b;
        while (c = c.parentNode) k.unshift(c);
        while (h[d] === k[d]) d++;
        return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0
      }, e) : l
    }, db.matches = function(a, b) {
      return db(a, null, null, b)
    }, db.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== l &amp;&amp; k(a), b = b.replace(S, "='$1']"), !(!c.matchesSelector || !n || p &amp;&amp; p.test(b) || o &amp;&amp; o.test(b))) try {
        var d = q.call(a, b);
        if (d || c.disconnectedMatch || a.document &amp;&amp; 11 !== a.document.nodeType) return d
      } catch (e) {}
      return db(b, l, null, [a]).length &gt; 0
    }, db.contains = function(a, b) {
      return (a.ownerDocument || a) !== l &amp;&amp; k(a), r(a, b)
    }, db.attr = function(a, b) {
      (a.ownerDocument || a) !== l &amp;&amp; k(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e &amp;&amp; C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;
      return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) &amp;&amp; f.specified ? f.value : null
    }, db.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, db.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (j = !c.detectDuplicates, i = !c.sortStable &amp;&amp; a.slice(0), a.sort(z), j) {
        while (b = a[f++]) b === a[f] &amp;&amp; (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return i = null, a
    }, e = db.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = db.selectors = {
      cacheLength: 50,
      createPseudo: fb,
      match: V,
      attrHandle: {},
      find: {},
      relative: {
        "&gt;": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || "").replace(ab, bb), "~=" === a[2] &amp;&amp; (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] &amp;&amp; db.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[5] &amp;&amp; a[2];
          return V.CHILD.test(a[0]) ? null : (a[3] &amp;&amp; void 0 !== a[4] ? a[2] = a[4] : c &amp;&amp; T.test(c) &amp;&amp; (b = ob(c, !0)) &amp;&amp; (b = c.indexOf(")", c.length - b) - c.length) &amp;&amp; (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(ab, bb).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = w[a + " "];
          return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) &amp;&amp; w(a, function(a) {
            return b.test("string" == typeof a.className &amp;&amp; a.className || typeof a.getAttribute !== A &amp;&amp; a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = db.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c &amp;&amp; 0 === e.indexOf(c) : "*=" === b ? c &amp;&amp; e.indexOf(c) &gt; -1 : "$=" === b ? c &amp;&amp; e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) &gt; -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d &amp;&amp; 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h &amp;&amp; b.nodeName.toLowerCase(),
              t = !i &amp;&amp; !h;
            if (q) {
              if (f) {
                while (p) {
                  l = b;
                  while (l = l[p])
                    if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                  o = p = "only" === a &amp;&amp; !o &amp;&amp; "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g &amp;&amp; t) {
                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u &amp;&amp; j[1], m = j[0] === u &amp;&amp; j[2], l = n &amp;&amp; q.childNodes[n];
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if (1 === l.nodeType &amp;&amp; ++m &amp;&amp; l === b) {
                    k[a] = [u, n, m];
                    break
                  }
              } else if (t &amp;&amp; (j = (b[s] || (b[s] = {}))[a]) &amp;&amp; j[0] === u) m = j[1];
              else
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) &amp;&amp; ++m &amp;&amp; (t &amp;&amp; ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;
              return m -= e, m === d || m % d === 0 &amp;&amp; m / d &gt;= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error("unsupported pseudo: " + a);
          return e[s] ? e(b) : e.length &gt; 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: fb(function(a) {
          var b = [],
            c = [],
            d = g(a.replace(P, "$1"));
          return d[s] ? fb(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) &amp;&amp; (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), !c.pop()
          }
        }),
        has: fb(function(a) {
          return function(b) {
            return db(a, b).length &gt; 0
          }
        }),
        contains: fb(function(a) {
          return function(b) {
            return (b.textContent || b.innerText || e(b)).indexOf(a) &gt; -1
          }
        }),
        lang: fb(function(a) {
          return U.test(a || "") || db.error("unsupported lang: " + a), a = a.replace(ab, bb).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = n ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) &amp;&amp; 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location &amp;&amp; a.location.hash;
          return c &amp;&amp; c.slice(1) === b.id
        },
        root: function(a) {
          return a === m
        },
        focus: function(a) {
          return a === l.activeElement &amp;&amp; (!l.hasFocus || l.hasFocus()) &amp;&amp; !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; !!a.checked || "option" === b &amp;&amp; !!a.selected
        },
        selected: function(a) {
          return a.parentNode &amp;&amp; a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType &lt; 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return X.test(a.nodeName)
        },
        input: function(a) {
          return W.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() &amp;&amp; "text" === a.type &amp;&amp; (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: lb(function() {
          return [0]
        }),
        last: lb(function(a, b) {
          return [b - 1]
        }),
        eq: lb(function(a, b, c) {
          return [0 &gt; c ? c + b : c]
        }),
        even: lb(function(a, b) {
          for (var c = 0; b &gt; c; c += 2) a.push(c);
          return a
        }),
        odd: lb(function(a, b) {
          for (var c = 1; b &gt; c; c += 2) a.push(c);
          return a
        }),
        lt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; --d &gt;= 0;) a.push(d);
          return a
        }),
        gt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; ++d &lt; b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = jb(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = kb(b);

    function nb() {}
    nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;

    function ob(a, b) {
      var c, e, f, g, h, i, j, k = x[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        (!c || (e = Q.exec(h))) &amp;&amp; (e &amp;&amp; (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) &amp;&amp; (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(P, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = V[g].exec(h)) || j[g] &amp;&amp; !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? db.error(a) : x(a, i).slice(0)
    }

    function pb(a) {
      for (var b = 0, c = a.length, d = ""; c &gt; b; b++) d += a[b].value;
      return d
    }

    function qb(a, b, c) {
      var d = b.dir,
        e = c &amp;&amp; "parentNode" === d,
        f = v++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j = [u, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) &amp;&amp; a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (i = b[s] || (b[s] = {}), (h = i[d]) &amp;&amp; h[0] === u &amp;&amp; h[1] === f) return j[2] = h[2];
              if (i[d] = j, j[2] = a(b, c, g)) return !0
            }
      }
    }

    function rb(a) {
      return a.length &gt; 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function sb(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i &gt; h; h++)(f = a[h]) &amp;&amp; (!c || c(f, d, e)) &amp;&amp; (g.push(f), j &amp;&amp; b.push(h));
      return g
    }

    function tb(a, b, c, d, e, f) {
      return d &amp;&amp; !d[s] &amp;&amp; (d = tb(d)), e &amp;&amp; !e[s] &amp;&amp; (e = tb(e, f)), fb(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || wb(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f &amp;&amp; b ? p : sb(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c &amp;&amp; c(q, r, h, i), d) {
          j = sb(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) &amp;&amp; (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) &amp;&amp; j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) &amp;&amp; (j = e ? I.call(f, l) : m[k]) &gt; -1 &amp;&amp; (f[j] = !(g[j] = l))
          }
        } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)
      })
    }

    function ub(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[" "], j = g ? 1 : 0, k = qb(function(a) {
          return a === b
        }, i, !0), l = qb(function(a) {
          return I.call(b, a) &gt; -1
        }, i, !0), m = [function(a, c, d) {
          return !g &amp;&amp; (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))
        }]; f &gt; j; j++)
        if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];
        else {
          if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {
            for (e = ++j; f &gt; e; e++)
              if (d.relative[a[e].type]) break;
            return tb(j &gt; 1 &amp;&amp; rb(m), j &gt; 1 &amp;&amp; pb(a.slice(0, j - 1).concat({
              value: " " === a[j - 2].type ? "*" : ""
            })).replace(P, "$1"), c, e &gt; j &amp;&amp; ub(a.slice(j, e)), f &gt; e &amp;&amp; ub(a = a.slice(e)), f &gt; e &amp;&amp; pb(a))
          }
          m.push(c)
        }
      return rb(m)
    }

    function vb(a, b) {
      var c = b.length &gt; 0,
        e = a.length &gt; 0,
        f = function(f, g, i, j, k) {
          var m, n, o, p = 0,
            q = "0",
            r = f &amp;&amp; [],
            s = [],
            t = h,
            v = f || e &amp;&amp; d.find.TAG("*", k),
            w = u += null == t ? 1 : Math.random() || .1,
            x = v.length;
          for (k &amp;&amp; (h = g !== l &amp;&amp; g); q !== x &amp;&amp; null != (m = v[q]); q++) {
            if (e &amp;&amp; m) {
              n = 0;
              while (o = a[n++])
                if (o(m, g, i)) {
                  j.push(m);
                  break
                }
              k &amp;&amp; (u = w)
            }
            c &amp;&amp; ((m = !o &amp;&amp; m) &amp;&amp; p--, f &amp;&amp; r.push(m))
          }
          if (p += q, c &amp;&amp; q !== p) {
            n = 0;
            while (o = b[n++]) o(r, s, g, i);
            if (f) {
              if (p &gt; 0)
                while (q--) r[q] || s[q] || (s[q] = E.call(j));
              s = sb(s)
            }
            G.apply(j, s), k &amp;&amp; !f &amp;&amp; s.length &gt; 0 &amp;&amp; p + b.length &gt; 1 &amp;&amp; db.uniqueSort(j)
          }
          return k &amp;&amp; (u = w, h = t), r
        };
      return c ? fb(f) : f
    }
    g = db.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = y[a + " "];
      if (!f) {
        b || (b = ob(a)), c = b.length;
        while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);
        f = y(a, vb(e, d))
      }
      return f
    };

    function wb(a, b, c) {
      for (var d = 0, e = b.length; e &gt; d; d++) db(a, b[d], c);
      return c
    }

    function xb(a, b, e, f) {
      var h, i, j, k, l, m = ob(a);
      if (!f &amp;&amp; 1 === m.length) {
        if (i = m[0] = m[0].slice(0), i.length &gt; 2 &amp;&amp; "ID" === (j = i[0]).type &amp;&amp; c.getById &amp;&amp; 9 === b.nodeType &amp;&amp; n &amp;&amp; d.relative[i[1].type]) {
          if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;
          a = a.slice(i.shift().value.length)
        }
        h = V.needsContext.test(a) ? 0 : i.length;
        while (h--) {
          if (j = i[h], d.relative[k = j.type]) break;
          if ((l = d.find[k]) &amp;&amp; (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) &amp;&amp; mb(b.parentNode) || b))) {
            if (i.splice(h, 1), a = f.length &amp;&amp; pb(i), !a) return G.apply(e, f), e;
            break
          }
        }
      }
      return g(a, m)(f, b, !n, e, $.test(a) &amp;&amp; mb(b.parentNode) || b), e
    }
    return c.sortStable = s.split("").sort(z).join("") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {
      return 1 &amp; a.compareDocumentPosition(l.createElement("div"))
    }), gb(function(a) {
      return a.innerHTML = "&lt;a href='#'&gt;&lt;/a&gt;", "#" === a.firstChild.getAttribute("href")
    }) || hb("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes &amp;&amp; gb(function(a) {
      return a.innerHTML = "&lt;input/&gt;", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || hb("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), gb(function(a) {
      return null == a.getAttribute("disabled")
    }) || hb(J, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) &amp;&amp; d.specified ? d.value : null
    }), db
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = n.expr.match.needsContext,
    v = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/,
    w = /^.[^:#\[\.,]*$/;

  function x(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return n.inArray(a, b) &gt;= 0 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c &amp;&amp; (a = ":not(" + a + ")"), 1 === b.length &amp;&amp; 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = [],
        d = this,
        e = d.length;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; e &gt; b; b++)
          if (n.contains(d[b], this)) return !0
      }));
      for (b = 0; e &gt; b; b++) n.find(a, d[b], c);
      return c = this.pushStack(e &gt; 1 ? n.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c
    },
    filter: function(a) {
      return this.pushStack(x(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(x(this, a || [], !0))
    },
    is: function(a) {
      return !!x(this, "string" == typeof a &amp;&amp; u.test(a) ? n(a) : a || [], !1).length
    }
  });
  var y, z = a.document,
    A = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,
    B = n.fn.init = function(a, b) {
      var c, d;
      if (!a) return this;
      if ("string" == typeof a) {
        if (c = "&lt;" === a.charAt(0) &amp;&amp; "&gt;" === a.charAt(a.length - 1) &amp;&amp; a.length &gt;= 3 ? [null, a, null] : A.exec(a), !c || !c[1] &amp;&amp; b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
        if (c[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b &amp;&amp; b.nodeType ? b.ownerDocument || b : z, !0)), v.test(c[1]) &amp;&amp; n.isPlainObject(b))
            for (c in b) n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
          return this
        }
        if (d = z.getElementById(c[2]), d &amp;&amp; d.parentNode) {
          if (d.id !== c[2]) return y.find(a);
          this.length = 1, this[0] = d
        }
        return this.context = z, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector &amp;&amp; (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  B.prototype = n.fn, y = n(z);
  var C = /^(?:parents|prev(?:Until|All))/,
    D = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.extend({
    dir: function(a, b, c) {
      var d = [],
        e = a[b];
      while (e &amp;&amp; 9 !== e.nodeType &amp;&amp; (void 0 === c || 1 !== e.nodeType || !n(e).is(c))) 1 === e.nodeType &amp;&amp; d.push(e), e = e[b];
      return d
    },
    sibling: function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType &amp;&amp; a !== b &amp;&amp; c.push(a);
      return c
    }
  }), n.fn.extend({
    has: function(a) {
      var b, c = n(a, this),
        d = c.length;
      return this.filter(function() {
        for (b = 0; d &gt; b; b++)
          if (n.contains(this, c[b])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e &gt; d; d++)
        for (c = this[d]; c &amp;&amp; c !== b; c = c.parentNode)
          if (c.nodeType &lt; 11 &amp;&amp; (g ? g.index(c) &gt; -1 : 1 === c.nodeType &amp;&amp; n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          }
      return this.pushStack(f.length &gt; 1 ? n.unique(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? n.inArray(this[0], n(a)) : n.inArray(a.jquery ? a[0] : a, this) : this[0] &amp;&amp; this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function E(a, b) {
    do a = a[b]; while (a &amp;&amp; 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return n.dir(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return n.dir(a, "parentNode", c)
    },
    next: function(a) {
      return E(a, "nextSibling")
    },
    prev: function(a) {
      return E(a, "previousSibling")
    },
    nextAll: function(a) {
      return n.dir(a, "nextSibling")
    },
    prevAll: function(a) {
      return n.dir(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return n.dir(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return n.dir(a, "previousSibling", c)
    },
    siblings: function(a) {
      return n.sibling((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return n.sibling(a.firstChild)
    },
    contents: function(a) {
      return n.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) &amp;&amp; (d = c), d &amp;&amp; "string" == typeof d &amp;&amp; (e = n.filter(d, e)), this.length &gt; 1 &amp;&amp; (D[a] || (e = n.unique(e)), C.test(a) &amp;&amp; (e = e.reverse())), this.pushStack(e)
    }
  });
  var F = /\S+/g,
    G = {};

  function H(a) {
    var b = G[a] = {};
    return n.each(a.match(F) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? G[a] || H(a) : n.extend({}, a);
    var b, c, d, e, f, g, h = [],
      i = !a.once &amp;&amp; [],
      j = function(l) {
        for (c = a.memory &amp;&amp; l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h &amp;&amp; e &gt; f; f++)
          if (h[f].apply(l[0], l[1]) === !1 &amp;&amp; a.stopOnFalse) {
            c = !1;
            break
          }
        b = !1, h &amp;&amp; (i ? i.length &amp;&amp; j(i.shift()) : c ? h = [] : k.disable())
      },
      k = {
        add: function() {
          if (h) {
            var d = h.length;
            ! function f(b) {
              n.each(b, function(b, c) {
                var d = n.type(c);
                "function" === d ? a.unique &amp;&amp; k.has(c) || h.push(c) : c &amp;&amp; c.length &amp;&amp; "string" !== d &amp;&amp; f(c)
              })
            }(arguments), b ? e = h.length : c &amp;&amp; (g = d, j(c))
          }
          return this
        },
        remove: function() {
          return h &amp;&amp; n.each(arguments, function(a, c) {
            var d;
            while ((d = n.inArray(c, h, d)) &gt; -1) h.splice(d, 1), b &amp;&amp; (e &gt;= d &amp;&amp; e--, f &gt;= d &amp;&amp; f--)
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, h) &gt; -1 : !(!h || !h.length)
        },
        empty: function() {
          return h = [], e = 0, this
        },
        disable: function() {
          return h = i = c = void 0, this
        },
        disabled: function() {
          return !h
        },
        lock: function() {
          return i = void 0, c || k.disable(), this
        },
        locked: function() {
          return !i
        },
        fireWith: function(a, c) {
          return !h || d &amp;&amp; !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this
        },
        fire: function() {
          return k.fireWith(this, arguments), this
        },
        fired: function() {
          return !!d
        }
      };
    return k
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) &amp;&amp; a[b];
                e[f[1]](function() {
                  var a = g &amp;&amp; g.apply(this, arguments);
                  a &amp;&amp; n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h &amp;&amp; g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a &amp;&amp; a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = d.call(arguments),
        e = c.length,
        f = 1 !== e || a &amp;&amp; n.isFunction(a.promise) ? e : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(e) {
            b[a] = this, c[a] = arguments.length &gt; 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (e &gt; 1)
        for (i = new Array(e), j = new Array(e), k = new Array(e); e &gt; b; b++) c[b] &amp;&amp; n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var I;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      if (a === !0 ? !--n.readyWait : !n.isReady) {
        if (!z.body) return setTimeout(n.ready);
        n.isReady = !0, a !== !0 &amp;&amp; --n.readyWait &gt; 0 || (I.resolveWith(z, [n]), n.fn.trigger &amp;&amp; n(z).trigger("ready").off("ready"))
      }
    }
  });

  function J() {
    z.addEventListener ? (z.removeEventListener("DOMContentLoaded", K, !1), a.removeEventListener("load", K, !1)) : (z.detachEvent("onreadystatechange", K), a.detachEvent("onload", K))
  }

  function K() {
    (z.addEventListener || "load" === event.type || "complete" === z.readyState) &amp;&amp; (J(), n.ready())
  }
  n.ready.promise = function(b) {
    if (!I)
      if (I = n.Deferred(), "complete" === z.readyState) setTimeout(n.ready);
      else if (z.addEventListener) z.addEventListener("DOMContentLoaded", K, !1), a.addEventListener("load", K, !1);
    else {
      z.attachEvent("onreadystatechange", K), a.attachEvent("onload", K);
      var c = !1;
      try {
        c = null == a.frameElement &amp;&amp; z.documentElement
      } catch (d) {}
      c &amp;&amp; c.doScroll &amp;&amp; ! function e() {
        if (!n.isReady) {
          try {
            c.doScroll("left")
          } catch (a) {
            return setTimeout(e, 50)
          }
          J(), n.ready()
        }
      }()
    }
    return I.promise(b)
  };
  var L = "undefined",
    M;
  for (M in n(l)) break;
  l.ownLast = "0" !== M, l.inlineBlockNeedsLayout = !1, n(function() {
      var a, b, c = z.getElementsByTagName("body")[0];
      c &amp;&amp; (a = z.createElement("div"), a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", b = z.createElement("div"), c.appendChild(a).appendChild(b), typeof b.style.zoom !== L &amp;&amp; (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) &amp;&amp; (c.style.zoom = 1)), c.removeChild(a), a = b = null)
    }),
    function() {
      var a = z.createElement("div");
      if (null == l.deleteExpando) {
        l.deleteExpando = !0;
        try {
          delete a.test
        } catch (b) {
          l.deleteExpando = !1
        }
      }
      a = null
    }(), n.acceptData = function(a) {
      var b = n.noData[(a.nodeName + " ").toLowerCase()],
        c = +a.nodeType || 1;
      return 1 !== c &amp;&amp; 9 !== c ? !1 : !b || b !== !0 &amp;&amp; a.getAttribute("classid") === b
    };
  var N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;

  function P(a, b, c) {
    if (void 0 === c &amp;&amp; 1 === a.nodeType) {
      var d = "data-" + b.replace(O, "-$1").toLowerCase();
      if (c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
        } catch (e) {}
        n.data(a, b, c)
      } else c = void 0
    }
    return c
  }

  function Q(a) {
    var b;
    for (b in a)
      if (("data" !== b || !n.isEmptyObject(a[b])) &amp;&amp; "toJSON" !== b) return !1;
    return !0
  }

  function R(a, b, d, e) {
    if (n.acceptData(a)) {
      var f, g, h = n.expando,
        i = a.nodeType,
        j = i ? n.cache : a,
        k = i ? a[h] : a[h] &amp;&amp; h;
      if (k &amp;&amp; j[k] &amp;&amp; (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || n.guid++ : h), j[k] || (j[k] = i ? {} : {
        toJSON: n.noop
      }), ("object" == typeof b || "function" == typeof b) &amp;&amp; (e ? j[k] = n.extend(j[k], b) : j[k].data = n.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d &amp;&amp; (g[n.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f &amp;&amp; (f = g[n.camelCase(b)])) : f = g, f
    }
  }

  function S(a, b, c) {
    if (n.acceptData(a)) {
      var d, e, f = a.nodeType,
        g = f ? n.cache : a,
        h = f ? a[n.expando] : n.expando;
      if (g[h]) {
        if (b &amp;&amp; (d = c ? g[h] : g[h].data)) {
          n.isArray(b) ? b = b.concat(n.map(b, n.camelCase)) : b in d ? b = [b] : (b = n.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;
          while (e--) delete d[b[e]];
          if (c ? !Q(d) : !n.isEmptyObject(d)) return
        }(c || (delete g[h].data, Q(g[h]))) &amp;&amp; (f ? n.cleanData([a], !0) : l.deleteExpando || g != g.window ? delete g[h] : g[h] = null)
      }
    }
  }
  n.extend({
    cache: {},
    noData: {
      "applet ": !0,
      "embed ": !0,
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },
    hasData: function(a) {
      return a = a.nodeType ? n.cache[a[n.expando]] : a[n.expando], !!a &amp;&amp; !Q(a)
    },
    data: function(a, b, c) {
      return R(a, b, c)
    },
    removeData: function(a, b) {
      return S(a, b)
    },
    _data: function(a, b, c) {
      return R(a, b, c, !0)
    },
    _removeData: function(a, b) {
      return S(a, b, !0)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f &amp;&amp; f.attributes;
      if (void 0 === a) {
        if (this.length &amp;&amp; (e = n.data(f), 1 === f.nodeType &amp;&amp; !n._data(f, "parsedAttrs"))) {
          c = g.length;
          while (c--) d = g[c].name, 0 === d.indexOf("data-") &amp;&amp; (d = n.camelCase(d.slice(5)), P(f, d, e[d]));
          n._data(f, "parsedAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        n.data(this, a)
      }) : arguments.length &gt; 1 ? this.each(function() {
        n.data(this, a, b)
      }) : f ? P(f, a, n.data(f, a)) : void 0
    },
    removeData: function(a) {
      return this.each(function() {
        n.removeData(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = n._data(a, b), c &amp;&amp; (!d || n.isArray(c) ? d = n._data(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e &amp;&amp; (e = c.shift(), d--), e &amp;&amp; ("fx" === b &amp;&amp; c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d &amp;&amp; f &amp;&amp; f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return n._data(a, c) || n._data(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          n._removeData(a, b + "queue"), n._removeData(a, c)
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a &amp;&amp; (b = a, a = "fx", c--), arguments.length &lt; c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a &amp;&amp; "inprogress" !== c[0] &amp;&amp; n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a &amp;&amp; (b = a, a = void 0), a = a || "fx";
      while (g--) c = n._data(f[g], a + "queueHooks"), c &amp;&amp; c.empty &amp;&amp; (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    U = ["Top", "Right", "Bottom", "Left"],
    V = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    },
    W = n.access = function(a, b, c, d, e, f, g) {
      var h = 0,
        i = a.length,
        j = null == c;
      if ("object" === n.type(c)) {
        e = !0;
        for (h in c) n.access(a, b, h, c[h], !0, f, g)
      } else if (void 0 !== d &amp;&amp; (e = !0, n.isFunction(d) || (g = !0), j &amp;&amp; (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
          return j.call(n(a), c)
        })), b))
        for (; i &gt; h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
      return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
    },
    X = /^(?:checkbox|radio)$/i;
  ! function() {
    var a = z.createDocumentFragment(),
      b = z.createElement("div"),
      c = z.createElement("input");
    if (b.setAttribute("className", "t"), b.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;", l.leadingWhitespace = 3 === b.firstChild.nodeType, l.tbody = !b.getElementsByTagName("tbody").length, l.htmlSerialize = !!b.getElementsByTagName("link").length, l.html5Clone = "&lt;:nav&gt;&lt;/:nav&gt;" !== z.createElement("nav").cloneNode(!0).outerHTML, c.type = "checkbox", c.checked = !0, a.appendChild(c), l.appendChecked = c.checked, b.innerHTML = "&lt;textarea&gt;x&lt;/textarea&gt;", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, a.appendChild(b), b.innerHTML = "&lt;input type='radio' checked='checked' name='t'/&gt;", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, l.noCloneEvent = !0, b.attachEvent &amp;&amp; (b.attachEvent("onclick", function() {
        l.noCloneEvent = !1
      }), b.cloneNode(!0).click()), null == l.deleteExpando) {
      l.deleteExpando = !0;
      try {
        delete b.test
      } catch (d) {
        l.deleteExpando = !1
      }
    }
    a = b = c = null
  }(),
  function() {
    var b, c, d = z.createElement("div");
    for (b in {
        submit: !0,
        change: !0,
        focusin: !0
      }) c = "on" + b, (l[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), l[b + "Bubbles"] = d.attributes[c].expando === !1);
    d = null
  }();
  var Y = /^(?:input|select|textarea)$/i,
    Z = /^key/,
    $ = /^(?:mouse|contextmenu)|click/,
    _ = /^(?:focusinfocus|focusoutblur)$/,
    ab = /^([^.]*)(?:\.(.+)|)$/;

  function bb() {
    return !0
  }

  function cb() {
    return !1
  }

  function db() {
    try {
      return z.activeElement
    } catch (a) {}
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n._data(a);
      if (r) {
        c.handler &amp;&amp; (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
          return typeof n === L || a &amp;&amp; n.event.triggered === a.type ? void 0 : n.event.dispatch.apply(k.elem, arguments)
        }, k.elem = a), b = (b || "").match(F) || [""], h = b.length;
        while (h--) f = ab.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o &amp;&amp; (j = n.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = n.event.special[o] || {}, l = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e &amp;&amp; n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, i), (m = g[o]) || (m = g[o] = [], m.delegateCount = 0, j.setup &amp;&amp; j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent &amp;&amp; a.attachEvent("on" + o, k))), j.add &amp;&amp; (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), n.event.global[o] = !0);
        a = null
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData(a) &amp;&amp; n._data(a);
      if (r &amp;&amp; (k = r.events)) {
        b = (b || "").match(F) || [""], j = b.length;
        while (j--)
          if (h = ab.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = k[o] || [], h = h[2] &amp;&amp; new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = m.length;
            while (f--) g = m[f], !e &amp;&amp; q !== g.origType || c &amp;&amp; c.guid !== g.guid || h &amp;&amp; !h.test(g.namespace) || d &amp;&amp; d !== g.selector &amp;&amp; ("**" !== d || !g.selector) || (m.splice(f, 1), g.selector &amp;&amp; m.delegateCount--, l.remove &amp;&amp; l.remove.call(a, g));
            i &amp;&amp; !m.length &amp;&amp; (l.teardown &amp;&amp; l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete k[o])
          } else
            for (o in k) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(k) &amp;&amp; (delete r.handle, n._removeData(a, "events"))
      }
    },
    trigger: function(b, c, d, e) {
      var f, g, h, i, k, l, m, o = [d || z],
        p = j.call(b, "type") ? b.type : b,
        q = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (h = l = d = d || z, 3 !== d.nodeType &amp;&amp; 8 !== d.nodeType &amp;&amp; !_.test(p + n.event.triggered) &amp;&amp; (p.indexOf(".") &gt;= 0 &amp;&amp; (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") &lt; 0 &amp;&amp; "on" + p, b = b[n.expando] ? b : new n.Event(p, "object" == typeof b &amp;&amp; b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), k = n.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
        if (!e &amp;&amp; !k.noBubble &amp;&amp; !n.isWindow(d)) {
          for (i = k.delegateType || p, _.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), l = h;
          l === (d.ownerDocument || z) &amp;&amp; o.push(l.defaultView || l.parentWindow || a)
        }
        m = 0;
        while ((h = o[m++]) &amp;&amp; !b.isPropagationStopped()) b.type = m &gt; 1 ? i : k.bindType || p, f = (n._data(h, "events") || {})[b.type] &amp;&amp; n._data(h, "handle"), f &amp;&amp; f.apply(h, c), f = g &amp;&amp; h[g], f &amp;&amp; f.apply &amp;&amp; n.acceptData(h) &amp;&amp; (b.result = f.apply(h, c), b.result === !1 &amp;&amp; b.preventDefault());
        if (b.type = p, !e &amp;&amp; !b.isDefaultPrevented() &amp;&amp; (!k._default || k._default.apply(o.pop(), c) === !1) &amp;&amp; n.acceptData(d) &amp;&amp; g &amp;&amp; d[p] &amp;&amp; !n.isWindow(d)) {
          l = d[g], l &amp;&amp; (d[g] = null), n.event.triggered = p;
          try {
            d[p]()
          } catch (r) {}
          n.event.triggered = void 0, l &amp;&amp; (d[g] = l)
        }
        return b.result
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, e, f, g, h = [],
        i = d.call(arguments),
        j = (n._data(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) &amp;&amp; !a.isPropagationStopped()) {
          a.currentTarget = f.elem, g = 0;
          while ((e = f.handlers[g++]) &amp;&amp; !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(e.namespace)) &amp;&amp; (a.handleObj = e, a.data = e.data, c = ((n.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c &amp;&amp; (a.result = c) === !1 &amp;&amp; (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch &amp;&amp; k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h &amp;&amp; i.nodeType &amp;&amp; (!a.button || "click" !== a.type))
        for (; i != this; i = i.parentNode || this)
          if (1 === i.nodeType &amp;&amp; (i.disabled !== !0 || "click" !== a.type)) {
            for (e = [], f = 0; h &gt; f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] &amp;&amp; (e[c] = d.needsContext ? n(c, this).index(i) &gt;= 0 : n.find(c, this, null, [i]).length), e[c] &amp;&amp; e.push(d);
            e.length &amp;&amp; g.push({
              elem: i,
              handlers: e
            })
          }
      return h &lt; b.length &amp;&amp; g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, d, e = a.type,
        f = a,
        g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = $.test(e) ? this.mouseHooks : Z.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
      while (b--) c = d[b], a[c] = f[c];
      return a.target || (a.target = f.srcElement || z), 3 === a.target.nodeType &amp;&amp; (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which &amp;&amp; (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, d, e, f = b.button,
          g = b.fromElement;
        return null == a.pageX &amp;&amp; null != b.clientX &amp;&amp; (d = a.target.ownerDocument || z, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e &amp;&amp; e.scrollLeft || c &amp;&amp; c.scrollLeft || 0) - (e &amp;&amp; e.clientLeft || c &amp;&amp; c.clientLeft || 0), a.pageY = b.clientY + (e &amp;&amp; e.scrollTop || c &amp;&amp; c.scrollTop || 0) - (e &amp;&amp; e.clientTop || c &amp;&amp; c.clientTop || 0)), !a.relatedTarget &amp;&amp; g &amp;&amp; (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 &amp; f ? 1 : 2 &amp; f ? 3 : 4 &amp; f ? 2 : 0), a
      }
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          if (this !== db() &amp;&amp; this.focus) try {
            return this.focus(), !1
          } catch (a) {}
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === db() &amp;&amp; this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return n.nodeName(this, "input") &amp;&amp; "checkbox" === this.type &amp;&amp; this.click ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result &amp;&amp; (a.originalEvent.returnValue = a.result)
        }
      }
    },
    simulate: function(a, b, c, d) {
      var e = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() &amp;&amp; c.preventDefault()
    }
  }, n.removeEvent = z.removeEventListener ? function(a, b, c) {
    a.removeEventListener &amp;&amp; a.removeEventListener(b, c, !1)
  } : function(a, b, c) {
    var d = "on" + b;
    a.detachEvent &amp;&amp; (typeof a[d] === L &amp;&amp; (a[d] = null), a.detachEvent(d, c))
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a &amp;&amp; a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented &amp;&amp; (a.returnValue === !1 || a.getPreventDefault &amp;&amp; a.getPreventDefault()) ? bb : cb) : this.type = a, b &amp;&amp; n.extend(this, b), this.timeStamp = a &amp;&amp; a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    isDefaultPrevented: cb,
    isPropagationStopped: cb,
    isImmediatePropagationStopped: cb,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = bb, a &amp;&amp; (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = bb, a &amp;&amp; (a.stopPropagation &amp;&amp; a.stopPropagation(), a.cancelBubble = !0)
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = bb, this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return (!e || e !== d &amp;&amp; !n.contains(d, e)) &amp;&amp; (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), l.submitBubbles || (n.event.special.submit = {
    setup: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.add(this, "click._submit keypress._submit", function(a) {
        var b = a.target,
          c = n.nodeName(b, "input") || n.nodeName(b, "button") ? b.form : void 0;
        c &amp;&amp; !n._data(c, "submitBubbles") &amp;&amp; (n.event.add(c, "submit._submit", function(a) {
          a._submit_bubble = !0
        }), n._data(c, "submitBubbles", !0))
      })
    },
    postDispatch: function(a) {
      a._submit_bubble &amp;&amp; (delete a._submit_bubble, this.parentNode &amp;&amp; !a.isTrigger &amp;&amp; n.event.simulate("submit", this.parentNode, a, !0))
    },
    teardown: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.remove(this, "._submit")
    }
  }), l.changeBubbles || (n.event.special.change = {
    setup: function() {
      return Y.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) &amp;&amp; (n.event.add(this, "propertychange._change", function(a) {
        "checked" === a.originalEvent.propertyName &amp;&amp; (this._just_changed = !0)
      }), n.event.add(this, "click._change", function(a) {
        this._just_changed &amp;&amp; !a.isTrigger &amp;&amp; (this._just_changed = !1), n.event.simulate("change", this, a, !0)
      })), !1) : void n.event.add(this, "beforeactivate._change", function(a) {
        var b = a.target;
        Y.test(b.nodeName) &amp;&amp; !n._data(b, "changeBubbles") &amp;&amp; (n.event.add(b, "change._change", function(a) {
          !this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate("change", this.parentNode, a, !0)
        }), n._data(b, "changeBubbles", !0))
      })
    },
    handle: function(a) {
      var b = a.target;
      return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type &amp;&amp; "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0
    },
    teardown: function() {
      return n.event.remove(this, "._change"), !Y.test(this.nodeName)
    }
  }), l.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0)
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b);
        e || d.addEventListener(a, c, !0), n._data(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b) - 1;
        e ? n._data(d, b, e) : (d.removeEventListener(a, c, !0), n._removeData(d, b))
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d, e) {
      var f, g;
      if ("object" == typeof a) {
        "string" != typeof b &amp;&amp; (c = c || b, b = void 0);
        for (f in a) this.on(f, b, c, a[f], e);
        return this
      }
      if (null == c &amp;&amp; null == d ? (d = b, c = b = void 0) : null == d &amp;&amp; ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = cb;
      else if (!d) return this;
      return 1 === e &amp;&amp; (g = d, d = function(a) {
        return n().off(a), g.apply(this, arguments)
      }, d.guid = g.guid || (g.guid = n.guid++)), this.each(function() {
        n.event.add(this, a, d, c, b)
      })
    },
    one: function(a, b, c, d) {
      return this.on(a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a &amp;&amp; a.preventDefault &amp;&amp; a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return (b === !1 || "function" == typeof b) &amp;&amp; (c = b, b = void 0), c === !1 &amp;&amp; (c = cb), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    },
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  });

  function eb(a) {
    var b = fb.split("|"),
      c = a.createDocumentFragment();
    if (c.createElement)
      while (b.length) c.createElement(b.pop());
    return c
  }
  var fb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    gb = / jQuery\d+="(?:null|\d+)"/g,
    hb = new RegExp("&lt;(?:" + fb + ")[\\s/&gt;]", "i"),
    ib = /^\s+/,
    jb = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
    kb = /&lt;([\w:]+)/,
    lb = /&lt;tbody/i,
    mb = /&lt;|&amp;#?\w+;/,
    nb = /&lt;(?:script|style|link)/i,
    ob = /checked\s*(?:[^=]|=\s*.checked.)/i,
    pb = /^$|\/(?:java|ecma)script/i,
    qb = /^true\/(.*)/,
    rb = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,
    sb = {
      option: [1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;"],
      legend: [1, "&lt;fieldset&gt;", "&lt;/fieldset&gt;"],
      area: [1, "&lt;map&gt;", "&lt;/map&gt;"],
      param: [1, "&lt;object&gt;", "&lt;/object&gt;"],
      thead: [1, "&lt;table&gt;", "&lt;/table&gt;"],
      tr: [2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;"],
      col: [2, "&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;"],
      td: [3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"],
      _default: l.htmlSerialize ? [0, "", ""] : [1, "X&lt;div&gt;", "&lt;/div&gt;"]
    },
    tb = eb(z),
    ub = tb.appendChild(z.createElement("div"));
  sb.optgroup = sb.option, sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb.thead, sb.th = sb.td;

  function vb(a, b) {
    var c, d, e = 0,
      f = typeof a.getElementsByTagName !== L ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== L ? a.querySelectorAll(b || "*") : void 0;
    if (!f)
      for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || n.nodeName(d, b) ? f.push(d) : n.merge(f, vb(d, b));
    return void 0 === b || b &amp;&amp; n.nodeName(a, b) ? n.merge([a], f) : f
  }

  function wb(a) {
    X.test(a.type) &amp;&amp; (a.defaultChecked = a.checked)
  }

  function xb(a, b) {
    return n.nodeName(a, "table") &amp;&amp; n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function yb(a) {
    return a.type = (null !== n.find.attr(a, "type")) + "/" + a.type, a
  }

  function zb(a) {
    var b = qb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function Ab(a, b) {
    for (var c, d = 0; null != (c = a[d]); d++) n._data(c, "globalEval", !b || n._data(b[d], "globalEval"))
  }

  function Bb(a, b) {
    if (1 === b.nodeType &amp;&amp; n.hasData(a)) {
      var c, d, e, f = n._data(a),
        g = n._data(b, f),
        h = f.events;
      if (h) {
        delete g.handle, g.events = {};
        for (c in h)
          for (d = 0, e = h[c].length; e &gt; d; d++) n.event.add(b, c, h[c][d])
      }
      g.data &amp;&amp; (g.data = n.extend({}, g.data))
    }
  }

  function Cb(a, b) {
    var c, d, e;
    if (1 === b.nodeType) {
      if (c = b.nodeName.toLowerCase(), !l.noCloneEvent &amp;&amp; b[n.expando]) {
        e = n._data(b);
        for (d in e.events) n.removeEvent(b, d, e.handle);
        b.removeAttribute(n.expando)
      }
      "script" === c &amp;&amp; b.text !== a.text ? (yb(b).text = a.text, zb(b)) : "object" === c ? (b.parentNode &amp;&amp; (b.outerHTML = a.outerHTML), l.html5Clone &amp;&amp; a.innerHTML &amp;&amp; !n.trim(b.innerHTML) &amp;&amp; (b.innerHTML = a.innerHTML)) : "input" === c &amp;&amp; X.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value &amp;&amp; (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) &amp;&amp; (b.defaultValue = a.defaultValue)
    }
  }
  n.extend({
    clone: function(a, b, c) {
      var d, e, f, g, h, i = n.contains(a.ownerDocument, a);
      if (l.html5Clone || n.isXMLDoc(a) || !hb.test("&lt;" + a.nodeName + "&gt;") ? f = a.cloneNode(!0) : (ub.innerHTML = a.outerHTML, ub.removeChild(f = ub.firstChild)), !(l.noCloneEvent &amp;&amp; l.noCloneChecked || 1 !== a.nodeType &amp;&amp; 11 !== a.nodeType || n.isXMLDoc(a)))
        for (d = vb(f), h = vb(a), g = 0; null != (e = h[g]); ++g) d[g] &amp;&amp; Cb(e, d[g]);
      if (b)
        if (c)
          for (h = h || vb(a), d = d || vb(f), g = 0; null != (e = h[g]); g++) Bb(e, d[g]);
        else Bb(a, f);
      return d = vb(f, "script"), d.length &gt; 0 &amp;&amp; Ab(d, !i &amp;&amp; vb(a, "script")), d = h = e = null, f
    },
    buildFragment: function(a, b, c, d) {
      for (var e, f, g, h, i, j, k, m = a.length, o = eb(b), p = [], q = 0; m &gt; q; q++)
        if (f = a[q], f || 0 === f)
          if ("object" === n.type(f)) n.merge(p, f.nodeType ? [f] : f);
          else if (mb.test(f)) {
        h = h || o.appendChild(b.createElement("div")), i = (kb.exec(f) || ["", ""])[1].toLowerCase(), k = sb[i] || sb._default, h.innerHTML = k[1] + f.replace(jb, "&lt;$1&gt;&lt;/$2&gt;") + k[2], e = k[0];
        while (e--) h = h.lastChild;
        if (!l.leadingWhitespace &amp;&amp; ib.test(f) &amp;&amp; p.push(b.createTextNode(ib.exec(f)[0])), !l.tbody) {
          f = "table" !== i || lb.test(f) ? "&lt;table&gt;" !== k[1] || lb.test(f) ? 0 : h : h.firstChild, e = f &amp;&amp; f.childNodes.length;
          while (e--) n.nodeName(j = f.childNodes[e], "tbody") &amp;&amp; !j.childNodes.length &amp;&amp; f.removeChild(j)
        }
        n.merge(p, h.childNodes), h.textContent = "";
        while (h.firstChild) h.removeChild(h.firstChild);
        h = o.lastChild
      } else p.push(b.createTextNode(f));
      h &amp;&amp; o.removeChild(h), l.appendChecked || n.grep(vb(p, "input"), wb), q = 0;
      while (f = p[q++])
        if ((!d || -1 === n.inArray(f, d)) &amp;&amp; (g = n.contains(f.ownerDocument, f), h = vb(o.appendChild(f), "script"), g &amp;&amp; Ab(h), c)) {
          e = 0;
          while (f = h[e++]) pb.test(f.type || "") &amp;&amp; c.push(f)
        }
      return h = null, o
    },
    cleanData: function(a, b) {
      for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null != (d = a[h]); h++)
        if ((b || n.acceptData(d)) &amp;&amp; (f = d[i], g = f &amp;&amp; j[f])) {
          if (g.events)
            for (e in g.events) m[e] ? n.event.remove(d, e) : n.removeEvent(d, e, g.handle);
          j[f] &amp;&amp; (delete j[f], k ? delete d[i] : typeof d.removeAttribute !== L ? d.removeAttribute(i) : d[i] = null, c.push(f))
        }
    }
  }), n.fn.extend({
    text: function(a) {
      return W(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().append((this[0] &amp;&amp; this[0].ownerDocument || z).createTextNode(a))
      }, null, a, arguments.length)
    },
    append: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    remove: function(a, b) {
      for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || n.cleanData(vb(c)), c.parentNode &amp;&amp; (b &amp;&amp; n.contains(c.ownerDocument, c) &amp;&amp; Ab(vb(c, "script")), c.parentNode.removeChild(c));
      return this
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) {
        1 === a.nodeType &amp;&amp; n.cleanData(vb(a, !1));
        while (a.firstChild) a.removeChild(a.firstChild);
        a.options &amp;&amp; n.nodeName(a, "select") &amp;&amp; (a.options.length = 0)
      }
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return W(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(gb, "") : void 0;
        if (!("string" != typeof a || nb.test(a) || !l.htmlSerialize &amp;&amp; hb.test(a) || !l.leadingWhitespace &amp;&amp; ib.test(a) || sb[(kb.exec(a) || ["", ""])[1].toLowerCase()])) {
          a = a.replace(jb, "&lt;$1&gt;&lt;/$2&gt;");
          try {
            for (; d &gt; c; c++) b = this[c] || {}, 1 === b.nodeType &amp;&amp; (n.cleanData(vb(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b &amp;&amp; this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = arguments[0];
      return this.domManip(arguments, function(b) {
        a = this.parentNode, n.cleanData(vb(this)), a &amp;&amp; a.replaceChild(b, this)
      }), a &amp;&amp; (a.length || a.nodeType) ? this : this.remove()
    },
    detach: function(a) {
      return this.remove(a, !0)
    },
    domManip: function(a, b) {
      a = e.apply([], a);
      var c, d, f, g, h, i, j = 0,
        k = this.length,
        m = this,
        o = k - 1,
        p = a[0],
        q = n.isFunction(p);
      if (q || k &gt; 1 &amp;&amp; "string" == typeof p &amp;&amp; !l.checkClone &amp;&amp; ob.test(p)) return this.each(function(c) {
        var d = m.eq(c);
        q &amp;&amp; (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
      });
      if (k &amp;&amp; (i = n.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length &amp;&amp; (i = c), c)) {
        for (g = n.map(vb(i, "script"), yb), f = g.length; k &gt; j; j++) d = i, j !== o &amp;&amp; (d = n.clone(d, !0, !0), f &amp;&amp; n.merge(g, vb(d, "script"))), b.call(this[j], d, j);
        if (f)
          for (h = g[g.length - 1].ownerDocument, n.map(g, zb), j = 0; f &gt; j; j++) d = g[j], pb.test(d.type || "") &amp;&amp; !n._data(d, "globalEval") &amp;&amp; n.contains(h, d) &amp;&amp; (d.src ? n._evalUrl &amp;&amp; n._evalUrl(d.src) : n.globalEval((d.text || d.textContent || d.innerHTML || "").replace(rb, "")));
        i = c = null
      }
      return this
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = 0, e = [], g = n(a), h = g.length - 1; h &gt;= d; d++) c = d === h ? this : this.clone(!0), n(g[d])[b](c), f.apply(e, c.get());
      return this.pushStack(e)
    }
  });
  var Db, Eb = {};

  function Fb(b, c) {
    var d = n(c.createElement(b)).appendTo(c.body),
      e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : n.css(d[0], "display");
    return d.detach(), e
  }

  function Gb(a) {
    var b = z,
      c = Eb[a];
    return c || (c = Fb(a, b), "none" !== c &amp;&amp; c || (Db = (Db || n("&lt;iframe frameborder='0' width='0' height='0'/&gt;")).appendTo(b.documentElement), b = (Db[0].contentWindow || Db[0].contentDocument).document, b.write(), b.close(), c = Fb(a, b), Db.detach()), Eb[a] = c), c
  }! function() {
    var a, b, c = z.createElement("div"),
      d = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    c.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = c.getElementsByTagName("a")[0], a.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(a.style.opacity), l.cssFloat = !!a.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, l.shrinkWrapBlocks = function() {
      var a, c, e, f;
      if (null == b) {
        if (a = z.getElementsByTagName("body")[0], !a) return;
        f = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", c = z.createElement("div"), e = z.createElement("div"), a.appendChild(c).appendChild(e), b = !1, typeof e.style.zoom !== L &amp;&amp; (e.style.cssText = d + ";width:1px;padding:1px;zoom:1", e.innerHTML = "&lt;div&gt;&lt;/div&gt;", e.firstChild.style.width = "5px", b = 3 !== e.offsetWidth), a.removeChild(c), a = c = e = null
      }
      return b
    }
  }();
  var Hb = /^margin/,
    Ib = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"),
    Jb, Kb, Lb = /^(top|right|bottom|left)$/;
  a.getComputedStyle ? (Jb = function(a) {
    return a.ownerDocument.defaultView.getComputedStyle(a, null)
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c &amp;&amp; ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), Ib.test(g) &amp;&amp; Hb.test(b) &amp;&amp; (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + ""
  }) : z.documentElement.currentStyle &amp;&amp; (Jb = function(a) {
    return a.currentStyle
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c[b] : void 0, null == g &amp;&amp; h &amp;&amp; h[b] &amp;&amp; (g = h[b]), Ib.test(g) &amp;&amp; !Lb.test(b) &amp;&amp; (d = h.left, e = a.runtimeStyle, f = e &amp;&amp; e.left, f &amp;&amp; (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f &amp;&amp; (e.left = f)), void 0 === g ? g : g + "" || "auto"
  });

  function Mb(a, b) {
    return {
      get: function() {
        var c = a();
        if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }! function() {
    var b, c, d, e, f, g, h = z.createElement("div"),
      i = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
      j = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    h.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", b = h.getElementsByTagName("a")[0], b.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(b.style.opacity), l.cssFloat = !!b.style.cssFloat, h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, b = h = null, n.extend(l, {
      reliableHiddenOffsets: function() {
        if (null != c) return c;
        var a, b, d, e = z.createElement("div"),
          f = z.getElementsByTagName("body")[0];
        if (f) return e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = z.createElement("div"), a.style.cssText = i, f.appendChild(a).appendChild(e), e.innerHTML = "&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;", b = e.getElementsByTagName("td"), b[0].style.cssText = "padding:0;margin:0;border:0;display:none", d = 0 === b[0].offsetHeight, b[0].style.display = "", b[1].style.display = "none", c = d &amp;&amp; 0 === b[0].offsetHeight, f.removeChild(a), e = f = null, c
      },
      boxSizing: function() {
        return null == d &amp;&amp; k(), d
      },
      boxSizingReliable: function() {
        return null == e &amp;&amp; k(), e
      },
      pixelPosition: function() {
        return null == f &amp;&amp; k(), f
      },
      reliableMarginRight: function() {
        var b, c, d, e;
        if (null == g &amp;&amp; a.getComputedStyle) {
          if (b = z.getElementsByTagName("body")[0], !b) return;
          c = z.createElement("div"), d = z.createElement("div"), c.style.cssText = i, b.appendChild(c).appendChild(d), e = d.appendChild(z.createElement("div")), e.style.cssText = d.style.cssText = j, e.style.marginRight = e.style.width = "0", d.style.width = "1px", g = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight), b.removeChild(c)
        }
        return g
      }
    });

    function k() {
      var b, c, h = z.getElementsByTagName("body")[0];
      h &amp;&amp; (b = z.createElement("div"), c = z.createElement("div"), b.style.cssText = i, h.appendChild(b).appendChild(c), c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", n.swap(h, null != h.style.zoom ? {
        zoom: 1
      } : {}, function() {
        d = 4 === c.offsetWidth
      }), e = !0, f = !1, g = !0, a.getComputedStyle &amp;&amp; (f = "1%" !== (a.getComputedStyle(c, null) || {}).top, e = "4px" === (a.getComputedStyle(c, null) || {
        width: "4px"
      }).width), h.removeChild(b), c = h = null)
    }
  }(), n.swap = function(a, b, c, d) {
    var e, f, g = {};
    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
    e = c.apply(a, d || []);
    for (f in b) a.style[f] = g[f];
    return e
  };
  var Nb = /alpha\([^)]*\)/i,
    Ob = /opacity\s*=\s*([^)]*)/,
    Pb = /^(none|table(?!-c[ea]).+)/,
    Qb = new RegExp("^(" + T + ")(.*)$", "i"),
    Rb = new RegExp("^([+-])=(" + T + ")", "i"),
    Sb = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Tb = {
      letterSpacing: 0,
      fontWeight: 400
    },
    Ub = ["Webkit", "O", "Moz", "ms"];

  function Vb(a, b) {
    if (b in a) return b;
    var c = b.charAt(0).toUpperCase() + b.slice(1),
      d = b,
      e = Ub.length;
    while (e--)
      if (b = Ub[e] + c, b in a) return b;
    return d
  }

  function Wb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h &gt; g; g++) d = a[g], d.style &amp;&amp; (f[g] = n._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display &amp;&amp; V(d) &amp;&amp; (f[g] = n._data(d, "olddisplay", Gb(d.nodeName)))) : f[g] || (e = V(d), (c &amp;&amp; "none" !== c || !e) &amp;&amp; n._data(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h &gt; g; g++) d = a[g], d.style &amp;&amp; (b &amp;&amp; "none" !== d.style.display &amp;&amp; "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }

  function Xb(a, b, c) {
    var d = Qb.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
  }

  function Yb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 &gt; f; f += 2) "margin" === c &amp;&amp; (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c &amp;&amp; (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c &amp;&amp; (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c &amp;&amp; (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g
  }

  function Zb(a, b, c) {
    var d = !0,
      e = "width" === b ? a.offsetWidth : a.offsetHeight,
      f = Jb(a),
      g = l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 &gt;= e || null == e) {
      if (e = Kb(a, b, f), (0 &gt; e || null == e) &amp;&amp; (e = a.style[b]), Ib.test(e)) return e;
      d = g &amp;&amp; (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
    }
    return e + Yb(a, b, c || (g ? "border" : "content"), d, f) + "px"
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = Kb(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": l.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function(a, b, c, d) {
      if (a &amp;&amp; 3 !== a.nodeType &amp;&amp; 8 !== a.nodeType &amp;&amp; a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        if (b = n.cssProps[h] || (n.cssProps[h] = Vb(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c) return g &amp;&amp; "get" in g &amp;&amp; void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
        if (f = typeof c, "string" === f &amp;&amp; (e = Rb.exec(c)) &amp;&amp; (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c &amp;&amp; c === c &amp;&amp; ("number" !== f || n.cssNumber[h] || (c += "px"), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g &amp;&amp; "set" in g &amp;&amp; void 0 === (c = g.set(a, c, d))))) try {
          i[b] = "", i[b] = c
        } catch (j) {}
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Vb(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g &amp;&amp; "get" in g &amp;&amp; (f = g.get(a, !0, c)), void 0 === f &amp;&amp; (f = Kb(a, b, d)), "normal" === f &amp;&amp; b in Tb &amp;&amp; (f = Tb[b]), "" === c || c ? (e = parseFloat(f), c === !0 || n.isNumeric(e) ? e || 0 : f) : f
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? 0 === a.offsetWidth &amp;&amp; Pb.test(n.css(a, "display")) ? n.swap(a, Sb, function() {
          return Zb(a, b, d)
        }) : Zb(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e = d &amp;&amp; Jb(a);
        return Xb(a, c, d ? Yb(a, b, d, l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
      }
    }
  }), l.opacity || (n.cssHooks.opacity = {
    get: function(a, b) {
      return Ob.test((b &amp;&amp; a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""
    },
    set: function(a, b) {
      var c = a.style,
        d = a.currentStyle,
        e = n.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "",
        f = d &amp;&amp; d.filter || c.filter || "";
      c.zoom = 1, (b &gt;= 1 || "" === b) &amp;&amp; "" === n.trim(f.replace(Nb, "")) &amp;&amp; c.removeAttribute &amp;&amp; (c.removeAttribute("filter"), "" === b || d &amp;&amp; !d.filter) || (c.filter = Nb.test(f) ? f.replace(Nb, e) : f + " " + e)
    }
  }), n.cssHooks.marginRight = Mb(l.reliableMarginRight, function(a, b) {
    return b ? n.swap(a, {
      display: "inline-block"
    }, Kb, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 &gt; d; d++) e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, Hb.test(a) || (n.cssHooks[a + b].set = Xb)
  }), n.fn.extend({
    css: function(a, b) {
      return W(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = Jb(a), e = b.length; e &gt; g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length &gt; 1)
    },
    show: function() {
      return Wb(this, !0)
    },
    hide: function() {
      return Wb(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function $b(a, b, c, d, e) {
    return new $b.prototype.init(a, b, c, d, e)
  }
  n.Tween = $b, $b.prototype = {
    constructor: $b,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = $b.propHooks[this.prop];
      return a &amp;&amp; a.get ? a.get(this) : $b.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = $b.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step &amp;&amp; this.options.step.call(this.elem, this.now, this), c &amp;&amp; c.set ? c.set(this) : $b.propHooks._default.set(this), this
    }
  }, $b.prototype.init.prototype = $b.prototype, $b.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style &amp;&amp; null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b &amp;&amp; "auto" !== b ? b : 0) : a.elem[a.prop]
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style &amp;&amp; (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
      }
    }
  }, $b.propHooks.scrollTop = $b.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType &amp;&amp; a.elem.parentNode &amp;&amp; (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    }
  }, n.fx = $b.prototype.init, n.fx.step = {};
  var _b, ac, bc = /^(?:toggle|show|hide)$/,
    cc = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"),
    dc = /queueHooks$/,
    ec = [jc],
    fc = {
      "*": [function(a, b) {
        var c = this.createTween(a, b),
          d = c.cur(),
          e = cc.exec(b),
          f = e &amp;&amp; e[3] || (n.cssNumber[a] ? "" : "px"),
          g = (n.cssNumber[a] || "px" !== f &amp;&amp; +d) &amp;&amp; cc.exec(n.css(c.elem, a)),
          h = 1,
          i = 20;
        if (g &amp;&amp; g[3] !== f) {
          f = f || g[3], e = e || [], g = +d || 1;
          do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) &amp;&amp; 1 !== h &amp;&amp; --i)
        }
        return e &amp;&amp; (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
      }]
    };

  function gc() {
    return setTimeout(function() {
      _b = void 0
    }), _b = n.now()
  }

  function hc(a, b) {
    var c, d = {
        height: a
      },
      e = 0;
    for (b = b ? 1 : 0; 4 &gt; e; e += 2 - b) c = U[e], d["margin" + c] = d["padding" + c] = a;
    return b &amp;&amp; (d.opacity = d.width = a), d
  }

  function ic(a, b, c) {
    for (var d, e = (fc[b] || []).concat(fc["*"]), f = 0, g = e.length; g &gt; f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function jc(a, b, c) {
    var d, e, f, g, h, i, j, k, m = this,
      o = {},
      p = a.style,
      q = a.nodeType &amp;&amp; V(a),
      r = n._data(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued &amp;&amp; (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, m.always(function() {
      m.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType &amp;&amp; ("height" in b || "width" in b) &amp;&amp; (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css(a, "display"), k = Gb(a.nodeName), "none" === j &amp;&amp; (j = k), "inline" === j &amp;&amp; "none" === n.css(a, "float") &amp;&amp; (l.inlineBlockNeedsLayout &amp;&amp; "inline" !== k ? p.zoom = 1 : p.display = "inline-block")), c.overflow &amp;&amp; (p.overflow = "hidden", l.shrinkWrapBlocks() || m.always(function() {
      p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], bc.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
          if ("show" !== e || !r || void 0 === r[d]) continue;
          q = !0
        }
        o[d] = r &amp;&amp; r[d] || n.style(a, d)
      }
    if (!n.isEmptyObject(o)) {
      r ? "hidden" in r &amp;&amp; (q = r.hidden) : r = n._data(a, "fxshow", {}), f &amp;&amp; (r.hidden = !q), q ? n(a).show() : m.done(function() {
        n(a).hide()
      }), m.done(function() {
        var b;
        n._removeData(a, "fxshow");
        for (b in o) n.style(a, b, o[b])
      });
      for (d in o) g = ic(q ? r[d] : 0, d, m), d in r || (r[d] = g.start, q &amp;&amp; (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function kc(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) &amp;&amp; (e = f[1], f = a[c] = f[0]), c !== d &amp;&amp; (a[d] = f, delete a[c]), g = n.cssHooks[d], g &amp;&amp; "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function lc(a, b, c) {
    var d, e, f = 0,
      g = ec.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = _b || gc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i &gt; g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 &gt; f &amp;&amp; i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {}
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: _b || gc(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d &gt; c; c++) j.tweens[c].run(1);
          return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for (kc(k, j.opts.specialEasing); g &gt; f; f++)
      if (d = ec[f].call(j, a, k, j.opts)) return d;
    return n.map(k, ic, j), n.isFunction(j.opts.start) &amp;&amp; j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(lc, {
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
        for (var c, d = 0, e = a.length; e &gt; d; d++) c = a[d], fc[c] = fc[c] || [], fc[c].unshift(b)
      },
      prefilter: function(a, b) {
        b ? ec.unshift(a) : ec.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a &amp;&amp; "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c &amp;&amp; b || n.isFunction(a) &amp;&amp; a,
        duration: a,
        easing: c &amp;&amp; b || b &amp;&amp; !n.isFunction(b) &amp;&amp; b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) &amp;&amp; (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) &amp;&amp; d.old.call(this), d.queue &amp;&amp; n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(V).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = lc(this, n.extend({}, a), f);
            (e || n._data(this, "finish")) &amp;&amp; b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a &amp;&amp; (c = b, b = a, a = void 0), b &amp;&amp; a !== !1 &amp;&amp; this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a &amp;&amp; a + "queueHooks",
            f = n.timers,
            g = n._data(this);
          if (e) g[e] &amp;&amp; g[e].stop &amp;&amp; d(g[e]);
          else
            for (e in g) g[e] &amp;&amp; g[e].stop &amp;&amp; dc.test(e) &amp;&amp; d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a &amp;&amp; f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          (b || !c) &amp;&amp; n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 &amp;&amp; (a = a || "fx"), this.each(function() {
          var b, c = n._data(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e &amp;&amp; e.stop &amp;&amp; e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this &amp;&amp; f[b].queue === a &amp;&amp; (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g &gt; b; b++) d[b] &amp;&amp; d[b].finish &amp;&amp; d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(hc(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: hc("show"),
      slideUp: hc("hide"),
      slideToggle: hc("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = n.timers,
        c = 0;
      for (_b = n.now(); c &lt; b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
      b.length || n.fx.stop(), _b = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      ac || (ac = setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      clearInterval(ac), ac = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(a, b) {
      return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
        var d = setTimeout(b, a);
        c.stop = function() {
          clearTimeout(d)
        }
      })
    },
    function() {
      var a, b, c, d, e = z.createElement("div");
      e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = e.getElementsByTagName("a")[0], c = z.createElement("select"), d = c.appendChild(z.createElement("option")), b = e.getElementsByTagName("input")[0], a.style.cssText = "top:1px", l.getSetAttribute = "t" !== e.className, l.style = /top/.test(a.getAttribute("style")), l.hrefNormalized = "/a" === a.getAttribute("href"), l.checkOn = !!b.value, l.optSelected = d.selected, l.enctype = !!z.createElement("form").enctype, c.disabled = !0, l.optDisabled = !d.disabled, b = z.createElement("input"), b.setAttribute("value", ""), l.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), l.radioValue = "t" === b.value, a = b = c = d = e = null
    }();
  var mc = /\r/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType &amp;&amp; (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) &amp;&amp; (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b &amp;&amp; "set" in b &amp;&amp; void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b &amp;&amp; "get" in b &amp;&amp; void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(mc, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.text(a)
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 &gt; e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 &gt; e ? h : f ? e : 0; h &gt; i; i++)
            if (c = d[i], !(!c.selected &amp;&amp; i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled &amp;&amp; n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            }
          return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--)
            if (d = e[g], n.inArray(n.valHooks.option.get(d), f) &gt;= 0) try {
              d.selected = c = !0
            } catch (h) {
              d.scrollHeight
            } else d.selected = !1;
          return c || (a.selectedIndex = -1), e
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) &gt;= 0 : void 0
      }
    }, l.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  });
  var nc, oc, pc = n.expr.attrHandle,
    qc = /^(?:checked|selected)$/i,
    rc = l.getSetAttribute,
    sc = l.input;
  n.fn.extend({
    attr: function(a, b) {
      return W(this, n.attr, a, b, arguments.length &gt; 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (a &amp;&amp; 3 !== f &amp;&amp; 8 !== f &amp;&amp; 2 !== f) return typeof a.getAttribute === L ? n.prop(a, b, c) : (1 === f &amp;&amp; n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? oc : nc)), void 0 === c ? d &amp;&amp; "get" in d &amp;&amp; null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d &amp;&amp; "set" in d &amp;&amp; void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b))
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b &amp;&amp; b.match(F);
      if (f &amp;&amp; 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) ? sc &amp;&amp; rc || !qc.test(c) ? a[d] = !1 : a[n.camelCase("default-" + c)] = a[d] = !1 : n.attr(a, c, ""), a.removeAttribute(rc ? c : d)
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!l.radioValue &amp;&amp; "radio" === b &amp;&amp; n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c &amp;&amp; (a.value = c), b
          }
        }
      }
    }
  }), oc = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : sc &amp;&amp; rc || !qc.test(c) ? a.setAttribute(!rc &amp;&amp; n.propFix[c] || c, c) : a[n.camelCase("default-" + c)] = a[c] = !0, c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = pc[b] || n.find.attr;
    pc[b] = sc &amp;&amp; rc || !qc.test(b) ? function(a, b, d) {
      var e, f;
      return d || (f = pc[b], pc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, pc[b] = f), e
    } : function(a, b, c) {
      return c ? void 0 : a[n.camelCase("default-" + b)] ? b.toLowerCase() : null
    }
  }), sc &amp;&amp; rc || (n.attrHooks.value = {
    set: function(a, b, c) {
      return n.nodeName(a, "input") ? void(a.defaultValue = b) : nc &amp;&amp; nc.set(a, b, c)
    }
  }), rc || (nc = {
    set: function(a, b, c) {
      var d = a.getAttributeNode(c);
      return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0
    }
  }, pc.id = pc.name = pc.coords = function(a, b, c) {
    var d;
    return c ? void 0 : (d = a.getAttributeNode(b)) &amp;&amp; "" !== d.value ? d.value : null
  }, n.valHooks.button = {
    get: function(a, b) {
      var c = a.getAttributeNode(b);
      return c &amp;&amp; c.specified ? c.value : void 0
    },
    set: nc.set
  }, n.attrHooks.contenteditable = {
    set: function(a, b, c) {
      nc.set(a, "" === b ? !1 : b, c)
    }
  }, n.each(["width", "height"], function(a, b) {
    n.attrHooks[b] = {
      set: function(a, c) {
        return "" === c ? (a.setAttribute(b, "auto"), c) : void 0
      }
    }
  })), l.style || (n.attrHooks.style = {
    get: function(a) {
      return a.style.cssText || void 0
    },
    set: function(a, b) {
      return a.style.cssText = b + ""
    }
  });
  var tc = /^(?:input|select|textarea|button|object)$/i,
    uc = /^(?:a|area)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return W(this, n.prop, a, b, arguments.length &gt; 1)
    },
    removeProp: function(a) {
      return a = n.propFix[a] || a, this.each(function() {
        try {
          this[a] = void 0, delete this[a]
        } catch (b) {}
      })
    }
  }), n.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(a, b, c) {
      var d, e, f, g = a.nodeType;
      if (a &amp;&amp; 3 !== g &amp;&amp; 8 !== g &amp;&amp; 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f &amp;&amp; (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e &amp;&amp; "set" in e &amp;&amp; void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e &amp;&amp; "get" in e &amp;&amp; null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          var b = n.find.attr(a, "tabindex");
          return b ? parseInt(b, 10) : tc.test(a.nodeName) || uc.test(a.nodeName) &amp;&amp; a.href ? 0 : -1
        }
      }
    }
  }), l.hrefNormalized || n.each(["href", "src"], function(a, b) {
    n.propHooks[b] = {
      get: function(a) {
        return a.getAttribute(b, 4)
      }
    }
  }), l.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; (b.selectedIndex, b.parentNode &amp;&amp; b.parentNode.selectedIndex), null
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  }), l.enctype || (n.propFix.enctype = "encoding");
  var vc = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : " ")) {
            f = 0;
            while (e = b[f++]) d.indexOf(" " + e + " ") &lt; 0 &amp;&amp; (d += e + " ");
            g = n.trim(d), c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = 0 === arguments.length || "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : "")) {
            f = 0;
            while (e = b[f++])
              while (d.indexOf(" " + e + " ") &gt;= 0) d = d.replace(" " + e + " ", " ");
            g = a ? n.trim(d) : "", c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b &amp;&amp; "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function(c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b)
      } : function() {
        if ("string" === c) {
          var b, d = 0,
            e = n(this),
            f = a.match(F) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else(c === L || "boolean" === c) &amp;&amp; (this.className &amp;&amp; n._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : n._data(this, "__className__") || "")
      })
    },
    hasClass: function(a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d &gt; c; c++)
        if (1 === this[c].nodeType &amp;&amp; (" " + this[c].className + " ").replace(vc, " ").indexOf(b) &gt;= 0) return !0;
      return !1
    }
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length &gt; 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    },
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    }
  });
  var wc = n.now(),
    xc = /\?/,
    yc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  n.parseJSON = function(b) {
    if (a.JSON &amp;&amp; a.JSON.parse) return a.JSON.parse(b + "");
    var c, d = null,
      e = n.trim(b + "");
    return e &amp;&amp; !n.trim(e.replace(yc, function(a, b, e, f) {
      return c &amp;&amp; b &amp;&amp; (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "")
    })) ? Function("return " + e)() : n.error("Invalid JSON: " + b)
  }, n.parseXML = function(b) {
    var c, d;
    if (!b || "string" != typeof b) return null;
    try {
      a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b))
    } catch (e) {
      c = void 0
    }
    return c &amp;&amp; c.documentElement &amp;&amp; !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c
  };
  var zc, Ac, Bc = /#.*$/,
    Cc = /([?&amp;])_=[^&amp;]*/,
    Dc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    Ec = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    Fc = /^(?:GET|HEAD)$/,
    Gc = /^\/\//,
    Hc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    Ic = {},
    Jc = {},
    Kc = "*/".concat("*");
  try {
    Ac = location.href
  } catch (Lc) {
    Ac = z.createElement("a"), Ac.href = "", Ac = Ac.href
  }
  zc = Hc.exec(Ac.toLowerCase()) || [];

  function Mc(a) {
    return function(b, c) {
      "string" != typeof b &amp;&amp; (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(F) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function Nc(a, b, c, d) {
    var e = {},
      f = a === Jc;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] &amp;&amp; g("*")
  }

  function Oc(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (d in b) void 0 !== b[d] &amp;&amp; ((e[d] ? a : c || (c = {}))[d] = b[d]);
    return c &amp;&amp; n.extend(!0, a, c), a
  }

  function Pc(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === e &amp;&amp; (e = a.mimeType || b.getResponseHeader("Content-Type"));
    if (e)
      for (g in h)
        if (h[g] &amp;&amp; h[g].test(e)) {
          i.unshift(g);
          break
        }
    if (i[0] in c) f = i[0];
    else {
      for (g in c) {
        if (!i[0] || a.converters[g + " " + i[0]]) {
          f = g;
          break
        }
        d || (d = g)
      }
      f = f || d
    }
    return f ? (f !== i[0] &amp;&amp; i.unshift(f), c[f]) : void 0
  }

  function Qc(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] &amp;&amp; (c[a.responseFields[f]] = b), !i &amp;&amp; d &amp;&amp; a.dataFilter &amp;&amp; (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i &amp;&amp; i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f &amp;&amp; (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 &amp;&amp; (f = h[0], k.unshift(h[1]));
            break
          }
      if (g !== !0)
        if (g &amp;&amp; a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ac,
      type: "GET",
      isLocal: Ec.test(zc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": Kc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? Oc(Oc(a, n.ajaxSettings), b) : Oc(n.ajaxSettings, a)
    },
    ajaxPrefilter: Mc(Ic),
    ajaxTransport: Mc(Jc),
    ajax: function(a, b) {
      "object" == typeof a &amp;&amp; (b = a, a = void 0), b = b || {};
      var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b),
        l = k.context || k,
        m = k.context &amp;&amp; (l.nodeType || l.jquery) ? n(l) : n.event,
        o = n.Deferred(),
        p = n.Callbacks("once memory"),
        q = k.statusCode || {},
        r = {},
        s = {},
        t = 0,
        u = "canceled",
        v = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === t) {
              if (!j) {
                j = {};
                while (b = Dc.exec(f)) j[b[1].toLowerCase()] = b[2]
              }
              b = j[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === t ? f : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return t || (a = s[c] = s[c] || a, r[a] = b), this
          },
          overrideMimeType: function(a) {
            return t || (k.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 &gt; t)
                for (b in a) q[b] = [q[b], a[b]];
              else v.always(a[v.status]);
            return this
          },
          abort: function(a) {
            var b = a || u;
            return i &amp;&amp; i.abort(b), x(0, b), this
          }
        };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || Ac) + "").replace(Bc, "").replace(Gc, zc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(F) || [""], null == k.crossDomain &amp;&amp; (c = Hc.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === zc[1] &amp;&amp; c[2] === zc[2] &amp;&amp; (c[3] || ("http:" === c[1] ? "80" : "443")) === (zc[3] || ("http:" === zc[1] ? "80" : "443")))), k.data &amp;&amp; k.processData &amp;&amp; "string" != typeof k.data &amp;&amp; (k.data = n.param(k.data, k.traditional)), Nc(Ic, k, b, v), 2 === t) return v;
      h = k.global, h &amp;&amp; 0 === n.active++ &amp;&amp; n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Fc.test(k.type), e = k.url, k.hasContent || (k.data &amp;&amp; (e = k.url += (xc.test(e) ? "&amp;" : "?") + k.data, delete k.data), k.cache === !1 &amp;&amp; (k.url = Cc.test(e) ? e.replace(Cc, "$1_=" + wc++) : e + (xc.test(e) ? "&amp;" : "?") + "_=" + wc++)), k.ifModified &amp;&amp; (n.lastModified[e] &amp;&amp; v.setRequestHeader("If-Modified-Since", n.lastModified[e]), n.etag[e] &amp;&amp; v.setRequestHeader("If-None-Match", n.etag[e])), (k.data &amp;&amp; k.hasContent &amp;&amp; k.contentType !== !1 || b.contentType) &amp;&amp; v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] &amp;&amp; k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Kc + "; q=0.01" : "") : k.accepts["*"]);
      for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
      if (k.beforeSend &amp;&amp; (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
      u = "abort";
      for (d in {
          success: 1,
          error: 1,
          complete: 1
        }) v[d](k[d]);
      if (i = Nc(Jc, k, b, v)) {
        v.readyState = 1, h &amp;&amp; m.trigger("ajaxSend", [v, k]), k.async &amp;&amp; k.timeout &gt; 0 &amp;&amp; (g = setTimeout(function() {
          v.abort("timeout")
        }, k.timeout));
        try {
          t = 1, i.send(r, x)
        } catch (w) {
          if (!(2 &gt; t)) throw w;
          x(-1, w)
        }
      } else x(-1, "No Transport");

      function x(a, b, c, d) {
        var j, r, s, u, w, x = b;
        2 !== t &amp;&amp; (t = 2, g &amp;&amp; clearTimeout(g), i = void 0, f = d || "", v.readyState = a &gt; 0 ? 4 : 0, j = a &gt;= 200 &amp;&amp; 300 &gt; a || 304 === a, c &amp;&amp; (u = Pc(k, v, c)), u = Qc(k, u, v, j), j ? (k.ifModified &amp;&amp; (w = v.getResponseHeader("Last-Modified"), w &amp;&amp; (n.lastModified[e] = w), w = v.getResponseHeader("etag"), w &amp;&amp; (n.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) &amp;&amp; (x = "error", 0 &gt; a &amp;&amp; (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h &amp;&amp; m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h &amp;&amp; (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")))
      }
      return v
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) &amp;&amp; (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      })
    }
  }), n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      });
      if (this[0]) {
        var b = n(a, this[0].ownerDocument).eq(0).clone(!0);
        this[0].parentNode &amp;&amp; b.insertBefore(this[0]), b.map(function() {
          var a = this;
          while (a.firstChild &amp;&amp; 1 === a.firstChild.nodeType) a = a.firstChild;
          return a
        }).append(this)
      }
      return this
    },
    wrapInner: function(a) {
      return this.each(n.isFunction(a) ? function(b) {
        n(this).wrapInner(a.call(this, b))
      } : function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return a.offsetWidth &lt;= 0 &amp;&amp; a.offsetHeight &lt;= 0 || !l.reliableHiddenOffsets() &amp;&amp; "none" === (a.style &amp;&amp; a.style.display || n.css(a, "display"))
  }, n.expr.filters.visible = function(a) {
    return !n.expr.filters.hidden(a)
  };
  var Rc = /%20/g,
    Sc = /\[\]$/,
    Tc = /\r?\n/g,
    Uc = /^(?:submit|button|image|reset|file)$/i,
    Vc = /^(?:input|select|textarea|keygen)/i;

  function Wc(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || Sc.test(a) ? d(a, e) : Wc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Wc(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b &amp;&amp; (b = n.ajaxSettings &amp;&amp; n.ajaxSettings.traditional), n.isArray(a) || a.jquery &amp;&amp; !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Wc(c, a[c], b, e);
    return d.join("&amp;").replace(Rc, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name &amp;&amp; !n(this).is(":disabled") &amp;&amp; Vc.test(this.nodeName) &amp;&amp; !Uc.test(a) &amp;&amp; (this.checked || !X.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Tc, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(Tc, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
    return !this.isLocal &amp;&amp; /^(get|post|head|put|delete|options)$/i.test(this.type) &amp;&amp; $c() || _c()
  } : $c;
  var Xc = 0,
    Yc = {},
    Zc = n.ajaxSettings.xhr();
  a.ActiveXObject &amp;&amp; n(a).on("unload", function() {
    for (var a in Yc) Yc[a](void 0, !0)
  }), l.cors = !!Zc &amp;&amp; "withCredentials" in Zc, Zc = l.ajax = !!Zc, Zc &amp;&amp; n.ajaxTransport(function(a) {
    if (!a.crossDomain || l.cors) {
      var b;
      return {
        send: function(c, d) {
          var e, f = a.xhr(),
            g = ++Xc;
          if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
            for (e in a.xhrFields) f[e] = a.xhrFields[e];
          a.mimeType &amp;&amp; f.overrideMimeType &amp;&amp; f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
          for (e in c) void 0 !== c[e] &amp;&amp; f.setRequestHeader(e, c[e] + "");
          f.send(a.hasContent &amp;&amp; a.data || null), b = function(c, e) {
            var h, i, j;
            if (b &amp;&amp; (e || 4 === f.readyState))
              if (delete Yc[g], b = void 0, f.onreadystatechange = n.noop, e) 4 !== f.readyState &amp;&amp; f.abort();
              else {
                j = {}, h = f.status, "string" == typeof f.responseText &amp;&amp; (j.text = f.responseText);
                try {
                  i = f.statusText
                } catch (k) {
                  i = ""
                }
                h || !a.isLocal || a.crossDomain ? 1223 === h &amp;&amp; (h = 204) : h = j.text ? 200 : 404
              }
            j &amp;&amp; d(h, i, j, f.getAllResponseHeaders())
          }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Yc[g] = b : b()
        },
        abort: function() {
          b &amp;&amp; b(void 0, !0)
        }
      }
    }
  });

  function $c() {
    try {
      return new a.XMLHttpRequest
    } catch (b) {}
  }

  function _c() {
    try {
      return new a.ActiveXObject("Microsoft.XMLHTTP")
    } catch (b) {}
  }
  n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache &amp;&amp; (a.cache = !1), a.crossDomain &amp;&amp; (a.type = "GET", a.global = !1)
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c = z.head || n("head")[0] || z.documentElement;
      return {
        send: function(d, e) {
          b = z.createElement("script"), b.async = !0, a.scriptCharset &amp;&amp; (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
            (c || !b.readyState || /loaded|complete/.test(b.readyState)) &amp;&amp; (b.onload = b.onreadystatechange = null, b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null, c || e(200, "success"))
          }, c.insertBefore(b, c.firstChild)
        },
        abort: function() {
          b &amp;&amp; b.onload(void 0, !0)
        }
      }
    }
  });
  var ad = [],
    bd = /(=)\?(?=&amp;|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = ad.pop() || n.expando + "_" + wc++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 &amp;&amp; (bd.test(b.url) ? "url" : "string" == typeof b.data &amp;&amp; !(b.contentType || "").indexOf("application/x-www-form-urlencoded") &amp;&amp; bd.test(b.data) &amp;&amp; "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(bd, "$1" + e) : b.jsonp !== !1 &amp;&amp; (b.url += (xc.test(b.url) ? "&amp;" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      a[e] = f, b[e] &amp;&amp; (b.jsonpCallback = c.jsonpCallback, ad.push(e)), g &amp;&amp; n.isFunction(f) &amp;&amp; f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b &amp;&amp; (c = b, b = !1), b = b || z;
    var d = v.exec(a),
      e = !c &amp;&amp; [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e &amp;&amp; e.length &amp;&amp; n(e).remove(), n.merge([], d.childNodes))
  };
  var cd = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a &amp;&amp; cd) return cd.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h &gt;= 0 &amp;&amp; (d = a.slice(h, a.length), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b &amp;&amp; "object" == typeof b &amp;&amp; (f = "POST"), g.length &gt; 0 &amp;&amp; n.ajax({
      url: a,
      type: f,
      dataType: "html",
      data: b
    }).done(function(a) {
      e = arguments, g.html(d ? n("&lt;div&gt;").append(n.parseHTML(a)).find(d) : a)
    }).complete(c &amp;&amp; function(a, b) {
      g.each(c, e || [a.responseText, b, a])
    }), this
  }, n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };
  var dd = a.document.documentElement;

  function ed(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k &amp;&amp; (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) &amp;&amp; n.inArray("auto", [f, i]) &gt; -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) &amp;&amp; (b = b.call(a, c, h)), null != b.top &amp;&amp; (m.top = b.top - h.top + g), null != b.left &amp;&amp; (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = {
          top: 0,
          left: 0
        },
        e = this[0],
        f = e &amp;&amp; e.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, e) ? (typeof e.getBoundingClientRect !== L &amp;&amp; (d = e.getBoundingClientRect()), c = ed(f), {
        top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
        left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
      }) : d
    },
    position: function() {
      if (this[0]) {
        var a, b, c = {
            top: 0,
            left: 0
          },
          d = this[0];
        return "fixed" === n.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (c = a.offset()), c.top += n.css(a[0], "borderTopWidth", !0), c.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - c.top - n.css(d, "marginTop", !0),
          left: b.left - c.left - n.css(d, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent || dd;
        while (a &amp;&amp; !n.nodeName(a, "html") &amp;&amp; "static" === n.css(a, "position")) a = a.offsetParent;
        return a || dd
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(a, b) {
    var c = /Y/.test(b);
    n.fn[a] = function(d) {
      return W(this, function(a, d, e) {
        var f = ed(a);
        return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void(f ? f.scrollTo(c ? n(f).scrollLeft() : e, c ? e : n(f).scrollTop()) : a[d] = e)
      }, a, d, arguments.length, null)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = Mb(l.pixelPosition, function(a, c) {
      return c ? (c = Kb(a, b), Ib.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length &amp;&amp; (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return W(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.size = function() {
    return this.length
  }, n.fn.andSelf = n.fn.addBack, "function" == typeof define &amp;&amp; define.amd &amp;&amp; define("jquery", [], function() {
    return n
  });
  var fd = a.jQuery,
    gd = a.$;
  return n.noConflict = function(b) {
    return a.$ === n &amp;&amp; (a.$ = gd), b &amp;&amp; a.jQuery === n &amp;&amp; (a.jQuery = fd), n
  }, typeof b === L &amp;&amp; (a.jQuery = a.$ = n), n
});
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0_no_conflict.js */
(function() {
  window.jQuery1110 = jQuery.noConflict(true);
})();;
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i &lt; array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j &lt; types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i &lt; _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &amp;&amp;
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length &lt; this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null &amp;&amp; _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index &gt;= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses &amp;&amp; responses.length &gt; 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i &lt; _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length &gt; 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength &gt; _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length &gt; 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i &lt; lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout &gt; 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null &amp;&amp; webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel &amp;&amp; !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j &lt; messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index &gt;= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length &gt; 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect &amp;&amp; _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported &amp;&amp; !!org.cometd.WebSocket &amp;&amp; _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i &lt; arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep &amp;&amp; typeof prop === 'object' &amp;&amp; prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' &amp;&amp; !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort &amp;&amp; hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined &amp;&amp; afterURI.length &gt; 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') &gt;= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions &amp;&amp; subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription &amp;&amp; !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i &lt; subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '-&gt;', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions &amp;&amp; subscriptions.length &gt; 0) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i &gt; 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined &amp;&amp; message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch &gt; 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff &lt; _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length &gt; 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch &lt; 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 &amp;&amp; !_isDisconnected() &amp;&amp; !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length &gt; 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() &amp;&amp; _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '-&gt;', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '-&gt;', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i &gt;= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription &amp;&amp; !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i &lt; rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport &amp;&amp; typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' &amp;&amp; define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON &amp;&amp; JSON.stringify) || (window.jaredJSON &amp;&amp; window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON &amp;&amp; JSON.parse) || (window.jaredJSON &amp;&amp; window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery1110 || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i &lt; _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i &lt; _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i &lt; subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log("&gt;&gt;&gt; connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected &amp;&amp; connected)
      _connectionOpened();
    else if (wasConnected &amp;&amp; !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }
  var modalContent = '&lt;iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"&gt;&lt;/iframe&gt;';
  var modalTemplate = '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '  &lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '     &lt;div class="modal-content"&gt;' +
    '        &lt;header class="modal-header"&gt;' +
    '           &lt;h4 id="small_modal1_title" class="modal-title"&gt;Login&lt;/h4&gt;' +
    '        &lt;/header&gt;' +
    '        &lt;div class="modal-body"&gt;' +
    '        &lt;/div&gt;' +
    '     &lt;/div&gt;' +
    '  &lt;/div&gt;' +
    '&lt;/div&gt;';

  function _loginShow() {
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i &lt; window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event &amp;&amp; connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED,
        this._subscribeWhenReady.bind(this));
      LOGGER.debug("Subscribed from channel: " + currentChannel.getName());
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription &amp;&amp; _initialized) {
        subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].resubscribe();
    },
    _handleResponse: function(message) {
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length &lt; 1 &amp;&amp; subscription &amp;&amp; !_disconnected()) {
        cometd.unsubscribe(subscription);
        subscription = null;
      }
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i &lt; uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        _connectionBrokenEvent = false;
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          for (var name in channels) {
            var channel = channels[name];
            channel.resubscribe();
          }
        });
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage("&gt;&gt;&gt; connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(jQuery1110);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext &amp;&amp; document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(jQuery1110);;
/*! RESOURCE: /scripts/amb_initialize.js */
if (typeof g_amb_on_login === 'undefined') {
  amb.getClient();
};;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  if (_window.g_ambClient) {
    ambClient = _window.g_ambClient;
    sameScope = true;
  }
  if (!ambClient)
    ambClient = amb.getClient();
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow &amp;&amp; loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB &amp;&amp; state !== "opened" &amp;&amp; state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log("&gt;&gt;&gt; init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log("&gt;&gt;&gt; record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i &lt; len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i &lt; len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '	&lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '		&lt;div class="modal-content"&gt;' +
    '			&lt;header class="modal-header"&gt;' +
    '				&lt;h4 id="small_modal1_title" class="modal-title"&gt;{{title || "Login"}}&lt;/h4&gt;' +
    '			&lt;/header&gt;' +
    '			&lt;div class="modal-body"&gt;' +
    '			&lt;iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"&gt;&lt;/iframe&gt;' +
    '			&lt;/div&gt;' +
    '		&lt;/div&gt;' +
    '	&lt;/div&gt;' +
    '&lt;/div&gt;'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/sn/common/presence/_module.js */
angular.module('sn.common.presence', ['ng.amb', 'sn.common.glide']).config(function($provide) {
  "use strict";
  $provide.constant("PRESENCE_DISABLED", "false" === "true");
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snPresence.js */
angular.module("sn.common.presence").factory('snPresence', function($rootScope, $window, $log, amb, $timeout, $http, snRecordPresence, snTabActivity, urlTools, PRESENCE_DISABLED) {
  "use strict";
  var REST = {
    PRESENCE: "/api/now/ui/presence"
  };
  var databaseInterval = ($window.NOW.presence_interval || 15) * 1000;
  var initialized = false;
  var primary = false;
  var presenceArray = [];
  var serverTimeMillis;
  var skew = 0;
  var st = 0;

  function init() {
    var location = urlTools.parseQueryString(window.location.search);
    var table = location['table'] || location['sysparm_table'];
    var sys_id = location['sys_id'] || location['sysparm_sys_id'];
    var query = location['sysparm_query'];
    initPresence(table, sys_id, query);
  }

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!initialized) {
      initialized = true;
      initRootScopes();
      if (!primary) {
        CustomEvent.observe('sn.presence', onPresenceEvent);
        CustomEvent.fireTop('sn.presence.ping');
      } else {
        presenceArray = getLocalPresence();
        if (presenceArray)
          $timeout(schedulePresence, 100);
        else
          updateDatabase();
      }
    }
    snRecordPresence.initPresence(t, id);
  }

  function onPresenceEvent(parms) {
    presenceArray = parms;
    $timeout(broadcastPresence);
  }

  function initRootScopes() {
    if ($window.NOW.presence_scopes) {
      var ps = $window.NOW.presence_scopes;
      if (ps.indexOf($rootScope) == -1)
        ps.push($rootScope);
    } else {
      $window.NOW.presence_scopes = [$rootScope];
      primary = CustomEvent.isTopWindow();
    }
  }

  function updateDatabase() {
    presenceArray = getLocalPresence();
    if (presenceArray) {
      determineStatus();
      $timeout(schedulePresence);
      return;
    }
    if (!amb.isLoggedIn() || !snTabActivity.isPrimary) {
      $timeout(schedulePresence);
      return;
    }
    var p = {
      user_agent: navigator.userAgent,
      ua_time: new Date().toISOString(),
      href: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      path: window.location.pathname + window.location.search
    };
    st = new Date().getTime();
    $http.post(REST.PRESENCE + '?sysparm_auto_request=true&amp;cd=' + st, p).success(function(data) {
      var rt = new Date().getTime() - st;
      if (rt &gt; 500)
        console.log("snPresence response time " + rt + "ms");
      if (data.result &amp;&amp; data.result.presenceArray) {
        presenceArray = data.result.presenceArray;
        setLocalPresence(presenceArray);
        serverTimeMillis = data.result.serverTimeMillis;
        skew = new Date().getTime() - serverTimeMillis;
        var t = Math.floor(skew / 1000);
        if (t &lt; -15)
          console.log("&gt;&gt;&gt;&gt;&gt; server ahead " + Math.abs(t) + " seconds");
        else if (t &gt; 15)
          console.log("&gt;&gt;&gt;&gt;&gt; browser time ahead " + t + " seconds");
      }
      schedulePresence();
    }).error(function(response, status) {
      console.log("snPresence " + status);
      if (429 == status)
        $timeout(updateDatabase, databaseInterval);
      else
        schedulePresence();
    })
  }

  function schedulePresence() {
    $timeout(updateDatabase, databaseInterval);
    determineStatus();
    broadcastPresence();
  }

  function broadcastPresence() {
    $rootScope.$broadcast("sn.presence", presenceArray);
    if (!primary)
      return;
    CustomEvent.fireAll('sn.presence', presenceArray);
  }

  function determineStatus() {
    if (!presenceArray || !presenceArray.forEach) {
      $log.log("factory.snPresence &gt;&gt;&gt; server error @ " + new Date());
      return;
    }
    var t = new Date().getTime();
    t -= skew;
    presenceArray.forEach(function(p) {
      var x = 0 + p.last_on;
      var y = t - x;
      p.status = "online";
      if (y &gt; (5 * databaseInterval))
        p.status = "offline";
      else if (y &gt; (3 * databaseInterval))
        p.status = "probably offline";
      else if (y &gt; (2.5 * databaseInterval))
        p.status = "maybe offline";
    })
  }

  function setLocalPresence(value) {
    var p = {
      saved: new Date().getTime(),
      presenceArray: value
    }
    $window.localStorage.setItem('snPresence', angular.toJson(p));
  }

  function getLocalPresence() {
    var p = $window.localStorage.getItem('snPresence');
    if (!p)
      return null;
    try {
      p = angular.fromJson(p);
    } catch (e) {
      p = {};
    }
    if (!p.presenceArray)
      return null;
    var now = new Date().getTime();
    if (now - p.saved &gt;= databaseInterval)
      return null;
    return p.presenceArray;
  }
  return {
    init: init,
    initWithDocument: initPresence,
    initPresence: initPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snRecordPresence.js */
angular.module("sn.common.presence").factory('snRecordPresence', function($rootScope, $location, amb, $timeout, $window, PRESENCE_DISABLED, snTabActivity) {
  "use strict";
  var statChannel;
  var interval = 20 * 1000;
  var sessions = {};
  var timer;
  var primary = false;
  var table;
  var sys_id;

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!t || !id)
      return;
    if (t == table &amp;&amp; id == sys_id)
      return;
    initRootScopes();
    if (!primary)
      return;
    termPresence();
    table = t;
    sys_id = id;
    var recordPresence = "/sn/rp/" + table + "/" + sys_id;
    $rootScope.me = NOW.session_id;
    statChannel = amb.getChannel(recordPresence);
    statChannel.subscribe(onStatus);
    amb.connected.then(function() {
      setStatus("entered");
      $rootScope.status = "viewing";
    });
    timer = $timeout(managePresence, interval);
    return statChannel;
  }

  function initRootScopes() {
    if ($window.NOW.record_presence_scopes) {
      var ps = $window.NOW.record_presence_scopes;
      if (ps.indexOf($rootScope) == -1) {
        ps.push($rootScope);
        CustomEvent.observe('sn.sessions', onPresenceEvent);
      }
    } else {
      $window.NOW.record_presence_scopes = [$rootScope];
      primary = true;
    }
  }

  function onPresenceEvent(sessionsToSend) {
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
  }

  function termPresence() {
    if (timer)
      $timeout.cancel(timer);
    if (!statChannel)
      return;
    publish("exited");
    statChannel.unsubscribe();
    statChannel = table = sys_id = null;
  }

  function setStatus(status) {
    if (status == $rootScope.status)
      return;
    $rootScope.status = status;
    publish($rootScope.status);
  }

  function publish(status) {
    if (!statChannel)
      return;
    if (amb.getState() !== "opened")
      return;
    statChannel.publish({
      status: status,
      session_id: NOW.session_id,
      user_name: NOW.user_name,
      user_id: NOW.user_id,
      user_display_name: NOW.user_display_name,
      user_initials: NOW.user_initials,
      user_avatar: NOW.user_avatar,
      ua: navigator.userAgent,
      table: table,
      sys_id: sys_id,
      time: new Date().toString().substring(0, 24)
    });
  }

  function onStatus(message) {
    var d = message.data;
    if (d.session_id == NOW.session_id)
      return;
    var s = sessions[d.session_id];
    if (s)
      angular.extend(s, d);
    else
      s = sessions[d.session_id] = d;
    s.lastUpdated = new Date();
    broadcastSessions();
    if (s.status == 'entered')
      publish($rootScope.status);
  }

  function managePresence() {
    var now = new Date().getTime();
    var deleted = false;
    Object.keys(sessions).forEach(function(id) {
      var s = sessions[id];
      if (!s.lastUpdated)
        return;
      var last = s.lastUpdated.getTime();
      var t = now - last;
      s.lastSeen = t / 1000;
      if (s.status === 'exited') {
        deleted = true;
        delete sessions[id];
      }
      if (t &gt; interval * 2)
        s.status = 'probably left';
      if (t &gt; interval * 4) {
        deleted = true;
        delete sessions[id];
      }
    });
    if (Object.keys(sessions).length !== 0)
      publish($rootScope.status);
    timer = $timeout(managePresence, interval);
    if (deleted)
      broadcastSessions();
  }

  function broadcastSessions() {
    var sessionsToSend = getUniqueSessions();
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
    if (primary)
      $timeout(function() {
        CustomEvent.fire('sn.sessions', sessionsToSend);
      })
  }

  function getUniqueSessions() {
    var uniqueSessionsByUser = {};
    var sessionKeys = Object.keys(sessions);
    sessionKeys.forEach(function(key) {
      var session = sessions[key];
      if (session.user_id == NOW.user_id)
        return;
      if (session.user_id in uniqueSessionsByUser) {
        var otherSession = uniqueSessionsByUser[session.user_id];
        var thisPrecedence = getStatusPrecedence(session.status);
        var otherPrecedence = getStatusPrecedence(otherSession.status);
        uniqueSessionsByUser[session.user_id] = thisPrecedence &lt; otherPrecedence ? session : otherSession;
        return
      }
      uniqueSessionsByUser[session.user_id] = session;
    });
    var uniqueSessions = {};
    angular.forEach(uniqueSessionsByUser, function(item) {
      uniqueSessions[item.session_id] = item;
    });
    return uniqueSessions;
  }

  function getStatusPrecedence(status) {
    switch (status) {
      case 'typing':
        return 0;
      case 'viewing':
        return 1;
      case 'entered':
        return 2;
      case 'exited':
      case 'probably left':
        return 4;
      case 'offline':
        return 5;
      default:
        return 3;
    }
  }
  $rootScope.$on("record.typing", function(evt, data) {
    setStatus(data.status);
  });
  var idleTable, idleSysID;
  snTabActivity.onIdle({
    onIdle: function RecordPresenceTabIdle() {
      idleTable = table;
      idleSysID = sys_id;
      sessions = {};
      termPresence();
      broadcastSessions();
    },
    onReturn: function RecordPresenceTabActive() {
      initPresence(idleTable, idleSysID, true);
      idleTable = idleSysID = void(0);
    },
    delay: interval * 4
  });
  return {
    initPresence: initPresence,
    termPresence: termPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snPresence.js */
angular.module('sn.common.presence').directive('snPresence', function(snPresence, $rootScope, $timeout) {
  'use strict';
  $timeout(snPresence.init, 100);
  var presences = {};
  $rootScope.$on('sn.presence', function(event, presenceArray) {
    if (!presenceArray) {
      angular.forEach(presences, function(p) {
        p.status = "offline";
      });
      return;
    }
    presenceArray.forEach(function(presence) {
      presences[presence.user] = presence;
    });
  });
  return {
    restrict: 'EA',
    replace: false,
    scope: {
      snPresence: '=',
      user: '='
    },
    link: function(scope, element) {
      if (!element.hasClass('presence'))
        element.addClass('presence');

      function updatePresence() {
        var id = scope.snPresence || scope.user;
        if (presences[id]) {
          var status = presences[id].status;
          if (status === 'maybe offline' || status === 'probably offline') {
            element.removeClass('presence-online presence-offline presence-away');
            element.addClass('presence-away');
          } else if (status == "offline" &amp;&amp; !element.hasClass('presence-offline')) {
            element.removeClass('presence-online presence-away');
            element.addClass('presence-offline');
          } else if ((status == "online" || status == "entered" || status == "viewing") &amp;&amp; !element.hasClass('presence-online')) {
            element.removeClass('presence-offline presence-away');
            element.addClass('presence-online');
          }
        } else {
          if (!element.hasClass('presence-offline'))
            element.addClass('presence-offline');
        }
      }
      $rootScope.$on('sn.presence', updatePresence);
      updatePresence();
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/user_profile/js_includes_user_profile.js */
/*! RESOURCE: /scripts/sn/common/user_profile/_module.js */
angular.module("sn.common.user_profile", []);;
/*! RESOURCE: /scripts/sn/common/user_profile/directive.snUserProfile.js */
angular.module('sn.common.user_profile').directive('snUserProfile', function(getTemplateUrl, snCustomEvent, $window, avatarProfilePersister) {
  "use strict";
  return {
    replace: true,
    restrict: 'E',
    templateUrl: getTemplateUrl('snUserProfile.xml'),
    scope: {
      profile: "=",
      showDirectMessagePrompt: "="
    },
    link: function(scope) {
      scope.showDirectMessagePromptFn = function() {
        if (scope.showDirectMessagePrompt) {
          var activeUserID = $window.NOW.user_id || "";
          return !(!scope.profile ||
            activeUserID === scope.profile.sysID ||
            (scope.profile.document &amp;&amp; activeUserID === scope.profile.document));
        } else {
          return false;
        }
      };
    },
    controller: function($scope, snConnectService) {
      if ($scope.profile &amp;&amp; $scope.profile.userID &amp;&amp; avatarProfilePersister.getAvatar($scope.profile.userID))
        $scope.profile = avatarProfilePersister.getAvatar($scope.profile.userID);
      $scope.$emit("sn-user-profile.ready");
      $scope.openDirectMessageConversation = function(evt) {
        if (evt.keyCode === 9)
          return;
        snConnectService.openWithProfile($scope.profile);
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/avatar/_module.js */
angular.module('sn.common.avatar', ['sn.common.presence', 'sn.common.messaging', 'sn.common.user_profile']).config(function($provide) {
  $provide.value("liveProfileID", '');
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snAvatarPopover.js */
angular.module('sn.common.avatar').directive('snAvatarPopover', function($http, $compile, getTemplateUrl, avatarProfilePersister, $injector) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_avatar_popover.xml'),
    replace: true,
    transclude: true,
    scope: {
      members: '=',
      primary: '=?',
      showPresence: '=?',
      enableContextMenu: '=?',
      enableTooltip: '=?',
      enableBindOnce: '@',
      displayMemberCount: "=?",
      groupAvatar: "@",
      nopopover: "=",
      directconversation: '@',
      conversation: '@',
      primaryNonAssign: '=?'
    },
    compile: function(tElement) {
      var template = tElement.html();
      return function(scope, element, attrs, controller, transcludeFn) {
        if (scope.directconversation) {
          if (scope.directconversation === "true")
            scope.directconversation = true;
          else
            scope.directconversation = false;
          scope.showdirectconversation = !scope.directconversation;
        } else {
          scope.showdirectconversation = true;
        }
        if ($injector.has('inSupportClient') &amp;&amp; $injector.get('inSupportClient'))
          scope.showdirectconversation = false;
        if (scope.primaryNonAssign) {
          scope.primary = angular.extend({}, scope.primary, scope.primaryNonAssign);
          if (scope.users &amp;&amp; scope.users[0])
            scope.users[0] = scope.primary;
        }

        function recompile() {
          if (scope.primaryNonAssign) {
            scope.primary = angular.extend({}, scope.primary, scope.primaryNonAssign);
            if (scope.users &amp;&amp; scope.users[0])
              scope.users[0] = scope.primary;
          }
          var newElement = $compile(template, transcludeFn)(scope);
          element.html(newElement);
          if (scope.enableTooltip) {
            element.tooltip({
              placement: 'auto top',
              container: 'body'
            }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
            if (element.hideFix)
              element.hideFix();
          }
        }
        if (attrs.enableBindOnce === 'false') {
          scope.$watch('primary', recompile);
          scope.$watch('primaryNonAssign', recompile);
          scope.$watch('members', recompile);
        }
        if (scope.enableTooltip &amp;&amp; scope.nopopover) {
          var usersWatch = scope.$watch('users', function() {
            if (scope.users &amp;&amp; scope.users.length === 1 &amp;&amp; scope.users[0] &amp;&amp; scope.users[0].name) {
              element.tooltip({
                placement: 'auto top',
                container: 'body'
              }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
              if (element.hideFix)
                element.hideFix();
              usersWatch();
            }
          });
        }
      };
    },
    controller: function($scope, liveProfileID, $timeout, $element, $document, snCustomEvent) {
      $scope.randId = Math.random();
      $scope.loadEvent = 'sn-user-profile.ready';
      $scope.closeEvent = ['chat:open_conversation', 'snAvatar.closePopover', 'body_clicked'];
      $scope.popoverConfig = {
        template: '&lt;div class="popover" role="tooltip"&gt;&lt;div class="arrow"&gt;&lt;/div&gt;&lt;div class="popover-content"&gt;&lt;/div&gt;&lt;/div&gt;'
      };
      $scope.displayMemberCount = $scope.displayMemberCount || false;
      $scope.liveProfileID = liveProfileID;
      if ($scope.primaryNonAssign) {
        $scope.primary = angular.extend({}, $scope.primary, $scope.primaryNonAssign);
        if ($scope.users &amp;&amp; $scope.users[0])
          $scope.users[0] = $scope.primary;
      }
      $scope.$watch('members', function(newVal, oldVal) {
        if (newVal === oldVal)
          return;
        if ($scope.members)
          buildAvatar();
      });
      $scope.noPopover = function() {
        $scope.popoverCursor = ($scope.nopopover || ($scope.members &amp;&amp; $scope.members.length &gt; 2)) ? "default" : "pointer";
        return ($scope.nopopover || ($scope.members &amp;&amp; $scope.members.length &gt; 2));
      }
      $scope.avatarType = function() {
        var result = [];
        if ($scope.groupAvatar || !$scope.users)
          return result;
        if ($scope.users.length &gt; 1)
          result.push("group")
        if ($scope.users.length === 2)
          result.push("avatar-duo")
        if ($scope.users.length === 3)
          result.push("avatar-trio")
        if ($scope.users.length &gt;= 4)
          result.push("avatar-quad")
        return result;
      }
      $scope.getBackgroundStyle = function(user) {
        var avatar = (user ? user.avatar : '');
        if ($scope.groupAvatar)
          avatar = $scope.groupAvatar;
        if (avatar &amp;&amp; avatar !== '')
          return {
            'background-image': 'url(' + avatar + ')'
          };
        if (user &amp;&amp; user.name)
          return '';
        return void(0);
      };
      $scope.stopPropCheck = function(evt) {
        $scope.$broadcast("snAvatar.closeOtherPopovers", $scope.randId);
        if (!$scope.nopopover) {
          evt.stopPropagation();
        }
      };
      $scope.$on("snAvatar.closeOtherPopovers", function(id) {
        if (id !== $scope.randId)
          snCustomEvent.fireTop('snAvatar.closePopover');
      });
      $scope.maxStringWidth = function() {
        var paddedWidth = parseInt($scope.avatarWidth * 0.8, 10);
        return $scope.users.length === 1 ? paddedWidth : paddedWidth / 2;
      };

      function buildInitials(name) {
        if (!name)
          return "--";
        var initials = name.split(" ").map(function(word) {
          return word.toUpperCase();
        }).filter(function(word) {
          return word.match(/^[A-Z]/);
        }).map(function(word) {
          return word.substring(0, 1);
        }).join("");
        return (initials.length &gt; 3) ?
          initials.substr(0, 3) :
          initials;
      }
      $scope.avatartooltip = function() {
        if (!$scope.enableTooltip) {
          return '';
        }
        if (!$scope.users) {
          return '';
        }
        var names = [];
        $scope.users.forEach(function(user) {
          if (!user) {
            return;
          }
          names.push(user.name);
        });
        return names.join(', ');
      };

      function buildAvatar() {
        if (typeof $scope.primary === 'string') {
          $http.get('/api/now/live/profiles/sys_user.' + $scope.primary).then(function(response) {
            $scope.users = [{
              userID: $scope.primary,
              name: response.data.result.name,
              initials: buildInitials(response.data.result.name),
              avatar: response.data.result.avatar
            }];
            $scope.presenceEnabled = $scope.showPresence &amp;&amp; !$scope.isDocument &amp;&amp; $scope.users.length === 1;
          });
          return;
        }
        if ($scope.primary) {
          if ($scope.primary.userImage)
            $scope.primary.avatar = $scope.primary.userImage;
          if (!$scope.primary.userID &amp;&amp; $scope.primary.sys_id)
            $scope.primary.userID = $scope.primary.sys_id;
        }
        $scope.isDocument = $scope.primary &amp;&amp; $scope.primary.table &amp;&amp; $scope.primary.table !== "sys_user" &amp;&amp; $scope.primary.table !== "chat_queue_entry";
        $scope.users = [$scope.primary];
        if ($scope.primary &amp;&amp; (!$scope.members || $scope.members.length &lt;= 0) &amp;&amp; ($scope.primary.avatar || $scope.primary.initials) &amp;&amp; $scope.isDocument) {
          $scope.users = [$scope.primary];
        } else if ($scope.members &amp;&amp; $scope.members.length &gt; 0) {
          $scope.users = buildCompositeAvatar($scope.members);
        }
        $scope.presenceEnabled = $scope.showPresence &amp;&amp; !$scope.isDocument &amp;&amp; $scope.users.length === 1;
      }

      function buildCompositeAvatar(members) {
        var currentUser = window.NOW.user ? window.NOW.user.userID : window.NOW.user_id;
        var users = angular.isArray(members) ? members.slice() : [members];
        users = users.sort(function(a, b) {
          var aID = a.userID || a.document;
          var bID = b.userID || b.document;
          if (a.table === "chat_queue_entry")
            return 1;
          if (aID === currentUser)
            return 1;
          else if (bID === currentUser)
            return -1;
          return 0;
        });
        if (users.length === 2)
          users = [users[0]];
        if (users.length &gt; 2 &amp;&amp; $scope.primary &amp;&amp; $scope.primary.name &amp;&amp; $scope.primary.table === "sys_user") {
          var index = -1;
          angular.forEach(users, function(user, i) {
            if (user.sys_id === $scope.primary.sys_id) {
              index = i;
            }
          });
          if (index &gt; -1) {
            users.splice(index, 1);
          }
          users.splice(1, 0, $scope.primary);
        }
        return users;
      }
      buildAvatar();
      $scope.loadFullProfile = function() {
        if ($scope.primary &amp;&amp; !$scope.primary.sys_id &amp;&amp; !avatarProfilePersister.getAvatar($scope.primary.userID)) {
          $http.get('/api/now/live/profiles/' + $scope.primary.userID).then(
            function(response) {
              try {
                angular.extend($scope.primary, response.data.result);
                avatarProfilePersister.setAvatar($scope.primary.userID, $scope.primary);
              } catch (e) {}
            });
        }
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snAvatar.js */
angular.module('sn.common.avatar').directive('snAvatar', function($http, $compile, getTemplateUrl, snCustomEvent, snConnectService) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_avatar.xml'),
    replace: true,
    transclude: true,
    scope: {
      members: '=',
      primary: '=',
      showPresence: '=?',
      enableContextMenu: '=?',
      enableTooltip: '=?',
      enableBindOnce: '@',
      displayMemberCount: "=?",
      groupAvatar: "@"
    },
    compile: function(tElement) {
      var template = tElement.html();
      return function(scope, element, attrs, controller, transcludeFn) {
        function recompile() {
          var newElement = $compile(template, transcludeFn)(scope);
          element.html(newElement);
          if (scope.enableTooltip) {
            element.tooltip({
              placement: 'auto top',
              container: 'body'
            }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
            if (element.hideFix)
              element.hideFix();
          }
        }
        if (attrs.enableBindOnce === 'false') {
          scope.$watch('primary', recompile);
          scope.$watch('members', recompile);
        }
        if (scope.enableTooltip) {
          var usersWatch = scope.$watch('users', function() {
            if (scope.users &amp;&amp; scope.users.length === 1 &amp;&amp; scope.users[0] &amp;&amp; scope.users[0].name) {
              element.tooltip({
                placement: 'auto top',
                container: 'body'
              }).attr('data-original-title', scope.users[0].name).tooltip('fixTitle');
              if (element.hideFix)
                element.hideFix();
              usersWatch();
            }
          });
        }
        if (scope.enableContextMenu !== false) {
          scope.contextOptions = [];
          var gUser = null;
          try {
            gUser = g_user;
          } catch (err) {}
          if (scope.users &amp;&amp; scope.users.length === 1 &amp;&amp; scope.users[0] &amp;&amp; (scope.users[0].userID || scope.users[0].sys_id)) {
            scope.contextOptions = [
              ["Open user's profile", function() {
                if (scope.users &amp;&amp; scope.users.length &gt; 0) {
                  window.open('/nav_to.do?uri=' + encodeURIComponent('sys_user.do?sys_id=' + scope.users[0].userID), '_blank');
                }
              }]
            ];
            if ((gUser &amp;&amp; scope.users[0].userID &amp;&amp; scope.users[0].userID !== gUser.userID) ||
              (scope.liveProfileID &amp;&amp; scope.users[0] &amp;&amp; scope.users[0].sysID !== scope.liveProfileID)) {
              scope.contextOptions.push(["Open a new chat", function() {
                snConnectService.openWithProfile(scope.users[0]);
              }]);
            }
          }
        } else {
          scope.contextOptions = [];
        }
      };
    },
    controller: function($scope, liveProfileID) {
      $scope.displayMemberCount = $scope.displayMemberCount || false;
      $scope.liveProfileID = liveProfileID;
      $scope.$watch('primary', function(newValue, oldValue) {
        if ($scope.primary &amp;&amp; newValue !== oldValue) {
          buildAvatar();
          if ($scope.contextOptions.length &gt; 0) {
            $scope.contextOptions = [
              ["Open user's profile", function() {
                if ($scope.users &amp;&amp; $scope.users.length &gt; 0) {
                  window.location.href = 'sys_user.do?sys_id=' + $scope.users[0].userID || $scope.users[0].userID;
                }
              }]
            ];
            var gUser = null;
            try {
              gUser = g_user;
            } catch (err) {}
            if ((!gUser &amp;&amp; !liveProfileID) || ($scope.users &amp;&amp; $scope.users.length === 1 &amp;&amp; $scope.users[0])) {
              if ((gUser &amp;&amp; $scope.users[0].userID &amp;&amp; $scope.users[0].userID !== gUser.userID) ||
                ($scope.liveProfileID &amp;&amp; $scope.users[0] &amp;&amp; $scope.users[0].sysID !== $scope.liveProfileID)) {
                $scope.contextOptions.push(["Open a new chat", function() {
                  snConnectService.openWithProfile($scope.users[0]);
                }]);
              }
            }
          }
        }
      });
      $scope.$watch('members', function() {
        if ($scope.members)
          buildAvatar();
      });
      $scope.avatarType = function() {
        var result = [];
        if ($scope.groupAvatar || !$scope.users)
          return result;
        if ($scope.users.length &gt; 1)
          result.push("group");
        if ($scope.users.length === 2)
          result.push("avatar-duo");
        if ($scope.users.length === 3)
          result.push("avatar-trio");
        if ($scope.users.length &gt;= 4)
          result.push("avatar-quad");
        return result;
      };
      $scope.getBackgroundStyle = function(user) {
        var avatar = (user ? user.avatar : '');
        if ($scope.groupAvatar)
          avatar = $scope.groupAvatar;
        if (avatar &amp;&amp; avatar !== '')
          return {
            'background-image': 'url(' + avatar + ')'
          };
        if (user &amp;&amp; user.name)
          return '';
        return void(0);
      };
      $scope.maxStringWidth = function() {
        var paddedWidth = parseInt($scope.avatarWidth * 0.8, 10);
        return $scope.users.length === 1 ? paddedWidth : paddedWidth / 2;
      };

      function buildInitials(name) {
        if (!name)
          return "--";
        var initials = name.split(" ").map(function(word) {
          return word.toUpperCase();
        }).filter(function(word) {
          return word.match(/^[A-Z]/);
        }).map(function(word) {
          return word.substring(0, 1);
        }).join("");
        return (initials.length &gt; 3) ?
          initials.substr(0, 3) :
          initials;
      }
      $scope.avatartooltip = function() {
        if (!$scope.enableTooltip) {
          return '';
        }
        if (!$scope.users) {
          return '';
        }
        var names = [];
        $scope.users.forEach(function(user) {
          if (!user) {
            return;
          }
          names.push(user.name);
        });
        return names.join(', ');
      };

      function buildAvatar() {
        if (typeof $scope.primary === 'string') {
          $http.get('/api/now/live/profiles/sys_user.' + $scope.primary).then(function(response) {
            $scope.users = [{
              userID: $scope.primary,
              name: response.data.result.name,
              initials: buildInitials(response.data.result.name),
              avatar: response.data.result.avatar
            }];
            $scope.presenceEnabled = $scope.showPresence &amp;&amp; !$scope.isDocument &amp;&amp; $scope.users.length === 1;
          });
          return;
        }
        if ($scope.primary) {
          if ($scope.primary.userImage)
            $scope.primary.avatar = $scope.primary.userImage;
          if (!$scope.primary.userID &amp;&amp; $scope.primary.sys_id)
            $scope.primary.userID = $scope.primary.sys_id;
        }
        $scope.isDocument = $scope.primary &amp;&amp; $scope.primary.table &amp;&amp; $scope.primary.table !== "sys_user" &amp;&amp; $scope.primary.table !== "chat_queue_entry";
        $scope.users = [$scope.primary];
        if ($scope.primary &amp;&amp; (!$scope.members || $scope.members.length &lt;= 0) &amp;&amp; ($scope.primary.avatar || $scope.primary.initials) &amp;&amp; $scope.isDocument) {
          $scope.users = [$scope.primary];
        } else if ($scope.members &amp;&amp; $scope.members.length &gt; 0) {
          $scope.users = buildCompositeAvatar($scope.members);
        }
        $scope.presenceEnabled = $scope.showPresence &amp;&amp; !$scope.isDocument &amp;&amp; $scope.users.length === 1;
      }

      function buildCompositeAvatar(members) {
        var currentUser = window.NOW.user ? window.NOW.user.userID : window.NOW.user_id;
        var users = angular.isArray(members) ? members.slice() : [members];
        users = users.sort(function(a, b) {
          var aID = a.userID || a.document;
          var bID = b.userID || b.document;
          if (a.table === "chat_queue_entry")
            return 1;
          if (aID === currentUser)
            return 1;
          else if (bID === currentUser)
            return -1;
          return 0;
        });
        if (users.length === 2)
          users = [users[0]];
        if (users.length &gt; 2 &amp;&amp; $scope.primary &amp;&amp; $scope.primary.name &amp;&amp; $scope.primary.table === "sys_user") {
          var index = -1;
          angular.forEach(users, function(user, i) {
            if (user.sys_id === $scope.primary.sys_id) {
              index = i;
            }
          });
          if (index &gt; -1) {
            users.splice(index, 1);
          }
          users.splice(1, 0, $scope.primary);
        }
        return users;
      }
      buildAvatar();
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/service.avatarProfilePersister.js */
angular.module('sn.common.avatar').service('avatarProfilePersister', function() {
  "use strict";
  var avatars = {};

  function setAvatar(id, payload) {
    avatars[id] = payload;
  }

  function getAvatar(id) {
    return avatars[id];
  }
  return {
    setAvatar: setAvatar,
    getAvatar: getAvatar
  }
});;
/*! RESOURCE: /scripts/sn/common/avatar/directive.snUserAvatar.js */
angular.module('sn.common.avatar').directive('snUserAvatar', function(getTemplateUrl) {
  "use strict";
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_user_avatar.xml'),
    replace: true,
    scope: {
      userId: '=',
      avatarUrl: '=',
      initials: '=',
      enablePresence: '@'
    },
    controller: function($scope) {
      $scope.enablePresence = $scope.enablePresence === 'true';
      $scope.getBackgroundStyle = function() {
        if ($scope.avatarUrl &amp;&amp; $scope.avatarUrl !== '')
          return {
            'background-image': 'url(' + $scope.avatarUrl + ')'
          };
        return '';
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/controls/js_includes_controls.js */
/*! RESOURCE: /scripts/sn/common/controls/_module.js */
angular.module('sn.common.controls', []);;
/*! RESOURCE: /scripts/sn/common/controls/directive.snChoiceList.js */
angular.module('sn.common.controls').directive('snChoiceList', function($timeout) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      snModel: "=",
      snTextField: "@",
      snValueField: "@",
      snOptions: "=?",
      snItems: "=?",
      snOnChange: "&amp;",
      snDisabled: "=",
      snDialogName: "=",
    },
    template: '&lt;select ng-disabled="snDisabled" ng-model="model" ng-options="item[snValueField] as item[snTextField] for item in snItems"&gt;&lt;option value="" ng-show="snOptions.placeholder"&gt;{{snOptions.placeholder}}&lt;/option&gt;&lt;/select&gt;',
    link: function(scope, element, attrs) {
      if (scope.snDialogName)
        scope.$on("dialog." + scope.snDialogName + ".close", function() {
          $timeout(function() {
            $(element).select2("destroy");
          })
        });
      $(element).css("opacity", 0);
      var config = {
        width: "100%"
      };
      if (scope.snOptions) {
        if (scope.snOptions.placeholder) {
          config.placeholderOption = "first";
        }
        if (scope.snOptions.hideSearch &amp;&amp; scope.snOptions.hideSearch === true) {
          config.minimumResultsForSearch = -1;
        }
      }

      function init() {
        scope.model = scope.snModel;
        render();
      }

      function render() {
        if (!attrs) {
          $timeout(function() {
            render();
          });
          return;
        }
        $timeout(function() {
          $(element).css("opacity", 1);
          $(element).select2("destroy");
          $(element).select2(config);
        });
      }
      init();
      scope.$watch("snItems", function(newValue, oldValue) {
        if (newValue !== oldValue) {
          init();
        }
      }, true);
      scope.$watch("snModel", function(newValue) {
        if (newValue !== undefined &amp;&amp; newValue !== scope.model) {
          init();
        }
      });
      scope.$watch("model", function(newValue, oldValue) {
        if (newValue !== oldValue) {
          scope.snModel = newValue;
          if (scope.snOnChange)
            scope.snOnChange({
              selectedValue: newValue
            });
        }
      });
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snReferencePicker.js */
angular.module('sn.common.controls').directive('snReferencePicker', function($timeout, $http, urlTools, filterExpressionParser, $sanitize, i18n) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      ed: "=?",
      field: "=",
      refTable: "=?",
      refId: "=?",
      snOptions: "=?",
      snOnChange: "&amp;",
      snOnBlur: "&amp;",
      snOnClose: "&amp;",
      snOnOpen: '&amp;',
      minimumInputLength: "@",
      snDisabled: "=",
      snPageSize: "@",
      dropdownCssClass: "@",
      formatResultCssClass: "&amp;",
      overlay: "=",
      additionalDisplayColumns: "@",
      displayColumn: "@",
      recordValues: '&amp;',
      getGlideForm: '&amp;glideForm',
      domain: "@",
      snSelectWidth: '@',
    },
    template: '&lt;input type="text" name="{{field.name}}" ng-disabled="snDisabled" style="min-width: 150px;" ng-model="field.displayValue" /&gt;',
    link: function(scope, element, attrs, ctrl) {
      scope.ed = scope.ed || scope.field.ed;
      scope.selectWidth = scope.snSelectWidth || '100%';
      element.css("opacity", 0);
      var fireReadyEvent = true;
      var g_form;
      if (angular.isDefined(scope.getGlideForm))
        g_form = scope.getGlideForm();
      var fieldAttributes = {};
      if (angular.isDefined(scope.field) &amp;&amp; angular.isDefined(scope.field.attributes) &amp;&amp; typeof scope.ed.attributes == 'undefined')
        if (Array.isArray(scope.field.attributes))
          fieldAttributes = scope.field.attributes;
        else
          fieldAttributes = parseAttributes(scope.field.attributes);
      else
        fieldAttributes = parseAttributes(scope.ed.attributes);
      if (!angular.isDefined(scope.additionalDisplayColumns) &amp;&amp; angular.isDefined(fieldAttributes['ref_ac_columns']))
        scope.additionalDisplayColumns = fieldAttributes['ref_ac_columns'];
      var select2AjaxHelpers = {
        formatSelection: function(item) {
          return $sanitize(getDisplayValue(item));
        },
        formatResult: function(item) {
          var displayValues = getDisplayValues(item);
          if (displayValues.length == 1)
            return $sanitize(displayValues[0]);
          if (displayValues.length &gt; 1) {
            var width = 100 / displayValues.length;
            var markup = "";
            for (var i = 0; i &lt; displayValues.length; i++)
              markup += "&lt;div style='width: " + width + "%;' class='select2-result-cell'&gt;" + $sanitize(displayValues[i]) + "&lt;/div&gt;";
            return markup;
          }
          return "";
        },
        search: function(queryParams) {
          if ('sysparm_include_variables' in queryParams.data) {
            var url = urlTools.getURL('ref_list_data', queryParams.data);
            return $http.get(url).then(queryParams.success);
          } else {
            var url = urlTools.getURL('ref_list_data');
            return $http.post(url, queryParams.data).then(queryParams.success);
          }
        },
        initSelection: function(elem, callback) {
          if (scope.field.displayValue)
            callback({
              sys_id: scope.field.value,
              name: scope.field.displayValue
            });
        }
      };
      var config = {
        width: scope.selectWidth,
        minimumInputLength: scope.minimumInputLength ? parseInt(scope.minimumInputLength, 10) : 0,
        overlay: scope.overlay,
        containerCssClass: 'select2-reference ng-form-element',
        placeholder: '   ',
        formatSearching: '',
        allowClear: attrs.allowClear !== 'false',
        id: function(item) {
          return item.sys_id;
        },
        sortResults: (scope.snOptions &amp;&amp; scope.snOptions.sortResults) ? scope.snOptions.sortResults : undefined,
        ajax: {
          quietMillis: NOW.ac_wait_time,
          data: function(filterText, page) {
            var filterExpression = filterExpressionParser.parse(filterText, scope.ed.defaultOperator);
            var colToSearch = getReferenceColumnToSearch();
            var q = colToSearch + filterExpression.operator + filterExpression.filterText +
              '^' + colToSearch + 'ISNOTEMPTY' + getExcludedValues() + "^EQ";
            var params = {
              start: (scope.pageSize * (page - 1)),
              count: scope.pageSize,
              sysparm_target_table: scope.refTable,
              sysparm_target_sys_id: scope.refId,
              sysparm_target_field: scope.ed.dependent_field || scope.ed.name,
              table: scope.ed.reference,
              qualifier: scope.ed.qualifier,
              data_adapter: scope.ed.data_adapter,
              attributes: scope.ed.attributes,
              dependent_field: scope.ed.dependent_field,
              dependent_table: scope.ed.dependent_table,
              dependent_value: scope.ed.dependent_value,
              p: scope.ed.reference + ';q:' + q + ';r:' + scope.ed.qualifier
            };
            if (scope.domain) {
              params.sysparm_domain = scope.domain;
            }
            if (angular.isDefined(scope.field) &amp;&amp; scope.field['_cat_variable'] === true) {
              delete params['sysparm_target_table'];
              params['sysparm_include_variables'] = true;
              params['variable_ids'] = scope.field.sys_id;
              var getFieldSequence = g_form.$private.options('getFieldSequence');
              if (getFieldSequence) {
                params['variable_sequence1'] = getFieldSequence();
              }
              var itemSysId = g_form.$private.options('itemSysId');
              params['sysparm_id'] = itemSysId;
              var getFieldParams = g_form.$private.options('getFieldParams');
              if (getFieldParams) {
                angular.extend(params, getFieldParams());
              }
            }
            if (scope.recordValues)
              params.sysparm_record_values = scope.recordValues();
            return params;
          },
          results: function(data, page) {
            return ctrl.filterResults(data, page, scope.pageSize);
          },
          transport: select2AjaxHelpers.search
        },
        formatSelection: select2AjaxHelpers.formatSelection,
        formatResult: select2AjaxHelpers.formatResult,
        initSelection: select2AjaxHelpers.initSelection,
        dropdownCssClass: attrs.dropdownCssClass,
        formatResultCssClass: scope.formatResultCssClass || null
      };
      if (scope.snOptions) {
        if (scope.snOptions.placeholder) {
          config.placeholder = scope.snOptions.placeholder;
        }
        if (scope.snOptions.width) {
          config.width = scope.snOptions.width;
        }
      }

      function getReferenceColumnToSearch() {
        var colName = 'name';
        if (scope.ed.searchField)
          colName = scope.ed.searchField;
        else if (fieldAttributes['ref_ac_columns_search'] == 'true' &amp;&amp; 'ref_ac_columns' in fieldAttributes &amp;&amp; fieldAttributes['ref_ac_columns'] != '') {
          var refAcColumns = fieldAttributes['ref_ac_columns'].split(';');
          colName = refAcColumns[0];
        } else if (fieldAttributes['ref_ac_order_by'])
          colName = fieldAttributes['ref_ac_order_by'];
        return colName;
      }

      function getExcludedValues() {
        if (scope.ed.excludeValues &amp;&amp; scope.ed.excludeValues != '') {
          return '^sys_idNOT IN' + scope.ed.excludeValues;
        }
        return '';
      }

      function parseAttributes(strAttributes) {
        var attributeArray = (strAttributes &amp;&amp; strAttributes.length ? strAttributes.split(',') : []);
        var attributeObj = {};
        for (var i = 0; i &lt; attributeArray.length; i++) {
          if (attributeArray[i].length &gt; 0) {
            var attribute = attributeArray[i].split('=');
            attributeObj[attribute[0]] = attribute.length &gt; 1 ? attribute[1] : '';
          }
        }
        return attributeObj;
      }

      function init() {
        scope.model = scope.snModel;
        render();
      }

      function render() {
        $timeout(function() {
          i18n.getMessage('Searching...', function(searchingMsg) {
            config.formatSearching = function() {
              return searchingMsg;
            };
          });
          element.css("opacity", 1);
          element.select2("destroy");
          var select2 = element.select2(config);
          select2.bind("change", select2Change);
          select2.bind("select2-removed", select2Change);
          select2.bind("select2-blur", function() {
            scope.$apply(function() {
              scope.snOnBlur();
            });
          });
          select2.bind("select2-close", function() {
            scope.$apply(function() {
              scope.snOnClose();
            });
          });
          select2.bind("select2-open", function() {
            scope.$apply(function() {
              if (scope.snOnOpen)
                scope.snOnOpen();
            });
          });
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      }

      function select2Change(e) {
        e.stopImmediatePropagation();
        if (e.added) {
          if (scope.$$phase || scope.$root.$$phase)
            return;
          var selectedItem = e.added;
          var value = selectedItem.sys_id;
          var displayValue = value ? getDisplayValue(selectedItem) : '';
          if (scope.snOptions &amp;&amp; scope.snOptions.useGlideForm === true) {
            g_form.setValue(scope.field.name, value, displayValue);
            scope.rowSelected();
          } else {
            scope.$apply(function() {
              scope.field.value = value;
              scope.field.displayValue = displayValue;
              scope.rowSelected();
            });
          }
          if (scope.snOnChange) {
            e.displayValue = displayValue;
            scope.snOnChange(e);
          }
        } else if (e.removed) {
          if (scope.snOptions &amp;&amp; scope.snOptions.useGlideForm === true) {
            g_form.clearValue(scope.field.name);
            if (scope.snOnChange)
              scope.snOnChange(e);
          } else {
            scope.$apply(function() {
              scope.field.displayValue = '';
              scope.field.value = '';
              if (scope.snOnChange)
                scope.snOnChange(e);
            });
          }
        }
      }

      function getDisplayValue(selectedItem) {
        var displayValue = '';
        if (selectedItem &amp;&amp; selectedItem.sys_id) {
          if (scope.displayColumn &amp;&amp; typeof selectedItem[scope.displayColumn] != "undefined")
            displayValue = selectedItem[scope.displayColumn];
          else if (selectedItem.$$displayValue)
            displayValue = selectedItem.$$displayValue;
          else if (selectedItem.name)
            displayValue = selectedItem.name;
          else if (selectedItem.title)
            displayValue = selectedItem.title;
        }
        return displayValue;
      }

      function getDisplayValues(selectedItem) {
        var displayValues = [];
        if (selectedItem &amp;&amp; selectedItem.sys_id) {
          var current = "";
          if (scope.displayColumn &amp;&amp; typeof selectedItem[scope.displayColumn] != "undefined")
            current = selectedItem[scope.displayColumn];
          else if (selectedItem.$$displayValue)
            current = selectedItem.$$displayValue;
          else if (selectedItem.name)
            current = selectedItem.name;
          else if (selectedItem.title)
            current = selectedItem.title;
          displayValues.push(current);
        }
        if (scope.additionalDisplayColumns) {
          var columns = scope.additionalDisplayColumns.split(",");
          for (var i = 0; i &lt; columns.length; i++) {
            var column = columns[i];
            if (selectedItem[column])
              displayValues.push(selectedItem[column]);
          }
        }
        return displayValues;
      }
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue != oldValue &amp;&amp; newValue !== scope.model) {
          init();
        }
      });
      scope.$on("snReferencePicker.activate", function(evt, parms) {
        $timeout(function() {
          element.select2("open");
        })
      });
      init();
    },
    controller: function($scope, $rootScope) {
      $scope.pageSize = 20;
      if ($scope.snPageSize)
        $scope.pageSize = parseInt($scope.snPageSize);
      $scope.rowSelected = function() {
        $rootScope.$broadcast("@page.reference.selected", {
          field: $scope.field,
          ed: $scope.ed
        });
      };
      this.filterResults = function(data, page) {
        return {
          results: data.data.items,
          more: (page * $scope.pageSize &lt; data.data.total)
        };
      };
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snRecordPicker.js */
angular.module('sn.common.controls').directive('snRecordPicker', function($timeout, $http, urlTools, filterExpressionParser, $sanitize, i18n) {
  "use strict";
  var cache = {};

  function cleanLabel(val) {
    if (typeof val == "object")
      return "";
    return typeof val == "string" ? val.trim() : val;
  }
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: '=',
      table: '=',
      defaultQuery: '=?',
      searchFields: '=?',
      valueField: '=?',
      displayField: '=?',
      displayFields: '=?',
      pageSize: '=?',
      onChange: '&amp;',
      snDisabled: '=',
      multiple: '=?',
      options: '=?',
      placeholder: '@'
    },
    template: '&lt;input type="text" ng-disabled="snDisabled" style="min-width: 150px;" name="{{field.name}}" ng-model="field.value" /&gt;',
    controller: function($scope) {
      if (!angular.isNumber($scope.pageSize))
        $scope.pageSize = 20;
      if (!angular.isDefined($scope.valueField))
        $scope.valueField = 'sys_id';
      this.filterResults = function(data, page) {
        return {
          results: data.data.result,
          more: (page * $scope.pageSize &lt; parseInt(data.headers('x-total-count'), 10))
        };
      };
    },
    link: function(scope, element, attrs, ctrl) {
      var isExecuting = false;
      var select2Helpers = {
        formatSelection: function(item) {
          return $sanitize(getDisplayValue(item));
        },
        formatResult: function(item) {
          var displayFields = getdisplayFields(item);
          if (displayFields.length == 1)
            return $sanitize(cleanLabel(displayFields[0]));
          if (displayFields.length &gt; 1) {
            var markup = $sanitize(displayFields[0]);
            var width = 100 / (displayFields.length - 1);
            markup += "&lt;div&gt;";
            for (var i = 1; i &lt; displayFields.length; i++)
              markup += "&lt;div style='width: " + width + "%;' class='select2-additional-display-field'&gt;" + $sanitize(cleanLabel(displayFields[i])) + "&lt;/div&gt;";
            markup += "&lt;/div&gt;";
            return markup;
          }
          return "";
        },
        search: function(queryParams) {
          var url = '/api/now/table/' + scope.table + '?' + urlTools.encodeURIParameters(queryParams.data);
          if (scope.options &amp;&amp; scope.options.cache &amp;&amp; cache[url])
            return queryParams.success(cache[url]);
          return $http.get(url).then(function(response) {
            if (scope.options &amp;&amp; scope.options.cache) {
              cache[url] = response;
            }
            return queryParams.success(response)
          });
        },
        initSelection: function(elem, callback) {
          if (scope.field.displayValue) {
            if (scope.multiple) {
              var items = [],
                sel;
              var values = scope.field.value.split(',');
              var displayValues = scope.field.displayValue.split(',');
              for (var i = 0; i &lt; values.length; i++) {
                sel = {};
                sel[scope.valueField] = values[i];
                sel[scope.displayField] = displayValues[i];
                items.push(sel);
              }
              callback(items);
            } else {
              var sel = {};
              sel[scope.valueField] = scope.field.value;
              sel[scope.displayField] = scope.field.displayValue;
              callback(sel);
            }
          } else
            callback([]);
        }
      };
      var config = {
        width: '100%',
        containerCssClass: 'select2-reference ng-form-element',
        placeholder: scope.placeholder || '    ',
        formatSearching: '',
        allowClear: (scope.options &amp;&amp; typeof scope.options.allowClear !== "undefined") ? scope.options.allowClear : true,
        id: function(item) {
          return item[scope.valueField];
        },
        ajax: {
          quietMillis: NOW.ac_wait_time,
          data: function(filterText, page) {
            var params = {
              sysparm_offset: (scope.pageSize * (page - 1)),
              sysparm_limit: scope.pageSize,
              sysparm_query: buildQuery(filterText, scope.searchFields, scope.defaultQuery)
            };
            return params;
          },
          results: function(data, page) {
            return ctrl.filterResults(data, page, scope.pageSize);
          },
          transport: select2Helpers.search
        },
        formatSelection: select2Helpers.formatSelection,
        formatResult: select2Helpers.formatResult,
        formatResultCssClass: function() {
          return '';
        },
        initSelection: select2Helpers.initSelection,
        multiple: scope.multiple
      };

      function buildQuery(filterText, searchFields, defaultQuery) {
        var queryParts = [];
        var operator = "CONTAINS";
        if (filterText.startsWith("*"))
          filterText = filterText.substring(1);
        if (defaultQuery)
          queryParts.push(defaultQuery);
        var filterExpression = filterExpressionParser.parse(filterText, operator);
        if (searchFields != null) {
          var fields = searchFields.split(',');
          if (filterExpression.filterText != '') {
            var OR = "";
            for (var i = 0; i &lt; fields.length; i++) {
              queryParts.push(OR + fields[i] + filterExpression.operator + filterExpression.filterText);
              OR = "OR";
            }
          }
          for (var i = 0; i &lt; fields.length; i++)
            queryParts.push('ORDERBY' + fields[i]);
          queryParts.push('EQ');
        }
        return queryParts.join('^');
      }
      scope.field = scope.field || {};
      var initTimeout = null;
      var value = scope.field.value;
      var oldValue = scope.field.value;
      var $select;

      function init() {
        element.css("opacity", 0);
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          i18n.getMessage('Searching...', function(searchingMsg) {
            config.formatSearching = function() {
              return searchingMsg;
            };
          });
          element.css("opacity", 1);
          element.select2("destroy");
          $select = element.select2(config);
          $select.bind("change", onChanged);
          $select.bind("select2-removed", onChanged);
          $select.bind("select2-selecting", onSelecting);
          $select.bind("select2-removing", onRemoving);
          scope.$emit('select2.ready', element);
        });
      }

      function onSelecting(e) {
        isExecuting = true;
        oldValue = scope.field.value;
        var selectedItem = e.choice;
        if (scope.multiple &amp;&amp; selectedItem[scope.valueField] != '') {
          var values = scope.field.value == '' ? [] : scope.field.value.split(',');
          var displayValues = scope.field.displayValue == '' ? [] : scope.field.displayValue.split(',');
          values.push(selectedItem[scope.valueField]);
          displayValues.push(getDisplayValue(selectedItem));
          scope.field.value = values.join(',');
          scope.field.displayValue = displayValues.join(',');
          e.preventDefault();
          $select.select2('val', values).select2('close');
          scope.$apply(function() {
            callChange(oldValue, e);
          });
        }
      }

      function onRemoving(e) {
        isExecuting = true;
        oldValue = scope.field.value;
        var removed = e.choice;
        if (scope.multiple) {
          var values = scope.field.value.split(',');
          var displayValues = scope.field.displayValue.split(',');
          for (var i = values.length - 1; i &gt;= 0; i--) {
            if (removed[scope.valueField] == values[i]) {
              values.splice(i, 1);
              displayValues.splice(i, 1);
              break;
            }
          }
          scope.field.value = values.join(',');
          scope.field.displayValue = displayValues.join(',');
          e.preventDefault();
          $select.select2('val', scope.field.value.split(','));
          scope.$apply(function() {
            callChange(oldValue, e);
          });
        }
      }

      function callChange(oldValue, e) {
        var f = scope.field;
        var p = {
          field: f,
          newValue: f.value,
          oldValue: oldValue,
          displayValue: f.displayValue
        }
        scope.$emit("field.change", p);
        scope.$emit("field.change." + f.name, p);
        if (scope.onChange)
          try {
            scope.onChange(e);
          } catch (ex) {
            console.log("directive.snRecordPicker error in onChange")
            console.log(ex)
          }
        isExecuting = false;
      }

      function onChanged(e) {
        e.stopImmediatePropagation();
        if (scope.$$phase || scope.$root.$$phase) {
          console.warn('in digest, returning early');
          return;
        }
        if (e.added) {
          var selectedItem = e.added;
          if (!scope.multiple) {
            scope.field.value = selectedItem[scope.valueField];
            if (scope.field.value) {
              scope.field.displayValue = getDisplayValue(selectedItem);
            } else
              scope.field.displayValue = '';
          }
        } else if (e.removed) {
          if (!scope.multiple) {
            scope.field.displayValue = '';
            scope.field.value = '';
          }
        }
        scope.$apply(function() {
          callChange(oldValue, e);
        });
      }

      function getDisplayValue(selectedItem) {
        var displayValue = selectedItem[scope.valueField];
        if (selectedItem) {
          if (scope.displayField &amp;&amp; angular.isDefined(selectedItem[scope.displayField]))
            displayValue = selectedItem[scope.displayField];
          else if (selectedItem.name)
            displayValue = selectedItem.name;
          else if (selectedItem.title)
            displayValue = selectedItem.title;
        }
        return cleanLabel(displayValue);
      }

      function getdisplayFields(selectedItem) {
        var displayFields = [];
        if (selectedItem &amp;&amp; selectedItem[scope.valueField]) {
          var current = "";
          if (scope.displayField &amp;&amp; angular.isDefined(selectedItem[scope.displayField]))
            current = selectedItem[scope.displayField];
          else if (selectedItem.name)
            current = selectedItem.name;
          else if (selectedItem.title)
            current = selectedItem.title;
          displayFields.push(current);
        }
        if (scope.displayFields) {
          var columns = scope.displayFields.split(",");
          for (var i = 0; i &lt; columns.length; i++) {
            var column = columns[i];
            if (selectedItem[column])
              displayFields.push(selectedItem[column]);
          }
        }
        return displayFields;
      }
      scope.$watch("field.value", function(newValue) {
        if (isExecuting) return;
        if (angular.isDefined(newValue) &amp;&amp; $select) {
          if (scope.multiple)
            $select.select2('val', newValue.split(',')).select2('close');
          else
            $select.select2('val', newValue).select2('close');
        }
      });
      if (attrs.displayValue) {
        attrs.$observe('displayValue', function(value) {
          scope.field.value = value;
        });
      }
      init();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snSelectBasic.js */
angular.module('sn.common.controls').directive('snSelectBasic', function($timeout) {
  return {
    restrict: 'C',
    priority: 1,
    require: '?ngModel',
    scope: {
      'snAllowClear': '@',
      'snSelectWidth': '@',
      'snChoices': '=?'
    },
    link: function(scope, element, attrs, ngModel) {
      if (angular.isFunction(element.select2)) {
        element.css("opacity", 0);
        scope.selectWidth = scope.snSelectWidth || '100%';
        scope.selectAllowClear = scope.snAllowClear === "true";
        $timeout(function() {
          element.css("opacity", 1);
          element.select2({
            allowClear: scope.selectAllowClear,
            width: scope.selectWidth
          });
          ngModel.$render = function() {
            element.select2('val', ngModel.$viewValue);
            element.val(ngModel.$viewValue);
          };
        });
        element.on('change', function() {
          scope.$evalAsync(setModelValue);
        });
        scope.$watch('snChoices', function(newValue, oldValue) {
          if (angular.isDefined(newValue) &amp;&amp; newValue != oldValue) {
            $timeout(function() {
              setModelValue();
            });
          }
        }, true);

        function setModelValue() {
          ngModel.$setViewValue(element.val());
        };
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snTableReference.js */
angular.module('sn.common.controls').directive('snTableReference', function($timeout) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: "=",
      snChange: "&amp;",
      snDisabled: "="
    },
    template: '&lt;select ng-disabled="snDisabled" style="min-width: 150px;" name="{{field.name}}" ng-model="fieldValue" ng-model-options="{getterSetter: true}" ng-options="choice.value as choice.label for choice in field.choices"&gt;&lt;/select&gt;',
    controller: function($scope) {
      $scope.fieldValue = function(selected) {
        if (angular.isDefined(selected)) {
          $scope.snChange({
            newValue: selected
          });
        }
        return $scope.field.value;
      }
    },
    link: function(scope, element) {
      var initTimeout = null;
      var fireReadyEvent = true;
      element.css("opacity", 0);

      function render() {
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          element.css("opacity", 1);
          element.select2("destroy");
          element.select2();
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      }
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue !== undefined &amp;&amp; newValue != oldValue) {
          render();
        }
      });
      render();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snFieldReference.js */
angular.module('sn.common.controls').directive('snFieldReference', function($timeout, $http, nowServer) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      field: "=",
      snChange: "&amp;",
      snDisabled: "=",
      getGlideForm: '&amp;glideForm'
    },
    template: '&lt;select ng-disabled="snDisabled" name="{{field.name}}" style="min-width: 150px;" ng-model="fieldValue" ng-model-options="{getterSetter: true}" ng-options="choice.name as choice.label for choice in field.choices"&gt;&lt;/select&gt;',
    controller: function($scope) {
      $scope.fieldValue = function(selected) {
        if (angular.isDefined(selected))
          $scope.snChange({
            newValue: selected
          });
        return $scope.field.value;
      }
      $scope.$watch('field.dependentValue', function(newVal, oldVal) {
        if (!angular.isDefined(newVal))
          return;
        var src = nowServer.getURL('table_fields', 'exclude_formatters=true&amp;fd_table=' + newVal);
        $http.post(src).success(function(response) {
          $scope.field.choices = response;
          $scope.render();
        });
      });
    },
    link: function(scope, element) {
      var initTimeout = null;
      var fireReadyEvent = true;
      scope.render = function() {
        $timeout.cancel(initTimeout);
        initTimeout = $timeout(function() {
          element.select2("destroy");
          element.select2();
          if (fireReadyEvent) {
            scope.$emit('select2.ready', element);
            fireReadyEvent = false;
          }
        });
      };
      scope.$watch("field.displayValue", function(newValue, oldValue) {
        if (newValue !== undefined &amp;&amp; newValue != oldValue) {
          scope.render();
        }
      });
      scope.render();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snSyncWith.js */
angular.module("sn.common.controls").directive('snSyncWith', function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    scope: false,
    link: function(scope, elem, attr) {
      scope.journalField = scope.$eval(attr.snSyncWith);
      scope.value = scope.$eval(attr.ngModel);
      if (attr.snSyncWithValueInFn)
        scope.$eval(attr.ngModel + "=" + attr.snSyncWithValueInFn, {
          text: scope.value
        });
      scope.$watch(function() {
        return scope.$eval(attr.snSyncWith);
      }, function(nv, ov) {
        if (nv !== ov)
          scope.journalField = nv;
      });
      scope.$watch(function() {
        return scope.$eval(attr.ngModel);
      }, function(nv, ov) {
        if (nv !== ov)
          scope.value = nv;
      });
      if (!window.g_form)
        return;
      scope.$watch('value', function(n, o) {
        if (n !== o)
          setFieldValue();
      });

      function setFieldValue() {
        setValue(scope.journalField, scope.value);
      }

      function setValue(field, value) {
        value = !!value ? value : '';
        var control = g_form.getControl(field);
        if (attr.snSyncWithValueOutFn)
          value = scope.$eval(attr.snSyncWithValueOutFn, {
            text: value
          })
        control.value = value;
        onChange(control.id);
      }
      scope.$watch('journalField', function(newValue, oldValue) {
        if (newValue !== oldValue) {
          if (oldValue)
            setValue(oldValue, '');
          if (newValue)
            setFieldValue();
        }
      }, true);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.contenteditable.js */
angular.module('sn.common.controls').directive('contenteditable', function($timeout) {
  return {
    require: 'ngModel',
    link: function(scope, elem, attrs, ctrl) {
      var changehandler = scope.changehandler;
      scope.usenewline = scope.usenewline + "" != "false";
      var newLine = "\n";
      var nodeBR = "BR";
      var nodeDIV = "DIV";
      var nodeText = "#text";
      var nbspRegExp = new RegExp(String.fromCharCode(160), "g");
      if (!scope.usenewline)
        elem.keypress(function(event) {
          if (event.which == "13") {
            if (scope.entercallback)
              scope.entercallback(elem);
            event.preventDefault();
          }
        });

      function processNodes(nodes) {
        var val = "";
        for (var i = 0; i &lt; nodes.length; i++) {
          var node = nodes[i];
          var follow = true;
          switch (node.nodeName) {
            case nodeText:
              val += node.nodeValue.replace(nbspRegExp, " ");
              break;
            case nodeDIV:
              val += newLine;
              if (node.childNodes.length == 1 &amp;&amp; node.childNodes[0].nodeName == nodeBR)
                follow = false;
              break;
            case nodeBR:
              val += scope.usenewline ? newLine : "";
          }
          if (follow)
            val += processNodes(node.childNodes)
        }
        return val;
      }

      function transferHTML() {
        var val = processNodes(elem[0].childNodes);
        ctrl.$setViewValue(val);
      }

      function transferText() {
        var val = ctrl.$viewValue;
        if (!val || val === null)
          val = "";
        val = val.replace(/\n/gi, scope.usenewline ? "&lt;br/&gt;" : "");
        val = val.replace(/  /gi, " &amp;nbsp;");
        elem.html(val);
      }

      function processPlaceholder() {
        if (elem[0].dataset) {
          if (elem[0].textContent)
            elem[0].dataset.divPlaceholderContent = 'true';
          else if (elem[0].dataset.divPlaceholderContent)
            delete(elem[0].dataset.divPlaceholderContent);
        }
      }
      elem.bind('keyup', function() {
        scope.$apply(function() {
          transferHTML();
          processPlaceholder();
        });
      });

      function selectText(elem) {
        var range;
        var selection;
        if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(elem);
          range.select();
        } else if (window.getSelection) {
          selection = window.getSelection();
          range = document.createRange();
          range.selectNodeContents(elem);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
      elem.bind('focus', function() {
        if (scope[attrs.tracker] &amp;&amp; scope[attrs.tracker]['isDefault_' + attrs.trackeratt])
          $timeout(function() {
            selectText(elem[0]);
          });
        elem.original = ctrl.$viewValue;
      });
      elem.bind('blur', function() {
        scope.$apply(function() {
          transferHTML();
          processPlaceholder();
          if (elem.original != ctrl.$viewValue &amp;&amp; changehandler) {
            if (scope[attrs.tracker] &amp;&amp; typeof scope[attrs.tracker]['isDefault_' + attrs.trackeratt] != "undefined")
              scope[attrs.tracker]['isDefault_' + attrs.trackeratt] = false;
            changehandler(scope[attrs.tracker], attrs.trackeratt);
          }
        });
      });
      elem.bind('paste', function() {
        scope.$apply(function() {
          setTimeout(function() {
            transferHTML();
            transferText();
          }, 0);
          return false;
        });
      });
      ctrl.$render = function() {
        transferText();
      };
      scope.$watch('field.readonly', function() {
        elem[0].contentEditable = !scope.$eval('field.readonly');
      });
      scope.$watch(
        function() {
          return {
            val: elem[0].textContent
          };
        },
        function(newValue, oldValue) {
          if (newValue.val != oldValue.val)
            processPlaceholder();
        },
        true);
      transferText();
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/controls/directive.snGlyph.js */
angular.module("sn.common.controls").directive("snGlyph", function() {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    scope: {
      char: "@",
    },
    template: '&lt;span class="glyphicon glyphicon-{{char}}" /&gt;',
    link: function(scope) {}
  }
});
angular.module("sn.common.controls").directive('fa', function() {
    return {
      restrict: 'E',
      template: '&lt;span class="fa" aria-hidden="true"&gt;&lt;/span&gt;',
      replace: true,
      link: function(scope, element, attrs) {
        'use strict';
        var currentClasses = {};

        function _observeStringAttr(attr, baseClass) {
          var className;
          attrs.$observe(attr, function() {
            baseClass = baseClass || 'fa-' + attr;
            element.removeClass(currentClasses[attr]);
            if (attrs[attr]) {
              className = [baseClass, attrs[attr]].join('-');
              element.addClass(className);
              currentClasses[attr] = className;
            }
          });
        }
        _observeStringAttr('name', 'fa');
        _observeStringAttr('rotate');
        _observeStringAttr('flip');
        _observeStringAttr('stack');
        attrs.$observe('size', function() {
          var className;
          element.removeClass(currentClasses.size);
          if (attrs.size === 'large') {
            className = 'fa-lg';
          } else if (!isNaN(parseInt(attrs.size, 10))) {
            className = 'fa-' + attrs.size + 'x';
          }
          element.addClass(className);
          currentClasses.size = className;
        });
        attrs.$observe('stack', function() {
          var className;
          element.removeClass(currentClasses.stack);
          if (attrs.stack === 'large') {
            className = 'fa-stack-lg';
          } else if (!isNaN(parseInt(attrs.stack, 10))) {
            className = 'fa-stack-' + attrs.stack + 'x';
          }
          element.addClass(className);
          currentClasses.stack = className;
        });

        function _observeBooleanAttr(attr, className) {
          var value;
          attrs.$observe(attr, function() {
            className = className || 'fa-' + attr;
            value = attr in attrs &amp;&amp; attrs[attr] !== 'false' &amp;&amp; attrs[attr] !== false;
            element.toggleClass(className, value);
          });
        }
        _observeBooleanAttr('border');
        _observeBooleanAttr('fw');
        _observeBooleanAttr('inverse');
        _observeBooleanAttr('spin');
        element.toggleClass('fa-li',
          element.parent() &amp;&amp;
          element.parent().prop('tagName') === 'LI' &amp;&amp;
          element.parent().parent() &amp;&amp;
          element.parent().parent().hasClass('fa-ul') &amp;&amp;
          element.parent().children()[0] === element[0] &amp;&amp;
          attrs.list !== 'false' &amp;&amp;
          attrs.list !== false
        );
        attrs.$observe('alt', function() {
          var altText = attrs.alt,
            altElem = element.next(),
            altElemClass = 'fa-alt-text';
          if (altText) {
            element.removeAttr('alt');
            if (!altElem || !altElem.hasClass(altElemClass)) {
              element.after('&lt;span class="sr-only fa-alt-text"&gt;&lt;/span&gt;');
              altElem = element.next();
            }
            altElem.text(altText);
          } else if (altElem &amp;&amp; altElem.hasClass(altElemClass)) {
            altElem.remove();
          }
        });
      }
    };
  })
  .directive('faStack', function() {
    return {
      restrict: 'E',
      transclude: true,
      template: '&lt;span ng-transclude class="fa-stack fa-lg"&gt;&lt;/span&gt;',
      replace: true,
      link: function(scope, element, attrs) {
        var currentClasses = {};

        function _observeStringAttr(attr, baseClass) {
          var className;
          attrs.$observe(attr, function() {
            baseClass = baseClass || 'fa-' + attr;
            element.removeClass(currentClasses[attr]);
            if (attrs[attr]) {
              className = [baseClass, attrs[attr]].join('-');
              element.addClass(className);
              currentClasses[attr] = className;
            }
          });
        }
        _observeStringAttr('size');
        attrs.$observe('size', function() {
          var className;
          element.removeClass(currentClasses.size);
          if (attrs.size === 'large') {
            className = 'fa-lg';
          } else if (!isNaN(parseInt(attrs.size, 10))) {
            className = 'fa-' + attrs.size + 'x';
          }
          element.addClass(className);
          currentClasses.size = className;
        });
      }
    };
  });;
/*! RESOURCE: /scripts/sn/common/controls/directive.snImageUploader.js */
angular.module('sn.common.controls').directive('snImageUploader', function($window, $rootScope, $timeout, getTemplateUrl, i18n, snAttachmentHandler) {
  var DRAG_IMAGE_SELECT = i18n.getMessage('Drag image or click to select');
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('directive.snImageUploader'),
    transclude: true,
    scope: {
      readOnly: '@',
      tableName: '@',
      sysId: '@',
      fieldName: '@',
      onUpload: '&amp;',
      onDelete: '&amp;',
      uploadMessage: '@',
      src: '='
    },
    controller: function($scope) {
      $scope.uploading = false;
      $scope.getTitle = function() {
        if ($scope.readOnly !== 'true')
          return DRAG_IMAGE_SELECT;
        return '';
      }
    },
    link: function(scope, element) {
      function isValidImage(file) {
        if (file.type.indexOf('image') != 0) {
          $alert(i18n.getMessage('Please select an image'));
          return false;
        }
        if (file.type.indexOf('tiff') &gt; 0) {
          $alert(i18n.getMessage('Please select a common image format such as gif, jpeg or png'));
          return false;
        }
        return true;
      }

      function $alert(message) {
        alert(message);
      }
      scope.onFileSelect = function($files) {
        if (scope.readOnly === 'true')
          return;
        if ($files.length == 0)
          return;
        var file = $files[0];
        if (!isValidImage(file))
          return;
        var uploadParams = {
          sysparm_fieldname: scope.fieldName
        };
        scope.uploading = true;
        snAttachmentHandler.create(scope.tableName, scope.sysId).uploadAttachment(file, uploadParams).then(function(response) {
          $timeout(function() {
            scope.uploading = false;
          });
          if (scope.onUpload)
            scope.onUpload({
              thumbnail: response.thumbnail
            });
          $rootScope.$broadcast("snImageUploader:complete", scope.sysId, response);
        });
      }
      scope.openFileSelector = function($event) {
        $event.stopPropagation();
        var input = element.find('input[type=file]');
        input.click();
      }
      scope.activateUpload = function($event) {
        if (scope.readOnly !== 'true')
          scope.openFileSelector($event);
        else
          scope.showUpload = !scope.showUpload;
      }
      scope.deleteAttachment = function() {
        var sys_id = scope.src.split(".")[0];
        snAttachmentHandler.deleteAttachment(sys_id).then(function() {
          scope.src = null;
          if (scope.onDelete)
            scope.onDelete();
          $rootScope.$broadcast("snImageUploader:delete", scope.sysId, sys_id);
        });
      }
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/i18n/js_includes_i18n.js */
/*! RESOURCE: /scripts/sn/common/i18n/_module.js */
angular.module('sn.common.i18n', ['sn.common.glide']);
angular.module('sn.i18n', ['sn.common.i18n']);;
/*! RESOURCE: /scripts/sn/common/i18n/directive.snBindI18n.js */
angular.module('sn.common.i18n').directive('snBindI18n', function(i18n, $sanitize) {
  return {
    restrict: 'A',
    link: function(scope, iElem, iAttrs) {
      i18n.getMessage(iAttrs.snBindI18n, function(translatedValue) {
        var sanitizedValue = $sanitize(translatedValue);
        iElem.append(sanitizedValue);
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/i18n/directive.message.js */
angular.module('sn.common.i18n').directive('nowMessage', function(i18n) {
  return {
    restrict: 'E',
    priority: 0,
    template: '',
    replace: true,
    compile: function(element, attrs, transclude) {
      var value = element.attr('value');
      if (!attrs.key || !value)
        return;
      i18n.loadMessage(attrs.key, value);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/i18n/service.i18n.js */
angular.module('sn.common.i18n').factory('i18n', function(nowServer, $http, $window, $log) {
  var messageMap = {};
  var isDebug = $window.NOW ? $window.NOW.i18n_debug : true;

  function getMessageFromServer(msgKey, callback) {
    getMessagesFromServer([msgKey], function() {
      if (callback)
        callback(messageMap[msgKey]);
    });
  }

  function getMessagesFromServer(msgArray, callback, msgArrayFull) {
    var url = nowServer.getURL('message');
    $http.post(url, {
      messages: msgArray
    }).success(function(response) {
      var messages = response.messages;
      for (var i in messages) {
        loadMessage(i, messages[i]);
      }
      var returnMessages = {},
        allMessages = msgArrayFull || msgArray;
      for (var j = 0; j &lt; allMessages.length; j++) {
        var key = allMessages[j];
        returnMessages[key] = messageMap[key];
      }
      if (callback)
        callback(returnMessages);
    });
  }

  function loadMessage(msgKey, msgValue) {
    messageMap[msgKey] = msgValue;
  }

  function debug(msg) {
    if (!isDebug)
      return;
    $log.log('i18n: ' + msg);
  }

  function interpolate(param) {
    return this.replace(/{([^{}]*)}/g,
      function(a, b) {
        var r = param[b];
        return typeof r === 'string' || typeof r === 'number' ? r : a;
      }
    );
  }
  if (!String.prototype.withValues)
    String.prototype.withValues = interpolate;
  return {
    getMessage: function(msgKey, callback) {
      debug('getMessage: Checking for ' + msgKey);
      if (messageMap.hasOwnProperty(msgKey)) {
        var message = messageMap[msgKey];
        if (typeof(callback) == 'function')
          callback(message);
        debug('getMessage: Found: ' + msgKey + ', message: ' + message);
        return message;
      }
      debug('getMessage: Not found: ' + msgKey + ', querying server');
      getMessageFromServer(msgKey, callback);
      msgKey.withValues = interpolate;
      if (typeof(callback) != 'function')
        $log.warn('getMessage (key="' + msgKey + '"): synchronous use not supported in Mobile or Service Portal unless message is already cached');
      return msgKey;
    },
    format: function(message) {
      if (arguments.length == 1)
        return message;
      if (arguments.length == 2 &amp;&amp; (typeof arguments[1] === 'object'))
        return interpolate.call(message, arguments[1]);
      return interpolate.call(message, [].slice.call(arguments, 1));
    },
    getMessages: function(msgArray, callback) {
      debug('getMessages: Checking for ' + msgArray.join(','));
      var results = {},
        needMessage = [],
        needServerRequest = false;
      for (var i = 0; i &lt; msgArray.length; i++) {
        var key = msgArray[i];
        if (!messageMap.hasOwnProperty(key)) {
          debug('getMessages: Did not find ' + key);
          needMessage.push(key);
          needServerRequest = true;
          results[key] = key;
          continue;
        }
        results[key] = messageMap[key];
        debug('getMessages: Found ' + key + ', message: ' + results[key]);
      }
      if (needServerRequest) {
        debug('getMessages: Querying server for ' + needMessage.join(','));
        getMessagesFromServer(needMessage, callback, msgArray);
      } else if (typeof(callback) == 'function') {
        debug('getMessages: Found all messages');
        callback(results);
      }
      return results;
    },
    clearMessages: function() {
      debug('clearMessages: clearing messages');
      messageMap = {};
    },
    loadMessage: function(msgKey, msgValue) {
      loadMessage(msgKey, msgValue);
      debug('loadMessage: loaded key: ' + msgKey + ', value: ' + msgValue);
    },
    preloadMessages: function() {
      var that = this
      angular.element('now-message').each(function() {
        var elem = angular.element(this);
        that.loadMessage(elem.attr('key'), elem.attr('value'));
      })
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/link/js_includes_link.js */
/*! RESOURCE: /scripts/sn/common/link/_module.js */
angular.module("sn.common.link", []);;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContent.js */
angular.module('sn.common.link').directive('snLinkContent', function($compile, linkContentTypes) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    template: "&lt;span /&gt;",
    scope: {
      link: "="
    },
    link: function(scope, elem) {
      var linkDirective = linkContentTypes.forType(scope.link);
      elem.attr(linkDirective, "");
      $compile(elem)(scope);
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentYoutube.js */
angular.module('sn.common.link').directive('snLinkContentYoutube', function(getTemplateUrl, $sce, inFrameSet) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentYoutube.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.playerActive = false;
      $scope.width = (inFrameSet) ? '248px' : '500px';
      $scope.height = (inFrameSet) ? '139px' : '281px';
      $scope.showPlayer = function() {
        $scope.playerActive = true;
      };
      $scope.getVideoEmbedLink = function() {
        if ($scope.link.embedLink) {
          var videoLink = $scope.link.embedLink + "?autoplay=1";
          return $sce.trustAsHtml("&lt;iframe width='" + $scope.width + "' height='" + $scope.height + "' autoplay='1' frameborder='0' allowfullscreen='' src='" + videoLink + "'&gt;&lt;/iframe&gt;");
        }
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentSoundcloud.js */
angular.module('sn.common.link').directive('snLinkContentSoundcloud', function(getTemplateUrl, $sce, inFrameSet) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentSoundcloud.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.playerActive = false;
      $scope.width = (inFrameSet) ? '248px' : '500px';
      $scope.height = (inFrameSet) ? '139px' : '281px';
      $scope.showPlayer = function() {
        $scope.playerActive = true;
      };
      $scope.getVideoEmbedLink = function() {
        if ($scope.link.embedLink) {
          var videoLink = $scope.link.embedLink + "&amp;amp;auto_play=true";
          var width = (inFrameSet) ? 248 : 500;
          return $sce.trustAsHtml("&lt;iframe width='" + $scope.width + "' height='" + $scope.height + "' autoplay='1' frameborder='0' allowfullscreen='' src='" + videoLink + "'&gt;&lt;/iframe&gt;");
        }
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentArticle.js */
angular.module('sn.common.link').directive('snLinkContentArticle', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentArticle.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {
      $scope.backgroundImageStyle = $scope.link.imageLink ?
        {
          "background-image": 'url(' + $scope.link.imageLink + ')'
        } :
        {};
      $scope.isVisible = function() {
        var link = $scope.link;
        return !!link.shortDescription || !!link.imageLink;
      };
      $scope.hasDescription = function() {
        var link = $scope.link;
        return link.shortDescription &amp;&amp; (link.shortDescription !== link.title);
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentError.js */
angular.module('sn.common.link').directive('snLinkContentError', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentError.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentImage.js */
angular.module('sn.common.link').directive('snLinkContentImage', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentImage.xml'),
    scope: {
      link: "="
    },
    controller: function($scope) {}
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentAttachment.js */
angular.module('sn.common.link').directive('snLinkContentAttachment', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentAttachment.xml'),
    scope: {
      attachment: '=',
      link: '='
    },
    controller: function($scope, $element, snCustomEvent) {
      $scope.attachment = $scope.attachment || $scope.link.attachment;
      $scope.calcImageSize = function() {
        var imageWidth = $scope.width;
        var imageHeight = $scope.height;
        var MAX_IMAGE_SIZE = $element.width() &lt; 298 ? $element.width() : 298;
        if (imageHeight &lt; 0 || imageWidth &lt; 0)
          return "";
        if (imageHeight &gt; imageWidth) {
          if (imageHeight &gt;= MAX_IMAGE_SIZE) {
            imageWidth *= MAX_IMAGE_SIZE / imageHeight;
            imageHeight = MAX_IMAGE_SIZE;
          }
        } else {
          if (imageWidth &gt;= MAX_IMAGE_SIZE) {
            imageHeight *= MAX_IMAGE_SIZE / imageWidth;
            imageWidth = MAX_IMAGE_SIZE
          }
        }
        return "height: " + imageHeight + "px; width: " + imageWidth + "px;";
      };
      $scope.aspectRatioClass = function() {
        return ($scope.height &gt; $scope.width) ? 'limit-height' : 'limit-width';
      };
      $scope.showImage = function(event) {
        if (event.keyCode === 9)
          return;
        snCustomEvent.fire('sn.attachment.preview', event, $scope.attachment.rawData);
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/directive.snLinkContentRecord.js */
angular.module('sn.common.link').directive('snLinkContentRecord', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    templateUrl: getTemplateUrl('snLinkContentRecord.xml'),
    scope: {
      link: '='
    },
    controller: function($scope) {
      $scope.isTitleVisible = function() {
        return !$scope.isDescriptionVisible() &amp;&amp; $scope.link.title;
      };
      $scope.isDescriptionVisible = function() {
        return $scope.link.shortDescription;
      };
      $scope.hasNoHeader = function() {
        return !$scope.isTitleVisible() &amp;&amp; !$scope.isDescriptionVisible();
      };
      $scope.isUnassigned = function() {
        return $scope.link.isTask &amp;&amp; !$scope.link.avatarID;
      };
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/link/provider.linkContentTypes.js */
angular.module('sn.common.link').provider('linkContentTypes', function linkContentTypesProvider() {
  "use strict";
  var linkDirectiveMap = {
    'record': "sn-link-content-record",
    'video': "sn-link-content-youtube",
    'music.song': "sn-link-content-soundcloud",
    'link': 'sn-link-content-article',
    'article': 'sn-link-content-article',
    'website': 'sn-link-content-article',
    'image': 'sn-link-content-image'
  };
  this.$get = function linkContentTypesFactory() {
    return {
      forType: function(link) {
        if (link.isUnauthorized)
          return "sn-link-content-error";
        if (!link.isActive)
          return "no-card";
        if (link.attachment)
          return "sn-link-content-attachment";
        return linkDirectiveMap[link.type] || "no-card";
      }
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/mention/js_includes_mention.js */
/*! RESOURCE: /scripts/sn/common/mention/_module.js */
angular.module("sn.common.mention", []);;
/*! RESOURCE: /scripts/sn/common/mention/directive.snMentionPopover.js */
angular.module('sn.common.mention').directive("snMentionPopover", function(getTemplateUrl, $timeout) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('snMentionPopover.xml'),
    link: function(scope, elem, $attrs) {
      elem.detach().appendTo(document.body);
      scope.profile = scope.$eval($attrs.profile);
      scope.dontPositionManually = scope.$eval($attrs.dontpositionmanually) || false;
      scope.onClick = function(event) {
        if (!angular.element(event.target).closest("#mention-popover").length ||
          angular.element(event.target).closest("#direct-message-popover-trigger").length) {
          scope.$evalAsync(function() {
            scope.$parent.showPopover = false;
            if (scope.dontPositionManually &amp;&amp; !(scope.$eval($attrs.snavatarpopover))) {
              elem.remove();
            } else {
              scope.$broadcast("sn-avatar-popover-destroy");
            }
          });
        }
      };
      scope.clickListener = $timeout(function() {
        angular.element('html').on('click.mentionPopover', scope.onClick);
      });

      function setPopoverPosition(clickX, clickY) {
        var topPosition;
        var leftPosition;
        var windowHeight = window.innerHeight;
        var windowWidth = window.innerWidth;
        if (((clickY - (elem.height() / 2))) &lt; 10)
          topPosition = 10;
        else
          topPosition = ((clickY + (elem.height() / 2)) &gt; windowHeight) ? windowHeight - elem.height() - 15 : clickY - (elem.height() / 2);
        leftPosition = ((clickX + 20 + (elem.width())) &gt; windowWidth) ? windowWidth - elem.width() - 15 : clickX + 20;
        elem.css("top", topPosition + "px").css("left", leftPosition + "px");
      }
      if (!scope.dontPositionManually) {
        $timeout(function() {
          var clickX = (scope.$parent &amp;&amp; scope.$parent.clickEvent &amp;&amp; scope.$parent.clickEvent.pageX) ? scope.$parent.clickEvent.pageX : clickX || 300;
          var clickY = (scope.$parent &amp;&amp; scope.$parent.clickEvent &amp;&amp; scope.$parent.clickEvent.pageY) ? scope.$parent.clickEvent.pageY : clickY || 300;
          setPopoverPosition(clickX, clickY);
          elem.velocity({
            opacity: 1
          }, {
            duration: 100,
            easing: "cubic"
          });
        });
      }
    },
    controller: function($scope, $element) {
      $scope.$on("$destroy", function() {
        angular.element('html').off('click.mentionPopover', $scope.onClick);
        $element.remove();
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/mention/service.snMention.js */
angular.module("sn.common.mention").factory("snMention", function(liveProfileID, $q, $http) {
  "use strict";
  var MENTION_PATH = "/api/now/form/mention/record";
  var USER_PATH = '/api/now/ui/user/';
  var avatarCache = {};

  function retrieveMembers(table, document, term) {
    if (!term || !document || !table) {
      var deferred = $q.defer();
      deferred.resolve([]);
      return deferred.promise;
    }
    return $http({
      url: MENTION_PATH + "/" + table + "/" + document,
      method: "GET",
      params: {
        term: term
      }
    }).then(function(response) {
      var members = response.data.result;
      var promises = [];
      angular.forEach(members, function(user) {
        if (avatarCache[user.sys_id]) {
          user.initials = avatarCache[user.sys_id].initials;
          user.avatar = avatarCache[user.sys_id].avatar;
        } else {
          var promise = $http.get(USER_PATH + user.sys_id).success(function(response) {
            user.initials = response.result.user_initials;
            user.avatar = response.result.user_avatar;
            avatarCache[user.sys_id] = {
              initials: user.initials,
              avatar: user.avatar
            };
          });
          promises.push(promise);
        }
      });
      return $q.all(promises).then(function() {
        return members;
      });
    })
  }
  return {
    retrieveMembers: retrieveMembers
  }
});;;
/*! RESOURCE: /scripts/sn/common/messaging/js_includes_messaging.js */
/*! RESOURCE: /scripts/sn/common/messaging/_module.js */
angular.module('sn.common.messaging', []);
angular.module('sn.messaging', ['sn.common.messaging']);;
/*! RESOURCE: /scripts/doctype/CustomEventManager.js */
var NOW = NOW || {};
var CustomEventManager = (function(existingCustomEvent) {
  "use strict";
  var events = (existingCustomEvent &amp;&amp; existingCustomEvent.events) || {};
  var isFiringFlag = false;
  var trace = false;
  var suppressEvents = false;
  var NOW_MSG = 'NOW.PostMessage';

  function observe(eventName, fn) {
    if (trace)
      jslog("$CustomEventManager observing: " + eventName);
    on(eventName, fn);
  }

  function on(name, func) {
    if (!func || typeof func !== 'function')
      return;
    if (typeof name === 'undefined')
      return;
    if (!events[name])
      events[name] = [];
    events[name].push(func);
  }

  function un(name, func) {
    if (!events[name])
      return;
    var idx = -1;
    for (var i = 0; i &lt; events[name].length; i++) {
      if (events[name][i] === func) {
        idx = i;
        break;
      }
    }
    if (idx &gt;= 0)
      events[name].splice(idx, 1)
  }

  function unAll(name) {
    if (events[name])
      delete events[name];
  }

  function fire(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    return fireEvent.apply(null, arguments);
  }

  function fireUp(eventName, args) {
    var win = window;
    while (win) {
      try {
        if (win.CustomEvent.fireEvent.apply(null, arguments) === false)
          return;
        win = win.parent === win ? null : win.parent;
      } catch (e) {
        return;
      }
    }
  }

  function fireEvent() {
    if (suppressEvents)
      return true;
    var args = Array.prototype.slice.apply(arguments);
    var name = args.shift();
    var eventList = events[name];
    if (!eventList)
      return true;
    var event = eventList.slice();
    isFiringFlag = true;
    for (var i = 0, l = event.length; i &lt; l; i++) {
      var ev = event[i];
      if (!ev)
        continue;
      if (ev.apply(null, args) === false) {
        isFiringFlag = false;
        return false;
      }
    }
    isFiringFlag = false;
    return true;
  }

  function isFiring() {
    return isFiringFlag;
  }

  function forward(name, element, func) {
    on(name, func);
    element.addEventListener(name, function(e) {
      fireEvent(e.type, this, e);
    }.bind(api));
  }

  function registerPostMessageEvent() {
    if (NOW.registeredPostMessageEvent) {
      return;
    }
    if (!window.postMessage) {
      return;
    }
    window.addEventListener('message', function(event) {
      var nowMessageJSON = event.data;
      var nowMessage;
      try {
        nowMessage = JSON.parse(nowMessageJSON.toString());
      } catch (e) {
        return;
      }
      if (!nowMessage.type == NOW_MSG) {
        return;
      }
      fire(nowMessage.eventName, nowMessage.args);
    }, false);
    NOW.registeredPostMessageEvent = true;
  }

  function doPostMessage(win, event, msg, targetOrigin) {
    var nowMessage = {
      type: NOW_MSG,
      eventName: event,
      args: msg
    };
    var nowMessageJSON;
    if (!win || !win.postMessage) {
      return
    }
    nowMessageJSON = JSON.stringify(nowMessage);
    win.postMessage(nowMessageJSON, targetOrigin);
  }

  function fireTop(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    fireEvent.apply(null, arguments);
    var t = getTopWindow();
    if (t !== null &amp;&amp; window !== t)
      t.CustomEvent.fire(eventName, args);
  }

  function fireAll(eventName, args) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + arguments.length);
    var topWindow = getTopWindow();
    notifyAllFrom(topWindow);

    function notifyAllFrom(rootFrame) {
      var childFrame;
      rootFrame.CustomEvent.fireEvent(eventName, args);
      for (var i = 0; i &lt; rootFrame.length; i++) {
        try {
          childFrame = rootFrame[i];
          if (!childFrame)
            continue;
          if (childFrame.CustomEvent &amp;&amp; typeof childFrame.CustomEvent.fireEvent === "function") {
            notifyAllFrom(childFrame);
          }
        } catch (e) {}
      }
    }
  }

  function fireToWindow(targetWindow, eventName, args, usePostMessage, targetOrigin) {
    if (trace)
      jslog("$CustomEventManager firing: " + eventName + " args: " + args.length);
    if (usePostMessage) {
      doPostMessage(targetWindow, eventName, args, targetOrigin);
    } else {
      targetWindow.CustomEvent.fireEvent(eventName, args);
    }
  }

  function getTopWindow() {
    var topWindow = window.self;
    try {
      while (topWindow.CustomEvent.fireEvent &amp;&amp; topWindow !== topWindow.parent &amp;&amp; topWindow.parent.CustomEvent.fireEvent) {
        topWindow = topWindow.parent;
      }
    } catch (e) {}
    return topWindow;
  }

  function isTopWindow() {
    return getTopWindow() == window.self;
  }

  function jslog(msg, src, dateTime) {
    try {
      if (!src) {
        var path = window.self.location.pathname;
        src = path.substring(path.lastIndexOf('/') + 1);
      }
      if (window.self.opener &amp;&amp; window != window.self.opener) {
        if (window.self.opener.jslog) {
          window.self.opener.jslog(msg, src, dateTime);
        }
      } else if (parent &amp;&amp; parent.jslog &amp;&amp; jslog != parent.jslog) {
        parent.jslog(msg, src, dateTime);
      } else {
        if (window.console &amp;&amp; window.console.log)
          console.log(msg);
      }
    } catch (e) {}
  }
  var api = {
    set trace(value) {
      trace = !!value;
    },
    get trace() {
      return trace;
    },
    set suppressEvents(value) {
      suppressEvents = !!value;
    },
    get suppressEvents() {
      return suppressEvents;
    },
    get events() {
      return events;
    },
    on: on,
    un: un,
    unAll: unAll,
    forward: forward,
    isFiring: isFiring,
    fireEvent: fireEvent,
    observe: observe,
    fire: fire,
    fireTop: fireTop,
    fireAll: fireAll,
    fireToWindow: fireToWindow,
    isTopWindow: isTopWindow,
    fireUp: fireUp,
    toString: function() {
      return 'CustomEventManager';
    }
  };
  registerPostMessageEvent();
  return api;
})(NOW.CustomEvent);
NOW.CustomEvent = CustomEventManager;
if (typeof CustomEvent !== "undefined") {
  CustomEvent.observe = NOW.CustomEvent.observe.bind(NOW.CustomEvent);
  CustomEvent.fire = NOW.CustomEvent.fire.bind(NOW.CustomEvent);
  CustomEvent.fireUp = NOW.CustomEvent.fireUp.bind(NOW.CustomEvent);
  CustomEvent.fireTop = NOW.CustomEvent.fireTop.bind(NOW.CustomEvent);
  CustomEvent.fireAll = NOW.CustomEvent.fireAll.bind(NOW.CustomEvent);
  CustomEvent.fireToWindow = NOW.CustomEvent.fireToWindow.bind(NOW.CustomEvent);
  CustomEvent.on = NOW.CustomEvent.on.bind(NOW.CustomEvent);
  CustomEvent.un = NOW.CustomEvent.un.bind(NOW.CustomEvent);
  CustomEvent.unAll = NOW.CustomEvent.unAll.bind(NOW.CustomEvent);
  CustomEvent.forward = NOW.CustomEvent.forward.bind(NOW.CustomEvent);
  CustomEvent.isFiring = NOW.CustomEvent.isFiring.bind(NOW.CustomEvent);
  CustomEvent.fireEvent = NOW.CustomEvent.fireEvent.bind(NOW.CustomEvent);
  CustomEvent.events = NOW.CustomEvent.events;
  CustomEvent.isTopWindow = NOW.CustomEvent.isTopWindow.bind(NOW.CustomEvent);
} else {
  window.CustomEvent = NOW.CustomEvent;
};
/*! RESOURCE: /scripts/sn/common/messaging/service.snCustomEvent.js */
angular.module('sn.common.messaging').factory('snCustomEvent', function() {
  "use strict";
  if (typeof NOW.CustomEvent === 'undefined')
    throw "CustomEvent not found in NOW global";
  return NOW.CustomEvent;
});;;
/*! RESOURCE: /scripts/sn/common/notification/js_includes_notification.js */
/*! RESOURCE: /scripts/sn/common/notification/_module.js */
angular.module('sn.common.notification', ['sn.common.util', 'ngSanitize']);;
/*! RESOURCE: /scripts/sn/common/notification/factory.notificationWrapper.js */
angular.module("sn.common.notification").factory("snNotificationWrapper", function($window, $timeout) {
  "use strict";

  function assignHandler(notification, handlerName, options) {
    if (typeof options[handlerName] === "function")
      notification[handlerName.toLowerCase()] = options[handlerName];
  }
  return function NotificationWrapper(title, options) {
    var defaults = {
      dir: 'auto',
      lang: 'en_US',
      decay: true,
      lifespan: 4000,
      body: "",
      tag: "",
      icon: '/native_notification_icon.png'
    };
    var optionsOnClick = options.onClick;
    options.onClick = function() {
      if (angular.isFunction($window.focus))
        $window.focus();
      if (typeof optionsOnClick === "function")
        optionsOnClick();
    }
    var result = {};
    options = angular.extend(defaults, options);
    var previousOnClose = options.onClose;
    options.onClose = function() {
      if (angular.isFunction(result.onclose))
        result.onclose();
      if (angular.isFunction(previousOnClose))
        previousOnClose();
    }
    var notification = new $window.Notification(title, options);
    assignHandler(notification, "onShow", options);
    assignHandler(notification, "onClick", options);
    assignHandler(notification, "onError", options);
    assignHandler(notification, "onClose", options);
    if (options.decay &amp;&amp; options.lifespan &gt; 0)
      $timeout(function() {
        notification.close();
      }, options.lifespan)
    result.close = function() {
      notification.close();
    }
    return result;
  }
});
/*! RESOURCE: /scripts/sn/common/notification/service.snNotifier.js */
angular.module("sn.common.notification").factory("snNotifier", function($window, snNotificationWrapper) {
  "use strict";
  return function(settings) {
    function requestNotificationPermission() {
      if ($window.Notification &amp;&amp; $window.Notification.permission === "default")
        $window.Notification.requestPermission();
    }

    function canUseNativeNotifications() {
      return ($window.Notification &amp;&amp; $window.Notification.permission === "granted");
    }
    var currentNotifications = [];
    settings = angular.extend({
      notifyMethods: ["native", "glide"]
    }, settings);
    var methods = {
      'native': nativeNotify,
      'glide': glideNotify
    };

    function nativeNotify(title, options) {
      if (canUseNativeNotifications()) {
        var newNotification = snNotificationWrapper(title, options);
        newNotification.onclose = function() {
          stopTrackingNotification(newNotification)
        };
        currentNotifications.push(newNotification);
        return true;
      }
      return false;
    }

    function glideNotify(title, options) {
      return false;
    }

    function stopTrackingNotification(newNotification) {
      var index = currentNotifications.indexOf(newNotification);
      if (index &gt; -1)
        currentNotifications.splice(index, 1);
    }

    function notify(title, options) {
      if (typeof options === "string")
        options = {
          body: options
        };
      options = options || {};
      for (var i = 0, len = settings.notifyMethods.length; i &lt; len; i++)
        if (typeof settings.notifyMethods[i] == "string") {
          if (methods[settings.notifyMethods[i]](title, options))
            break;
        } else {
          if (settings.notifyMethods[i](title, options))
            break;
        }
    }

    function clearAllNotifications() {
      while (currentNotifications.length &gt; 0)
        currentNotifications.pop().close();
    }
    return {
      notify: notify,
      canUseNativeNotifications: canUseNativeNotifications,
      clearAllNotifications: clearAllNotifications,
      requestNotificationPermission: requestNotificationPermission
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/notification/directive.snNotification.js */
angular.module('sn.common.notification').directive('snNotification', function($timeout, $rootScope) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    template: '&lt;div class="notification-container"&gt;&lt;/div&gt;',
    link: function(scope, element) {
      scope.addNotification = function(payload) {
          if (!payload)
            payload = {};
          if (!payload.text)
            payload.text = '';
          if (!payload.classes)
            payload.classes = '';
          if (!payload.duration)
            payload.duration = 5000;
          angular.element('&lt;div/&gt;').qtip({
            content: {
              text: payload.text,
              title: {
                button: false
              }
            },
            position: {
              target: [0, 0],
              container: angular.element('.notification-container')
            },
            show: {
              event: false,
              ready: true,
              effect: function() {
                angular.element(this).stop(0, 1).animate({
                  height: 'toggle'
                }, 400, 'swing');
              },
              delay: 0,
              persistent: false
            },
            hide: {
              event: false,
              effect: function(api) {
                angular.element(this).stop(0, 1).animate({
                  height: 'toggle'
                }, 400, 'swing');
              }
            },
            style: {
              classes: 'jgrowl' + ' ' + payload.classes,
              tip: false
            },
            events: {
              render: function(event, api) {
                if (!api.options.show.persistent) {
                  angular.element(this).bind('mouseover mouseout', function(e) {
                      clearTimeout(api.timer);
                      if (e.type !== 'mouseover') {
                        api.timer = setTimeout(function() {
                          api.hide(e);
                        }, payload.duration);
                      }
                    })
                    .triggerHandler('mouseout');
                }
              }
            }
          });
        },
        scope.$on('notification.notify', function(event, payload) {
          scope.addNotification(payload);
        });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/notification/service.snNotification.js */
angular.module('sn.common.notification').factory('snNotification', function($document, $templateCache, $compile, $rootScope,
  $timeout, $q, getTemplateUrl, $http) {
  'use strict';
  var openNotifications = [],
    timeouts = {},
    options = {
      top: 20,
      gap: 10,
      duration: 5000
    };
  return {
    show: function(type, message, duration, onClick) {
      return createNotificationElement(type, message).then(function(element) {
        displayNotification(element);
        checkAndSetDestroyDuration(element, duration);
        return element;
      });
    },
    hide: hide,
    setOptions: function(opts) {
      if (angular.isObject(opts))
        angular.extend(options, opts);
    }
  };

  function getTemplate() {
    var templateName = 'sn_notification.xml',
      template = $templateCache.get(templateName),
      deferred = $q.defer();
    if (!template) {
      var url = getTemplateUrl(templateName);
      $http.get(url).then(function(result) {
          $templateCache.put(templateName, result.data);
          deferred.resolve(result.data);
        },
        function(reason) {
          return $q.reject(reason);
        });
    } else
      deferred.resolve(template);
    return deferred.promise;
  }

  function createNotificationElement(type, message) {
    var thisScope, thisElement;
    return getTemplate().then(function(template) {
      thisScope = $rootScope.$new();
      thisScope.type = type;
      thisScope.message = message;
      thisElement = $compile(template)(thisScope);
      return angular.element(thisElement[0]);
    });
  }

  function displayNotification(element) {
    var body = $document.find('body'),
      id = 'elm' + Date.now(),
      pos;
    body.append(element);
    pos = options.top + openNotifications.length * getElementHeight(element);
    positionElement(element, pos);
    element.addClass('visible');
    element.attr('id', id);
    element.find('button').bind('click', function(e) {
      hideElement(element);
    });
    openNotifications.push(element);
    if (options.duration &gt; 0)
      timeouts[id] = $timeout(function() {
        hideNext();
      }, options.duration);
  }

  function hide(element) {
    $timeout.cancel(timeouts[element.attr('id')]);
    element.removeClass('visible');
    element.addClass('hidden');
    element.find('button').eq(0).unbind();
    element.scope().$destroy();
    element.remove();
    repositionAll();
  }

  function hideElement(element) {
    var index = openNotifications.indexOf(element);
    openNotifications.splice(index, 1);
    hide(element);
  }

  function hideNext() {
    var element = openNotifications.shift();
    if (element)
      hide(element);
  }

  function getElementHeight(element) {
    return element[0].offsetHeight + options.gap;
  }

  function positionElement(element, pos) {
    element[0].style.top = pos + 'px';
  }

  function repositionAll() {
    var pos = options.top;
    openNotifications.forEach(function(element) {
      positionElement(element, pos);
      pos += getElementHeight(element);
    });
  }

  function checkAndSetDestroyDuration(element, duration) {
    if (duration) {
      timeouts[element.attr('id')] = $timeout(function() {
        hideElement(element);
      }, duration);
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/presence/js_includes_presence.js */
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0.min.js */
/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
! function(a, b) {
  "object" == typeof module &amp;&amp; "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = "".trim,
    l = {},
    m = "1.11.0",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return d.call(this)
    },
    get: function(a) {
      return null != a ? 0 &gt; a ? this[a + this.length] : this[a] : d.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a, b) {
      return n.each(this, a, b)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(d.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 &gt; a ? b : 0);
      return this.pushStack(c &gt;= 0 &amp;&amp; b &gt; c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor(null)
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g &amp;&amp; (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i &amp;&amp; (g = this, h--); i &gt; h; h++)
      if (null != (e = arguments[h]))
        for (d in e) a = g[d], c = e[d], g !== c &amp;&amp; (j &amp;&amp; c &amp;&amp; (n.isPlainObject(c) || (b = n.isArray(c))) ? (b ? (b = !1, f = a &amp;&amp; n.isArray(a) ? a : []) : f = a &amp;&amp; n.isPlainObject(a) ? a : {}, g[d] = n.extend(j, f, c)) : void 0 !== c &amp;&amp; (g[d] = c));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray || function(a) {
      return "array" === n.type(a)
    },
    isWindow: function(a) {
      return null != a &amp;&amp; a == a.window
    },
    isNumeric: function(a) {
      return a - parseFloat(a) &gt;= 0
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    isPlainObject: function(a) {
      var b;
      if (!a || "object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;
      try {
        if (a.constructor &amp;&amp; !j.call(a, "constructor") &amp;&amp; !j.call(a.constructor.prototype, "isPrototypeOf")) return !1
      } catch (c) {
        return !1
      }
      if (l.ownLast)
        for (b in a) return j.call(a, b);
      for (b in a);
      return void 0 === b || j.call(a, b)
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
    },
    globalEval: function(b) {
      b &amp;&amp; n.trim(b) &amp;&amp; (a.execScript || function(b) {
        a.eval.call(a, b)
      })(b)
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b, c) {
      var d, e = 0,
        f = a.length,
        g = s(a);
      if (c) {
        if (g) {
          for (; f &gt; e; e++)
            if (d = b.apply(a[e], c), d === !1) break
        } else
          for (e in a)
            if (d = b.apply(a[e], c), d === !1) break
      } else if (g) {
        for (; f &gt; e; e++)
          if (d = b.call(a[e], e, a[e]), d === !1) break
      } else
        for (e in a)
          if (d = b.call(a[e], e, a[e]), d === !1) break;
      return a
    },
    trim: k &amp;&amp; !k.call("\ufeff\xa0") ? function(a) {
      return null == a ? "" : k.call(a)
    } : function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a &amp;&amp; (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
    },
    inArray: function(a, b, c) {
      var d;
      if (b) {
        if (g) return g.call(b, a, c);
        for (d = b.length, c = c ? 0 &gt; c ? Math.max(0, d + c) : c : 0; d &gt; c; c++)
          if (c in b &amp;&amp; b[c] === a) return c
      }
      return -1
    },
    merge: function(a, b) {
      var c = +b.length,
        d = 0,
        e = a.length;
      while (c &gt; d) a[e++] = b[d++];
      if (c !== c)
        while (void 0 !== b[d]) a[e++] = b[d++];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g &gt; f; f++) d = !b(a[f], f), d !== h &amp;&amp; e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, f = 0,
        g = a.length,
        h = s(a),
        i = [];
      if (h)
        for (; g &gt; f; f++) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      else
        for (f in a) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      return e.apply([], i)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, e, f;
      return "string" == typeof b &amp;&amp; (f = a[b], b = a, a = f), n.isFunction(a) ? (c = d.call(arguments, 2), e = function() {
        return a.apply(b || this, c.concat(d.call(arguments)))
      }, e.guid = a.guid = a.guid || n.guid++, e) : void 0
    },
    now: function() {
      return +new Date
    },
    support: l
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
    h["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType &amp;&amp; b ? !0 : "array" === c || 0 === b || "number" == typeof b &amp;&amp; b &gt; 0 &amp;&amp; b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = "sizzle" + -new Date,
      t = a.document,
      u = 0,
      v = 0,
      w = eb(),
      x = eb(),
      y = eb(),
      z = function(a, b) {
        return a === b &amp;&amp; (j = !0), 0
      },
      A = "undefined",
      B = 1 &lt;&lt; 31,
      C = {}.hasOwnProperty,
      D = [],
      E = D.pop,
      F = D.push,
      G = D.push,
      H = D.slice,
      I = D.indexOf || function(a) {
        for (var b = 0, c = this.length; c &gt; b; b++)
          if (this[b] === a) return b;
        return -1
      },
      J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      K = "[\\x20\\t\\r\\n\\f]",
      L = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      M = L.replace("w", "w#"),
      N = "\\[" + K + "*(" + L + ")" + K + "*(?:([*^$|!~]?=)" + K + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + M + ")|)|)" + K + "*\\]",
      O = ":(" + L + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + N.replace(3, 8) + ")*)|.*)\\)|)",
      P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"),
      Q = new RegExp("^" + K + "*," + K + "*"),
      R = new RegExp("^" + K + "*([&gt;+~]|" + K + ")" + K + "*"),
      S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"),
      T = new RegExp(O),
      U = new RegExp("^" + M + "$"),
      V = {
        ID: new RegExp("^#(" + L + ")"),
        CLASS: new RegExp("^\\.(" + L + ")"),
        TAG: new RegExp("^(" + L.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + N),
        PSEUDO: new RegExp("^" + O),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + J + ")$", "i"),
        needsContext: new RegExp("^" + K + "*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
      },
      W = /^(?:input|select|textarea|button)$/i,
      X = /^h\d$/i,
      Y = /^[^{]+\{\s*\[native \w/,
      Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      $ = /[+~]/,
      _ = /'|\\/g,
      ab = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"),
      bb = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 &gt; d ? String.fromCharCode(d + 65536) : String.fromCharCode(d &gt;&gt; 10 | 55296, 1023 &amp; d | 56320)
      };
    try {
      G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType
    } catch (cb) {
      G = {
        apply: D.length ? function(a, b) {
          F.apply(a, H.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function db(a, b, d, e) {
      var f, g, h, i, j, m, p, q, u, v;
      if ((b ? b.ownerDocument || b : t) !== l &amp;&amp; k(b), b = b || l, d = d || [], !a || "string" != typeof a) return d;
      if (1 !== (i = b.nodeType) &amp;&amp; 9 !== i) return [];
      if (n &amp;&amp; !e) {
        if (f = Z.exec(a))
          if (h = f[1]) {
            if (9 === i) {
              if (g = b.getElementById(h), !g || !g.parentNode) return d;
              if (g.id === h) return d.push(g), d
            } else if (b.ownerDocument &amp;&amp; (g = b.ownerDocument.getElementById(h)) &amp;&amp; r(b, g) &amp;&amp; g.id === h) return d.push(g), d
          } else {
            if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;
            if ((h = f[3]) &amp;&amp; c.getElementsByClassName &amp;&amp; b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d
          }
        if (c.qsa &amp;&amp; (!o || !o.test(a))) {
          if (q = p = s, u = b, v = 9 === i &amp;&amp; a, 1 === i &amp;&amp; "object" !== b.nodeName.toLowerCase()) {
            m = ob(a), (p = b.getAttribute("id")) ? q = p.replace(_, "\\$&amp;") : b.setAttribute("id", q), q = "[id='" + q + "'] ", j = m.length;
            while (j--) m[j] = q + pb(m[j]);
            u = $.test(a) &amp;&amp; mb(b.parentNode) || b, v = m.join(",")
          }
          if (v) try {
            return G.apply(d, u.querySelectorAll(v)), d
          } catch (w) {} finally {
            p || b.removeAttribute("id")
          }
        }
      }
      return xb(a.replace(P, "$1"), b, d, e)
    }

    function eb() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") &gt; d.cacheLength &amp;&amp; delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function fb(a) {
      return a[s] = !0, a
    }

    function gb(a) {
      var b = l.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null
      }
    }

    function hb(a, b) {
      var c = a.split("|"),
        e = a.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function ib(a, b) {
      var c = b &amp;&amp; a,
        d = c &amp;&amp; 1 === a.nodeType &amp;&amp; 1 === b.nodeType &amp;&amp; (~b.sourceIndex || B) - (~a.sourceIndex || B);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function jb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c &amp;&amp; b.type === a
      }
    }

    function kb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) &amp;&amp; b.type === a
      }
    }

    function lb(a) {
      return fb(function(b) {
        return b = +b, fb(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] &amp;&amp; (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function mb(a) {
      return a &amp;&amp; typeof a.getElementsByTagName !== A &amp;&amp; a
    }
    c = db.support = {}, f = db.isXML = function(a) {
      var b = a &amp;&amp; (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, k = db.setDocument = function(a) {
      var b, e = a ? a.ownerDocument || a : t,
        g = e.defaultView;
      return e !== l &amp;&amp; 9 === e.nodeType &amp;&amp; e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g &amp;&amp; g !== g.top &amp;&amp; (g.addEventListener ? g.addEventListener("unload", function() {
        k()
      }, !1) : g.attachEvent &amp;&amp; g.attachEvent("onunload", function() {
        k()
      })), c.attributes = gb(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = gb(function(a) {
        return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = Y.test(e.getElementsByClassName) &amp;&amp; gb(function(a) {
        return a.innerHTML = "&lt;div class='a'&gt;&lt;/div&gt;&lt;div class='a i'&gt;&lt;/div&gt;", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length
      }), c.getById = gb(function(a) {
        return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if (typeof b.getElementById !== A &amp;&amp; n) {
          var c = b.getElementById(a);
          return c &amp;&amp; c.parentNode ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          var c = typeof a.getAttributeNode !== A &amp;&amp; a.getAttributeNode("id");
          return c &amp;&amp; c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType &amp;&amp; d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName &amp;&amp; function(a, b) {
        return typeof b.getElementsByClassName !== A &amp;&amp; n ? b.getElementsByClassName(a) : void 0
      }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) &amp;&amp; (gb(function(a) {
        a.innerHTML = "&lt;select t=''&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;", a.querySelectorAll("[t^='']").length &amp;&amp; o.push("[*^$]=" + K + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || o.push("\\[" + K + "*(?:value|" + J + ")"), a.querySelectorAll(":checked").length || o.push(":checked")
      }), gb(function(a) {
        var b = e.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length &amp;&amp; o.push("name" + K + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || o.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), o.push(",.*:")
      })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) &amp;&amp; gb(function(a) {
        c.disconnectedMatch = q.call(a, "div"), q.call(a, "[s!='']:x"), p.push("!=", O)
      }), o = o.length &amp;&amp; new RegExp(o.join("|")), p = p.length &amp;&amp; new RegExp(p.join("|")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b &amp;&amp; b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition &amp;&amp; 16 &amp; a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, z = b ? function(a, b) {
        if (a === b) return j = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 &amp; d || !c.sortDetached &amp;&amp; b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t &amp;&amp; r(t, a) ? -1 : b === e || b.ownerDocument === t &amp;&amp; r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 &amp; d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return j = !0, 0;
        var c, d = 0,
          f = a.parentNode,
          g = b.parentNode,
          h = [a],
          k = [b];
        if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;
        if (f === g) return ib(a, b);
        c = a;
        while (c = c.parentNode) h.unshift(c);
        c = b;
        while (c = c.parentNode) k.unshift(c);
        while (h[d] === k[d]) d++;
        return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0
      }, e) : l
    }, db.matches = function(a, b) {
      return db(a, null, null, b)
    }, db.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== l &amp;&amp; k(a), b = b.replace(S, "='$1']"), !(!c.matchesSelector || !n || p &amp;&amp; p.test(b) || o &amp;&amp; o.test(b))) try {
        var d = q.call(a, b);
        if (d || c.disconnectedMatch || a.document &amp;&amp; 11 !== a.document.nodeType) return d
      } catch (e) {}
      return db(b, l, null, [a]).length &gt; 0
    }, db.contains = function(a, b) {
      return (a.ownerDocument || a) !== l &amp;&amp; k(a), r(a, b)
    }, db.attr = function(a, b) {
      (a.ownerDocument || a) !== l &amp;&amp; k(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e &amp;&amp; C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;
      return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) &amp;&amp; f.specified ? f.value : null
    }, db.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, db.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (j = !c.detectDuplicates, i = !c.sortStable &amp;&amp; a.slice(0), a.sort(z), j) {
        while (b = a[f++]) b === a[f] &amp;&amp; (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return i = null, a
    }, e = db.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = db.selectors = {
      cacheLength: 50,
      createPseudo: fb,
      match: V,
      attrHandle: {},
      find: {},
      relative: {
        "&gt;": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || "").replace(ab, bb), "~=" === a[2] &amp;&amp; (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] &amp;&amp; db.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[5] &amp;&amp; a[2];
          return V.CHILD.test(a[0]) ? null : (a[3] &amp;&amp; void 0 !== a[4] ? a[2] = a[4] : c &amp;&amp; T.test(c) &amp;&amp; (b = ob(c, !0)) &amp;&amp; (b = c.indexOf(")", c.length - b) - c.length) &amp;&amp; (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(ab, bb).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = w[a + " "];
          return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) &amp;&amp; w(a, function(a) {
            return b.test("string" == typeof a.className &amp;&amp; a.className || typeof a.getAttribute !== A &amp;&amp; a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = db.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c &amp;&amp; 0 === e.indexOf(c) : "*=" === b ? c &amp;&amp; e.indexOf(c) &gt; -1 : "$=" === b ? c &amp;&amp; e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) &gt; -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d &amp;&amp; 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h &amp;&amp; b.nodeName.toLowerCase(),
              t = !i &amp;&amp; !h;
            if (q) {
              if (f) {
                while (p) {
                  l = b;
                  while (l = l[p])
                    if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                  o = p = "only" === a &amp;&amp; !o &amp;&amp; "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g &amp;&amp; t) {
                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u &amp;&amp; j[1], m = j[0] === u &amp;&amp; j[2], l = n &amp;&amp; q.childNodes[n];
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if (1 === l.nodeType &amp;&amp; ++m &amp;&amp; l === b) {
                    k[a] = [u, n, m];
                    break
                  }
              } else if (t &amp;&amp; (j = (b[s] || (b[s] = {}))[a]) &amp;&amp; j[0] === u) m = j[1];
              else
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) &amp;&amp; ++m &amp;&amp; (t &amp;&amp; ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;
              return m -= e, m === d || m % d === 0 &amp;&amp; m / d &gt;= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error("unsupported pseudo: " + a);
          return e[s] ? e(b) : e.length &gt; 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: fb(function(a) {
          var b = [],
            c = [],
            d = g(a.replace(P, "$1"));
          return d[s] ? fb(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) &amp;&amp; (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), !c.pop()
          }
        }),
        has: fb(function(a) {
          return function(b) {
            return db(a, b).length &gt; 0
          }
        }),
        contains: fb(function(a) {
          return function(b) {
            return (b.textContent || b.innerText || e(b)).indexOf(a) &gt; -1
          }
        }),
        lang: fb(function(a) {
          return U.test(a || "") || db.error("unsupported lang: " + a), a = a.replace(ab, bb).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = n ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) &amp;&amp; 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location &amp;&amp; a.location.hash;
          return c &amp;&amp; c.slice(1) === b.id
        },
        root: function(a) {
          return a === m
        },
        focus: function(a) {
          return a === l.activeElement &amp;&amp; (!l.hasFocus || l.hasFocus()) &amp;&amp; !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; !!a.checked || "option" === b &amp;&amp; !!a.selected
        },
        selected: function(a) {
          return a.parentNode &amp;&amp; a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType &lt; 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return X.test(a.nodeName)
        },
        input: function(a) {
          return W.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() &amp;&amp; "text" === a.type &amp;&amp; (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: lb(function() {
          return [0]
        }),
        last: lb(function(a, b) {
          return [b - 1]
        }),
        eq: lb(function(a, b, c) {
          return [0 &gt; c ? c + b : c]
        }),
        even: lb(function(a, b) {
          for (var c = 0; b &gt; c; c += 2) a.push(c);
          return a
        }),
        odd: lb(function(a, b) {
          for (var c = 1; b &gt; c; c += 2) a.push(c);
          return a
        }),
        lt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; --d &gt;= 0;) a.push(d);
          return a
        }),
        gt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; ++d &lt; b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = jb(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = kb(b);

    function nb() {}
    nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;

    function ob(a, b) {
      var c, e, f, g, h, i, j, k = x[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        (!c || (e = Q.exec(h))) &amp;&amp; (e &amp;&amp; (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) &amp;&amp; (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(P, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = V[g].exec(h)) || j[g] &amp;&amp; !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? db.error(a) : x(a, i).slice(0)
    }

    function pb(a) {
      for (var b = 0, c = a.length, d = ""; c &gt; b; b++) d += a[b].value;
      return d
    }

    function qb(a, b, c) {
      var d = b.dir,
        e = c &amp;&amp; "parentNode" === d,
        f = v++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j = [u, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) &amp;&amp; a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (i = b[s] || (b[s] = {}), (h = i[d]) &amp;&amp; h[0] === u &amp;&amp; h[1] === f) return j[2] = h[2];
              if (i[d] = j, j[2] = a(b, c, g)) return !0
            }
      }
    }

    function rb(a) {
      return a.length &gt; 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function sb(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i &gt; h; h++)(f = a[h]) &amp;&amp; (!c || c(f, d, e)) &amp;&amp; (g.push(f), j &amp;&amp; b.push(h));
      return g
    }

    function tb(a, b, c, d, e, f) {
      return d &amp;&amp; !d[s] &amp;&amp; (d = tb(d)), e &amp;&amp; !e[s] &amp;&amp; (e = tb(e, f)), fb(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || wb(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f &amp;&amp; b ? p : sb(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c &amp;&amp; c(q, r, h, i), d) {
          j = sb(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) &amp;&amp; (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) &amp;&amp; j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) &amp;&amp; (j = e ? I.call(f, l) : m[k]) &gt; -1 &amp;&amp; (f[j] = !(g[j] = l))
          }
        } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)
      })
    }

    function ub(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[" "], j = g ? 1 : 0, k = qb(function(a) {
          return a === b
        }, i, !0), l = qb(function(a) {
          return I.call(b, a) &gt; -1
        }, i, !0), m = [function(a, c, d) {
          return !g &amp;&amp; (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))
        }]; f &gt; j; j++)
        if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];
        else {
          if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {
            for (e = ++j; f &gt; e; e++)
              if (d.relative[a[e].type]) break;
            return tb(j &gt; 1 &amp;&amp; rb(m), j &gt; 1 &amp;&amp; pb(a.slice(0, j - 1).concat({
              value: " " === a[j - 2].type ? "*" : ""
            })).replace(P, "$1"), c, e &gt; j &amp;&amp; ub(a.slice(j, e)), f &gt; e &amp;&amp; ub(a = a.slice(e)), f &gt; e &amp;&amp; pb(a))
          }
          m.push(c)
        }
      return rb(m)
    }

    function vb(a, b) {
      var c = b.length &gt; 0,
        e = a.length &gt; 0,
        f = function(f, g, i, j, k) {
          var m, n, o, p = 0,
            q = "0",
            r = f &amp;&amp; [],
            s = [],
            t = h,
            v = f || e &amp;&amp; d.find.TAG("*", k),
            w = u += null == t ? 1 : Math.random() || .1,
            x = v.length;
          for (k &amp;&amp; (h = g !== l &amp;&amp; g); q !== x &amp;&amp; null != (m = v[q]); q++) {
            if (e &amp;&amp; m) {
              n = 0;
              while (o = a[n++])
                if (o(m, g, i)) {
                  j.push(m);
                  break
                }
              k &amp;&amp; (u = w)
            }
            c &amp;&amp; ((m = !o &amp;&amp; m) &amp;&amp; p--, f &amp;&amp; r.push(m))
          }
          if (p += q, c &amp;&amp; q !== p) {
            n = 0;
            while (o = b[n++]) o(r, s, g, i);
            if (f) {
              if (p &gt; 0)
                while (q--) r[q] || s[q] || (s[q] = E.call(j));
              s = sb(s)
            }
            G.apply(j, s), k &amp;&amp; !f &amp;&amp; s.length &gt; 0 &amp;&amp; p + b.length &gt; 1 &amp;&amp; db.uniqueSort(j)
          }
          return k &amp;&amp; (u = w, h = t), r
        };
      return c ? fb(f) : f
    }
    g = db.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = y[a + " "];
      if (!f) {
        b || (b = ob(a)), c = b.length;
        while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);
        f = y(a, vb(e, d))
      }
      return f
    };

    function wb(a, b, c) {
      for (var d = 0, e = b.length; e &gt; d; d++) db(a, b[d], c);
      return c
    }

    function xb(a, b, e, f) {
      var h, i, j, k, l, m = ob(a);
      if (!f &amp;&amp; 1 === m.length) {
        if (i = m[0] = m[0].slice(0), i.length &gt; 2 &amp;&amp; "ID" === (j = i[0]).type &amp;&amp; c.getById &amp;&amp; 9 === b.nodeType &amp;&amp; n &amp;&amp; d.relative[i[1].type]) {
          if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;
          a = a.slice(i.shift().value.length)
        }
        h = V.needsContext.test(a) ? 0 : i.length;
        while (h--) {
          if (j = i[h], d.relative[k = j.type]) break;
          if ((l = d.find[k]) &amp;&amp; (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) &amp;&amp; mb(b.parentNode) || b))) {
            if (i.splice(h, 1), a = f.length &amp;&amp; pb(i), !a) return G.apply(e, f), e;
            break
          }
        }
      }
      return g(a, m)(f, b, !n, e, $.test(a) &amp;&amp; mb(b.parentNode) || b), e
    }
    return c.sortStable = s.split("").sort(z).join("") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {
      return 1 &amp; a.compareDocumentPosition(l.createElement("div"))
    }), gb(function(a) {
      return a.innerHTML = "&lt;a href='#'&gt;&lt;/a&gt;", "#" === a.firstChild.getAttribute("href")
    }) || hb("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes &amp;&amp; gb(function(a) {
      return a.innerHTML = "&lt;input/&gt;", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || hb("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), gb(function(a) {
      return null == a.getAttribute("disabled")
    }) || hb(J, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) &amp;&amp; d.specified ? d.value : null
    }), db
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = n.expr.match.needsContext,
    v = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/,
    w = /^.[^:#\[\.,]*$/;

  function x(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return n.inArray(a, b) &gt;= 0 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c &amp;&amp; (a = ":not(" + a + ")"), 1 === b.length &amp;&amp; 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = [],
        d = this,
        e = d.length;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; e &gt; b; b++)
          if (n.contains(d[b], this)) return !0
      }));
      for (b = 0; e &gt; b; b++) n.find(a, d[b], c);
      return c = this.pushStack(e &gt; 1 ? n.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c
    },
    filter: function(a) {
      return this.pushStack(x(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(x(this, a || [], !0))
    },
    is: function(a) {
      return !!x(this, "string" == typeof a &amp;&amp; u.test(a) ? n(a) : a || [], !1).length
    }
  });
  var y, z = a.document,
    A = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,
    B = n.fn.init = function(a, b) {
      var c, d;
      if (!a) return this;
      if ("string" == typeof a) {
        if (c = "&lt;" === a.charAt(0) &amp;&amp; "&gt;" === a.charAt(a.length - 1) &amp;&amp; a.length &gt;= 3 ? [null, a, null] : A.exec(a), !c || !c[1] &amp;&amp; b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
        if (c[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b &amp;&amp; b.nodeType ? b.ownerDocument || b : z, !0)), v.test(c[1]) &amp;&amp; n.isPlainObject(b))
            for (c in b) n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
          return this
        }
        if (d = z.getElementById(c[2]), d &amp;&amp; d.parentNode) {
          if (d.id !== c[2]) return y.find(a);
          this.length = 1, this[0] = d
        }
        return this.context = z, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector &amp;&amp; (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  B.prototype = n.fn, y = n(z);
  var C = /^(?:parents|prev(?:Until|All))/,
    D = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.extend({
    dir: function(a, b, c) {
      var d = [],
        e = a[b];
      while (e &amp;&amp; 9 !== e.nodeType &amp;&amp; (void 0 === c || 1 !== e.nodeType || !n(e).is(c))) 1 === e.nodeType &amp;&amp; d.push(e), e = e[b];
      return d
    },
    sibling: function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType &amp;&amp; a !== b &amp;&amp; c.push(a);
      return c
    }
  }), n.fn.extend({
    has: function(a) {
      var b, c = n(a, this),
        d = c.length;
      return this.filter(function() {
        for (b = 0; d &gt; b; b++)
          if (n.contains(this, c[b])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e &gt; d; d++)
        for (c = this[d]; c &amp;&amp; c !== b; c = c.parentNode)
          if (c.nodeType &lt; 11 &amp;&amp; (g ? g.index(c) &gt; -1 : 1 === c.nodeType &amp;&amp; n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          }
      return this.pushStack(f.length &gt; 1 ? n.unique(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? n.inArray(this[0], n(a)) : n.inArray(a.jquery ? a[0] : a, this) : this[0] &amp;&amp; this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function E(a, b) {
    do a = a[b]; while (a &amp;&amp; 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return n.dir(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return n.dir(a, "parentNode", c)
    },
    next: function(a) {
      return E(a, "nextSibling")
    },
    prev: function(a) {
      return E(a, "previousSibling")
    },
    nextAll: function(a) {
      return n.dir(a, "nextSibling")
    },
    prevAll: function(a) {
      return n.dir(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return n.dir(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return n.dir(a, "previousSibling", c)
    },
    siblings: function(a) {
      return n.sibling((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return n.sibling(a.firstChild)
    },
    contents: function(a) {
      return n.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) &amp;&amp; (d = c), d &amp;&amp; "string" == typeof d &amp;&amp; (e = n.filter(d, e)), this.length &gt; 1 &amp;&amp; (D[a] || (e = n.unique(e)), C.test(a) &amp;&amp; (e = e.reverse())), this.pushStack(e)
    }
  });
  var F = /\S+/g,
    G = {};

  function H(a) {
    var b = G[a] = {};
    return n.each(a.match(F) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? G[a] || H(a) : n.extend({}, a);
    var b, c, d, e, f, g, h = [],
      i = !a.once &amp;&amp; [],
      j = function(l) {
        for (c = a.memory &amp;&amp; l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h &amp;&amp; e &gt; f; f++)
          if (h[f].apply(l[0], l[1]) === !1 &amp;&amp; a.stopOnFalse) {
            c = !1;
            break
          }
        b = !1, h &amp;&amp; (i ? i.length &amp;&amp; j(i.shift()) : c ? h = [] : k.disable())
      },
      k = {
        add: function() {
          if (h) {
            var d = h.length;
            ! function f(b) {
              n.each(b, function(b, c) {
                var d = n.type(c);
                "function" === d ? a.unique &amp;&amp; k.has(c) || h.push(c) : c &amp;&amp; c.length &amp;&amp; "string" !== d &amp;&amp; f(c)
              })
            }(arguments), b ? e = h.length : c &amp;&amp; (g = d, j(c))
          }
          return this
        },
        remove: function() {
          return h &amp;&amp; n.each(arguments, function(a, c) {
            var d;
            while ((d = n.inArray(c, h, d)) &gt; -1) h.splice(d, 1), b &amp;&amp; (e &gt;= d &amp;&amp; e--, f &gt;= d &amp;&amp; f--)
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, h) &gt; -1 : !(!h || !h.length)
        },
        empty: function() {
          return h = [], e = 0, this
        },
        disable: function() {
          return h = i = c = void 0, this
        },
        disabled: function() {
          return !h
        },
        lock: function() {
          return i = void 0, c || k.disable(), this
        },
        locked: function() {
          return !i
        },
        fireWith: function(a, c) {
          return !h || d &amp;&amp; !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this
        },
        fire: function() {
          return k.fireWith(this, arguments), this
        },
        fired: function() {
          return !!d
        }
      };
    return k
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) &amp;&amp; a[b];
                e[f[1]](function() {
                  var a = g &amp;&amp; g.apply(this, arguments);
                  a &amp;&amp; n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h &amp;&amp; g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a &amp;&amp; a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = d.call(arguments),
        e = c.length,
        f = 1 !== e || a &amp;&amp; n.isFunction(a.promise) ? e : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(e) {
            b[a] = this, c[a] = arguments.length &gt; 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (e &gt; 1)
        for (i = new Array(e), j = new Array(e), k = new Array(e); e &gt; b; b++) c[b] &amp;&amp; n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var I;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      if (a === !0 ? !--n.readyWait : !n.isReady) {
        if (!z.body) return setTimeout(n.ready);
        n.isReady = !0, a !== !0 &amp;&amp; --n.readyWait &gt; 0 || (I.resolveWith(z, [n]), n.fn.trigger &amp;&amp; n(z).trigger("ready").off("ready"))
      }
    }
  });

  function J() {
    z.addEventListener ? (z.removeEventListener("DOMContentLoaded", K, !1), a.removeEventListener("load", K, !1)) : (z.detachEvent("onreadystatechange", K), a.detachEvent("onload", K))
  }

  function K() {
    (z.addEventListener || "load" === event.type || "complete" === z.readyState) &amp;&amp; (J(), n.ready())
  }
  n.ready.promise = function(b) {
    if (!I)
      if (I = n.Deferred(), "complete" === z.readyState) setTimeout(n.ready);
      else if (z.addEventListener) z.addEventListener("DOMContentLoaded", K, !1), a.addEventListener("load", K, !1);
    else {
      z.attachEvent("onreadystatechange", K), a.attachEvent("onload", K);
      var c = !1;
      try {
        c = null == a.frameElement &amp;&amp; z.documentElement
      } catch (d) {}
      c &amp;&amp; c.doScroll &amp;&amp; ! function e() {
        if (!n.isReady) {
          try {
            c.doScroll("left")
          } catch (a) {
            return setTimeout(e, 50)
          }
          J(), n.ready()
        }
      }()
    }
    return I.promise(b)
  };
  var L = "undefined",
    M;
  for (M in n(l)) break;
  l.ownLast = "0" !== M, l.inlineBlockNeedsLayout = !1, n(function() {
      var a, b, c = z.getElementsByTagName("body")[0];
      c &amp;&amp; (a = z.createElement("div"), a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", b = z.createElement("div"), c.appendChild(a).appendChild(b), typeof b.style.zoom !== L &amp;&amp; (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) &amp;&amp; (c.style.zoom = 1)), c.removeChild(a), a = b = null)
    }),
    function() {
      var a = z.createElement("div");
      if (null == l.deleteExpando) {
        l.deleteExpando = !0;
        try {
          delete a.test
        } catch (b) {
          l.deleteExpando = !1
        }
      }
      a = null
    }(), n.acceptData = function(a) {
      var b = n.noData[(a.nodeName + " ").toLowerCase()],
        c = +a.nodeType || 1;
      return 1 !== c &amp;&amp; 9 !== c ? !1 : !b || b !== !0 &amp;&amp; a.getAttribute("classid") === b
    };
  var N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;

  function P(a, b, c) {
    if (void 0 === c &amp;&amp; 1 === a.nodeType) {
      var d = "data-" + b.replace(O, "-$1").toLowerCase();
      if (c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
        } catch (e) {}
        n.data(a, b, c)
      } else c = void 0
    }
    return c
  }

  function Q(a) {
    var b;
    for (b in a)
      if (("data" !== b || !n.isEmptyObject(a[b])) &amp;&amp; "toJSON" !== b) return !1;
    return !0
  }

  function R(a, b, d, e) {
    if (n.acceptData(a)) {
      var f, g, h = n.expando,
        i = a.nodeType,
        j = i ? n.cache : a,
        k = i ? a[h] : a[h] &amp;&amp; h;
      if (k &amp;&amp; j[k] &amp;&amp; (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || n.guid++ : h), j[k] || (j[k] = i ? {} : {
        toJSON: n.noop
      }), ("object" == typeof b || "function" == typeof b) &amp;&amp; (e ? j[k] = n.extend(j[k], b) : j[k].data = n.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d &amp;&amp; (g[n.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f &amp;&amp; (f = g[n.camelCase(b)])) : f = g, f
    }
  }

  function S(a, b, c) {
    if (n.acceptData(a)) {
      var d, e, f = a.nodeType,
        g = f ? n.cache : a,
        h = f ? a[n.expando] : n.expando;
      if (g[h]) {
        if (b &amp;&amp; (d = c ? g[h] : g[h].data)) {
          n.isArray(b) ? b = b.concat(n.map(b, n.camelCase)) : b in d ? b = [b] : (b = n.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;
          while (e--) delete d[b[e]];
          if (c ? !Q(d) : !n.isEmptyObject(d)) return
        }(c || (delete g[h].data, Q(g[h]))) &amp;&amp; (f ? n.cleanData([a], !0) : l.deleteExpando || g != g.window ? delete g[h] : g[h] = null)
      }
    }
  }
  n.extend({
    cache: {},
    noData: {
      "applet ": !0,
      "embed ": !0,
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },
    hasData: function(a) {
      return a = a.nodeType ? n.cache[a[n.expando]] : a[n.expando], !!a &amp;&amp; !Q(a)
    },
    data: function(a, b, c) {
      return R(a, b, c)
    },
    removeData: function(a, b) {
      return S(a, b)
    },
    _data: function(a, b, c) {
      return R(a, b, c, !0)
    },
    _removeData: function(a, b) {
      return S(a, b, !0)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f &amp;&amp; f.attributes;
      if (void 0 === a) {
        if (this.length &amp;&amp; (e = n.data(f), 1 === f.nodeType &amp;&amp; !n._data(f, "parsedAttrs"))) {
          c = g.length;
          while (c--) d = g[c].name, 0 === d.indexOf("data-") &amp;&amp; (d = n.camelCase(d.slice(5)), P(f, d, e[d]));
          n._data(f, "parsedAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        n.data(this, a)
      }) : arguments.length &gt; 1 ? this.each(function() {
        n.data(this, a, b)
      }) : f ? P(f, a, n.data(f, a)) : void 0
    },
    removeData: function(a) {
      return this.each(function() {
        n.removeData(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = n._data(a, b), c &amp;&amp; (!d || n.isArray(c) ? d = n._data(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e &amp;&amp; (e = c.shift(), d--), e &amp;&amp; ("fx" === b &amp;&amp; c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d &amp;&amp; f &amp;&amp; f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return n._data(a, c) || n._data(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          n._removeData(a, b + "queue"), n._removeData(a, c)
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a &amp;&amp; (b = a, a = "fx", c--), arguments.length &lt; c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a &amp;&amp; "inprogress" !== c[0] &amp;&amp; n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a &amp;&amp; (b = a, a = void 0), a = a || "fx";
      while (g--) c = n._data(f[g], a + "queueHooks"), c &amp;&amp; c.empty &amp;&amp; (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    U = ["Top", "Right", "Bottom", "Left"],
    V = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    },
    W = n.access = function(a, b, c, d, e, f, g) {
      var h = 0,
        i = a.length,
        j = null == c;
      if ("object" === n.type(c)) {
        e = !0;
        for (h in c) n.access(a, b, h, c[h], !0, f, g)
      } else if (void 0 !== d &amp;&amp; (e = !0, n.isFunction(d) || (g = !0), j &amp;&amp; (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
          return j.call(n(a), c)
        })), b))
        for (; i &gt; h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
      return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
    },
    X = /^(?:checkbox|radio)$/i;
  ! function() {
    var a = z.createDocumentFragment(),
      b = z.createElement("div"),
      c = z.createElement("input");
    if (b.setAttribute("className", "t"), b.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;", l.leadingWhitespace = 3 === b.firstChild.nodeType, l.tbody = !b.getElementsByTagName("tbody").length, l.htmlSerialize = !!b.getElementsByTagName("link").length, l.html5Clone = "&lt;:nav&gt;&lt;/:nav&gt;" !== z.createElement("nav").cloneNode(!0).outerHTML, c.type = "checkbox", c.checked = !0, a.appendChild(c), l.appendChecked = c.checked, b.innerHTML = "&lt;textarea&gt;x&lt;/textarea&gt;", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, a.appendChild(b), b.innerHTML = "&lt;input type='radio' checked='checked' name='t'/&gt;", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, l.noCloneEvent = !0, b.attachEvent &amp;&amp; (b.attachEvent("onclick", function() {
        l.noCloneEvent = !1
      }), b.cloneNode(!0).click()), null == l.deleteExpando) {
      l.deleteExpando = !0;
      try {
        delete b.test
      } catch (d) {
        l.deleteExpando = !1
      }
    }
    a = b = c = null
  }(),
  function() {
    var b, c, d = z.createElement("div");
    for (b in {
        submit: !0,
        change: !0,
        focusin: !0
      }) c = "on" + b, (l[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), l[b + "Bubbles"] = d.attributes[c].expando === !1);
    d = null
  }();
  var Y = /^(?:input|select|textarea)$/i,
    Z = /^key/,
    $ = /^(?:mouse|contextmenu)|click/,
    _ = /^(?:focusinfocus|focusoutblur)$/,
    ab = /^([^.]*)(?:\.(.+)|)$/;

  function bb() {
    return !0
  }

  function cb() {
    return !1
  }

  function db() {
    try {
      return z.activeElement
    } catch (a) {}
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n._data(a);
      if (r) {
        c.handler &amp;&amp; (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
          return typeof n === L || a &amp;&amp; n.event.triggered === a.type ? void 0 : n.event.dispatch.apply(k.elem, arguments)
        }, k.elem = a), b = (b || "").match(F) || [""], h = b.length;
        while (h--) f = ab.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o &amp;&amp; (j = n.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = n.event.special[o] || {}, l = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e &amp;&amp; n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, i), (m = g[o]) || (m = g[o] = [], m.delegateCount = 0, j.setup &amp;&amp; j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent &amp;&amp; a.attachEvent("on" + o, k))), j.add &amp;&amp; (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), n.event.global[o] = !0);
        a = null
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData(a) &amp;&amp; n._data(a);
      if (r &amp;&amp; (k = r.events)) {
        b = (b || "").match(F) || [""], j = b.length;
        while (j--)
          if (h = ab.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = k[o] || [], h = h[2] &amp;&amp; new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = m.length;
            while (f--) g = m[f], !e &amp;&amp; q !== g.origType || c &amp;&amp; c.guid !== g.guid || h &amp;&amp; !h.test(g.namespace) || d &amp;&amp; d !== g.selector &amp;&amp; ("**" !== d || !g.selector) || (m.splice(f, 1), g.selector &amp;&amp; m.delegateCount--, l.remove &amp;&amp; l.remove.call(a, g));
            i &amp;&amp; !m.length &amp;&amp; (l.teardown &amp;&amp; l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete k[o])
          } else
            for (o in k) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(k) &amp;&amp; (delete r.handle, n._removeData(a, "events"))
      }
    },
    trigger: function(b, c, d, e) {
      var f, g, h, i, k, l, m, o = [d || z],
        p = j.call(b, "type") ? b.type : b,
        q = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (h = l = d = d || z, 3 !== d.nodeType &amp;&amp; 8 !== d.nodeType &amp;&amp; !_.test(p + n.event.triggered) &amp;&amp; (p.indexOf(".") &gt;= 0 &amp;&amp; (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") &lt; 0 &amp;&amp; "on" + p, b = b[n.expando] ? b : new n.Event(p, "object" == typeof b &amp;&amp; b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), k = n.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
        if (!e &amp;&amp; !k.noBubble &amp;&amp; !n.isWindow(d)) {
          for (i = k.delegateType || p, _.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), l = h;
          l === (d.ownerDocument || z) &amp;&amp; o.push(l.defaultView || l.parentWindow || a)
        }
        m = 0;
        while ((h = o[m++]) &amp;&amp; !b.isPropagationStopped()) b.type = m &gt; 1 ? i : k.bindType || p, f = (n._data(h, "events") || {})[b.type] &amp;&amp; n._data(h, "handle"), f &amp;&amp; f.apply(h, c), f = g &amp;&amp; h[g], f &amp;&amp; f.apply &amp;&amp; n.acceptData(h) &amp;&amp; (b.result = f.apply(h, c), b.result === !1 &amp;&amp; b.preventDefault());
        if (b.type = p, !e &amp;&amp; !b.isDefaultPrevented() &amp;&amp; (!k._default || k._default.apply(o.pop(), c) === !1) &amp;&amp; n.acceptData(d) &amp;&amp; g &amp;&amp; d[p] &amp;&amp; !n.isWindow(d)) {
          l = d[g], l &amp;&amp; (d[g] = null), n.event.triggered = p;
          try {
            d[p]()
          } catch (r) {}
          n.event.triggered = void 0, l &amp;&amp; (d[g] = l)
        }
        return b.result
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, e, f, g, h = [],
        i = d.call(arguments),
        j = (n._data(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) &amp;&amp; !a.isPropagationStopped()) {
          a.currentTarget = f.elem, g = 0;
          while ((e = f.handlers[g++]) &amp;&amp; !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(e.namespace)) &amp;&amp; (a.handleObj = e, a.data = e.data, c = ((n.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c &amp;&amp; (a.result = c) === !1 &amp;&amp; (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch &amp;&amp; k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h &amp;&amp; i.nodeType &amp;&amp; (!a.button || "click" !== a.type))
        for (; i != this; i = i.parentNode || this)
          if (1 === i.nodeType &amp;&amp; (i.disabled !== !0 || "click" !== a.type)) {
            for (e = [], f = 0; h &gt; f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] &amp;&amp; (e[c] = d.needsContext ? n(c, this).index(i) &gt;= 0 : n.find(c, this, null, [i]).length), e[c] &amp;&amp; e.push(d);
            e.length &amp;&amp; g.push({
              elem: i,
              handlers: e
            })
          }
      return h &lt; b.length &amp;&amp; g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, d, e = a.type,
        f = a,
        g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = $.test(e) ? this.mouseHooks : Z.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
      while (b--) c = d[b], a[c] = f[c];
      return a.target || (a.target = f.srcElement || z), 3 === a.target.nodeType &amp;&amp; (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which &amp;&amp; (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, d, e, f = b.button,
          g = b.fromElement;
        return null == a.pageX &amp;&amp; null != b.clientX &amp;&amp; (d = a.target.ownerDocument || z, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e &amp;&amp; e.scrollLeft || c &amp;&amp; c.scrollLeft || 0) - (e &amp;&amp; e.clientLeft || c &amp;&amp; c.clientLeft || 0), a.pageY = b.clientY + (e &amp;&amp; e.scrollTop || c &amp;&amp; c.scrollTop || 0) - (e &amp;&amp; e.clientTop || c &amp;&amp; c.clientTop || 0)), !a.relatedTarget &amp;&amp; g &amp;&amp; (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 &amp; f ? 1 : 2 &amp; f ? 3 : 4 &amp; f ? 2 : 0), a
      }
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          if (this !== db() &amp;&amp; this.focus) try {
            return this.focus(), !1
          } catch (a) {}
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === db() &amp;&amp; this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return n.nodeName(this, "input") &amp;&amp; "checkbox" === this.type &amp;&amp; this.click ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result &amp;&amp; (a.originalEvent.returnValue = a.result)
        }
      }
    },
    simulate: function(a, b, c, d) {
      var e = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() &amp;&amp; c.preventDefault()
    }
  }, n.removeEvent = z.removeEventListener ? function(a, b, c) {
    a.removeEventListener &amp;&amp; a.removeEventListener(b, c, !1)
  } : function(a, b, c) {
    var d = "on" + b;
    a.detachEvent &amp;&amp; (typeof a[d] === L &amp;&amp; (a[d] = null), a.detachEvent(d, c))
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a &amp;&amp; a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented &amp;&amp; (a.returnValue === !1 || a.getPreventDefault &amp;&amp; a.getPreventDefault()) ? bb : cb) : this.type = a, b &amp;&amp; n.extend(this, b), this.timeStamp = a &amp;&amp; a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    isDefaultPrevented: cb,
    isPropagationStopped: cb,
    isImmediatePropagationStopped: cb,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = bb, a &amp;&amp; (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = bb, a &amp;&amp; (a.stopPropagation &amp;&amp; a.stopPropagation(), a.cancelBubble = !0)
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = bb, this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return (!e || e !== d &amp;&amp; !n.contains(d, e)) &amp;&amp; (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), l.submitBubbles || (n.event.special.submit = {
    setup: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.add(this, "click._submit keypress._submit", function(a) {
        var b = a.target,
          c = n.nodeName(b, "input") || n.nodeName(b, "button") ? b.form : void 0;
        c &amp;&amp; !n._data(c, "submitBubbles") &amp;&amp; (n.event.add(c, "submit._submit", function(a) {
          a._submit_bubble = !0
        }), n._data(c, "submitBubbles", !0))
      })
    },
    postDispatch: function(a) {
      a._submit_bubble &amp;&amp; (delete a._submit_bubble, this.parentNode &amp;&amp; !a.isTrigger &amp;&amp; n.event.simulate("submit", this.parentNode, a, !0))
    },
    teardown: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.remove(this, "._submit")
    }
  }), l.changeBubbles || (n.event.special.change = {
    setup: function() {
      return Y.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) &amp;&amp; (n.event.add(this, "propertychange._change", function(a) {
        "checked" === a.originalEvent.propertyName &amp;&amp; (this._just_changed = !0)
      }), n.event.add(this, "click._change", function(a) {
        this._just_changed &amp;&amp; !a.isTrigger &amp;&amp; (this._just_changed = !1), n.event.simulate("change", this, a, !0)
      })), !1) : void n.event.add(this, "beforeactivate._change", function(a) {
        var b = a.target;
        Y.test(b.nodeName) &amp;&amp; !n._data(b, "changeBubbles") &amp;&amp; (n.event.add(b, "change._change", function(a) {
          !this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate("change", this.parentNode, a, !0)
        }), n._data(b, "changeBubbles", !0))
      })
    },
    handle: function(a) {
      var b = a.target;
      return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type &amp;&amp; "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0
    },
    teardown: function() {
      return n.event.remove(this, "._change"), !Y.test(this.nodeName)
    }
  }), l.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0)
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b);
        e || d.addEventListener(a, c, !0), n._data(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b) - 1;
        e ? n._data(d, b, e) : (d.removeEventListener(a, c, !0), n._removeData(d, b))
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d, e) {
      var f, g;
      if ("object" == typeof a) {
        "string" != typeof b &amp;&amp; (c = c || b, b = void 0);
        for (f in a) this.on(f, b, c, a[f], e);
        return this
      }
      if (null == c &amp;&amp; null == d ? (d = b, c = b = void 0) : null == d &amp;&amp; ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = cb;
      else if (!d) return this;
      return 1 === e &amp;&amp; (g = d, d = function(a) {
        return n().off(a), g.apply(this, arguments)
      }, d.guid = g.guid || (g.guid = n.guid++)), this.each(function() {
        n.event.add(this, a, d, c, b)
      })
    },
    one: function(a, b, c, d) {
      return this.on(a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a &amp;&amp; a.preventDefault &amp;&amp; a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return (b === !1 || "function" == typeof b) &amp;&amp; (c = b, b = void 0), c === !1 &amp;&amp; (c = cb), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    },
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  });

  function eb(a) {
    var b = fb.split("|"),
      c = a.createDocumentFragment();
    if (c.createElement)
      while (b.length) c.createElement(b.pop());
    return c
  }
  var fb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    gb = / jQuery\d+="(?:null|\d+)"/g,
    hb = new RegExp("&lt;(?:" + fb + ")[\\s/&gt;]", "i"),
    ib = /^\s+/,
    jb = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
    kb = /&lt;([\w:]+)/,
    lb = /&lt;tbody/i,
    mb = /&lt;|&amp;#?\w+;/,
    nb = /&lt;(?:script|style|link)/i,
    ob = /checked\s*(?:[^=]|=\s*.checked.)/i,
    pb = /^$|\/(?:java|ecma)script/i,
    qb = /^true\/(.*)/,
    rb = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,
    sb = {
      option: [1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;"],
      legend: [1, "&lt;fieldset&gt;", "&lt;/fieldset&gt;"],
      area: [1, "&lt;map&gt;", "&lt;/map&gt;"],
      param: [1, "&lt;object&gt;", "&lt;/object&gt;"],
      thead: [1, "&lt;table&gt;", "&lt;/table&gt;"],
      tr: [2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;"],
      col: [2, "&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;"],
      td: [3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"],
      _default: l.htmlSerialize ? [0, "", ""] : [1, "X&lt;div&gt;", "&lt;/div&gt;"]
    },
    tb = eb(z),
    ub = tb.appendChild(z.createElement("div"));
  sb.optgroup = sb.option, sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb.thead, sb.th = sb.td;

  function vb(a, b) {
    var c, d, e = 0,
      f = typeof a.getElementsByTagName !== L ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== L ? a.querySelectorAll(b || "*") : void 0;
    if (!f)
      for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || n.nodeName(d, b) ? f.push(d) : n.merge(f, vb(d, b));
    return void 0 === b || b &amp;&amp; n.nodeName(a, b) ? n.merge([a], f) : f
  }

  function wb(a) {
    X.test(a.type) &amp;&amp; (a.defaultChecked = a.checked)
  }

  function xb(a, b) {
    return n.nodeName(a, "table") &amp;&amp; n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function yb(a) {
    return a.type = (null !== n.find.attr(a, "type")) + "/" + a.type, a
  }

  function zb(a) {
    var b = qb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function Ab(a, b) {
    for (var c, d = 0; null != (c = a[d]); d++) n._data(c, "globalEval", !b || n._data(b[d], "globalEval"))
  }

  function Bb(a, b) {
    if (1 === b.nodeType &amp;&amp; n.hasData(a)) {
      var c, d, e, f = n._data(a),
        g = n._data(b, f),
        h = f.events;
      if (h) {
        delete g.handle, g.events = {};
        for (c in h)
          for (d = 0, e = h[c].length; e &gt; d; d++) n.event.add(b, c, h[c][d])
      }
      g.data &amp;&amp; (g.data = n.extend({}, g.data))
    }
  }

  function Cb(a, b) {
    var c, d, e;
    if (1 === b.nodeType) {
      if (c = b.nodeName.toLowerCase(), !l.noCloneEvent &amp;&amp; b[n.expando]) {
        e = n._data(b);
        for (d in e.events) n.removeEvent(b, d, e.handle);
        b.removeAttribute(n.expando)
      }
      "script" === c &amp;&amp; b.text !== a.text ? (yb(b).text = a.text, zb(b)) : "object" === c ? (b.parentNode &amp;&amp; (b.outerHTML = a.outerHTML), l.html5Clone &amp;&amp; a.innerHTML &amp;&amp; !n.trim(b.innerHTML) &amp;&amp; (b.innerHTML = a.innerHTML)) : "input" === c &amp;&amp; X.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value &amp;&amp; (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) &amp;&amp; (b.defaultValue = a.defaultValue)
    }
  }
  n.extend({
    clone: function(a, b, c) {
      var d, e, f, g, h, i = n.contains(a.ownerDocument, a);
      if (l.html5Clone || n.isXMLDoc(a) || !hb.test("&lt;" + a.nodeName + "&gt;") ? f = a.cloneNode(!0) : (ub.innerHTML = a.outerHTML, ub.removeChild(f = ub.firstChild)), !(l.noCloneEvent &amp;&amp; l.noCloneChecked || 1 !== a.nodeType &amp;&amp; 11 !== a.nodeType || n.isXMLDoc(a)))
        for (d = vb(f), h = vb(a), g = 0; null != (e = h[g]); ++g) d[g] &amp;&amp; Cb(e, d[g]);
      if (b)
        if (c)
          for (h = h || vb(a), d = d || vb(f), g = 0; null != (e = h[g]); g++) Bb(e, d[g]);
        else Bb(a, f);
      return d = vb(f, "script"), d.length &gt; 0 &amp;&amp; Ab(d, !i &amp;&amp; vb(a, "script")), d = h = e = null, f
    },
    buildFragment: function(a, b, c, d) {
      for (var e, f, g, h, i, j, k, m = a.length, o = eb(b), p = [], q = 0; m &gt; q; q++)
        if (f = a[q], f || 0 === f)
          if ("object" === n.type(f)) n.merge(p, f.nodeType ? [f] : f);
          else if (mb.test(f)) {
        h = h || o.appendChild(b.createElement("div")), i = (kb.exec(f) || ["", ""])[1].toLowerCase(), k = sb[i] || sb._default, h.innerHTML = k[1] + f.replace(jb, "&lt;$1&gt;&lt;/$2&gt;") + k[2], e = k[0];
        while (e--) h = h.lastChild;
        if (!l.leadingWhitespace &amp;&amp; ib.test(f) &amp;&amp; p.push(b.createTextNode(ib.exec(f)[0])), !l.tbody) {
          f = "table" !== i || lb.test(f) ? "&lt;table&gt;" !== k[1] || lb.test(f) ? 0 : h : h.firstChild, e = f &amp;&amp; f.childNodes.length;
          while (e--) n.nodeName(j = f.childNodes[e], "tbody") &amp;&amp; !j.childNodes.length &amp;&amp; f.removeChild(j)
        }
        n.merge(p, h.childNodes), h.textContent = "";
        while (h.firstChild) h.removeChild(h.firstChild);
        h = o.lastChild
      } else p.push(b.createTextNode(f));
      h &amp;&amp; o.removeChild(h), l.appendChecked || n.grep(vb(p, "input"), wb), q = 0;
      while (f = p[q++])
        if ((!d || -1 === n.inArray(f, d)) &amp;&amp; (g = n.contains(f.ownerDocument, f), h = vb(o.appendChild(f), "script"), g &amp;&amp; Ab(h), c)) {
          e = 0;
          while (f = h[e++]) pb.test(f.type || "") &amp;&amp; c.push(f)
        }
      return h = null, o
    },
    cleanData: function(a, b) {
      for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null != (d = a[h]); h++)
        if ((b || n.acceptData(d)) &amp;&amp; (f = d[i], g = f &amp;&amp; j[f])) {
          if (g.events)
            for (e in g.events) m[e] ? n.event.remove(d, e) : n.removeEvent(d, e, g.handle);
          j[f] &amp;&amp; (delete j[f], k ? delete d[i] : typeof d.removeAttribute !== L ? d.removeAttribute(i) : d[i] = null, c.push(f))
        }
    }
  }), n.fn.extend({
    text: function(a) {
      return W(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().append((this[0] &amp;&amp; this[0].ownerDocument || z).createTextNode(a))
      }, null, a, arguments.length)
    },
    append: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    remove: function(a, b) {
      for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || n.cleanData(vb(c)), c.parentNode &amp;&amp; (b &amp;&amp; n.contains(c.ownerDocument, c) &amp;&amp; Ab(vb(c, "script")), c.parentNode.removeChild(c));
      return this
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) {
        1 === a.nodeType &amp;&amp; n.cleanData(vb(a, !1));
        while (a.firstChild) a.removeChild(a.firstChild);
        a.options &amp;&amp; n.nodeName(a, "select") &amp;&amp; (a.options.length = 0)
      }
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return W(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(gb, "") : void 0;
        if (!("string" != typeof a || nb.test(a) || !l.htmlSerialize &amp;&amp; hb.test(a) || !l.leadingWhitespace &amp;&amp; ib.test(a) || sb[(kb.exec(a) || ["", ""])[1].toLowerCase()])) {
          a = a.replace(jb, "&lt;$1&gt;&lt;/$2&gt;");
          try {
            for (; d &gt; c; c++) b = this[c] || {}, 1 === b.nodeType &amp;&amp; (n.cleanData(vb(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b &amp;&amp; this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = arguments[0];
      return this.domManip(arguments, function(b) {
        a = this.parentNode, n.cleanData(vb(this)), a &amp;&amp; a.replaceChild(b, this)
      }), a &amp;&amp; (a.length || a.nodeType) ? this : this.remove()
    },
    detach: function(a) {
      return this.remove(a, !0)
    },
    domManip: function(a, b) {
      a = e.apply([], a);
      var c, d, f, g, h, i, j = 0,
        k = this.length,
        m = this,
        o = k - 1,
        p = a[0],
        q = n.isFunction(p);
      if (q || k &gt; 1 &amp;&amp; "string" == typeof p &amp;&amp; !l.checkClone &amp;&amp; ob.test(p)) return this.each(function(c) {
        var d = m.eq(c);
        q &amp;&amp; (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
      });
      if (k &amp;&amp; (i = n.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length &amp;&amp; (i = c), c)) {
        for (g = n.map(vb(i, "script"), yb), f = g.length; k &gt; j; j++) d = i, j !== o &amp;&amp; (d = n.clone(d, !0, !0), f &amp;&amp; n.merge(g, vb(d, "script"))), b.call(this[j], d, j);
        if (f)
          for (h = g[g.length - 1].ownerDocument, n.map(g, zb), j = 0; f &gt; j; j++) d = g[j], pb.test(d.type || "") &amp;&amp; !n._data(d, "globalEval") &amp;&amp; n.contains(h, d) &amp;&amp; (d.src ? n._evalUrl &amp;&amp; n._evalUrl(d.src) : n.globalEval((d.text || d.textContent || d.innerHTML || "").replace(rb, "")));
        i = c = null
      }
      return this
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = 0, e = [], g = n(a), h = g.length - 1; h &gt;= d; d++) c = d === h ? this : this.clone(!0), n(g[d])[b](c), f.apply(e, c.get());
      return this.pushStack(e)
    }
  });
  var Db, Eb = {};

  function Fb(b, c) {
    var d = n(c.createElement(b)).appendTo(c.body),
      e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : n.css(d[0], "display");
    return d.detach(), e
  }

  function Gb(a) {
    var b = z,
      c = Eb[a];
    return c || (c = Fb(a, b), "none" !== c &amp;&amp; c || (Db = (Db || n("&lt;iframe frameborder='0' width='0' height='0'/&gt;")).appendTo(b.documentElement), b = (Db[0].contentWindow || Db[0].contentDocument).document, b.write(), b.close(), c = Fb(a, b), Db.detach()), Eb[a] = c), c
  }! function() {
    var a, b, c = z.createElement("div"),
      d = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    c.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = c.getElementsByTagName("a")[0], a.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(a.style.opacity), l.cssFloat = !!a.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, l.shrinkWrapBlocks = function() {
      var a, c, e, f;
      if (null == b) {
        if (a = z.getElementsByTagName("body")[0], !a) return;
        f = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", c = z.createElement("div"), e = z.createElement("div"), a.appendChild(c).appendChild(e), b = !1, typeof e.style.zoom !== L &amp;&amp; (e.style.cssText = d + ";width:1px;padding:1px;zoom:1", e.innerHTML = "&lt;div&gt;&lt;/div&gt;", e.firstChild.style.width = "5px", b = 3 !== e.offsetWidth), a.removeChild(c), a = c = e = null
      }
      return b
    }
  }();
  var Hb = /^margin/,
    Ib = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"),
    Jb, Kb, Lb = /^(top|right|bottom|left)$/;
  a.getComputedStyle ? (Jb = function(a) {
    return a.ownerDocument.defaultView.getComputedStyle(a, null)
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c &amp;&amp; ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), Ib.test(g) &amp;&amp; Hb.test(b) &amp;&amp; (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + ""
  }) : z.documentElement.currentStyle &amp;&amp; (Jb = function(a) {
    return a.currentStyle
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c[b] : void 0, null == g &amp;&amp; h &amp;&amp; h[b] &amp;&amp; (g = h[b]), Ib.test(g) &amp;&amp; !Lb.test(b) &amp;&amp; (d = h.left, e = a.runtimeStyle, f = e &amp;&amp; e.left, f &amp;&amp; (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f &amp;&amp; (e.left = f)), void 0 === g ? g : g + "" || "auto"
  });

  function Mb(a, b) {
    return {
      get: function() {
        var c = a();
        if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }! function() {
    var b, c, d, e, f, g, h = z.createElement("div"),
      i = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
      j = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    h.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", b = h.getElementsByTagName("a")[0], b.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(b.style.opacity), l.cssFloat = !!b.style.cssFloat, h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, b = h = null, n.extend(l, {
      reliableHiddenOffsets: function() {
        if (null != c) return c;
        var a, b, d, e = z.createElement("div"),
          f = z.getElementsByTagName("body")[0];
        if (f) return e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = z.createElement("div"), a.style.cssText = i, f.appendChild(a).appendChild(e), e.innerHTML = "&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;", b = e.getElementsByTagName("td"), b[0].style.cssText = "padding:0;margin:0;border:0;display:none", d = 0 === b[0].offsetHeight, b[0].style.display = "", b[1].style.display = "none", c = d &amp;&amp; 0 === b[0].offsetHeight, f.removeChild(a), e = f = null, c
      },
      boxSizing: function() {
        return null == d &amp;&amp; k(), d
      },
      boxSizingReliable: function() {
        return null == e &amp;&amp; k(), e
      },
      pixelPosition: function() {
        return null == f &amp;&amp; k(), f
      },
      reliableMarginRight: function() {
        var b, c, d, e;
        if (null == g &amp;&amp; a.getComputedStyle) {
          if (b = z.getElementsByTagName("body")[0], !b) return;
          c = z.createElement("div"), d = z.createElement("div"), c.style.cssText = i, b.appendChild(c).appendChild(d), e = d.appendChild(z.createElement("div")), e.style.cssText = d.style.cssText = j, e.style.marginRight = e.style.width = "0", d.style.width = "1px", g = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight), b.removeChild(c)
        }
        return g
      }
    });

    function k() {
      var b, c, h = z.getElementsByTagName("body")[0];
      h &amp;&amp; (b = z.createElement("div"), c = z.createElement("div"), b.style.cssText = i, h.appendChild(b).appendChild(c), c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", n.swap(h, null != h.style.zoom ? {
        zoom: 1
      } : {}, function() {
        d = 4 === c.offsetWidth
      }), e = !0, f = !1, g = !0, a.getComputedStyle &amp;&amp; (f = "1%" !== (a.getComputedStyle(c, null) || {}).top, e = "4px" === (a.getComputedStyle(c, null) || {
        width: "4px"
      }).width), h.removeChild(b), c = h = null)
    }
  }(), n.swap = function(a, b, c, d) {
    var e, f, g = {};
    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
    e = c.apply(a, d || []);
    for (f in b) a.style[f] = g[f];
    return e
  };
  var Nb = /alpha\([^)]*\)/i,
    Ob = /opacity\s*=\s*([^)]*)/,
    Pb = /^(none|table(?!-c[ea]).+)/,
    Qb = new RegExp("^(" + T + ")(.*)$", "i"),
    Rb = new RegExp("^([+-])=(" + T + ")", "i"),
    Sb = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Tb = {
      letterSpacing: 0,
      fontWeight: 400
    },
    Ub = ["Webkit", "O", "Moz", "ms"];

  function Vb(a, b) {
    if (b in a) return b;
    var c = b.charAt(0).toUpperCase() + b.slice(1),
      d = b,
      e = Ub.length;
    while (e--)
      if (b = Ub[e] + c, b in a) return b;
    return d
  }

  function Wb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h &gt; g; g++) d = a[g], d.style &amp;&amp; (f[g] = n._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display &amp;&amp; V(d) &amp;&amp; (f[g] = n._data(d, "olddisplay", Gb(d.nodeName)))) : f[g] || (e = V(d), (c &amp;&amp; "none" !== c || !e) &amp;&amp; n._data(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h &gt; g; g++) d = a[g], d.style &amp;&amp; (b &amp;&amp; "none" !== d.style.display &amp;&amp; "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }

  function Xb(a, b, c) {
    var d = Qb.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
  }

  function Yb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 &gt; f; f += 2) "margin" === c &amp;&amp; (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c &amp;&amp; (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c &amp;&amp; (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c &amp;&amp; (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g
  }

  function Zb(a, b, c) {
    var d = !0,
      e = "width" === b ? a.offsetWidth : a.offsetHeight,
      f = Jb(a),
      g = l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 &gt;= e || null == e) {
      if (e = Kb(a, b, f), (0 &gt; e || null == e) &amp;&amp; (e = a.style[b]), Ib.test(e)) return e;
      d = g &amp;&amp; (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
    }
    return e + Yb(a, b, c || (g ? "border" : "content"), d, f) + "px"
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = Kb(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": l.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function(a, b, c, d) {
      if (a &amp;&amp; 3 !== a.nodeType &amp;&amp; 8 !== a.nodeType &amp;&amp; a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        if (b = n.cssProps[h] || (n.cssProps[h] = Vb(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c) return g &amp;&amp; "get" in g &amp;&amp; void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
        if (f = typeof c, "string" === f &amp;&amp; (e = Rb.exec(c)) &amp;&amp; (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c &amp;&amp; c === c &amp;&amp; ("number" !== f || n.cssNumber[h] || (c += "px"), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g &amp;&amp; "set" in g &amp;&amp; void 0 === (c = g.set(a, c, d))))) try {
          i[b] = "", i[b] = c
        } catch (j) {}
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Vb(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g &amp;&amp; "get" in g &amp;&amp; (f = g.get(a, !0, c)), void 0 === f &amp;&amp; (f = Kb(a, b, d)), "normal" === f &amp;&amp; b in Tb &amp;&amp; (f = Tb[b]), "" === c || c ? (e = parseFloat(f), c === !0 || n.isNumeric(e) ? e || 0 : f) : f
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? 0 === a.offsetWidth &amp;&amp; Pb.test(n.css(a, "display")) ? n.swap(a, Sb, function() {
          return Zb(a, b, d)
        }) : Zb(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e = d &amp;&amp; Jb(a);
        return Xb(a, c, d ? Yb(a, b, d, l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
      }
    }
  }), l.opacity || (n.cssHooks.opacity = {
    get: function(a, b) {
      return Ob.test((b &amp;&amp; a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""
    },
    set: function(a, b) {
      var c = a.style,
        d = a.currentStyle,
        e = n.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "",
        f = d &amp;&amp; d.filter || c.filter || "";
      c.zoom = 1, (b &gt;= 1 || "" === b) &amp;&amp; "" === n.trim(f.replace(Nb, "")) &amp;&amp; c.removeAttribute &amp;&amp; (c.removeAttribute("filter"), "" === b || d &amp;&amp; !d.filter) || (c.filter = Nb.test(f) ? f.replace(Nb, e) : f + " " + e)
    }
  }), n.cssHooks.marginRight = Mb(l.reliableMarginRight, function(a, b) {
    return b ? n.swap(a, {
      display: "inline-block"
    }, Kb, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 &gt; d; d++) e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, Hb.test(a) || (n.cssHooks[a + b].set = Xb)
  }), n.fn.extend({
    css: function(a, b) {
      return W(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = Jb(a), e = b.length; e &gt; g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length &gt; 1)
    },
    show: function() {
      return Wb(this, !0)
    },
    hide: function() {
      return Wb(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function $b(a, b, c, d, e) {
    return new $b.prototype.init(a, b, c, d, e)
  }
  n.Tween = $b, $b.prototype = {
    constructor: $b,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = $b.propHooks[this.prop];
      return a &amp;&amp; a.get ? a.get(this) : $b.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = $b.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step &amp;&amp; this.options.step.call(this.elem, this.now, this), c &amp;&amp; c.set ? c.set(this) : $b.propHooks._default.set(this), this
    }
  }, $b.prototype.init.prototype = $b.prototype, $b.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style &amp;&amp; null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b &amp;&amp; "auto" !== b ? b : 0) : a.elem[a.prop]
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style &amp;&amp; (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
      }
    }
  }, $b.propHooks.scrollTop = $b.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType &amp;&amp; a.elem.parentNode &amp;&amp; (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    }
  }, n.fx = $b.prototype.init, n.fx.step = {};
  var _b, ac, bc = /^(?:toggle|show|hide)$/,
    cc = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"),
    dc = /queueHooks$/,
    ec = [jc],
    fc = {
      "*": [function(a, b) {
        var c = this.createTween(a, b),
          d = c.cur(),
          e = cc.exec(b),
          f = e &amp;&amp; e[3] || (n.cssNumber[a] ? "" : "px"),
          g = (n.cssNumber[a] || "px" !== f &amp;&amp; +d) &amp;&amp; cc.exec(n.css(c.elem, a)),
          h = 1,
          i = 20;
        if (g &amp;&amp; g[3] !== f) {
          f = f || g[3], e = e || [], g = +d || 1;
          do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) &amp;&amp; 1 !== h &amp;&amp; --i)
        }
        return e &amp;&amp; (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
      }]
    };

  function gc() {
    return setTimeout(function() {
      _b = void 0
    }), _b = n.now()
  }

  function hc(a, b) {
    var c, d = {
        height: a
      },
      e = 0;
    for (b = b ? 1 : 0; 4 &gt; e; e += 2 - b) c = U[e], d["margin" + c] = d["padding" + c] = a;
    return b &amp;&amp; (d.opacity = d.width = a), d
  }

  function ic(a, b, c) {
    for (var d, e = (fc[b] || []).concat(fc["*"]), f = 0, g = e.length; g &gt; f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function jc(a, b, c) {
    var d, e, f, g, h, i, j, k, m = this,
      o = {},
      p = a.style,
      q = a.nodeType &amp;&amp; V(a),
      r = n._data(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued &amp;&amp; (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, m.always(function() {
      m.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType &amp;&amp; ("height" in b || "width" in b) &amp;&amp; (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css(a, "display"), k = Gb(a.nodeName), "none" === j &amp;&amp; (j = k), "inline" === j &amp;&amp; "none" === n.css(a, "float") &amp;&amp; (l.inlineBlockNeedsLayout &amp;&amp; "inline" !== k ? p.zoom = 1 : p.display = "inline-block")), c.overflow &amp;&amp; (p.overflow = "hidden", l.shrinkWrapBlocks() || m.always(function() {
      p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], bc.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
          if ("show" !== e || !r || void 0 === r[d]) continue;
          q = !0
        }
        o[d] = r &amp;&amp; r[d] || n.style(a, d)
      }
    if (!n.isEmptyObject(o)) {
      r ? "hidden" in r &amp;&amp; (q = r.hidden) : r = n._data(a, "fxshow", {}), f &amp;&amp; (r.hidden = !q), q ? n(a).show() : m.done(function() {
        n(a).hide()
      }), m.done(function() {
        var b;
        n._removeData(a, "fxshow");
        for (b in o) n.style(a, b, o[b])
      });
      for (d in o) g = ic(q ? r[d] : 0, d, m), d in r || (r[d] = g.start, q &amp;&amp; (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function kc(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) &amp;&amp; (e = f[1], f = a[c] = f[0]), c !== d &amp;&amp; (a[d] = f, delete a[c]), g = n.cssHooks[d], g &amp;&amp; "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function lc(a, b, c) {
    var d, e, f = 0,
      g = ec.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = _b || gc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i &gt; g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 &gt; f &amp;&amp; i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {}
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: _b || gc(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d &gt; c; c++) j.tweens[c].run(1);
          return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for (kc(k, j.opts.specialEasing); g &gt; f; f++)
      if (d = ec[f].call(j, a, k, j.opts)) return d;
    return n.map(k, ic, j), n.isFunction(j.opts.start) &amp;&amp; j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(lc, {
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
        for (var c, d = 0, e = a.length; e &gt; d; d++) c = a[d], fc[c] = fc[c] || [], fc[c].unshift(b)
      },
      prefilter: function(a, b) {
        b ? ec.unshift(a) : ec.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a &amp;&amp; "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c &amp;&amp; b || n.isFunction(a) &amp;&amp; a,
        duration: a,
        easing: c &amp;&amp; b || b &amp;&amp; !n.isFunction(b) &amp;&amp; b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) &amp;&amp; (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) &amp;&amp; d.old.call(this), d.queue &amp;&amp; n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(V).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = lc(this, n.extend({}, a), f);
            (e || n._data(this, "finish")) &amp;&amp; b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a &amp;&amp; (c = b, b = a, a = void 0), b &amp;&amp; a !== !1 &amp;&amp; this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a &amp;&amp; a + "queueHooks",
            f = n.timers,
            g = n._data(this);
          if (e) g[e] &amp;&amp; g[e].stop &amp;&amp; d(g[e]);
          else
            for (e in g) g[e] &amp;&amp; g[e].stop &amp;&amp; dc.test(e) &amp;&amp; d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a &amp;&amp; f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          (b || !c) &amp;&amp; n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 &amp;&amp; (a = a || "fx"), this.each(function() {
          var b, c = n._data(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e &amp;&amp; e.stop &amp;&amp; e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this &amp;&amp; f[b].queue === a &amp;&amp; (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g &gt; b; b++) d[b] &amp;&amp; d[b].finish &amp;&amp; d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(hc(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: hc("show"),
      slideUp: hc("hide"),
      slideToggle: hc("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = n.timers,
        c = 0;
      for (_b = n.now(); c &lt; b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
      b.length || n.fx.stop(), _b = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      ac || (ac = setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      clearInterval(ac), ac = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(a, b) {
      return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
        var d = setTimeout(b, a);
        c.stop = function() {
          clearTimeout(d)
        }
      })
    },
    function() {
      var a, b, c, d, e = z.createElement("div");
      e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = e.getElementsByTagName("a")[0], c = z.createElement("select"), d = c.appendChild(z.createElement("option")), b = e.getElementsByTagName("input")[0], a.style.cssText = "top:1px", l.getSetAttribute = "t" !== e.className, l.style = /top/.test(a.getAttribute("style")), l.hrefNormalized = "/a" === a.getAttribute("href"), l.checkOn = !!b.value, l.optSelected = d.selected, l.enctype = !!z.createElement("form").enctype, c.disabled = !0, l.optDisabled = !d.disabled, b = z.createElement("input"), b.setAttribute("value", ""), l.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), l.radioValue = "t" === b.value, a = b = c = d = e = null
    }();
  var mc = /\r/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType &amp;&amp; (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) &amp;&amp; (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b &amp;&amp; "set" in b &amp;&amp; void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b &amp;&amp; "get" in b &amp;&amp; void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(mc, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.text(a)
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 &gt; e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 &gt; e ? h : f ? e : 0; h &gt; i; i++)
            if (c = d[i], !(!c.selected &amp;&amp; i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled &amp;&amp; n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            }
          return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--)
            if (d = e[g], n.inArray(n.valHooks.option.get(d), f) &gt;= 0) try {
              d.selected = c = !0
            } catch (h) {
              d.scrollHeight
            } else d.selected = !1;
          return c || (a.selectedIndex = -1), e
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) &gt;= 0 : void 0
      }
    }, l.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  });
  var nc, oc, pc = n.expr.attrHandle,
    qc = /^(?:checked|selected)$/i,
    rc = l.getSetAttribute,
    sc = l.input;
  n.fn.extend({
    attr: function(a, b) {
      return W(this, n.attr, a, b, arguments.length &gt; 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (a &amp;&amp; 3 !== f &amp;&amp; 8 !== f &amp;&amp; 2 !== f) return typeof a.getAttribute === L ? n.prop(a, b, c) : (1 === f &amp;&amp; n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? oc : nc)), void 0 === c ? d &amp;&amp; "get" in d &amp;&amp; null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d &amp;&amp; "set" in d &amp;&amp; void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b))
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b &amp;&amp; b.match(F);
      if (f &amp;&amp; 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) ? sc &amp;&amp; rc || !qc.test(c) ? a[d] = !1 : a[n.camelCase("default-" + c)] = a[d] = !1 : n.attr(a, c, ""), a.removeAttribute(rc ? c : d)
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!l.radioValue &amp;&amp; "radio" === b &amp;&amp; n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c &amp;&amp; (a.value = c), b
          }
        }
      }
    }
  }), oc = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : sc &amp;&amp; rc || !qc.test(c) ? a.setAttribute(!rc &amp;&amp; n.propFix[c] || c, c) : a[n.camelCase("default-" + c)] = a[c] = !0, c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = pc[b] || n.find.attr;
    pc[b] = sc &amp;&amp; rc || !qc.test(b) ? function(a, b, d) {
      var e, f;
      return d || (f = pc[b], pc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, pc[b] = f), e
    } : function(a, b, c) {
      return c ? void 0 : a[n.camelCase("default-" + b)] ? b.toLowerCase() : null
    }
  }), sc &amp;&amp; rc || (n.attrHooks.value = {
    set: function(a, b, c) {
      return n.nodeName(a, "input") ? void(a.defaultValue = b) : nc &amp;&amp; nc.set(a, b, c)
    }
  }), rc || (nc = {
    set: function(a, b, c) {
      var d = a.getAttributeNode(c);
      return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0
    }
  }, pc.id = pc.name = pc.coords = function(a, b, c) {
    var d;
    return c ? void 0 : (d = a.getAttributeNode(b)) &amp;&amp; "" !== d.value ? d.value : null
  }, n.valHooks.button = {
    get: function(a, b) {
      var c = a.getAttributeNode(b);
      return c &amp;&amp; c.specified ? c.value : void 0
    },
    set: nc.set
  }, n.attrHooks.contenteditable = {
    set: function(a, b, c) {
      nc.set(a, "" === b ? !1 : b, c)
    }
  }, n.each(["width", "height"], function(a, b) {
    n.attrHooks[b] = {
      set: function(a, c) {
        return "" === c ? (a.setAttribute(b, "auto"), c) : void 0
      }
    }
  })), l.style || (n.attrHooks.style = {
    get: function(a) {
      return a.style.cssText || void 0
    },
    set: function(a, b) {
      return a.style.cssText = b + ""
    }
  });
  var tc = /^(?:input|select|textarea|button|object)$/i,
    uc = /^(?:a|area)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return W(this, n.prop, a, b, arguments.length &gt; 1)
    },
    removeProp: function(a) {
      return a = n.propFix[a] || a, this.each(function() {
        try {
          this[a] = void 0, delete this[a]
        } catch (b) {}
      })
    }
  }), n.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(a, b, c) {
      var d, e, f, g = a.nodeType;
      if (a &amp;&amp; 3 !== g &amp;&amp; 8 !== g &amp;&amp; 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f &amp;&amp; (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e &amp;&amp; "set" in e &amp;&amp; void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e &amp;&amp; "get" in e &amp;&amp; null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          var b = n.find.attr(a, "tabindex");
          return b ? parseInt(b, 10) : tc.test(a.nodeName) || uc.test(a.nodeName) &amp;&amp; a.href ? 0 : -1
        }
      }
    }
  }), l.hrefNormalized || n.each(["href", "src"], function(a, b) {
    n.propHooks[b] = {
      get: function(a) {
        return a.getAttribute(b, 4)
      }
    }
  }), l.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; (b.selectedIndex, b.parentNode &amp;&amp; b.parentNode.selectedIndex), null
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  }), l.enctype || (n.propFix.enctype = "encoding");
  var vc = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : " ")) {
            f = 0;
            while (e = b[f++]) d.indexOf(" " + e + " ") &lt; 0 &amp;&amp; (d += e + " ");
            g = n.trim(d), c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = 0 === arguments.length || "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : "")) {
            f = 0;
            while (e = b[f++])
              while (d.indexOf(" " + e + " ") &gt;= 0) d = d.replace(" " + e + " ", " ");
            g = a ? n.trim(d) : "", c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b &amp;&amp; "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function(c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b)
      } : function() {
        if ("string" === c) {
          var b, d = 0,
            e = n(this),
            f = a.match(F) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else(c === L || "boolean" === c) &amp;&amp; (this.className &amp;&amp; n._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : n._data(this, "__className__") || "")
      })
    },
    hasClass: function(a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d &gt; c; c++)
        if (1 === this[c].nodeType &amp;&amp; (" " + this[c].className + " ").replace(vc, " ").indexOf(b) &gt;= 0) return !0;
      return !1
    }
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length &gt; 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    },
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    }
  });
  var wc = n.now(),
    xc = /\?/,
    yc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  n.parseJSON = function(b) {
    if (a.JSON &amp;&amp; a.JSON.parse) return a.JSON.parse(b + "");
    var c, d = null,
      e = n.trim(b + "");
    return e &amp;&amp; !n.trim(e.replace(yc, function(a, b, e, f) {
      return c &amp;&amp; b &amp;&amp; (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "")
    })) ? Function("return " + e)() : n.error("Invalid JSON: " + b)
  }, n.parseXML = function(b) {
    var c, d;
    if (!b || "string" != typeof b) return null;
    try {
      a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b))
    } catch (e) {
      c = void 0
    }
    return c &amp;&amp; c.documentElement &amp;&amp; !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c
  };
  var zc, Ac, Bc = /#.*$/,
    Cc = /([?&amp;])_=[^&amp;]*/,
    Dc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    Ec = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    Fc = /^(?:GET|HEAD)$/,
    Gc = /^\/\//,
    Hc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    Ic = {},
    Jc = {},
    Kc = "*/".concat("*");
  try {
    Ac = location.href
  } catch (Lc) {
    Ac = z.createElement("a"), Ac.href = "", Ac = Ac.href
  }
  zc = Hc.exec(Ac.toLowerCase()) || [];

  function Mc(a) {
    return function(b, c) {
      "string" != typeof b &amp;&amp; (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(F) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function Nc(a, b, c, d) {
    var e = {},
      f = a === Jc;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] &amp;&amp; g("*")
  }

  function Oc(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (d in b) void 0 !== b[d] &amp;&amp; ((e[d] ? a : c || (c = {}))[d] = b[d]);
    return c &amp;&amp; n.extend(!0, a, c), a
  }

  function Pc(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === e &amp;&amp; (e = a.mimeType || b.getResponseHeader("Content-Type"));
    if (e)
      for (g in h)
        if (h[g] &amp;&amp; h[g].test(e)) {
          i.unshift(g);
          break
        }
    if (i[0] in c) f = i[0];
    else {
      for (g in c) {
        if (!i[0] || a.converters[g + " " + i[0]]) {
          f = g;
          break
        }
        d || (d = g)
      }
      f = f || d
    }
    return f ? (f !== i[0] &amp;&amp; i.unshift(f), c[f]) : void 0
  }

  function Qc(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] &amp;&amp; (c[a.responseFields[f]] = b), !i &amp;&amp; d &amp;&amp; a.dataFilter &amp;&amp; (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i &amp;&amp; i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f &amp;&amp; (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 &amp;&amp; (f = h[0], k.unshift(h[1]));
            break
          }
      if (g !== !0)
        if (g &amp;&amp; a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ac,
      type: "GET",
      isLocal: Ec.test(zc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": Kc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? Oc(Oc(a, n.ajaxSettings), b) : Oc(n.ajaxSettings, a)
    },
    ajaxPrefilter: Mc(Ic),
    ajaxTransport: Mc(Jc),
    ajax: function(a, b) {
      "object" == typeof a &amp;&amp; (b = a, a = void 0), b = b || {};
      var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b),
        l = k.context || k,
        m = k.context &amp;&amp; (l.nodeType || l.jquery) ? n(l) : n.event,
        o = n.Deferred(),
        p = n.Callbacks("once memory"),
        q = k.statusCode || {},
        r = {},
        s = {},
        t = 0,
        u = "canceled",
        v = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === t) {
              if (!j) {
                j = {};
                while (b = Dc.exec(f)) j[b[1].toLowerCase()] = b[2]
              }
              b = j[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === t ? f : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return t || (a = s[c] = s[c] || a, r[a] = b), this
          },
          overrideMimeType: function(a) {
            return t || (k.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 &gt; t)
                for (b in a) q[b] = [q[b], a[b]];
              else v.always(a[v.status]);
            return this
          },
          abort: function(a) {
            var b = a || u;
            return i &amp;&amp; i.abort(b), x(0, b), this
          }
        };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || Ac) + "").replace(Bc, "").replace(Gc, zc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(F) || [""], null == k.crossDomain &amp;&amp; (c = Hc.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === zc[1] &amp;&amp; c[2] === zc[2] &amp;&amp; (c[3] || ("http:" === c[1] ? "80" : "443")) === (zc[3] || ("http:" === zc[1] ? "80" : "443")))), k.data &amp;&amp; k.processData &amp;&amp; "string" != typeof k.data &amp;&amp; (k.data = n.param(k.data, k.traditional)), Nc(Ic, k, b, v), 2 === t) return v;
      h = k.global, h &amp;&amp; 0 === n.active++ &amp;&amp; n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Fc.test(k.type), e = k.url, k.hasContent || (k.data &amp;&amp; (e = k.url += (xc.test(e) ? "&amp;" : "?") + k.data, delete k.data), k.cache === !1 &amp;&amp; (k.url = Cc.test(e) ? e.replace(Cc, "$1_=" + wc++) : e + (xc.test(e) ? "&amp;" : "?") + "_=" + wc++)), k.ifModified &amp;&amp; (n.lastModified[e] &amp;&amp; v.setRequestHeader("If-Modified-Since", n.lastModified[e]), n.etag[e] &amp;&amp; v.setRequestHeader("If-None-Match", n.etag[e])), (k.data &amp;&amp; k.hasContent &amp;&amp; k.contentType !== !1 || b.contentType) &amp;&amp; v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] &amp;&amp; k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Kc + "; q=0.01" : "") : k.accepts["*"]);
      for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
      if (k.beforeSend &amp;&amp; (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
      u = "abort";
      for (d in {
          success: 1,
          error: 1,
          complete: 1
        }) v[d](k[d]);
      if (i = Nc(Jc, k, b, v)) {
        v.readyState = 1, h &amp;&amp; m.trigger("ajaxSend", [v, k]), k.async &amp;&amp; k.timeout &gt; 0 &amp;&amp; (g = setTimeout(function() {
          v.abort("timeout")
        }, k.timeout));
        try {
          t = 1, i.send(r, x)
        } catch (w) {
          if (!(2 &gt; t)) throw w;
          x(-1, w)
        }
      } else x(-1, "No Transport");

      function x(a, b, c, d) {
        var j, r, s, u, w, x = b;
        2 !== t &amp;&amp; (t = 2, g &amp;&amp; clearTimeout(g), i = void 0, f = d || "", v.readyState = a &gt; 0 ? 4 : 0, j = a &gt;= 200 &amp;&amp; 300 &gt; a || 304 === a, c &amp;&amp; (u = Pc(k, v, c)), u = Qc(k, u, v, j), j ? (k.ifModified &amp;&amp; (w = v.getResponseHeader("Last-Modified"), w &amp;&amp; (n.lastModified[e] = w), w = v.getResponseHeader("etag"), w &amp;&amp; (n.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) &amp;&amp; (x = "error", 0 &gt; a &amp;&amp; (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h &amp;&amp; m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h &amp;&amp; (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")))
      }
      return v
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) &amp;&amp; (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      })
    }
  }), n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      });
      if (this[0]) {
        var b = n(a, this[0].ownerDocument).eq(0).clone(!0);
        this[0].parentNode &amp;&amp; b.insertBefore(this[0]), b.map(function() {
          var a = this;
          while (a.firstChild &amp;&amp; 1 === a.firstChild.nodeType) a = a.firstChild;
          return a
        }).append(this)
      }
      return this
    },
    wrapInner: function(a) {
      return this.each(n.isFunction(a) ? function(b) {
        n(this).wrapInner(a.call(this, b))
      } : function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return a.offsetWidth &lt;= 0 &amp;&amp; a.offsetHeight &lt;= 0 || !l.reliableHiddenOffsets() &amp;&amp; "none" === (a.style &amp;&amp; a.style.display || n.css(a, "display"))
  }, n.expr.filters.visible = function(a) {
    return !n.expr.filters.hidden(a)
  };
  var Rc = /%20/g,
    Sc = /\[\]$/,
    Tc = /\r?\n/g,
    Uc = /^(?:submit|button|image|reset|file)$/i,
    Vc = /^(?:input|select|textarea|keygen)/i;

  function Wc(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || Sc.test(a) ? d(a, e) : Wc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Wc(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b &amp;&amp; (b = n.ajaxSettings &amp;&amp; n.ajaxSettings.traditional), n.isArray(a) || a.jquery &amp;&amp; !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Wc(c, a[c], b, e);
    return d.join("&amp;").replace(Rc, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name &amp;&amp; !n(this).is(":disabled") &amp;&amp; Vc.test(this.nodeName) &amp;&amp; !Uc.test(a) &amp;&amp; (this.checked || !X.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Tc, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(Tc, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
    return !this.isLocal &amp;&amp; /^(get|post|head|put|delete|options)$/i.test(this.type) &amp;&amp; $c() || _c()
  } : $c;
  var Xc = 0,
    Yc = {},
    Zc = n.ajaxSettings.xhr();
  a.ActiveXObject &amp;&amp; n(a).on("unload", function() {
    for (var a in Yc) Yc[a](void 0, !0)
  }), l.cors = !!Zc &amp;&amp; "withCredentials" in Zc, Zc = l.ajax = !!Zc, Zc &amp;&amp; n.ajaxTransport(function(a) {
    if (!a.crossDomain || l.cors) {
      var b;
      return {
        send: function(c, d) {
          var e, f = a.xhr(),
            g = ++Xc;
          if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
            for (e in a.xhrFields) f[e] = a.xhrFields[e];
          a.mimeType &amp;&amp; f.overrideMimeType &amp;&amp; f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
          for (e in c) void 0 !== c[e] &amp;&amp; f.setRequestHeader(e, c[e] + "");
          f.send(a.hasContent &amp;&amp; a.data || null), b = function(c, e) {
            var h, i, j;
            if (b &amp;&amp; (e || 4 === f.readyState))
              if (delete Yc[g], b = void 0, f.onreadystatechange = n.noop, e) 4 !== f.readyState &amp;&amp; f.abort();
              else {
                j = {}, h = f.status, "string" == typeof f.responseText &amp;&amp; (j.text = f.responseText);
                try {
                  i = f.statusText
                } catch (k) {
                  i = ""
                }
                h || !a.isLocal || a.crossDomain ? 1223 === h &amp;&amp; (h = 204) : h = j.text ? 200 : 404
              }
            j &amp;&amp; d(h, i, j, f.getAllResponseHeaders())
          }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Yc[g] = b : b()
        },
        abort: function() {
          b &amp;&amp; b(void 0, !0)
        }
      }
    }
  });

  function $c() {
    try {
      return new a.XMLHttpRequest
    } catch (b) {}
  }

  function _c() {
    try {
      return new a.ActiveXObject("Microsoft.XMLHTTP")
    } catch (b) {}
  }
  n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache &amp;&amp; (a.cache = !1), a.crossDomain &amp;&amp; (a.type = "GET", a.global = !1)
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c = z.head || n("head")[0] || z.documentElement;
      return {
        send: function(d, e) {
          b = z.createElement("script"), b.async = !0, a.scriptCharset &amp;&amp; (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
            (c || !b.readyState || /loaded|complete/.test(b.readyState)) &amp;&amp; (b.onload = b.onreadystatechange = null, b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null, c || e(200, "success"))
          }, c.insertBefore(b, c.firstChild)
        },
        abort: function() {
          b &amp;&amp; b.onload(void 0, !0)
        }
      }
    }
  });
  var ad = [],
    bd = /(=)\?(?=&amp;|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = ad.pop() || n.expando + "_" + wc++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 &amp;&amp; (bd.test(b.url) ? "url" : "string" == typeof b.data &amp;&amp; !(b.contentType || "").indexOf("application/x-www-form-urlencoded") &amp;&amp; bd.test(b.data) &amp;&amp; "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(bd, "$1" + e) : b.jsonp !== !1 &amp;&amp; (b.url += (xc.test(b.url) ? "&amp;" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      a[e] = f, b[e] &amp;&amp; (b.jsonpCallback = c.jsonpCallback, ad.push(e)), g &amp;&amp; n.isFunction(f) &amp;&amp; f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b &amp;&amp; (c = b, b = !1), b = b || z;
    var d = v.exec(a),
      e = !c &amp;&amp; [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e &amp;&amp; e.length &amp;&amp; n(e).remove(), n.merge([], d.childNodes))
  };
  var cd = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a &amp;&amp; cd) return cd.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h &gt;= 0 &amp;&amp; (d = a.slice(h, a.length), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b &amp;&amp; "object" == typeof b &amp;&amp; (f = "POST"), g.length &gt; 0 &amp;&amp; n.ajax({
      url: a,
      type: f,
      dataType: "html",
      data: b
    }).done(function(a) {
      e = arguments, g.html(d ? n("&lt;div&gt;").append(n.parseHTML(a)).find(d) : a)
    }).complete(c &amp;&amp; function(a, b) {
      g.each(c, e || [a.responseText, b, a])
    }), this
  }, n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };
  var dd = a.document.documentElement;

  function ed(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k &amp;&amp; (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) &amp;&amp; n.inArray("auto", [f, i]) &gt; -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) &amp;&amp; (b = b.call(a, c, h)), null != b.top &amp;&amp; (m.top = b.top - h.top + g), null != b.left &amp;&amp; (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = {
          top: 0,
          left: 0
        },
        e = this[0],
        f = e &amp;&amp; e.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, e) ? (typeof e.getBoundingClientRect !== L &amp;&amp; (d = e.getBoundingClientRect()), c = ed(f), {
        top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
        left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
      }) : d
    },
    position: function() {
      if (this[0]) {
        var a, b, c = {
            top: 0,
            left: 0
          },
          d = this[0];
        return "fixed" === n.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (c = a.offset()), c.top += n.css(a[0], "borderTopWidth", !0), c.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - c.top - n.css(d, "marginTop", !0),
          left: b.left - c.left - n.css(d, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent || dd;
        while (a &amp;&amp; !n.nodeName(a, "html") &amp;&amp; "static" === n.css(a, "position")) a = a.offsetParent;
        return a || dd
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(a, b) {
    var c = /Y/.test(b);
    n.fn[a] = function(d) {
      return W(this, function(a, d, e) {
        var f = ed(a);
        return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void(f ? f.scrollTo(c ? n(f).scrollLeft() : e, c ? e : n(f).scrollTop()) : a[d] = e)
      }, a, d, arguments.length, null)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = Mb(l.pixelPosition, function(a, c) {
      return c ? (c = Kb(a, b), Ib.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length &amp;&amp; (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return W(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.size = function() {
    return this.length
  }, n.fn.andSelf = n.fn.addBack, "function" == typeof define &amp;&amp; define.amd &amp;&amp; define("jquery", [], function() {
    return n
  });
  var fd = a.jQuery,
    gd = a.$;
  return n.noConflict = function(b) {
    return a.$ === n &amp;&amp; (a.$ = gd), b &amp;&amp; a.jQuery === n &amp;&amp; (a.jQuery = fd), n
  }, typeof b === L &amp;&amp; (a.jQuery = a.$ = n), n
});
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0_no_conflict.js */
(function() {
  window.jQuery1110 = jQuery.noConflict(true);
})();;
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i &lt; array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j &lt; types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i &lt; _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &amp;&amp;
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length &lt; this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null &amp;&amp; _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index &gt;= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses &amp;&amp; responses.length &gt; 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i &lt; _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length &gt; 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength &gt; _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length &gt; 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i &lt; lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout &gt; 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null &amp;&amp; webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel &amp;&amp; !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j &lt; messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index &gt;= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length &gt; 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect &amp;&amp; _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported &amp;&amp; !!org.cometd.WebSocket &amp;&amp; _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i &lt; arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep &amp;&amp; typeof prop === 'object' &amp;&amp; prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' &amp;&amp; !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort &amp;&amp; hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined &amp;&amp; afterURI.length &gt; 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') &gt;= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions &amp;&amp; subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription &amp;&amp; !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i &lt; subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '-&gt;', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions &amp;&amp; subscriptions.length &gt; 0) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i &gt; 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined &amp;&amp; message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch &gt; 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff &lt; _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length &gt; 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch &lt; 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 &amp;&amp; !_isDisconnected() &amp;&amp; !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length &gt; 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() &amp;&amp; _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '-&gt;', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '-&gt;', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i &gt;= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription &amp;&amp; !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i &lt; rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport &amp;&amp; typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' &amp;&amp; define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON &amp;&amp; JSON.stringify) || (window.jaredJSON &amp;&amp; window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON &amp;&amp; JSON.parse) || (window.jaredJSON &amp;&amp; window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery1110 || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i &lt; _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i &lt; _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i &lt; subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log("&gt;&gt;&gt; connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected &amp;&amp; connected)
      _connectionOpened();
    else if (wasConnected &amp;&amp; !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }
  var modalContent = '&lt;iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"&gt;&lt;/iframe&gt;';
  var modalTemplate = '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '  &lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '     &lt;div class="modal-content"&gt;' +
    '        &lt;header class="modal-header"&gt;' +
    '           &lt;h4 id="small_modal1_title" class="modal-title"&gt;Login&lt;/h4&gt;' +
    '        &lt;/header&gt;' +
    '        &lt;div class="modal-body"&gt;' +
    '        &lt;/div&gt;' +
    '     &lt;/div&gt;' +
    '  &lt;/div&gt;' +
    '&lt;/div&gt;';

  function _loginShow() {
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i &lt; window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event &amp;&amp; connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED,
        this._subscribeWhenReady.bind(this));
      LOGGER.debug("Subscribed from channel: " + currentChannel.getName());
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription &amp;&amp; _initialized) {
        subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].resubscribe();
    },
    _handleResponse: function(message) {
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length &lt; 1 &amp;&amp; subscription &amp;&amp; !_disconnected()) {
        cometd.unsubscribe(subscription);
        subscription = null;
      }
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i &lt; uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        _connectionBrokenEvent = false;
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          for (var name in channels) {
            var channel = channels[name];
            channel.resubscribe();
          }
        });
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage("&gt;&gt;&gt; connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(jQuery1110);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext &amp;&amp; document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(jQuery1110);;
/*! RESOURCE: /scripts/amb_initialize.js */
if (typeof g_amb_on_login === 'undefined') {
  amb.getClient();
};;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  if (_window.g_ambClient) {
    ambClient = _window.g_ambClient;
    sameScope = true;
  }
  if (!ambClient)
    ambClient = amb.getClient();
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow &amp;&amp; loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB &amp;&amp; state !== "opened" &amp;&amp; state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log("&gt;&gt;&gt; init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log("&gt;&gt;&gt; record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i &lt; len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i &lt; len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '	&lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '		&lt;div class="modal-content"&gt;' +
    '			&lt;header class="modal-header"&gt;' +
    '				&lt;h4 id="small_modal1_title" class="modal-title"&gt;{{title || "Login"}}&lt;/h4&gt;' +
    '			&lt;/header&gt;' +
    '			&lt;div class="modal-body"&gt;' +
    '			&lt;iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"&gt;&lt;/iframe&gt;' +
    '			&lt;/div&gt;' +
    '		&lt;/div&gt;' +
    '	&lt;/div&gt;' +
    '&lt;/div&gt;'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/sn/common/presence/_module.js */
angular.module('sn.common.presence', ['ng.amb', 'sn.common.glide']).config(function($provide) {
  "use strict";
  $provide.constant("PRESENCE_DISABLED", "false" === "true");
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snPresence.js */
angular.module("sn.common.presence").factory('snPresence', function($rootScope, $window, $log, amb, $timeout, $http, snRecordPresence, snTabActivity, urlTools, PRESENCE_DISABLED) {
  "use strict";
  var REST = {
    PRESENCE: "/api/now/ui/presence"
  };
  var databaseInterval = ($window.NOW.presence_interval || 15) * 1000;
  var initialized = false;
  var primary = false;
  var presenceArray = [];
  var serverTimeMillis;
  var skew = 0;
  var st = 0;

  function init() {
    var location = urlTools.parseQueryString(window.location.search);
    var table = location['table'] || location['sysparm_table'];
    var sys_id = location['sys_id'] || location['sysparm_sys_id'];
    var query = location['sysparm_query'];
    initPresence(table, sys_id, query);
  }

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!initialized) {
      initialized = true;
      initRootScopes();
      if (!primary) {
        CustomEvent.observe('sn.presence', onPresenceEvent);
        CustomEvent.fireTop('sn.presence.ping');
      } else {
        presenceArray = getLocalPresence();
        if (presenceArray)
          $timeout(schedulePresence, 100);
        else
          updateDatabase();
      }
    }
    snRecordPresence.initPresence(t, id);
  }

  function onPresenceEvent(parms) {
    presenceArray = parms;
    $timeout(broadcastPresence);
  }

  function initRootScopes() {
    if ($window.NOW.presence_scopes) {
      var ps = $window.NOW.presence_scopes;
      if (ps.indexOf($rootScope) == -1)
        ps.push($rootScope);
    } else {
      $window.NOW.presence_scopes = [$rootScope];
      primary = CustomEvent.isTopWindow();
    }
  }

  function updateDatabase() {
    presenceArray = getLocalPresence();
    if (presenceArray) {
      determineStatus();
      $timeout(schedulePresence);
      return;
    }
    if (!amb.isLoggedIn() || !snTabActivity.isPrimary) {
      $timeout(schedulePresence);
      return;
    }
    var p = {
      user_agent: navigator.userAgent,
      ua_time: new Date().toISOString(),
      href: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      path: window.location.pathname + window.location.search
    };
    st = new Date().getTime();
    $http.post(REST.PRESENCE + '?sysparm_auto_request=true&amp;cd=' + st, p).success(function(data) {
      var rt = new Date().getTime() - st;
      if (rt &gt; 500)
        console.log("snPresence response time " + rt + "ms");
      if (data.result &amp;&amp; data.result.presenceArray) {
        presenceArray = data.result.presenceArray;
        setLocalPresence(presenceArray);
        serverTimeMillis = data.result.serverTimeMillis;
        skew = new Date().getTime() - serverTimeMillis;
        var t = Math.floor(skew / 1000);
        if (t &lt; -15)
          console.log("&gt;&gt;&gt;&gt;&gt; server ahead " + Math.abs(t) + " seconds");
        else if (t &gt; 15)
          console.log("&gt;&gt;&gt;&gt;&gt; browser time ahead " + t + " seconds");
      }
      schedulePresence();
    }).error(function(response, status) {
      console.log("snPresence " + status);
      if (429 == status)
        $timeout(updateDatabase, databaseInterval);
      else
        schedulePresence();
    })
  }

  function schedulePresence() {
    $timeout(updateDatabase, databaseInterval);
    determineStatus();
    broadcastPresence();
  }

  function broadcastPresence() {
    $rootScope.$broadcast("sn.presence", presenceArray);
    if (!primary)
      return;
    CustomEvent.fireAll('sn.presence', presenceArray);
  }

  function determineStatus() {
    if (!presenceArray || !presenceArray.forEach) {
      $log.log("factory.snPresence &gt;&gt;&gt; server error @ " + new Date());
      return;
    }
    var t = new Date().getTime();
    t -= skew;
    presenceArray.forEach(function(p) {
      var x = 0 + p.last_on;
      var y = t - x;
      p.status = "online";
      if (y &gt; (5 * databaseInterval))
        p.status = "offline";
      else if (y &gt; (3 * databaseInterval))
        p.status = "probably offline";
      else if (y &gt; (2.5 * databaseInterval))
        p.status = "maybe offline";
    })
  }

  function setLocalPresence(value) {
    var p = {
      saved: new Date().getTime(),
      presenceArray: value
    }
    $window.localStorage.setItem('snPresence', angular.toJson(p));
  }

  function getLocalPresence() {
    var p = $window.localStorage.getItem('snPresence');
    if (!p)
      return null;
    try {
      p = angular.fromJson(p);
    } catch (e) {
      p = {};
    }
    if (!p.presenceArray)
      return null;
    var now = new Date().getTime();
    if (now - p.saved &gt;= databaseInterval)
      return null;
    return p.presenceArray;
  }
  return {
    init: init,
    initWithDocument: initPresence,
    initPresence: initPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/factory.snRecordPresence.js */
angular.module("sn.common.presence").factory('snRecordPresence', function($rootScope, $location, amb, $timeout, $window, PRESENCE_DISABLED, snTabActivity) {
  "use strict";
  var statChannel;
  var interval = 20 * 1000;
  var sessions = {};
  var timer;
  var primary = false;
  var table;
  var sys_id;

  function initPresence(t, id) {
    if (PRESENCE_DISABLED)
      return;
    if (!t || !id)
      return;
    if (t == table &amp;&amp; id == sys_id)
      return;
    initRootScopes();
    if (!primary)
      return;
    termPresence();
    table = t;
    sys_id = id;
    var recordPresence = "/sn/rp/" + table + "/" + sys_id;
    $rootScope.me = NOW.session_id;
    statChannel = amb.getChannel(recordPresence);
    statChannel.subscribe(onStatus);
    amb.connected.then(function() {
      setStatus("entered");
      $rootScope.status = "viewing";
    });
    timer = $timeout(managePresence, interval);
    return statChannel;
  }

  function initRootScopes() {
    if ($window.NOW.record_presence_scopes) {
      var ps = $window.NOW.record_presence_scopes;
      if (ps.indexOf($rootScope) == -1) {
        ps.push($rootScope);
        CustomEvent.observe('sn.sessions', onPresenceEvent);
      }
    } else {
      $window.NOW.record_presence_scopes = [$rootScope];
      primary = true;
    }
  }

  function onPresenceEvent(sessionsToSend) {
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
  }

  function termPresence() {
    if (timer)
      $timeout.cancel(timer);
    if (!statChannel)
      return;
    publish("exited");
    statChannel.unsubscribe();
    statChannel = table = sys_id = null;
  }

  function setStatus(status) {
    if (status == $rootScope.status)
      return;
    $rootScope.status = status;
    publish($rootScope.status);
  }

  function publish(status) {
    if (!statChannel)
      return;
    if (amb.getState() !== "opened")
      return;
    statChannel.publish({
      status: status,
      session_id: NOW.session_id,
      user_name: NOW.user_name,
      user_id: NOW.user_id,
      user_display_name: NOW.user_display_name,
      user_initials: NOW.user_initials,
      user_avatar: NOW.user_avatar,
      ua: navigator.userAgent,
      table: table,
      sys_id: sys_id,
      time: new Date().toString().substring(0, 24)
    });
  }

  function onStatus(message) {
    var d = message.data;
    if (d.session_id == NOW.session_id)
      return;
    var s = sessions[d.session_id];
    if (s)
      angular.extend(s, d);
    else
      s = sessions[d.session_id] = d;
    s.lastUpdated = new Date();
    broadcastSessions();
    if (s.status == 'entered')
      publish($rootScope.status);
  }

  function managePresence() {
    var now = new Date().getTime();
    var deleted = false;
    Object.keys(sessions).forEach(function(id) {
      var s = sessions[id];
      if (!s.lastUpdated)
        return;
      var last = s.lastUpdated.getTime();
      var t = now - last;
      s.lastSeen = t / 1000;
      if (s.status === 'exited') {
        deleted = true;
        delete sessions[id];
      }
      if (t &gt; interval * 2)
        s.status = 'probably left';
      if (t &gt; interval * 4) {
        deleted = true;
        delete sessions[id];
      }
    });
    if (Object.keys(sessions).length !== 0)
      publish($rootScope.status);
    timer = $timeout(managePresence, interval);
    if (deleted)
      broadcastSessions();
  }

  function broadcastSessions() {
    var sessionsToSend = getUniqueSessions();
    $rootScope.$broadcast("sn.sessions", sessionsToSend);
    $rootScope.$broadcast("sp.sessions", sessionsToSend);
    if (primary)
      $timeout(function() {
        CustomEvent.fire('sn.sessions', sessionsToSend);
      })
  }

  function getUniqueSessions() {
    var uniqueSessionsByUser = {};
    var sessionKeys = Object.keys(sessions);
    sessionKeys.forEach(function(key) {
      var session = sessions[key];
      if (session.user_id == NOW.user_id)
        return;
      if (session.user_id in uniqueSessionsByUser) {
        var otherSession = uniqueSessionsByUser[session.user_id];
        var thisPrecedence = getStatusPrecedence(session.status);
        var otherPrecedence = getStatusPrecedence(otherSession.status);
        uniqueSessionsByUser[session.user_id] = thisPrecedence &lt; otherPrecedence ? session : otherSession;
        return
      }
      uniqueSessionsByUser[session.user_id] = session;
    });
    var uniqueSessions = {};
    angular.forEach(uniqueSessionsByUser, function(item) {
      uniqueSessions[item.session_id] = item;
    });
    return uniqueSessions;
  }

  function getStatusPrecedence(status) {
    switch (status) {
      case 'typing':
        return 0;
      case 'viewing':
        return 1;
      case 'entered':
        return 2;
      case 'exited':
      case 'probably left':
        return 4;
      case 'offline':
        return 5;
      default:
        return 3;
    }
  }
  $rootScope.$on("record.typing", function(evt, data) {
    setStatus(data.status);
  });
  var idleTable, idleSysID;
  snTabActivity.onIdle({
    onIdle: function RecordPresenceTabIdle() {
      idleTable = table;
      idleSysID = sys_id;
      sessions = {};
      termPresence();
      broadcastSessions();
    },
    onReturn: function RecordPresenceTabActive() {
      initPresence(idleTable, idleSysID, true);
      idleTable = idleSysID = void(0);
    },
    delay: interval * 4
  });
  return {
    initPresence: initPresence,
    termPresence: termPresence
  }
});;
/*! RESOURCE: /scripts/sn/common/presence/directive.snPresence.js */
angular.module('sn.common.presence').directive('snPresence', function(snPresence, $rootScope, $timeout) {
  'use strict';
  $timeout(snPresence.init, 100);
  var presences = {};
  $rootScope.$on('sn.presence', function(event, presenceArray) {
    if (!presenceArray) {
      angular.forEach(presences, function(p) {
        p.status = "offline";
      });
      return;
    }
    presenceArray.forEach(function(presence) {
      presences[presence.user] = presence;
    });
  });
  return {
    restrict: 'EA',
    replace: false,
    scope: {
      snPresence: '=',
      user: '='
    },
    link: function(scope, element) {
      if (!element.hasClass('presence'))
        element.addClass('presence');

      function updatePresence() {
        var id = scope.snPresence || scope.user;
        if (presences[id]) {
          var status = presences[id].status;
          if (status === 'maybe offline' || status === 'probably offline') {
            element.removeClass('presence-online presence-offline presence-away');
            element.addClass('presence-away');
          } else if (status == "offline" &amp;&amp; !element.hasClass('presence-offline')) {
            element.removeClass('presence-online presence-away');
            element.addClass('presence-offline');
          } else if ((status == "online" || status == "entered" || status == "viewing") &amp;&amp; !element.hasClass('presence-online')) {
            element.removeClass('presence-offline presence-away');
            element.addClass('presence-online');
          }
        } else {
          if (!element.hasClass('presence-offline'))
            element.addClass('presence-offline');
        }
      }
      $rootScope.$on('sn.presence', updatePresence);
      updatePresence();
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/user_profile/js_includes_user_profile.js */
/*! RESOURCE: /scripts/sn/common/user_profile/_module.js */
angular.module("sn.common.user_profile", []);;
/*! RESOURCE: /scripts/sn/common/user_profile/directive.snUserProfile.js */
angular.module('sn.common.user_profile').directive('snUserProfile', function(getTemplateUrl, snCustomEvent, $window, avatarProfilePersister) {
  "use strict";
  return {
    replace: true,
    restrict: 'E',
    templateUrl: getTemplateUrl('snUserProfile.xml'),
    scope: {
      profile: "=",
      showDirectMessagePrompt: "="
    },
    link: function(scope) {
      scope.showDirectMessagePromptFn = function() {
        if (scope.showDirectMessagePrompt) {
          var activeUserID = $window.NOW.user_id || "";
          return !(!scope.profile ||
            activeUserID === scope.profile.sysID ||
            (scope.profile.document &amp;&amp; activeUserID === scope.profile.document));
        } else {
          return false;
        }
      };
    },
    controller: function($scope, snConnectService) {
      if ($scope.profile &amp;&amp; $scope.profile.userID &amp;&amp; avatarProfilePersister.getAvatar($scope.profile.userID))
        $scope.profile = avatarProfilePersister.getAvatar($scope.profile.userID);
      $scope.$emit("sn-user-profile.ready");
      $scope.openDirectMessageConversation = function(evt) {
        if (evt.keyCode === 9)
          return;
        snConnectService.openWithProfile($scope.profile);
      };
    }
  }
});;;
/*! RESOURCE: /scripts/sn/common/util/js_includes_util.js */
/*! RESOURCE: /scripts/sn/common/util/_module.js */
angular.module('sn.common.util', ['sn.common.auth']);
angular.module('sn.util', ['sn.common.util']);;
/*! RESOURCE: /scripts/sn/common/util/service.dateUtils.js */
angular.module('sn.common.util').factory('dateUtils', function() {
  var dateUtils = {
    SYS_DATE_FORMAT: "yyyy-MM-dd",
    SYS_TIME_FORMAT: "HH:mm:ss",
    SYS_DATE_TIME_FORMAT: "yyyy-MM-dd HH:mm:ss",
    MONTH_NAMES: new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'),
    DAY_NAMES: new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
    LZ: function(x) {
      return (x &lt; 0 || x &gt; 9 ? "" : "0") + x
    },
    isDate: function(val, format) {
      var date = this.getDateFromFormat(val, format);
      if (date == 0) {
        return false;
      }
      return true;
    },
    compareDates: function(date1, dateformat1, date2, dateformat2) {
      var d1 = this.getDateFromFormat(date1, dateformat1);
      var d2 = this.getDateFromFormat(date2, dateformat2);
      if (d1 == 0 || d2 == 0) {
        return -1;
      } else if (d1 &gt; d2) {
        return 1;
      }
      return 0;
    },
    formatDateServer: function(date, format) {
      var ga = new GlideAjax("DateTimeUtils");
      ga.addParam("sysparm_name", "formatCalendarDate");
      var browserOffset = date.getTimezoneOffset() * 60000;
      var utcTime = date.getTime() - browserOffset;
      var userDateTime = utcTime - g_tz_offset;
      ga.addParam("sysparm_value", userDateTime);
      ga.getXMLWait();
      return ga.getAnswer();
    },
    formatDate: function(date, format) {
      if (format.indexOf("z") &gt; 0)
        return this.formatDateServer(date, format);
      format = format + "";
      var result = "";
      var i_format = 0;
      var c = "";
      var token = "";
      var y = date.getYear() + "";
      var M = date.getMonth() + 1;
      var d = date.getDate();
      var E = date.getDay();
      var H = date.getHours();
      var m = date.getMinutes();
      var s = date.getSeconds();
      var yyyy, yy, MMM, MM, dd, hh, h, mm, ss, ampm, HH, H, KK, K, kk, k;
      var value = new Object();
      value["M"] = M;
      value["MM"] = this.LZ(M);
      value["MMM"] = this.MONTH_NAMES[M + 11];
      value["NNN"] = this.MONTH_NAMES[M + 11];
      value["MMMM"] = this.MONTH_NAMES[M - 1];
      value["d"] = d;
      value["dd"] = this.LZ(d);
      value["E"] = this.DAY_NAMES[E + 7];
      value["EE"] = this.DAY_NAMES[E];
      value["H"] = H;
      value["HH"] = this.LZ(H);
      if (format.indexOf('w') != -1) {
        var wk = date.getWeek();
        if (wk &gt;= 52 &amp;&amp; M == 1) {
          y = date.getYear();
          y--;
          y = y + "";
        }
        if (wk == 1 &amp;&amp; M == 12) {
          y = date.getYear();
          y++;
          y = y + "";
        }
        value["w"] = wk;
        value["ww"] = this.LZ(wk);
      }
      var dayOfWeek = (7 + (E + 1) - (g_first_day_of_week - 1)) % 7;
      if (dayOfWeek == 0)
        dayOfWeek = 7;
      value["D"] = dayOfWeek;
      if (y.length &lt; 4) {
        y = "" + (y - 0 + 1900);
      }
      value["y"] = "" + y;
      value["yyyy"] = y;
      value["yy"] = y.substring(2, 4);
      if (H == 0) {
        value["h"] = 12;
      } else if (H &gt; 12) {
        value["h"] = H - 12;
      } else {
        value["h"] = H;
      }
      value["hh"] = this.LZ(value["h"]);
      if (H &gt; 11) {
        value["K"] = H - 12;
      } else {
        value["K"] = H;
      }
      value["k"] = H + 1;
      value["KK"] = this.LZ(value["K"]);
      value["kk"] = this.LZ(value["k"]);
      if (H &gt; 11) {
        value["a"] = "PM";
      } else {
        value["a"] = "AM";
      }
      value["m"] = m;
      value["mm"] = this.LZ(m);
      value["s"] = s;
      value["ss"] = this.LZ(s);
      while (i_format &lt; format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) &amp;&amp; (i_format &lt; format.length)) {
          token += format.charAt(i_format++);
        }
        if (value[token] != null) {
          result = result + value[token];
        } else {
          result = result + token;
        }
      }
      return result;
    },
    _isInteger: function(val) {
      var digits = "1234567890";
      for (var i = 0; i &lt; val.length; i++) {
        if (digits.indexOf(val.charAt(i)) == -1) {
          return false;
        }
      }
      return true;
    },
    _getInt: function(str, i, minlength, maxlength) {
      for (var x = maxlength; x &gt;= minlength; x--) {
        var token = str.substring(i, i + x);
        if (token.length &lt; minlength) {
          return null;
        }
        if (this._isInteger(token)) {
          return token;
        }
      }
      return null;
    },
    getDateFromFormat: function(val, format) {
      val = val + "";
      format = format + "";
      var i_val = 0;
      var i_format = 0;
      var c = "";
      var token = "";
      var token2 = "";
      var x, y;
      var now = new Date();
      var year = now.getYear();
      var month = now.getMonth() + 1;
      var date = 0;
      var hh = now.getHours();
      var mm = now.getMinutes();
      var ss = now.getSeconds();
      var ampm = "";
      var week = false;
      while (i_format &lt; format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) &amp;&amp; (i_format &lt; format.length)) {
          token += format.charAt(i_format++);
        }
        if (token == "yyyy" || token == "yy" || token == "y") {
          if (token == "yyyy") {
            x = 4;
            y = 4;
          }
          if (token == "yy") {
            x = 2;
            y = 2;
          }
          if (token == "y") {
            x = 2;
            y = 4;
          }
          year = this._getInt(val, i_val, x, y);
          if (year == null) {
            return 0;
          }
          i_val += year.length;
          if (year.length == 2) {
            if (year &gt; 70) {
              year = 1900 + (year - 0);
            } else {
              year = 2000 + (year - 0);
            }
          }
        } else if (token == "MMM" || token == "NNN") {
          month = 0;
          for (var i = 0; i &lt; this.MONTH_NAMES.length; i++) {
            var month_name = this.MONTH_NAMES[i];
            if (val.substring(i_val, i_val + month_name.length).toLowerCase() == month_name.toLowerCase()) {
              if (token == "MMM" || (token == "NNN" &amp;&amp; i &gt; 11)) {
                month = i + 1;
                if (month &gt; 12) {
                  month -= 12;
                }
                i_val += month_name.length;
                break;
              }
            }
          }
          if ((month &lt; 1) || (month &gt; 12)) {
            return 0;
          }
        } else if (token == "EE" || token == "E") {
          for (var i = 0; i &lt; this.DAY_NAMES.length; i++) {
            var day_name = this.DAY_NAMES[i];
            if (val.substring(i_val, i_val + day_name.length).toLowerCase() == day_name.toLowerCase()) {
              if (week) {
                if (i == 0 || i == 7)
                  date += 6;
                else if (i == 2 || i == 9)
                  date += 1;
                else if (i == 3 || i == 10)
                  date += 2;
                else if (i == 4 || i == 11)
                  date += 3;
                else if (i == 5 || i == 12)
                  date += 4;
                else if (i == 6 || i == 13)
                  date += 5;
              }
              i_val += day_name.length;
              break;
            }
          }
        } else if (token == "MM" || token == "M") {
          month = this._getInt(val, i_val, token.length, 2);
          if (month == null || (month &lt; 1) || (month &gt; 12)) {
            return 0;
          }
          i_val += month.length;
        } else if (token == "dd" || token == "d") {
          date = this._getInt(val, i_val, token.length, 2);
          if (date == null || (date &lt; 1) || (date &gt; 31)) {
            return 0;
          }
          i_val += date.length;
        } else if (token == "hh" || token == "h") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 1) || (hh &gt; 12)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "HH" || token == "H") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 0) || (hh &gt; 23)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "KK" || token == "K") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 0) || (hh &gt; 11)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "kk" || token == "k") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 1) || (hh &gt; 24)) {
            return 0;
          }
          i_val += hh.length;
          hh--;
        } else if (token == "mm" || token == "m") {
          mm = this._getInt(val, i_val, token.length, 2);
          if (mm == null || (mm &lt; 0) || (mm &gt; 59)) {
            return 0;
          }
          i_val += mm.length;
        } else if (token == "ss" || token == "s") {
          ss = this._getInt(val, i_val, token.length, 2);
          if (ss == null || (ss &lt; 0) || (ss &gt; 59)) {
            return 0;
          }
          i_val += ss.length;
        } else if (token == "a") {
          if (val.substring(i_val, i_val + 2).toLowerCase() == "am") {
            ampm = "AM";
          } else if (val.substring(i_val, i_val + 2).toLowerCase() == "pm") {
            ampm = "PM";
          } else {
            return 0;
          }
          i_val += 2;
        } else if (token == "w" || token == "ww") {
          var weekNum = this._getInt(val, i_val, token.length, 2);
          week = true;
          if (weekNum != null) {
            var temp = new Date(year, 0, 1, 0, 0, 0);
            temp.setWeek(parseInt(weekNum, 10));
            year = temp.getFullYear();
            month = temp.getMonth() + 1;
            date = temp.getDate();
          }
          weekNum += "";
          i_val += weekNum.length;
        } else if (token == "D") {
          if (week) {
            var day = this._getInt(val, i_val, token.length, 1);
            if ((day == null) || (day &lt;= 0) || (day &gt; 7))
              return 0;
            var temp = new Date(year, month - 1, date, hh, mm, ss);
            var dayOfWeek = temp.getDay();
            day = parseInt(day, 10);
            day = (day + g_first_day_of_week - 1) % 7;
            if (day == 0)
              day = 7;
            day--;
            if (day &lt; dayOfWeek)
              day = 7 - (dayOfWeek - day);
            else
              day -= dayOfWeek;
            if (day &gt; 0) {
              temp.setDate(temp.getDate() + day);
              year = temp.getFullYear();
              month = temp.getMonth() + 1;
              date = temp.getDate();
            }
            i_val++;
          }
        } else if (token == "z")
          i_val += 3;
        else {
          if (val.substring(i_val, i_val + token.length) != token) {
            return 0;
          } else {
            i_val += token.length;
          }
        }
      }
      if (i_val != val.length) {
        return 0;
      }
      if (month == 2) {
        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) {
          if (date &gt; 29) {
            return 0;
          }
        } else {
          if (date &gt; 28) {
            return 0;
          }
        }
      }
      if ((month == 4) || (month == 6) || (month == 9) || (month == 11)) {
        if (date &gt; 30) {
          return 0;
        }
      }
      if (hh &lt; 12 &amp;&amp; ampm == "PM") {
        hh = hh - 0 + 12;
      } else if (hh &gt; 11 &amp;&amp; ampm == "AM") {
        hh -= 12;
      }
      var newdate = new Date(year, month - 1, date, hh, mm, ss);
      return newdate.getTime();
    },
    parseDate: function(val) {
      var preferEuro = (arguments.length == 2) ? arguments[1] : false;
      generalFormats = new Array('y-M-d', 'MMM d, y', 'MMM d,y', 'y-MMM-d', 'd-MMM-y', 'MMM d');
      monthFirst = new Array('M/d/y', 'M-d-y', 'M.d.y', 'MMM-d', 'M/d', 'M-d');
      dateFirst = new Array('d/M/y', 'd-M-y', 'd.M.y', 'd-MMM', 'd/M', 'd-M');
      yearFirst = new Array('yyyyw.F', 'yyw.F');
      var checkList = new Array('generalFormats', preferEuro ? 'dateFirst' : 'monthFirst', preferEuro ? 'monthFirst' : 'dateFirst', 'yearFirst');
      var d = null;
      for (var i = 0; i &lt; checkList.length; i++) {
        var l = window[checkList[i]];
        for (var j = 0; j &lt; l.length; j++) {
          d = this.getDateFromFormat(val, l[j]);
          if (d != 0) {
            return new Date(d);
          }
        }
      }
      return null;
    }
  };
  Date.prototype.getWeek = function() {
    var newYear = new Date(this.getFullYear(), 0, 1);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    day = (day &gt;= 0 ? day : day + 7);
    var dayNum = Math.floor((this.getTime() - newYear.getTime() - (this.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    var weekNum;
    if (day &lt; 4) {
      weekNum = Math.floor((dayNum + day - 1) / 7) + 1;
      if (weekNum &gt; 52)
        weekNum = this._checkNextYear(weekNum);
      return weekNum;
    }
    weekNum = Math.floor((dayNum + day - 1) / 7);
    if (weekNum &lt; 1)
      weekNum = this._lastWeekOfYear();
    else if (weekNum &gt; 52)
      weekNum = this._checkNextYear(weekNum);
    return weekNum;
  };
  Date.prototype._lastWeekOfYear = function() {
    var newYear = new Date(this.getFullYear() - 1, 0, 1);
    var endOfYear = new Date(this.getFullYear() - 1, 11, 31);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    var dayNum = Math.floor((endOfYear.getTime() - newYear.getTime() - (endOfYear.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    return day &lt; 4 ? Math.floor((dayNum + day - 1) / 7) + 1 : Math.floor((dayNum + day - 1) / 7);
  };
  Date.prototype._checkNextYear = function() {
    var nYear = new Date(this.getFullYear() + 1, 0, 1);
    var nDay = nYear.getDay() - (g_first_day_of_week - 1);
    nDay = nDay &gt;= 0 ? nDay : nDay + 7;
    return nDay &lt; 4 ? 1 : 53;
  };
  Date.prototype.setWeek = function(weekNum) {
    weekNum--;
    var startOfYear = new Date(this.getFullYear(), 0, 1);
    var day = startOfYear.getDay() - (g_first_day_of_week - 1);
    if (day &gt; 0 &amp;&amp; day &lt; 4) {
      this.setFullYear(startOfYear.getFullYear() - 1);
      this.setDate(31 - day + 1);
      this.setMonth(11);
    } else if (day &gt; 3)
      this.setDate(startOfYear.getDate() + (7 - day));
    this.setDate(this.getDate() + (7 * weekNum));
  };
  return dateUtils;
});
/*! RESOURCE: /scripts/sn/common/util/service.debounceFn.js */
angular.module("sn.common.util").service("debounceFn", function() {
  "use strict";

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate &amp;&amp; !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
  return {
    debounce: debounce
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.unwrappedHTTPPromise.js */
angular.module('sn.common.util').factory("unwrappedHTTPPromise", function($q) {
  "use strict";

  function isGenericPromise(promise) {
    return (typeof promise.then === "function" &amp;&amp;
      promise.success === undefined &amp;&amp;
      promise.error === undefined);
  }
  return function(httpPromise) {
    if (isGenericPromise(httpPromise))
      return httpPromise;
    var deferred = $q.defer();
    httpPromise.success(function(data) {
      deferred.resolve(data);
    }).error(function(data, status) {
      deferred.reject({
        data: data,
        status: status
      })
    });
    return deferred.promise;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.urlTools.js */
angular.module('sn.common.util').constant('angularProcessorUrl', 'angular.do?sysparm_type=');
angular.module('sn.common.util').factory("urlTools", function(getTemplateUrl, angularProcessorUrl) {
  "use strict";

  function getPartialURL(name, parameters) {
    var url = getTemplateUrl(name);
    if (parameters) {
      if (typeof parameters !== 'string') {
        parameters = encodeURIParameters(parameters);
      }
      if (parameters.length) {
        url += "&amp;" + parameters;
      }
    }
    if (window.NOW &amp;&amp; window.NOW.ng_cache_defeat)
      url += "&amp;t=" + new Date().getTime();
    return url;
  }

  function getURL(name, parameters) {
    if (parameters &amp;&amp; typeof parameters === 'object')
      return urlFor(name, parameters);
    var url = angularProcessorUrl;
    url += name;
    if (parameters)
      url += "&amp;" + parameters;
    return url;
  }

  function urlFor(route, parameters) {
    var p = encodeURIParameters(parameters);
    return angularProcessorUrl + route + (p.length ? '&amp;' + p : '');
  }

  function getPropertyURL(name) {
    var url = angularProcessorUrl + "get_property&amp;name=" + name;
    url += "&amp;t=" + new Date().getTime();
    return url;
  }

  function encodeURIParameters(parameters) {
    var s = [];
    for (var parameter in parameters) {
      if (parameters.hasOwnProperty(parameter)) {
        var key = encodeURIComponent(parameter);
        var value = parameters[parameter] ? encodeURIComponent(parameters[parameter]) : '';
        s.push(key + "=" + value);
      }
    }
    return s.join('&amp;');
  }

  function parseQueryString(qs) {
    qs = qs || '';
    if (qs.charAt(0) === '?') {
      qs = qs.substr(1);
    }
    var a = qs.split('&amp;');
    if (a === "") {
      return {};
    }
    if (a &amp;&amp; a[0].indexOf('http') != -1)
      a[0] = a[0].split("?")[1];
    var b = {};
    for (var i = 0; i &lt; a.length; i++) {
      var p = a[i].split('=', 2);
      if (p.length == 1) {
        b[p[0]] = "";
      } else {
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
    }
    return b;
  }
  return {
    getPartialURL: getPartialURL,
    getURL: getURL,
    urlFor: urlFor,
    getPropertyURL: getPropertyURL,
    encodeURIParameters: encodeURIParameters,
    parseQueryString: parseQueryString
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.getTemplateUrl.js */
angular.module('sn.common.util').provider('getTemplateUrl', function(angularProcessorUrl) {
  'use strict';
  var _handlerId = 0;
  var _handlers = {};
  this.registerHandler = function(handler) {
    var registeredId = _handlerId;
    _handlers[_handlerId] = handler;
    _handlerId++;
    return function() {
      delete _handlers[registeredId];
    };
  };
  this.$get = function() {
    return getTemplateUrl;
  };

  function getTemplateUrl(templatePath) {
    if (_handlerId &gt; 0) {
      var path;
      var handled = false;
      angular.forEach(_handlers, function(handler) {
        if (!handled) {
          var handlerPath = handler(templatePath);
          if (typeof handlerPath !== 'undefined') {
            path = handlerPath;
            handled = true;
          }
        }
      });
      if (handled) {
        return path;
      }
    }
    return angularProcessorUrl + 'get_partial&amp;name=' + templatePath;
  }
});;
/*! RESOURCE: /scripts/sn/common/util/service.snTabActivity.js */
angular.module("sn.common.util").service("snTabActivity", function($window, $timeout, $rootElement, $document) {
  "use strict";
  var activeEvents = ["keydown", "DOMMouseScroll", "mousewheel", "mousedown", "touchstart", "mousemove", "mouseenter", "input", "focus", "scroll"],
    defaultIdle = 75000,
    isPrimary = true,
    idleTime = 0,
    isVisible = true,
    idleTimeout = void(0),
    pageIdleTimeout = void(0),
    hasActed = false,
    appName = $rootElement.attr('ng-app') || "",
    storageKey = "sn.tabs." + appName + ".activeTab";
  var callbacks = {
    "tab.primary": [],
    "tab.secondary": [],
    "activity.active": [],
    "activity.idle": [{
      delay: defaultIdle,
      cb: function() {}
    }]
  };
  $window.tabGUID = $window.tabGUID || createGUID();

  function setAppName(an) {
    appName = an;
    storageKey = "sn.tabs." + appName + ".activeTab";
    makePrimary(true);
  }

  function createGUID(l) {
    l = l || 32;
    var strResult = '';
    while (strResult.length &lt; l)
      strResult += (((1 + Math.random() + new Date().getTime()) * 0x10000) | 0).toString(16).substring(1);
    return strResult.substr(0, l);
  }

  function ngObjectIndexOf(arr, obj) {
    for (var i = 0, len = arr.length; i &lt; len; i++)
      if (angular.equals(arr[i], obj))
        return i;
    return -1;
  }
  var detectedApi,
    apis = [{
      eventName: 'visibilitychange',
      propertyName: 'hidden'
    }, {
      eventName: 'mozvisibilitychange',
      propertyName: 'mozHidden'
    }, {
      eventName: 'msvisibilitychange',
      propertyName: 'msHidden'
    }, {
      eventName: 'webkitvisibilitychange',
      propertyName: 'webkitHidden'
    }];
  apis.some(function(api) {
    if (angular.isDefined($document[0][api.propertyName])) {
      detectedApi = api;
      return true;
    }
  });
  if (detectedApi)
    $document.on(detectedApi.eventName, function() {
      if (!$document[0][detectedApi.propertyName]) {
        makePrimary();
        isVisible = true;
      } else {
        if (!idleTimeout &amp;&amp; !idleTime)
          waitForIdle(0);
        isVisible = false;
      }
    });
  angular.element($window).on({
    "mouseleave": function(e) {
      var destination = angular.isUndefined(e.toElement) ? e.relatedTarget : e.toElement;
      if (destination === null &amp;&amp; $document[0].hasFocus()) {
        waitForIdle(0);
      }
    },
    "storage": function(e) {
      if (e.originalEvent.key !== storageKey)
        return;
      if ($window.localStorage.getItem(storageKey) !== $window.tabGUID)
        makeSecondary();
    }
  });

  function waitForIdle(index, delayOffset) {
    var callback = callbacks['activity.idle'][index];
    var numCallbacks = callbacks['activity.idle'].length;
    delayOffset = delayOffset || callback.delay;
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    angular.element($window).one(activeEvents.join(".snTabActivity "), setActive);
    if (index &gt;= numCallbacks)
      return;
    if (idleTimeout)
      $timeout.cancel(idleTimeout);
    idleTimeout = $timeout(function() {
      idleTime = callback.delay;
      callback.cb();
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
      angular.element($window).off(activeEvents.join(".snTabActivity "));
      angular.element($window).one(activeEvents.join(".snTabActivity "), setActive);
      for (var i = index + 1; i &lt; numCallbacks; i++) {
        var nextDelay = callbacks['activity.idle'][i].delay;
        if (nextDelay &lt;= callback.delay)
          callbacks['activity.idle'][i].cb();
        else {
          waitForIdle(i, nextDelay - callback.delay);
          break;
        }
      }
    }, delayOffset, false);
  }

  function setActive() {
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    if (idleTimeout) {
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
    }
    var activeCallbacks = callbacks['activity.active'];
    activeCallbacks.some(function(callback) {
      if (callback.delay &lt;= idleTime)
        callback.cb();
      else
        return true;
    });
    idleTime = 0;
    makePrimary();
    if (pageIdleTimeout) {
      $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = void(0);
    }
    var minDelay = callbacks['activity.idle'][0].delay;
    hasActed = false;
    if (!pageIdleTimeout)
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
    listenForActivity();
  }

  function pageIdleHandler() {
    if (idleTimeout)
      return;
    var minDelay = callbacks['activity.idle'][0].delay;
    if (hasActed) {
      hasActed = false;
      if (pageIdleTimeout)
        $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
      listenForActivity();
      return;
    }
    var delayOffset = minDelay;
    if (callbacks['activity.idle'].length &gt; 1)
      delayOffset = callbacks['activity.idle'][1].delay - minDelay;
    idleTime = minDelay;
    callbacks['activity.idle'][0].cb();
    waitForIdle(1, delayOffset);
    pageIdleTimeout = void(0);
  }

  function listenForActivity() {
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    angular.element($window).one(activeEvents.join(".snTabActivity "), onActivity);
    angular.element("#gsft_main").on("load.snTabActivity", function() {
      var src = angular.element(this).attr('src');
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = this.contentWindow ? this.contentWindow : this.contentDocument.defaultView;
        angular.element(iframeWindow).off(activeEvents.join(".snTabActivity "));
        angular.element(iframeWindow).one(activeEvents.join(".snTabActivity "), onActivity);
      }
    });
    angular.element('iframe').each(function(idx, iframe) {
      var src = angular.element(iframe).attr('src');
      if (!src)
        return;
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = iframe.contentWindow ? iframe.contentWindow : iframe.contentDocument.defaultView;
        angular.element(iframeWindow).off(activeEvents.join(".snTabActivity "));
        angular.element(iframeWindow).one(activeEvents.join(".snTabActivity "), onActivity);
      }
    });
  }

  function onActivity() {
    hasActed = true;
    makePrimary();
  }

  function makePrimary(initial) {
    var oldGuid = $window.localStorage.getItem(storageKey);
    isPrimary = true;
    isVisible = true;
    $timeout.cancel(idleTimeout);
    idleTimeout = void(0);
    if (canUseStorage() &amp;&amp; oldGuid !== $window.tabGUID &amp;&amp; !initial)
      for (var i = 0, len = callbacks["tab.primary"].length; i &lt; len; i++)
        callbacks["tab.primary"][i].cb();
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
    } catch (ignored) {}
    if (idleTime &amp;&amp; $document[0].hasFocus())
      setActive();
  }

  function makeSecondary() {
    isPrimary = false;
    isVisible = false;
    for (var i = 0, len = callbacks["tab.secondary"].length; i &lt; len; i++)
      callbacks["tab.secondary"][i].cb();
  }

  function registerCallback(event, callback, scope) {
    var cbObject = angular.isObject(callback) ? callback : {
      delay: defaultIdle,
      cb: callback
    };
    if (callbacks[event]) {
      callbacks[event].push(cbObject);
      callbacks[event].sort(function(a, b) {
        return a.delay - b.delay;
      })
    }

    function destroyCallback() {
      if (callbacks[event]) {
        var pos = ngObjectIndexOf(callbacks[event], cbObject);
        if (pos !== -1)
          callbacks[event].splice(pos, 1);
      }
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyCallback();
      });
    return destroyCallback;
  }

  function registerIdleCallback(options, onIdle, onReturn, scope) {
    var delay = options,
      onIdleDestroy,
      onReturnDestroy;
    if (angular.isObject(options)) {
      delay = options.delay;
      onIdle = options.onIdle || onIdle;
      onReturn = options.onReturn || onReturn;
      scope = options.scope || scope;
    }
    if (angular.isFunction(onIdle))
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: onIdle
      });
    else if (angular.isFunction(onReturn)) {
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: function() {}
      });
    }
    if (angular.isFunction(onReturn))
      onReturnDestroy = registerCallback("activity.active", {
        delay: delay,
        cb: onReturn
      });

    function destroyAll() {
      if (angular.isFunction(onIdleDestroy))
        onIdleDestroy();
      if (angular.isFunction(onReturnDestroy))
        onReturnDestroy();
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyAll();
      });
    return destroyAll;
  }

  function canUseStorage() {
    var canWe = false;
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
      canWe = true;
    } catch (ignored) {}
    return canWe;
  }
  makePrimary(true);
  listenForActivity();
  pageIdleTimeout = $timeout(pageIdleHandler, defaultIdle, false);
  return {
    on: registerCallback,
    onIdle: registerIdleCallback,
    setAppName: setAppName,
    get isPrimary() {
      return isPrimary;
    },
    get isIdle() {
      return idleTime &gt; 0;
    },
    get idleTime() {
      return idleTime;
    },
    get isVisible() {
      return isVisible;
    },
    get appName() {
      return appName;
    },
    get defaultIdleTime() {
      return defaultIdle
    },
    isActive: function() {
      return this.idleTime &lt; this.defaultIdleTime &amp;&amp; this.isVisible;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.ArraySynchronizer.js */
angular.module("sn.common.util").factory("ArraySynchronizer", function() {
  'use strict';

  function ArraySynchronizer() {}

  function index(key, arr) {
    var result = {};
    var keys = [];
    result.orderedKeys = keys;
    angular.forEach(arr, function(item) {
      var keyValue = item[key];
      result[keyValue] = item;
      keys.push(keyValue);
    });
    return result;
  }

  function sortByKeyAndModel(arr, key, model) {
    arr.sort(function(a, b) {
      var aIndex = model.indexOf(a[key]);
      var bIndex = model.indexOf(b[key]);
      if (aIndex &gt; bIndex)
        return 1;
      else if (aIndex &lt; bIndex)
        return -1;
      return 0;
    });
  }
  ArraySynchronizer.prototype = {
    add: function(syncField, dest, source, end) {
      end = end || "bottom";
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1) {
          if (end === "bottom") {
            dest.push(sourceIndex[key]);
          } else {
            dest.unshift(sourceIndex[key]);
          }
        }
      });
    },
    synchronize: function(syncField, dest, source, deepKeySyncArray) {
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      deepKeySyncArray = (typeof deepKeySyncArray === "undefined") ? [] : deepKeySyncArray;
      for (var i = destIndex.orderedKeys.length - 1; i &gt;= 0; i--) {
        var key = destIndex.orderedKeys[i];
        if (sourceIndex.orderedKeys.indexOf(key) === -1) {
          destIndex.orderedKeys.splice(i, 1);
          dest.splice(i, 1);
        }
        if (deepKeySyncArray.length &gt; 0) {
          angular.forEach(deepKeySyncArray, function(deepKey) {
            if (sourceIndex[key] &amp;&amp; destIndex[key][deepKey] !== sourceIndex[key][deepKey]) {
              destIndex[key][deepKey] = sourceIndex[key][deepKey];
            }
          });
        }
      }
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1)
          dest.push(sourceIndex[key]);
      });
      sortByKeyAndModel(dest, syncField, sourceIndex.orderedKeys);
    }
  };
  return ArraySynchronizer;
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBindOnce.js */
angular.module("sn.common.util").directive("snBindOnce", function($sanitize) {
  "use strict";
  return {
    restrict: "A",
    link: function(scope, element, attrs) {
      var value = scope.$eval(attrs.snBindOnce);
      var sanitizedValue = $sanitize(value);
      element.append(sanitizedValue);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/util/directive.snCloak.js */
angular.module("sn.common.util").directive("snCloak", function() {
  "use strict";
  return {
    restrict: "A",
    compile: function(element, attr) {
      return function() {
        attr.$set('snCloak', undefined);
        element.removeClass('sn-cloak');
      }
    }
  };
});
/*! RESOURCE: /scripts/sn/common/util/service.md5.js */
angular.module('sn.common.util').factory('md5', function() {
  'use strict';
  var md5cycle = function(x, k) {
    var a = x[0],
      b = x[1],
      c = x[2],
      d = x[3];
    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);
    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);
    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);
    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  };
  var cmn = function(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)), b);
  };
  var ff = function(a, b, c, d, x, s, t) {
    return cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);
  };
  var gg = function(a, b, c, d, x, s, t) {
    return cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);
  };
  var hh = function(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  };
  var ii = function(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
  };
  var md51 = function(s) {
    var txt = '';
    var n = s.length,
      state = [1732584193, -271733879, -1732584194, 271733878],
      i;
    for (i = 64; i &lt;= s.length; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i &lt; s.length; i++)
      tail[i &gt;&gt; 2] |= s.charCodeAt(i) &lt;&lt; ((i % 4) &lt;&lt; 3);
    tail[i &gt;&gt; 2] |= 0x80 &lt;&lt; ((i % 4) &lt;&lt; 3);
    if (i &gt; 55) {
      md5cycle(state, tail);
      for (i = 0; i &lt; 16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  };
  var md5blk = function(s) {
    var md5blks = [],
      i;
    for (i = 0; i &lt; 64; i += 4) {
      md5blks[i &gt;&gt; 2] = s.charCodeAt(i) +
        (s.charCodeAt(i + 1) &lt;&lt; 8) +
        (s.charCodeAt(i + 2) &lt;&lt; 16) +
        (s.charCodeAt(i + 3) &lt;&lt; 24);
    }
    return md5blks;
  };
  var hex_chr = '0123456789abcdef'.split('');
  var rhex = function(n) {
    var s = '',
      j = 0;
    for (; j &lt; 4; j++)
      s += hex_chr[(n &gt;&gt; (j * 8 + 4)) &amp; 0x0F] +
      hex_chr[(n &gt;&gt; (j * 8)) &amp; 0x0F];
    return s;
  };
  var hex = function(x) {
    for (var i = 0; i &lt; x.length; i++)
      x[i] = rhex(x[i]);
    return x.join('');
  };
  var add32 = function(a, b) {
    return (a + b) &amp; 0xFFFFFFFF;
  };
  return function(s) {
    return hex(md51(s));
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.priorityQueue.js */
angular.module('sn.common.util').factory('priorityQueue', function() {
  'use strict';
  return function(comparator) {
    var items = [];
    var compare = comparator || function(a, b) {
      return a - b;
    };
    var swap = function(a, b) {
      var temp = items[a];
      items[a] = items[b];
      items[b] = temp;
    };
    var bubbleUp = function(pos) {
      var parent;
      while (pos &gt; 0) {
        parent = (pos - 1) &gt;&gt; 1;
        if (compare(items[pos], items[parent]) &gt;= 0)
          break;
        swap(parent, pos);
        pos = parent;
      }
    };
    var bubbleDown = function(pos) {
      var left, right, min, last = items.length - 1;
      while (true) {
        left = (pos &lt;&lt; 1) + 1;
        right = left + 1;
        min = pos;
        if (left &lt;= last &amp;&amp; compare(items[left], items[min]) &lt; 0)
          min = left;
        if (right &lt;= last &amp;&amp; compare(items[right], items[min]) &lt; 0)
          min = right;
        if (min === pos)
          break;
        swap(min, pos);
        pos = min;
      }
    };
    return {
      add: function(item) {
        items.push(item);
        bubbleUp(items.length - 1);
      },
      poll: function() {
        var first = items[0],
          last = items.pop();
        if (items.length &gt; 0) {
          items[0] = last;
          bubbleDown(0);
        }
        return first;
      },
      peek: function() {
        return items[0];
      },
      clear: function() {
        items = [];
      },
      inspect: function() {
        return angular.toJson(items, true);
      },
      get size() {
        return items.length;
      },
      get all() {
        return items;
      },
      set comparator(fn) {
        compare = fn;
      }
    };
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snResource.js */
angular.module('sn.common.util').factory('snResource', function($http, $q, priorityQueue, md5) {
  'use strict';
  var methods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'jsonp', 'trace'],
    queue = priorityQueue(function(a, b) {
      return a.timestamp - b.timestamp;
    }),
    resource = {},
    pendingRequests = [],
    inFlightRequests = [];
  return function() {
    var requestInterceptors = $http.defaults.transformRequest,
      responseInterceptors = $http.defaults.transformResponse;
    var next = function() {
      var request = queue.peek();
      pendingRequests.shift();
      inFlightRequests.push(request.hash);
      $http(request.config).then(function(response) {
        request.deferred.resolve(response);
      }, function(reason) {
        request.deferred.reject(reason);
      }).finally(function() {
        queue.poll();
        inFlightRequests.shift();
        if (queue.size &gt; 0)
          next();
      });
    };
    angular.forEach(methods, function(method) {
      resource[method] = function(url, data) {
        var deferredRequest = $q.defer(),
          promise = deferredRequest.promise,
          deferredAbort = $q.defer(),
          config = {
            method: method,
            url: url,
            data: data,
            transformRequest: requestInterceptors,
            transformResponse: responseInterceptors,
            timeout: deferredAbort.promise
          },
          hash = md5(JSON.stringify(config));
        pendingRequests.push(hash);
        queue.add({
          config: config,
          deferred: deferredRequest,
          timestamp: Date.now(),
          hash: hash
        });
        if (queue.size === 1)
          next();
        promise.abort = function() {
          deferredAbort.resolve('Request cancelled');
        };
        return promise;
      };
    });
    resource.addRequestInterceptor = function(fn) {
      requestInterceptors = requestInterceptors.concat([fn]);
    };
    resource.addResponseInterceptor = function(fn) {
      responseInterceptors = responseInterceptors.concat([fn]);
    };
    resource.queueSize = function() {
      return queue.size;
    };
    resource.queuedRequests = function() {
      return queue.all;
    };
    return resource;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snConnect.js */
angular.module("sn.common.util").service("snConnectService", function($http, snCustomEvent) {
  "use strict";
  var connectPaths = ["/$c.do", "/$chat.do"];

  function canOpenInFrameset() {
    return window.top.NOW.collaborationFrameset;
  }

  function isInConnect() {
    var parentPath = getParentPath();
    return connectPaths.some(function(path) {
      return parentPath == path;
    });
  }

  function getParentPath() {
    try {
      return window.top.location.pathname;
    } catch (IGNORED) {
      return "";
    }
  }

  function openWithProfile(profile) {
    if (isInConnect() || canOpenInFrameset())
      snCustomEvent.fireTop('chat:open_conversation', profile);
    else
      window.open("$c.do#/with/" + profile.sys_id, "_blank");
  }
  return {
    openWithProfile: openWithProfile
  }
});;
/*! RESOURCE: /scripts/sn/common/util/snPolyfill.js */
(function() {
  "use strict";
  polyfill(String.prototype, 'startsWith', function(prefix) {
    return this.indexOf(prefix) === 0;
  });
  polyfill(String.prototype, 'endsWith', function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  });
  polyfill(Number, 'isNaN', function(value) {
    return value !== value;
  });
  polyfill(window, 'btoa', function(input) {
    var str = String(input);
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    for (
      var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 &amp; block &gt;&gt; 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3 / 4);
      if (charCode &gt; 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block &lt;&lt; 8 | charCode;
    }
    return output;
  });

  function polyfill(obj, slot, fn) {
    if (obj[slot] === void(0)) {
      obj[slot] = fn;
    }
  }
  window.console = window.console || {
    log: function() {}
  };
})();;
/*! RESOURCE: /scripts/sn/common/util/directive.snFocus.js */
angular.module('sn.common.util').directive('snFocus', function($timeout) {
  'use strict';
  return function(scope, element, attrs) {
    scope.$watch(attrs.snFocus, function(value) {
      if (value !== true)
        return;
      $timeout(function() {
        element[0].focus();
      });
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snResizeHeight.js */
angular.module('sn.common.util').directive('snResizeHeight', function($timeout) {
  "use strict";
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      var typographyStyles = [
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
      ];
      var maxHeight = parseInt(elem.css('max-height'), 10) || 0;
      var offset = 0;
      if (elem.css('box-sizing') === 'border-box' || elem.css('-moz-box-sizing') === 'border-box' || elem.css('-webkit-box-sizing') === 'border-box')
        offset = elem.outerHeight() - elem.height();
      var styles = {};
      angular.forEach(typographyStyles, function(val) {
        styles[val] = elem.css(val);
      });
      var $clone = angular.element('&lt;textarea rows="1" tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"&gt;&lt;/textarea&gt;');
      $clone.css(styles);
      $timeout(function() {
        angular.element(document.body).append($clone);
        reSize();
      }, 0, false);
      if (window.chrome) {
        var width = elem[0].style.width;
        elem[0].style.width = '0px';
        var ignore = elem[0].offsetWidth;
        elem[0].style.width = width;
      }

      function reSize() {
        if (!setWidth())
          return;
        if (!elem[0].value &amp;&amp; attrs['placeholder'])
          $clone[0].value = attrs['placeholder'] || '';
        else
          $clone[0].value = elem[0].value;
        $clone[0].scrollTop = 0;
        $clone[0].scrollTop = 9e4;
        var newHeight = $clone[0].scrollTop;
        if (maxHeight &amp;&amp; newHeight &gt; maxHeight) {
          newHeight = maxHeight;
          elem[0].style.overflow = "auto";
        } else
          elem[0].style.overflow = "hidden";
        newHeight += offset;
        elem[0].style.height = newHeight + "px";
      }

      function setWidth() {
        var width;
        var style = window.getComputedStyle ? window.getComputedStyle(elem[0], null) : false;
        if (style) {
          width = elem[0].getBoundingClientRect().width;
          if (width === 0 || typeof width !== 'number') {
            if (style.width.length &amp;&amp; style.width[style.width.length - 1] === '%') {
              $timeout(reSize, 0, false);
              return false;
            }
            width = parseInt(style.width, 10);
          }
          angular.forEach(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(val) {
            width -= parseInt(style[val], 10);
          });
        } else {
          width = Math.max(elem.width(), 0);
        }
        $clone[0].style.width = width + 'px';
        return true;
      }
      scope.$watch(
        function() {
          return elem[0].value
        },
        function(newValue, oldValue) {
          if (newValue === oldValue)
            return;
          reSize();
        }
      );
      elem.on('input.resize', reSize);
      if (attrs['snResizeHeight'] == "trim") {
        elem.on('blur', function() {
          elem.val(elem.val().trim());
          reSize();
        });
      }
      scope.$on('$destroy', function() {
        $clone.remove();
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBlurOnEnter.js */
angular.module('sn.common.util').directive('snBlurOnEnter', function() {
  'use strict';
  return function(scope, element) {
    element.bind("keydown keypress", function(event) {
      if (event.which !== 13)
        return;
      element.blur();
      event.preventDefault();
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snStickyHeaders.js */
angular.module('sn.common.util').directive('snStickyHeaders', function() {
  "use strict";
  return {
    restrict: 'A',
    transclude: false,
    replace: false,
    link: function(scope, element, attrs) {
      element.addClass('sticky-headers');
      var containers;
      var scrollContainer = element.find('[sn-sticky-scroll-container]');
      scrollContainer.addClass('sticky-scroll-container');

      function refreshHeaders() {
        if (attrs.snStickyHeaders !== 'false') {
          angular.forEach(containers, function(container) {
            var stickyContainer = angular.element(container);
            var stickyHeader = stickyContainer.find('[sn-sticky-header]');
            var stickyOffset = stickyContainer.position().top + stickyContainer.outerHeight();
            stickyContainer.addClass('sticky-container');
            if (stickyOffset &lt; stickyContainer.outerHeight() &amp;&amp; stickyOffset &gt; -stickyHeader.outerHeight()) {
              stickyContainer.css('padding-top', stickyHeader.outerHeight());
              stickyHeader.css('width', stickyHeader.outerWidth());
              stickyHeader.removeClass('sticky-header-disabled').addClass('sticky-header-enabled');
            } else {
              stickyContainer.css('padding-top', '');
              stickyHeader.css('width', '');
              stickyHeader.removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
            }
          });
        } else {
          element.find('[sn-sticky-container]').removeClass('sticky-container');
          element.find('[sn-sticky-container]').css('padding-top', '');
          element.find('[sn-sticky-header]').css('width', '');
          element.find('[sn-sticky-header]').removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
        }
      }
      scope.$watch(function() {
        scrollContainer.find('[sn-sticky-header]').addClass('sticky-header');
        containers = element.find('[sn-sticky-container]');
        return attrs.snStickyHeaders;
      }, refreshHeaders);
      scope.$watch(function() {
        return scrollContainer[0].scrollHeight;
      }, refreshHeaders);
      scrollContainer.on('scroll', refreshHeaders);
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/ui/js_includes_ui.js */
/*! RESOURCE: /scripts/sn/common/ui/_module.js */
angular.module('sn.common.ui', ['sn.common.messaging']);;
/*! RESOURCE: /scripts/sn/common/ui/popover/js_includes_ui_popover.js */
/*! RESOURCE: /scripts/sn/common/ui/popover/_module.js */
angular.module('sn.common.ui.popover', []);;
/*! RESOURCE: /scripts/sn/common/ui/popover/directive.snBindPopoverSelection.js */
angular.module('sn.common.ui.popover').directive('snBindPopoverSelection', function(snCustomEvent) {
  "use strict";
  return {
    restrict: "A",
    controller: function($scope, $element, $attrs, snCustomEvent) {
      snCustomEvent.observe('list.record_select', recordSelectDataHandler);

      function recordSelectDataHandler(data, event) {
        if (!data || !event)
          return;
        event.stopPropagation();
        var ref = ($scope.field) ? $scope.field.ref : $attrs.ref;
        if (data.ref === ref) {
          if (window.g_form) {
            if ($attrs.addOption) {
              addGlideListChoice('select_0' + $attrs.ref, data.value, data.displayValue);
            } else {
              var fieldValue = typeof $attrs.ref === 'undefined' ? data.ref : $attrs.ref;
              window.g_form._setValue(fieldValue, data.value, data.displayValue);
              clearDerivedFields(data.value);
            }
          }
          if ($scope.field) {
            $scope.field.value = data.value;
            $scope.field.displayValue = data.displayValue;
          }
        }
      }

      function clearDerivedFields(value) {
        if (window.DerivedFields) {
          var df = new DerivedFields($scope.field ? $scope.field.ref : $attrs.ref);
          df.clearRelated();
          df.updateRelated(value);
        }
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/popover/directive.snComplexPopover.js */
angular.module('sn.common.ui.popover').directive('snComplexPopover', function(getTemplateUrl, $q, $http, $templateCache, $compile, $timeout, $window) {
  "use strict";
  return {
    restrict: 'E',
    replace: true,
    templateUrl: function(elem, attrs) {
      return getTemplateUrl(attrs.buttonTemplate);
    },
    controller: function($scope, $element, $attrs, $q, $document, snCustomEvent, snComplexPopoverService) {
      $scope.type = $attrs.complexPopoverType || "complex_popover";
      if ($scope.closeEvent) {
        if (typeof $scope.closeEvent === "string") {
          snCustomEvent.observe($scope.closeEvent, destroyPopover);
          $scope.$on($scope.closeEvent, destroyPopover);
        } else if (typeof $scope.closeEvent === "object") {
          $scope.closeEvent.forEach(function(event) {
            snCustomEvent.observe(event, destroyPopover);
            $scope.$on(event, destroyPopover);
          })
        }
      }
      $scope.$parent.$on('$destroy', destroyPopover);
      var newScope;
      var open;
      var popover;
      var content;
      var popoverDefaults = {
        container: 'body',
        html: true,
        placement: 'auto',
        trigger: 'manual',
        template: '&lt;div class="complex_popover popover" role="tooltip"&gt;&lt;div class="arrow"&gt;&lt;/div&gt;&lt;div class="popover-content"&gt;&lt;/div&gt;&lt;/div&gt;'
      };
      var popoverConfig = angular.extend(popoverDefaults, $scope.popoverConfig);
      $scope.loading = false;
      $scope.initialized = false;
      $scope.togglePopover = function(event) {
        if (!$scope.initialized) {
          showPopover(event);
        } else {
          destroyPopover();
        }
      };

      function showPopover(e) {
        if ($scope.loading)
          return;
        $scope.$toggleButton = angular.element(e.target);
        $scope.loading = true;
        $scope.$emit('list.toggleLoadingState', true);
        _getTemplate()
          .then(_insertTemplate)
          .then(_createPopover)
          .then(_bindHtml)
          .then(function() {
            $scope.loading = false;
            $scope.initialized = true;
            if (!$scope.loadEvent)
              _openPopover();
          });
      }

      function destroyPopover() {
        if (!newScope)
          return;
        $scope.$toggleButton.on('hidden.bs.popover', function() {
          open = false;
          $scope.$toggleButton.data('bs.popover').$element.removeData('bs.popover').off('.popover');
          $scope.$toggleButton = null;
          snCustomEvent.fire('hidden.complexpopover.' + $scope.ref);
        });
        $scope.$toggleButton.popover('hide');
        snCustomEvent.fire('hide.complexpopover.' + $scope.ref, $scope.$toggleButton);
        newScope.$broadcast('$destroy');
        newScope.$destroy();
        newScope = null;
        $scope.initialized = false;
        angular.element('html').off('click', complexHtmlHandler);
      }

      function _getTemplate() {
        return snComplexPopoverService.getTemplate(getTemplateUrl($attrs.template));
      }

      function _createPopover() {
        $scope.$toggleButton.popover(popoverConfig);
        return $q.when(true);
      }

      function _insertTemplate(response) {
        newScope = $scope.$new();
        if ($scope.loadEvent)
          newScope.$on($scope.loadEvent, _openPopover);
        content = $compile(response.data)(newScope);
        popoverConfig.content = content;
        newScope.open = true;
        snCustomEvent.fire('inserted.complexpopover.' + $scope.ref, $scope.$toggleButton);
        return $q.when(true);
      }

      function _bindHtml() {
        angular.element('html').on('click', complexHtmlHandler);
        return $q.when(true);
      }

      function complexHtmlHandler(e) {
        var parentComplexPopoverScope = angular.element(e.target).parents('.popover-content').children().scope();
        if (parentComplexPopoverScope &amp;&amp; (parentComplexPopoverScope.type = "complex_popover") &amp;&amp; $scope.type === "complex_popover")
          return;
        if (angular.element(e.target).parents('html').length === 0)
          return;
        if ($scope.initialized &amp;&amp; !$scope.loading &amp;&amp; !$scope.$toggleButton.is(e.target) &amp;&amp; content.parents('.popover').has(angular.element(e.target)).length === 0) {
          e.preventDefault();
          e.stopPropagation();
          destroyPopover(e);
        }
      }

      function _openPopover() {
        if (open)
          return;
        open = true;
        $timeout(function() {
          $scope.$toggleButton.popover('show');
          snCustomEvent.fire('show.complexpopover.' + $scope.ref, $scope.$toggleButton);
          $scope.$toggleButton.on('shown.bs.popover', function() {
            snCustomEvent.fire('shown.complexpopover.' + $scope.ref, $scope.$toggleButton);
          });
        }, 0);
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/popover/service.snComplexPopoverService.js */
angular.module('sn.common.ui.popover').service('snComplexPopoverService', function($http, $q, $templateCache) {
  "use strict";
  return {
    getTemplate: getTemplate
  };

  function getTemplate(template) {
    return $http.get(template, {
      cache: $templateCache
    });
  }
});;;
/*! RESOURCE: /scripts/sn/common/ui/directive.snConfirmModal.js */
angular.module('sn.common.ui').directive('snConfirmModal', function(getTemplateUrl) {
  return {
    templateUrl: getTemplateUrl('sn_confirm_modal.xml'),
    restrict: 'E',
    replace: true,
    transclude: true,
    scope: {
      config: '=?',
      modalName: '@',
      title: '@?',
      message: '@?',
      cancelButton: '@?',
      okButton: '@?',
      alertButton: '@?',
      cancel: '&amp;?',
      ok: '&amp;?',
      alert: '&amp;?'
    },
    link: function(scope, element) {
      element.find('.modal').remove();
    },
    controller: function($scope, $rootScope) {
      $scope.config = $scope.config || {};

      function Button(fn, text) {
        return {
          fn: fn,
          text: text
        }
      }
      var buttons = {
        'cancelButton': new Button('cancel', 'Cancel'),
        'okButton': new Button('ok', 'OK'),
        'alertButton': new Button('alert', 'Close'),
        getText: function(type) {
          var button = this[type];
          if (button &amp;&amp; $scope.get(button.fn))
            return button.text;
        }
      };
      $scope.get = function(type) {
        if ($scope.config[type])
          return $scope.config[type];
        if (!$scope[type]) {
          var text = buttons.getText(type);
          if (text)
            return $scope.config[type] = text;
        }
        return $scope.config[type] = $scope[type];
      };
      if (!$scope.get('modalName'))
        $scope.config.modalName = 'confirm-modal';

      function call(type) {
        var action = $scope.get(type);
        if (action) {
          if (angular.isFunction(action))
            action();
          return true;
        }
        return !!buttons.getText(type);
      }
      $scope.cancelPressed = close('cancel');
      $scope.okPressed = close('ok');
      $scope.alertPressed = close('alert');

      function close(type) {
        return function() {
          actionClosed = true;
          $rootScope.$broadcast('dialog.' + $scope.config.modalName + '.close');
          call(type);
        }
      }
      var actionClosed;
      $scope.$on('dialog.' + $scope.get('modalName') + '.opened', function() {
        actionClosed = false;
      });
      $scope.$on('dialog.' + $scope.get('modalName') + '.closed', function() {
        if (actionClosed)
          return;
        if (call('cancel'))
          return;
        if (call('alert'))
          return;
        call('ok');
      });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snContextMenu.js */
angular.module('sn.common.ui').directive('contextMenu', function($document, $window, snCustomEvent) {
  var $contextMenu, $ul;
  var scrollHeight = angular.element("body").get(0).scrollHeight;
  var contextMenuItemHeight = 0;

  function setContextMenuPosition(event, $ul) {
    if (contextMenuItemHeight === 0)
      contextMenuItemHeight = 24;
    var cmWidth = 150;
    var cmHeight = contextMenuItemHeight * $ul.children().length;
    var startX = event.pageX + cmWidth &gt;= $window.innerWidth ? event.pageX - cmWidth : event.pageX;
    var startY = event.pageY + cmHeight &gt;= $window.innerHeight ? event.pageY - cmHeight : event.pageY;
    $ul.css({
      display: 'block',
      position: 'absolute',
      left: startX,
      top: startY
    });
  }

  function renderContextMenuItems($scope, event, options) {
    $ul.empty();
    angular.forEach(options, function(item) {
      var $li = angular.element('&lt;li&gt;');
      if (item === null) {
        $li.addClass('divider');
      } else {
        var $a = angular.element('&lt;a&gt;');
        $a.attr({
          tabindex: '-1'
        });
        $a.text(typeof item[0] == 'string' ? item[0] : item[0].call($scope, $scope));
        $li.append($a);
        $li.on('click', function($event) {
          $event.preventDefault();
          $scope.$apply(function() {
            _clearContextMenus(event);
            item[1].call($scope, $scope);
          });
        });
      }
      $ul.append($li);
    });
    setContextMenuPosition(event, $ul);
  }
  var renderContextMenu = function($scope, event, options) {
    angular.element(event.currentTarget).addClass('context');
    $contextMenu = angular.element('&lt;div&gt;', {
      'class': 'dropdown clearfix context-dropdown open'
    });
    $contextMenu.on('click', function(e) {
      if (angular.element(e.target).hasClass('dropdown')) {
        _clearContextMenus(event);
      }
    });
    $contextMenu.on('contextmenu', function(event) {
      event.preventDefault();
      _clearContextMenus(event);
    });
    $contextMenu.css({
      position: 'absolute',
      top: 0,
      height: scrollHeight,
      left: 0,
      right: 0,
      zIndex: 9999
    });
    $document.find('body').append($contextMenu);
    $ul = angular.element('&lt;ul&gt;', {
      'class': 'dropdown-menu',
      'role': 'menu'
    });
    renderContextMenuItems($scope, event, options);
    $contextMenu.append($ul);
    $contextMenu.data('resizeHandler', function() {
      scrollHeight = angular.element("body").get(0).scrollHeight;
      $contextMenu.css('height', scrollHeight);
    });
    snCustomEvent.observe('partial.page.reload', $contextMenu.data('resizeHandler'));
  };

  function _clearContextMenus(event) {
    if (!event) {
      return;
    }
    angular.element(event.currentTarget).removeClass('context');
    var els = angular.element(".context-dropdown");
    angular.forEach(els, function(el) {
      snCustomEvent.un('partial.page.reload', angular.element(el).data('resizeHandler'));
      angular.element(el).remove();
    });
  }
  return function(scope, element, attrs) {
    element.on('contextmenu', function(event) {
      if (event.ctrlKey)
        return;
      if (angular.element(element).attr('context-type'))
        return;
      scope.$apply(function() {
        applyMenu(event);
        clearWindowSelection();
      });
    });
    element.on('click', function(event) {
      var $el = angular.element(element);
      var $target = angular.element(event.target);
      if (!$el.attr('context-type') &amp;&amp; !$target.hasClass('context-menu-click'))
        return;
      scope.$apply(function() {
        applyMenu(event);
        clearWindowSelection();
      });
    });

    function clearWindowSelection() {
      if (window.getSelection)
        if (window.getSelection().empty)
          window.getSelection().empty();
        else if (window.getSelection().removeAllRanges)
        window.getSelection().removeAllRanges();
      else if (document.selection)
        document.selection.empty();
    }

    function applyMenu(event) {
      var tagName = event.target.tagName;
      if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'BUTTON') {
        return;
      }
      var menu = scope.$eval(attrs.contextMenu);
      if (menu instanceof Array) {
        if (menu.length &gt; 0) {
          event.stopPropagation();
          event.preventDefault();
          scope.$watch(function() {
            return menu;
          }, function(newValue, oldValue) {
            if (newValue !== oldValue) renderContextMenuItems(scope, event, menu);
          }, true);
          renderContextMenu(scope, event, menu);
        }
      } else if (typeof menu !== 'undefined' &amp;&amp; typeof menu.then === 'function') {
        event.stopPropagation();
        event.preventDefault();
        menu.then(function(response) {
          var contextMenu = response;
          if (contextMenu.length &gt; 0) {
            scope.$watch(function() {
              return contextMenu;
            }, function(newValue, oldValue) {
              if (newValue !== oldValue)
                renderContextMenuItems(scope, event, contextMenu);
            }, true);
            renderContextMenu(scope, event, contextMenu);
          } else {
            throw '"' + attrs.contextMenu + '" is not an array or promise';
          }
        });
      } else {
        throw '"' + attrs.contextMenu + '" is not an array or promise';
      }
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snDialog.js */
angular.module("sn.common.ui").directive("snDialog", function($timeout, $rootScope, $document) {
  "use strict";
  return {
    restrict: "AE",
    transclude: true,
    scope: {
      modal: "=?",
      disableAutoFocus: "=?",
      classCheck: "="
    },
    replace: true,
    template: '&lt;dialog&gt;&lt;div ng-click="onClickClose()" class="close-button icon-button icon-cross"&gt;&lt;/div&gt;&lt;/dialog&gt;',
    link: function(scope, element, attrs, ctrl, transcludeFn) {
      var transcludeScope = {};
      scope.isOpen = function() {
        return element[0].open;
      };
      transcludeFn(element.scope().$new(), function(a, b) {
        element.append(a);
        transcludeScope = b;
      });
      element.click(function(event) {
        event.stopPropagation();
        if (event.offsetX &lt; 0 || event.offsetX &gt; element[0].offsetWidth || event.offsetY &lt; 0 || event.offsetY &gt; element[0].offsetHeight)
          if (!scope.classCheck)
            scope.onClickClose();
          else {
            var classes = scope.classCheck.split(",");
            var found = false;
            for (var i = 0; i &lt; classes.length; i++)
              if (angular.element(event.srcElement).closest(classes[i]).length &gt; 0)
                found = true;
            if (!found)
              scope.onClickClose();
          }
      });
      scope.show = function() {
        var d = element[0];
        if (!d.showModal || true) {
          dialogPolyfill.registerDialog(d);
          d.setDisableAutoFocus(scope.disableAutoFocus);
        }
        if (scope.modal)
          d.showModal();
        else
          d.show();
        if (!angular.element(d).hasClass('sn-alert')) {
          $timeout(function() {
            if (d.dialogPolyfillInfo &amp;&amp; d.dialogPolyfillInfo.backdrop) {
              angular.element(d.dialogPolyfillInfo.backdrop).one('click', function(event) {
                if (!scope.classCheck || angular.element(event.srcElement).closest(scope.classCheck).length == 0)
                  scope.onClickClose();
              })
            } else {
              $document.on('click', function(event) {
                if (!scope.classCheck || angular.element(event.srcElement).closest(scope.classCheck).length == 0)
                  scope.onClickClose();
              })
            }
          });
        }
      };
      scope.setPosition = function(data) {
        var contextData = scope.getContextData(data);
        if (contextData &amp;&amp; element &amp;&amp; element[0]) {
          if (contextData.position) {
            element[0].style.top = contextData.position.top + "px";
            element[0].style.left = contextData.position.left + "px";
            element[0].style.margin = "0px";
          }
          if (contextData.dimensions) {
            element[0].style.width = contextData.dimensions.width + "px";
            element[0].style.height = contextData.dimensions.height + "px";
          }
        }
      }
      scope.$on("dialog." + attrs.name + ".move", function(event, data) {
        scope.setPosition(data);
      })
      scope.$on("dialog." + attrs.name + ".show", function(event, data) {
        scope.setPosition(data);
        scope.setKeyEvents(data);
        if (scope.isOpen() === true)
          scope.close();
        else
          scope.show();
        angular.element(".sn-dialog-menu").each(function(index, value) {
          var name = angular.element(this).attr('name');
          if (name != attrs.name &amp;&amp; !angular.element(this).attr('open')) {
            return true;
          }
          if (name != attrs.name &amp;&amp; angular.element(this).attr('open')) {
            $rootScope.$broadcast("dialog." + name + ".close");
          }
        });
      })
      scope.onClickClose = function() {
        if (scope.isOpen())
          $rootScope.$broadcast("dialog." + attrs.name + ".close");
      }
      scope.close = function() {
        var d = element[0];
        d.close();
        scope.removeListeners();
      }
      scope.ok = function(contextData) {
        contextData.ok();
        scope.removeListeners();
      }
      scope.cancel = function(contextData) {
        contextData.cancel();
        scope.removeListeners();
      }
      scope.removeListeners = function() {
        element[0].removeEventListener("ok", scope.handleContextOk, false);
        element[0].removeEventListener("cancel", scope.handleContextCancel, false);
      }
      scope.setKeyEvents = function(data) {
        var contextData = scope.getContextData(data);
        if (contextData &amp;&amp; contextData.cancel) {
          scope.handleContextOk = function() {
            scope.ok(contextData);
          }
          scope.handleContextCancel = function() {
            scope.cancel(contextData);
          }
          element[0].addEventListener("ok", scope.handleContextOk, false);
          element[0].addEventListener("cancel", scope.handleContextCancel, false);
        }
      }
      scope.getContextData = function(data) {
        var context = attrs.context;
        var contextData = null;
        if (context &amp;&amp; data &amp;&amp; context in data) {
          contextData = data[context];
          transcludeScope[context] = contextData;
        }
        return contextData;
      }
      scope.$on("dialog." + attrs.name + ".close", scope.close);
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snFlyout.js */
angular.module('sn.common.ui').directive('snFlyout', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    templateUrl: getTemplateUrl('sn_flyout.xml'),
    scope: true,
    link: function($scope, element, attrs) {
      $scope.open = false;
      $scope.more = false;
      $scope.position = attrs.position || 'left';
      $scope.flyoutControl = attrs.control;
      $scope.register = attrs.register;
      var body = angular.element('.flyout-body', element);
      var header = angular.element('.flyout-header', element);
      var tabs = angular.element('.flyout-tabs', element);
      var distance = 0;
      var position = $scope.position;
      var options = {
        duration: 800,
        easing: 'easeOutBounce'
      }
      var animation = {};
      if ($scope.flyoutControl) {
        $('.flyout-handle', element).hide();
        var controls = angular.element('#' + $scope.flyoutControl);
        controls.click(function() {
          angular.element(this).trigger("snFlyout.open");
        });
        controls.on('snFlyout.open', function() {
          $scope.$apply(function() {
            $scope.open = !$scope.open;
          });
        });
      }
      var animate = function() {
        element.velocity(animation, options);
      }
      var setup = function() {
        animation[position] = -distance;
        if ($scope.open)
          element.css(position, 0);
        else
          element.css(position, -distance);
      }
      var calculatePosition = function() {
        if ($scope.open) {
          animation[position] = 0;
        } else {
          if ($scope.position === 'left' || $scope.position === 'right')
            animation[position] = -body.outerWidth();
          else
            animation[position] = -body.outerHeight();
        }
      }
      $scope.$watch('open', function(newValue, oldValue) {
        if (newValue === oldValue)
          return;
        calculatePosition();
        animate();
      });
      $scope.$watch('more', function(newValue, oldValue) {
        if (newValue === oldValue)
          return;
        var moreAnimation = {};
        if ($scope.more) {
          element.addClass('fly-double');
          moreAnimation = {
            width: body.outerWidth() * 2
          };
        } else {
          element.removeClass('fly-double');
          moreAnimation = {
            width: body.outerWidth() / 2
          };
        }
        body.velocity(moreAnimation, options);
        header.velocity(moreAnimation, options);
      });
      if ($scope.position === 'left' || $scope.position === 'right') {
        $scope.$watch(element[0].offsetWidth, function() {
          element.addClass('fly-from-' + $scope.position);
          distance = body.outerWidth();
          setup();
        });
      } else if ($scope.position === 'top' || $scope.position === 'bottom') {
        $scope.$watch(element[0].offsetWidth, function() {
          element.addClass('fly-from-' + $scope.position);
          distance = body.outerHeight() + header.outerHeight();
          setup();
        });
      }
      $scope.$on($scope.register + ".bounceTabByIndex", function(event, index) {
        $scope.bounceTab(index);
      });
      $scope.$on($scope.register + ".bounceTab", function(event, tab) {
        $scope.bounceTab($scope.tabs.indexOf(tab));
      });
      $scope.$on($scope.register + ".selectTabByIndex", function(event, index) {
        $scope.selectTab($scope.tabs[index]);
      });
      $scope.$on($scope.register + ".selectTab", function(event, tab) {
        $scope.selectTab(tab);
      });
    },
    controller: function($scope, $element) {
      $scope.tabs = [];
      var baseColor, highLightColor;
      $scope.selectTab = function(tab) {
        if ($scope.selectedTab)
          $scope.selectedTab.selected = false;
        tab.selected = true;
        $scope.selectedTab = tab;
        normalizeTab($scope.tabs.indexOf(tab));
      }

      function expandTab(tabElem) {
        tabElem.queue("tabBounce", function(next) {
          tabElem.velocity({
            width: ["2.5rem", "2.125rem"],
            backgroundColorRed: [highLightColor[0], baseColor[0]],
            backgroundColorGreen: [highLightColor[1], baseColor[1]],
            backgroundColorBlue: [highLightColor[2], baseColor[2]]
          }, {
            easing: "easeInExpo",
            duration: 250
          });
          next();
        });
      }

      function contractTab(tabElem) {
        tabElem.queue("tabBounce", function(next) {
          tabElem.velocity({
            width: ["2.125rem", "2.5rem"],
            backgroundColorRed: [baseColor[0], highLightColor[0]],
            backgroundColorGreen: [baseColor[1], highLightColor[1]],
            backgroundColorBlue: [baseColor[2], highLightColor[2]]
          }, {
            easing: "easeInExpo",
            duration: 250
          });
          next();
        });
      }
      $scope.bounceTab = function(index) {
        if (index &gt;= $scope.tabs.length || index &lt; 0)
          return;
        var tabScope = $scope.tabs[index];
        if (!tabScope.selected) {
          var tabElem = $element.find('.flyout-tab').eq(index);
          if (!baseColor) {
            baseColor = tabElem.css('backgroundColor').match(/[0-9]+/g);
            for (var i = 0; i &lt; baseColor.length; i++)
              baseColor[i] = parseInt(baseColor[i], 10);
          }
          if (!highLightColor)
            highLightColor = invertColor(baseColor);
          if (tabScope.highlighted)
            contractTab(tabElem);
          for (var i = 0; i &lt; 2; i++) {
            expandTab(tabElem);
            contractTab(tabElem);
          }
          expandTab(tabElem);
          tabElem.dequeue("tabBounce");
          tabScope.highlighted = true;
        }
      }
      $scope.toggleOpen = function() {
        $scope.open = !$scope.open;
      }
      this.addTab = function(tab) {
        $scope.tabs.push(tab);
        if ($scope.tabs.length === 1)
          $scope.selectTab(tab)
      }

      function normalizeTab(index) {
        if (index &lt; 0 || index &gt;= $scope.tabs.length || !$scope.tabs[index].highlighted)
          return;
        var tabElem = $element.find('.flyout-tab').eq(index);
        tabElem.velocity({
          width: ["2.125rem", "2.5rem"]
        }, {
          easing: "easeInExpo",
          duration: 250
        });
        tabElem.css('backgroundColor', '');
        $scope.tabs[index].highlighted = false;
      }

      function invertColor(rgb) {
        if (typeof rgb === "string")
          var color = rgb.match(/[0-9]+/g);
        else
          var color = rgb.slice(0);
        for (var i = 0; i &lt; color.length; i++)
          color[i] = 255 - parseInt(color[i], 10);
        return color;
      }
    }
  }
}).directive("snFlyoutTab", function() {
  "use strict";
  return {
    restrict: "E",
    require: "^snFlyout",
    replace: true,
    scope: true,
    transclude: true,
    template: "&lt;div ng-show='selected' ng-transclude='' style='height: 100%'&gt;&lt;/div&gt;",
    link: function(scope, element, attrs, flyoutCtrl) {
      flyoutCtrl.addTab(scope);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/ui/directive.snModal.js */
angular.module("sn.common.ui").directive("snModal", function($timeout, $rootScope) {
  "use strict";
  return {
    restrict: "AE",
    transclude: true,
    scope: {},
    replace: true,
    template: '&lt;div tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;&lt;/div&gt;',
    link: function(scope, element, attrs, ctrl, transcludeFn) {
      var transcludeScope = {};
      transcludeFn(element.scope().$new(), function(a, b) {
        element.append(a);
        transcludeScope = b;
      });
      scope.$on("dialog." + attrs.name + ".show", function(event, data) {
        if (!isOpen())
          show(data);
      });
      scope.$on("dialog." + attrs.name + ".close", function() {
        if (isOpen())
          close();
      });

      function eventFn(eventName) {
        return function(e) {
          $rootScope.$broadcast("dialog." + attrs.name + "." + eventName, e);
        }
      }
      var events = {
        'shown.bs.modal': eventFn("opened"),
        'hide.bs.modal': eventFn("hide"),
        'hidden.bs.modal': eventFn("closed")
      };

      function show(data) {
        var context = attrs.context;
        var contextData = null;
        if (context &amp;&amp; data &amp;&amp; context in data) {
          contextData = data[context];
          transcludeScope[context] = contextData;
        }
        $timeout(function() {
          angular.element('.sn-popover-basic').each(function() {
            var $this = angular.element(this);
            if (angular.element($this.attr('data-target')).is(':visible')) {
              $this.popover('hide');
            }
          });
        });
        element.modal('show');
        for (var event in events)
          if (events.hasOwnProperty(event))
            element.on(event, events[event]);
      }

      function close() {
        element.modal('hide');
        for (var event in events)
          if (events.hasOwnProperty(event))
            element.off(event, events[event]);
      }

      function isOpen() {
        return element.hasClass('in');
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snModalShow.js */
angular.module('sn.common.ui').directive('snModalShow', function() {
  "use strict";
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      element.click(function() {
        showDialog();
      });
      element.keyup(function(evt) {
        if (evt.which != 13)
          return;
        showDialog();
      });

      function showDialog() {
        scope.$broadcast('dialog.' + attrs.snModalShow + '.show');
      }
      if (window.SingletonKeyboardRegistry) {
        SingletonKeyboardRegistry.getInstance().bind('ctrl + alt + i', function() {
          scope.$broadcast('dialog.impersonate.show');
        }).selector(null, true);
      }
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snTabs.js */
angular.module('sn.common.ui').directive('snTabs', function() {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    scope: {
      tabData: '='
    },
    link: function($scope, element, attrs) {
      $scope.tabClass = attrs.tabClass;
      $scope.register = attrs.register;
      attrs.$observe('register', function(value) {
        $scope.register = value;
        $scope.setupListeners();
      });
      $scope.bounceTab = function() {
        angular.element()
      }
    },
    controller: 'snTabs'
  }
}).controller('snTabs', function($scope, $rootScope) {
  $scope.selectedTabIndex = 0;
  $scope.tabData[$scope.selectedTabIndex].selected = true;
  $scope.setupListeners = function() {
    $scope.$on($scope.register + '.selectTabByIndex', function(event, index) {
      $scope.selectTabByIndex(event, index);
    });
  }
  $scope.selectTabByIndex = function(event, index) {
    if (index === $scope.selectedTabIndex)
      return;
    if (event.stopPropagation)
      event.stopPropagation();
    $scope.tabData[$scope.selectedTabIndex].selected = false;
    $scope.tabData[index].selected = true;
    $scope.selectedTabIndex = index;
    $rootScope.$broadcast($scope.register + '.selectTabByIndex', $scope.selectedTabIndex);
  }
}).directive('snTab', function() {
  'use strict';
  return {
    restrict: 'E',
    transclude: true,
    replace: 'true',
    scope: {
      tabData: '=',
      index: '='
    },
    template: '',
    controller: 'snTab',
    link: function($scope, element, attrs) {
      $scope.register = attrs.register;
      attrs.$observe('register', function(value) {
        $scope.register = value;
        $scope.setupListeners();
      });
      $scope.bounceTab = function() {
        alert('Bounce Tab at Index: ' + $scope.index);
      }
    }
  }
}).controller('snTab', function($scope) {
  $scope.selectTabByIndex = function(index) {
    $scope.$emit($scope.register + '.selectTabByIndex', index);
  }
  $scope.setupListeners = function() {
    $scope.$on($scope.register + '.showTabActivity', function(event, index, type) {
      $scope.showTabActivity(index, type);
    });
  }
  $scope.showTabActivity = function(index, type) {
    if ($scope.index !== index)
      return;
    switch (type) {
      case 'message':
        break;
      case 'error':
        break;
      default:
        $scope.bounceTab();
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snTextExpander.js */
angular.module('sn.common.ui').directive('snTextExpander', function(getTemplateUrl, $timeout) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl('sn_text_expander.xml'),
    scope: {
      maxHeight: '&amp;',
      value: '='
    },
    link: function compile(scope, element, attrs) {
      var container = angular.element(element).find('.textblock-content-container');
      var content = angular.element(element).find('.textblock-content');
      if (scope.maxHeight() === undefined) {
        scope.maxHeight = function() {
          return 100;
        }
      }
      container.css('overflow-y', 'hidden');
      container.css('max-height', scope.maxHeight() + 'px');
    },
    controller: function($scope, $element) {
      var container = $element.find('.textblock-content-container');
      var content = $element.find('.textblock-content');
      $scope.value = $scope.value || '';
      $scope.toggleExpand = function() {
        $scope.showMore = !$scope.showMore;
        if ($scope.showMore) {
          container.css('max-height', content.height());
        } else {
          container.css('max-height', $scope.maxHeight());
        }
      };
      $timeout(function() {
        if (content.height() &gt; $scope.maxHeight()) {
          $scope.showToggle = true;
          $scope.showMore = false;
        }
      });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/ui/directive.snAttachmentPreview.js */
angular.module('sn.common.ui').directive('snAttachmentPreview', function(getTemplateUrl, snCustomEvent) {
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('sn_attachment_preview.xml'),
    controller: function($scope) {
      snCustomEvent.observe('sn.attachment.preview', function(evt, attachment) {
        if (evt.stopPropagation)
          evt.stopPropagation();
        if (evt.preventDefault)
          evt.preventDefault();
        $scope.image = attachment;
        $scope.$broadcast('dialog.attachment_preview.show');
        return false;
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/ui/service.progressDialog.js */
angular.module('sn.common.ui').factory('progressDialog', ['$rootScope', '$compile', '$timeout', '$http', '$templateCache', 'nowServer', 'i18n', function($rootScope, $compile, $timeout, $http, $templateCache, nowServer, i18n) {
  'use strict';
  i18n.getMessages(['Close']);
  return {
    STATES: ["Pending", "Running", "Succeeded", "Failed", "Cancelled"],
    STATUS_IMAGES: ["images/workflow_skipped.gif", "images/loading_anim2.gifx",
      "images/progress_success.png", "images/progress_failure.png",
      'images/request_cancelled.gif'
    ],
    EXPAND_IMAGE: "images/icons/filter_hide.gif",
    COLLAPSE_IMAGE: "images/icons/filter_reveal.gif",
    BACK_IMAGE: "images/activity_filter_off.gif",
    TIMEOUT_INTERVAL: 750,
    _findChildMessage: function(statusObject) {
      if (!statusObject.children) return null;
      for (var i = 0; i &lt; statusObject.children.length; i++) {
        var child = statusObject.children[i];
        if (child.state == '1') {
          var msg = child.message;
          var submsg = this._findChildMessage(child);
          if (submsg == null)
            return msg;
          else
            return null;
        } else if (child.state == '0') {
          return null;
        } else {}
      }
      return null;
    },
    create: function(scope, elemid, title, startCallback, endCallback, closeCallback) {
      var namespace = this;
      var progressItem = scope.$new(true);
      progressItem.id = elemid + "_progressDialog";
      progressItem.overlayVisible = true;
      progressItem.state = 0;
      progressItem.message = '';
      progressItem.percentComplete = 0;
      progressItem.enableChildMessages = false;
      if (!title) title = '';
      progressItem.title = title;
      progressItem.button_close = i18n.getMessage('Close');
      var overlayElement;
      overlayElement = $compile(
        '&lt;div id="{{id}}" ng-show="overlayVisible" class="modal modal-mask" role="dialog" tabindex="-1"&gt;' +
        '&lt;div class="modal-dialog m_progress_overlay_content"&gt;' +
        '&lt;div class="modal-content"&gt;' +
        '&lt;header class="modal-header"&gt;' +
        '&lt;h4 class="modal-title"&gt;{{title}}&lt;/h4&gt;' +
        '&lt;/header&gt;' +
        '&lt;div class="modal-body"&gt;' +
        '&lt;div class="progress" ng-class="{\'progress-danger\': (state == 3)}"&gt;' +
        '&lt;div class="progress-bar" ng-class="{\'progress-bar-danger\': (state == 3)}" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="{{percentComplete}}" ng-style="{width: percentComplete + \'%\'}"&gt;' +
        '&lt;/div&gt;' +
        '&lt;/div&gt;' +
        '&lt;div&gt;{{message}}&lt;span style="float: right;" ng-show="state==1 || state == 2"&gt;{{percentComplete}}%&lt;/span&gt;&lt;/div&gt;' +
        '&lt;/div&gt;' +
        '&lt;footer class="modal-footer"&gt;' +
        '&lt;button class="btn btn-default sn-button sn-button-normal" ng-click="close()" ng-show="state &gt; 1"&gt;{{button_close}}&lt;/button&gt;' +
        '&lt;/footer&gt;' +
        '&lt;/div&gt;' +
        '&lt;/div&gt;' +
        '&lt;/div&gt;')(progressItem);
      $("body")[0].appendChild(overlayElement[0]);
      progressItem.setEnableChildMessages = function(enableChildren) {
        progressItem.enableChildMessages = enableChildren;
      }
      progressItem.start = function(src, dataArray) {
        $http.post(src, dataArray).success(function(response) {
            progressItem.trackerId = response;
            try {
              if (startCallback) startCallback(response);
            } catch (e) {}
            $timeout(progressItem.checkProgress.bind(progressItem));
          })
          .error(function(response, status, headers, config) {
            progressItem.state = '3';
            if (endCallback) endCallback(response);
          });
      };
      progressItem.checkProgress = function() {
        var src = nowServer.getURL('progress_status', {
          sysparm_execution_id: this.trackerId
        });
        $http.post(src).success(function(response) {
            if ($.isEmptyObject(response)) {
              progressItem.state = '3';
              if (endCallback) endCallback(response);
              return;
            }
            progressItem.update(response);
            if (response.status == 'error' || response.state == '') {
              progressItem.state = '3';
              if (response.message)
                progressItem.message = response.message;
              else
                progressItem.message = response;
              if (endCallback) endCallback(response);
              return;
            }
            if (response.state == '0' || response.state == '1') {
              $timeout(progressItem.checkProgress.bind(progressItem), namespace.TIMEOUT_INTERVAL);
            } else {
              if (endCallback) endCallback(response);
            }
          })
          .error(function(response, status, headers, config) {
            progressItem.state = '3';
            progressItem.message = response;
            if (endCallback) endCallback(response);
          });
      };
      progressItem.update = function(statusObject) {
        var msg = statusObject.message;
        if (progressItem.enableChildMessages) {
          var childMsg = namespace._findChildMessage(statusObject);
          if (childMsg != null)
            msg = childMsg;
        }
        this.message = msg;
        this.state = statusObject.state;
        this.percentComplete = statusObject.percent_complete;
      };
      progressItem.close = function(ev) {
        try {
          if (closeCallback) closeCallback();
        } catch (e) {}
        $("body")[0].removeChild($("#" + this.id)[0]);
        delete namespace.progressItem;
      };
      return progressItem;
    }
  }
}]);;
/*! RESOURCE: /scripts/sn/common/ui/factory.paneManager.js */
angular.module("sn.common.ui").factory("paneManager", ['$timeout', 'userPreferences', 'snCustomEvent', function($timeout, userPreferences, snCustomEvent) {
  "use strict";
  var paneIndex = {};

  function registerPane(paneName) {
    if (!paneName in paneIndex) {
      paneIndex[paneName] = false;
    }
    userPreferences.getPreference(paneName + '.opened').then(function(value) {
      var isOpen = value !== 'false';
      if (isOpen) {
        togglePane(paneName);
      }
    });
  }

  function togglePane(paneName) {
    for (var currentPane in paneIndex) {
      if (paneName != currentPane &amp;&amp; paneIndex[currentPane]) {
        CustomEvent.fireTop(currentPane + '.toggle');
        saveState(currentPane, false);
      }
    }
    snCustomEvent.fireTop(paneName + '.toggle');
    saveState(paneName, !paneIndex[paneName]);
  };

  function saveState(paneName, state) {
    paneIndex[paneName] = state;
    userPreferences.setPreference(paneName + '.opened', state);
  }
  return {
    registerPane: registerPane,
    togglePane: togglePane
  };
}]);;;
/*! RESOURCE: /scripts/sn/common/stream/js_includes_stream.js */
/*! RESOURCE: /scripts/thirdparty/ment.io/mentio.js */
(function() {
  'use strict';
  angular.module('mentio', [])
    .directive('mentio', ['mentioUtil', '$document', '$compile', '$log', '$timeout',
      function(mentioUtil, $document, $compile, $log, $timeout) {
        return {
          restrict: 'A',
          scope: {
            macros: '=mentioMacros',
            search: '&amp;mentioSearch',
            select: '&amp;mentioSelect',
            items: '=mentioItems',
            typedTerm: '=mentioTypedTerm',
            altId: '=mentioId',
            iframeElement: '=mentioIframeElement',
            requireLeadingSpace: '=mentioRequireLeadingSpace',
            suppressTrailingSpace: '=mentioSuppressTrailingSpace',
            selectNotFound: '=mentioSelectNotFound',
            trimTerm: '=mentioTrimTerm',
            ngModel: '='
          },
          controller: ["$scope", "$timeout", "$attrs", function($scope, $timeout, $attrs) {
            $scope.query = function(triggerChar, triggerText) {
              var remoteScope = $scope.triggerCharMap[triggerChar];
              if ($scope.trimTerm === undefined || $scope.trimTerm) {
                triggerText = triggerText.trim();
              }
              remoteScope.showMenu();
              remoteScope.search({
                term: triggerText
              });
              remoteScope.typedTerm = triggerText;
            };
            $scope.defaultSearch = function(locals) {
              var results = [];
              angular.forEach($scope.items, function(item) {
                if (item.label.toUpperCase().indexOf(locals.term.toUpperCase()) &gt;= 0) {
                  results.push(item);
                }
              });
              $scope.localItems = results;
            };
            $scope.bridgeSearch = function(termString) {
              var searchFn = $attrs.mentioSearch ? $scope.search : $scope.defaultSearch;
              searchFn({
                term: termString
              });
            };
            $scope.defaultSelect = function(locals) {
              return $scope.defaultTriggerChar + locals.item.label;
            };
            $scope.bridgeSelect = function(itemVar) {
              var selectFn = $attrs.mentioSelect ? $scope.select : $scope.defaultSelect;
              return selectFn({
                item: itemVar
              });
            };
            $scope.setTriggerText = function(text) {
              if ($scope.syncTriggerText) {
                $scope.typedTerm = ($scope.trimTerm === undefined || $scope.trimTerm) ? text.trim() : text;
              }
            };
            $scope.context = function() {
              if ($scope.iframeElement) {
                return {
                  iframe: $scope.iframeElement
                };
              }
            };
            $scope.replaceText = function(text, hasTrailingSpace) {
              $scope.hideAll();
              mentioUtil.replaceTriggerText($scope.context(), $scope.targetElement, $scope.targetElementPath,
                $scope.targetElementSelectedOffset, $scope.triggerCharSet, text, $scope.requireLeadingSpace,
                hasTrailingSpace, $scope.suppressTrailingSpace);
              if (!hasTrailingSpace) {
                $scope.setTriggerText('');
                angular.element($scope.targetElement).triggerHandler('change');
                if ($scope.isContentEditable()) {
                  $scope.contentEditableMenuPasted = true;
                  var timer = $timeout(function() {
                    $scope.contentEditableMenuPasted = false;
                  }, 200);
                  $scope.$on('$destroy', function() {
                    $timeout.cancel(timer);
                  });
                }
              }
            };
            $scope.hideAll = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  $scope.triggerCharMap[key].hideMenu();
                }
              }
            };
            $scope.getActiveMenuScope = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    return $scope.triggerCharMap[key];
                  }
                }
              }
              return null;
            };
            $scope.selectActive = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    $scope.triggerCharMap[key].selectActive();
                  }
                }
              }
            };
            $scope.isActive = function() {
              for (var key in $scope.triggerCharMap) {
                if ($scope.triggerCharMap.hasOwnProperty(key)) {
                  if ($scope.triggerCharMap[key].visible) {
                    return true;
                  }
                }
              }
              return false;
            };
            $scope.isContentEditable = function() {
              return ($scope.targetElement.nodeName !== 'INPUT' &amp;&amp; $scope.targetElement.nodeName !== 'TEXTAREA');
            };
            $scope.replaceMacro = function(macro, hasTrailingSpace) {
              if (!hasTrailingSpace) {
                $scope.replacingMacro = true;
                $scope.timer = $timeout(function() {
                  mentioUtil.replaceMacroText($scope.context(), $scope.targetElement,
                    $scope.targetElementPath, $scope.targetElementSelectedOffset,
                    $scope.macros, $scope.macros[macro]);
                  angular.element($scope.targetElement).triggerHandler('change');
                  $scope.replacingMacro = false;
                }, 300);
                $scope.$on('$destroy', function() {
                  $timeout.cancel($scope.timer);
                });
              } else {
                mentioUtil.replaceMacroText($scope.context(), $scope.targetElement, $scope.targetElementPath,
                  $scope.targetElementSelectedOffset, $scope.macros, $scope.macros[macro]);
              }
            };
            $scope.addMenu = function(menuScope) {
              if (menuScope.parentScope &amp;&amp; $scope.triggerCharMap.hasOwnProperty(menuScope.triggerChar)) {
                return;
              }
              $scope.triggerCharMap[menuScope.triggerChar] = menuScope;
              if ($scope.triggerCharSet === undefined) {
                $scope.triggerCharSet = [];
              }
              $scope.triggerCharSet.push(menuScope.triggerChar);
              menuScope.setParent($scope);
            };
            $scope.$on(
              'menuCreated',
              function(event, data) {
                if (
                  $attrs.id !== undefined ||
                  $attrs.mentioId !== undefined
                ) {
                  if (
                    $attrs.id === data.targetElement ||
                    (
                      $attrs.mentioId !== undefined &amp;&amp;
                      $scope.altId === data.targetElement
                    )
                  ) {
                    $scope.addMenu(data.scope);
                  }
                }
              }
            );
            $document.on(
              'click',
              function() {
                if ($scope.isActive()) {
                  $scope.$apply(function() {
                    $scope.hideAll();
                  });
                }
              }
            );
            $document.on(
              'keydown keypress paste',
              function(event) {
                var activeMenuScope = $scope.getActiveMenuScope();
                if (activeMenuScope) {
                  if (event.which === 9 || event.which === 13) {
                    event.preventDefault();
                    activeMenuScope.selectActive();
                  }
                  if (event.which === 27) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.hideMenu();
                    });
                  }
                  if (event.which === 40) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.activateNextItem();
                    });
                    activeMenuScope.adjustScroll(1);
                  }
                  if (event.which === 38) {
                    event.preventDefault();
                    activeMenuScope.$apply(function() {
                      activeMenuScope.activatePreviousItem();
                    });
                    activeMenuScope.adjustScroll(-1);
                  }
                  if (event.which === 37 || event.which === 39) {
                    event.preventDefault();
                  }
                }
              }
            );
          }],
          link: function(scope, element, attrs) {
            scope.triggerCharMap = {};
            scope.targetElement = element;
            attrs.$set('autocomplete', 'off');
            if (attrs.mentioItems) {
              scope.localItems = [];
              scope.parentScope = scope;
              var itemsRef = attrs.mentioSearch ? ' mentio-items="items"' : ' mentio-items="localItems"';
              scope.defaultTriggerChar = attrs.mentioTriggerChar ? scope.$eval(attrs.mentioTriggerChar) : '@';
              var html = '&lt;mentio-menu' +
                ' mentio-search="bridgeSearch(term)"' +
                ' mentio-select="bridgeSelect(item)"' +
                itemsRef;
              if (attrs.mentioTemplateUrl) {
                html = html + ' mentio-template-url="' + attrs.mentioTemplateUrl + '"';
              }
              html = html + ' mentio-trigger-char="\'' + scope.defaultTriggerChar + '\'"' +
                ' mentio-parent-scope="parentScope"' +
                '/&gt;';
              var linkFn = $compile(html);
              var el = linkFn(scope);
              element.parent().append(el);
              scope.$on('$destroy', function() {
                el.remove();
              });
            }
            if (attrs.mentioTypedTerm) {
              scope.syncTriggerText = true;
            }

            function keyHandler(event) {
              function stopEvent(event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
              }
              var activeMenuScope = scope.getActiveMenuScope();
              if (activeMenuScope) {
                if (event.which === 9 || event.which === 13) {
                  stopEvent(event);
                  activeMenuScope.selectActive();
                  return false;
                }
                if (event.which === 27) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.hideMenu();
                  });
                  return false;
                }
                if (event.which === 40) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.activateNextItem();
                  });
                  activeMenuScope.adjustScroll(1);
                  return false;
                }
                if (event.which === 38) {
                  stopEvent(event);
                  activeMenuScope.$apply(function() {
                    activeMenuScope.activatePreviousItem();
                  });
                  activeMenuScope.adjustScroll(-1);
                  return false;
                }
                if (event.which === 37 || event.which === 39) {
                  stopEvent(event);
                  return false;
                }
              }
            }
            scope.$watch(
              'iframeElement',
              function(newValue) {
                if (newValue) {
                  var iframeDocument = newValue.contentWindow.document;
                  iframeDocument.addEventListener('click',
                    function() {
                      if (scope.isActive()) {
                        scope.$apply(function() {
                          scope.hideAll();
                        });
                      }
                    }
                  );
                  iframeDocument.addEventListener('keydown', keyHandler, true);
                  scope.$on('$destroy', function() {
                    iframeDocument.removeEventListener('keydown', keyHandler);
                  });
                }
              }
            );
            scope.$watch(
              'ngModel',
              function(newValue) {
                if ((!newValue || newValue === '') &amp;&amp; !scope.isActive()) {
                  return;
                }
                if (scope.triggerCharSet === undefined) {
                  $log.warn('Error, no mentio-items attribute was provided, ' +
                    'and no separate mentio-menus were specified.  Nothing to do.');
                  return;
                }
                if (scope.contentEditableMenuPasted) {
                  scope.contentEditableMenuPasted = false;
                  return;
                }
                if (scope.replacingMacro) {
                  $timeout.cancel(scope.timer);
                  scope.replacingMacro = false;
                }
                var isActive = scope.isActive();
                var isContentEditable = scope.isContentEditable();
                var mentionInfo = mentioUtil.getTriggerInfo(scope.context(), scope.triggerCharSet,
                  scope.requireLeadingSpace, isActive);
                if (mentionInfo !== undefined &amp;&amp;
                  (!isActive ||
                    (isActive &amp;&amp;
                      (
                        (isContentEditable &amp;&amp; mentionInfo.mentionTriggerChar ===
                          scope.currentMentionTriggerChar) ||
                        (!isContentEditable &amp;&amp; mentionInfo.mentionPosition ===
                          scope.currentMentionPosition)
                      )
                    )
                  )
                ) {
                  if (mentionInfo.mentionSelectedElement) {
                    scope.targetElement = mentionInfo.mentionSelectedElement;
                    scope.targetElementPath = mentionInfo.mentionSelectedPath;
                    scope.targetElementSelectedOffset = mentionInfo.mentionSelectedOffset;
                  }
                  scope.setTriggerText(mentionInfo.mentionText);
                  scope.currentMentionPosition = mentionInfo.mentionPosition;
                  scope.currentMentionTriggerChar = mentionInfo.mentionTriggerChar;
                  scope.query(mentionInfo.mentionTriggerChar, mentionInfo.mentionText);
                } else {
                  var currentTypedTerm = scope.typedTerm;
                  scope.setTriggerText('');
                  scope.hideAll();
                  var macroMatchInfo = mentioUtil.getMacroMatch(scope.context(), scope.macros);
                  if (macroMatchInfo !== undefined) {
                    scope.targetElement = macroMatchInfo.macroSelectedElement;
                    scope.targetElementPath = macroMatchInfo.macroSelectedPath;
                    scope.targetElementSelectedOffset = macroMatchInfo.macroSelectedOffset;
                    scope.replaceMacro(macroMatchInfo.macroText, macroMatchInfo.macroHasTrailingSpace);
                  } else if (scope.selectNotFound &amp;&amp; currentTypedTerm &amp;&amp; currentTypedTerm !== '') {
                    var lastScope = scope.triggerCharMap[scope.currentMentionTriggerChar];
                    if (lastScope) {
                      var text = lastScope.select({
                        item: {
                          label: currentTypedTerm
                        }
                      });
                      if (typeof text.then === 'function') {
                        text.then(scope.replaceText);
                      } else {
                        scope.replaceText(text, true);
                      }
                    }
                  }
                }
              }
            );
          }
        };
      }
    ])
    .directive('mentioMenu', ['mentioUtil', '$rootScope', '$log', '$window', '$document', '$timeout',
      function(mentioUtil, $rootScope, $log, $window, $document, $timeout) {
        return {
          restrict: 'E',
          scope: {
            search: '&amp;mentioSearch',
            select: '&amp;mentioSelect',
            items: '=mentioItems',
            triggerChar: '=mentioTriggerChar',
            forElem: '=mentioFor',
            parentScope: '=mentioParentScope'
          },
          templateUrl: function(tElement, tAttrs) {
            return tAttrs.mentioTemplateUrl !== undefined ? tAttrs.mentioTemplateUrl : 'mentio-menu.tpl.html';
          },
          controller: ["$scope", function($scope) {
            $scope.visible = false;
            this.activate = $scope.activate = function(item) {
              $scope.activeItem = item;
            };
            this.isActive = $scope.isActive = function(item) {
              return $scope.activeItem === item;
            };
            this.selectItem = $scope.selectItem = function(item) {
              if (item.termLengthIsZero) {
                item.name = $scope.triggerChar + $scope.typedTerm
              }
              var text = $scope.select({
                item: item
              });
              if (typeof text.then === 'function') {
                text.then($scope.parentMentio.replaceText);
              } else {
                $scope.parentMentio.replaceText(text);
              }
            };
            $scope.activateNextItem = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              this.activate($scope.items[(index + 1) % $scope.items.length]);
            };
            $scope.activatePreviousItem = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              this.activate($scope.items[index === 0 ? $scope.items.length - 1 : index - 1]);
            };
            $scope.isFirstItemActive = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              return index === 0;
            };
            $scope.isLastItemActive = function() {
              var index = $scope.items.indexOf($scope.activeItem);
              return index === ($scope.items.length - 1);
            };
            $scope.selectActive = function() {
              $scope.selectItem($scope.activeItem);
            };
            $scope.isVisible = function() {
              return $scope.visible;
            };
            $scope.showMenu = function() {
              if (!$scope.visible) {
                $scope.menuElement.css("visibility", "visible");
                $scope.requestVisiblePendingSearch = true;
              }
            };
            $scope.setParent = function(scope) {
              $scope.parentMentio = scope;
              $scope.targetElement = scope.targetElement;
            };
          }],
          link: function(scope, element) {
            element[0].parentNode.removeChild(element[0]);
            $document[0].body.appendChild(element[0]);
            scope.menuElement = element;
            scope.menuElement.css("visibility", "hidden");
            if (scope.parentScope) {
              scope.parentScope.addMenu(scope);
            } else {
              if (!scope.forElem) {
                $log.error('mentio-menu requires a target element in tbe mentio-for attribute');
                return;
              }
              if (!scope.triggerChar) {
                $log.error('mentio-menu requires a trigger char');
                return;
              }
              $rootScope.$broadcast('menuCreated', {
                targetElement: scope.forElem,
                scope: scope
              });
            }
            angular.element($window).bind(
              'resize',
              function() {
                if (scope.isVisible()) {
                  var triggerCharSet = [];
                  triggerCharSet.push(scope.triggerChar);
                  mentioUtil.popUnderMention(scope.parentMentio.context(),
                    triggerCharSet, element, scope.requireLeadingSpace);
                }
              }
            );
            scope.$watch('items', function(items) {
              if (items &amp;&amp; items.length &gt; 0) {
                scope.activate(items[0]);
                if (!scope.visible &amp;&amp; scope.requestVisiblePendingSearch) {
                  scope.visible = true;
                  scope.requestVisiblePendingSearch = false;
                }
                $timeout(function() {
                  var menu = element.find(".dropdown-menu");
                  if (menu.length &gt; 0 &amp;&amp; menu.offset().top &lt; 0)
                    menu.addClass("reverse");
                }, 0, false);
              } else {
                scope.activate({
                  termLengthIsZero: true
                });
              }
            });
            scope.$watch('isVisible()', function(visible) {
              if (visible) {
                var triggerCharSet = [];
                triggerCharSet.push(scope.triggerChar);
                mentioUtil.popUnderMention(scope.parentMentio.context(),
                  triggerCharSet, element, scope.requireLeadingSpace);
              } else {
                element.find(".dropdown-menu").removeClass("reverse");
              }
            });
            scope.parentMentio.$on('$destroy', function() {
              element.remove();
            });
            scope.hideMenu = function() {
              scope.visible = false;
              element.css('display', 'none');
            };
            scope.adjustScroll = function(direction) {
              var menuEl = element[0];
              var menuItemsList = menuEl.querySelector('ul');
              var menuItem = menuEl.querySelector('[mentio-menu-item].active');
              if (scope.isFirstItemActive()) {
                return menuItemsList.scrollTop = 0;
              } else if (scope.isLastItemActive()) {
                return menuItemsList.scrollTop = menuItemsList.scrollHeight;
              }
              if (direction === 1) {
                menuItemsList.scrollTop += menuItem.offsetHeight;
              } else {
                menuItemsList.scrollTop -= menuItem.offsetHeight;
              }
            };
          }
        };
      }
    ])
    .directive('mentioMenuItem', function() {
      return {
        restrict: 'A',
        scope: {
          item: '=mentioMenuItem'
        },
        require: '^mentioMenu',
        link: function(scope, element, attrs, controller) {
          scope.$watch(function() {
            return controller.isActive(scope.item);
          }, function(active) {
            if (active) {
              element.addClass('active');
            } else {
              element.removeClass('active');
            }
          });
          element.bind('mouseenter', function() {
            scope.$apply(function() {
              controller.activate(scope.item);
            });
          });
          element.bind('click', function() {
            controller.selectItem(scope.item);
            return false;
          });
        }
      };
    })
    .filter('unsafe', ["$sce", function($sce) {
      return function(val) {
        return $sce.trustAsHtml(val);
      };
    }])
    .filter('mentioHighlight', function() {
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      return function(matchItem, query, hightlightClass) {
        if (query) {
          var replaceText = hightlightClass ?
            '&lt;span class="' + hightlightClass + '"&gt;$&amp;&lt;/span&gt;' :
            '&lt;strong&gt;$&amp;&lt;/strong&gt;';
          return ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), replaceText);
        } else {
          return matchItem;
        }
      };
    });
  'use strict';
  angular.module('mentio')
    .factory('mentioUtil', ["$window", "$location", "$anchorScroll", "$timeout", function($window, $location, $anchorScroll, $timeout) {
      function popUnderMention(ctx, triggerCharSet, selectionEl, requireLeadingSpace) {
        var coordinates;
        var mentionInfo = getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, false);
        if (mentionInfo !== undefined) {
          if (selectedElementIsTextAreaOrInput(ctx)) {
            coordinates = getTextAreaOrInputUnderlinePosition(ctx, getDocument(ctx).activeElement,
              mentionInfo.mentionPosition);
          } else {
            coordinates = getContentEditableCaretPosition(ctx, mentionInfo.mentionPosition);
          }
          selectionEl.css({
            top: coordinates.top + 'px',
            left: coordinates.left + 'px',
            position: 'absolute',
            zIndex: 5000,
            display: 'block'
          });
          $timeout(function() {
            scrollIntoView(ctx, selectionEl);
          }, 0);
        } else {
          selectionEl.css({
            display: 'none'
          });
        }
      }

      function scrollIntoView(ctx, elem) {
        var reasonableBuffer = 20;
        var maxScrollDisplacement = 100;
        var clientRect;
        var e = elem[0];
        while (clientRect === undefined || clientRect.height === 0) {
          clientRect = e.getBoundingClientRect();
          if (clientRect.height === 0) {
            e = e.childNodes[0];
            if (e === undefined || !e.getBoundingClientRect) {
              return;
            }
          }
        }
        var elemTop = clientRect.top;
        var elemBottom = elemTop + clientRect.height;
        if (elemTop &lt; 0) {
          $window.scrollTo(0, $window.pageYOffset + clientRect.top - reasonableBuffer);
        } else if (elemBottom &gt; $window.innerHeight) {
          var maxY = $window.pageYOffset + clientRect.top - reasonableBuffer;
          if (maxY - $window.pageYOffset &gt; maxScrollDisplacement) {
            maxY = $window.pageYOffset + maxScrollDisplacement;
          }
          var targetY = $window.pageYOffset - ($window.innerHeight - elemBottom);
          if (targetY &gt; maxY) {
            targetY = maxY;
          }
          $window.scrollTo(0, targetY);
        }
      }

      function selectedElementIsTextAreaOrInput(ctx) {
        var element = getDocument(ctx).activeElement;
        if (element !== null) {
          var nodeName = element.nodeName;
          var type = element.getAttribute('type');
          return (nodeName === 'INPUT' &amp;&amp; type === 'text') || nodeName === 'TEXTAREA';
        }
        return false;
      }

      function selectElement(ctx, targetElement, path, offset) {
        var range;
        var elem = targetElement;
        if (path) {
          for (var i = 0; i &lt; path.length; i++) {
            elem = elem.childNodes[path[i]];
            if (elem === undefined) {
              return;
            }
            while (elem.length &lt; offset) {
              offset -= elem.length;
              elem = elem.nextSibling;
            }
            if (elem.childNodes.length === 0 &amp;&amp; !elem.length) {
              elem = elem.previousSibling;
            }
          }
        }
        var sel = getWindowSelection(ctx);
        range = getDocument(ctx).createRange();
        range.setStart(elem, offset);
        range.setEnd(elem, offset);
        range.collapse(true);
        try {
          sel.removeAllRanges();
        } catch (error) {}
        sel.addRange(range);
        targetElement.focus();
      }

      function pasteHtml(ctx, html, startPos, endPos) {
        var range, sel;
        sel = getWindowSelection(ctx);
        range = getDocument(ctx).createRange();
        range.setStart(sel.anchorNode, startPos);
        range.setEnd(sel.anchorNode, endPos);
        range.deleteContents();
        var el = getDocument(ctx).createElement('div');
        el.innerHTML = html;
        var frag = getDocument(ctx).createDocumentFragment(),
          node, lastNode;
        while ((node = el.firstChild)) {
          lastNode = frag.appendChild(node);
        }
        range.insertNode(frag);
        if (lastNode) {
          range = range.cloneRange();
          range.setStartAfter(lastNode);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }

      function resetSelection(ctx, targetElement, path, offset) {
        var nodeName = targetElement.nodeName;
        if (nodeName === 'INPUT' || nodeName === 'TEXTAREA') {
          if (targetElement !== getDocument(ctx).activeElement) {
            targetElement.focus();
          }
        } else {
          selectElement(ctx, targetElement, path, offset);
        }
      }

      function replaceMacroText(ctx, targetElement, path, offset, macros, text) {
        resetSelection(ctx, targetElement, path, offset);
        var macroMatchInfo = getMacroMatch(ctx, macros);
        if (macroMatchInfo.macroHasTrailingSpace) {
          macroMatchInfo.macroText = macroMatchInfo.macroText + '\xA0';
          text = text + '\xA0';
        }
        if (macroMatchInfo !== undefined) {
          var element = getDocument(ctx).activeElement;
          if (selectedElementIsTextAreaOrInput(ctx)) {
            var startPos = macroMatchInfo.macroPosition;
            var endPos = macroMatchInfo.macroPosition + macroMatchInfo.macroText.length;
            element.value = element.value.substring(0, startPos) + text +
              element.value.substring(endPos, element.value.length);
            element.selectionStart = startPos + text.length;
            element.selectionEnd = startPos + text.length;
          } else {
            pasteHtml(ctx, text, macroMatchInfo.macroPosition,
              macroMatchInfo.macroPosition + macroMatchInfo.macroText.length);
          }
        }
      }

      function replaceTriggerText(ctx, targetElement, path, offset, triggerCharSet,
        text, requireLeadingSpace, hasTrailingSpace, suppressTrailingSpace) {
        resetSelection(ctx, targetElement, path, offset);
        var mentionInfo = getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, true, hasTrailingSpace);
        if (mentionInfo !== undefined) {
          if (selectedElementIsTextAreaOrInput()) {
            var myField = getDocument(ctx).activeElement;
            if (!suppressTrailingSpace) {
              text = text + ' ';
            }
            var startPos = mentionInfo.mentionPosition;
            var endPos = mentionInfo.mentionPosition + mentionInfo.mentionText.length + 1;
            myField.value = myField.value.substring(0, startPos) + text +
              myField.value.substring(endPos, myField.value.length);
            myField.selectionStart = startPos + text.length;
            myField.selectionEnd = startPos + text.length;
          } else {
            if (!suppressTrailingSpace) {
              text = text + '\xA0';
            }
            pasteHtml(ctx, text, mentionInfo.mentionPosition,
              mentionInfo.mentionPosition + mentionInfo.mentionText.length + 1);
          }
        }
      }

      function getNodePositionInParent(ctx, elem) {
        if (elem.parentNode === null) {
          return 0;
        }
        for (var i = 0; i &lt; elem.parentNode.childNodes.length; i++) {
          var node = elem.parentNode.childNodes[i];
          if (node === elem) {
            return i;
          }
        }
      }

      function getMacroMatch(ctx, macros) {
        var selected, path = [],
          offset;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          selected = getDocument(ctx).activeElement;
        } else {
          var selectionInfo = getContentEditableSelectedPath(ctx);
          if (selectionInfo) {
            selected = selectionInfo.selected;
            path = selectionInfo.path;
            offset = selectionInfo.offset;
          }
        }
        var effectiveRange = getTextPrecedingCurrentSelection(ctx);
        if (effectiveRange !== undefined &amp;&amp; effectiveRange !== null) {
          var matchInfo;
          var hasTrailingSpace = false;
          if (effectiveRange.length &gt; 0 &amp;&amp;
            (effectiveRange.charAt(effectiveRange.length - 1) === '\xA0' ||
              effectiveRange.charAt(effectiveRange.length - 1) === ' ')) {
            hasTrailingSpace = true;
            effectiveRange = effectiveRange.substring(0, effectiveRange.length - 1);
          }
          angular.forEach(macros, function(macro, c) {
            var idx = effectiveRange.toUpperCase().lastIndexOf(c.toUpperCase());
            if (idx &gt;= 0 &amp;&amp; c.length + idx === effectiveRange.length) {
              var prevCharPos = idx - 1;
              if (idx === 0 || effectiveRange.charAt(prevCharPos) === '\xA0' ||
                effectiveRange.charAt(prevCharPos) === ' ') {
                matchInfo = {
                  macroPosition: idx,
                  macroText: c,
                  macroSelectedElement: selected,
                  macroSelectedPath: path,
                  macroSelectedOffset: offset,
                  macroHasTrailingSpace: hasTrailingSpace
                };
              }
            }
          });
          if (matchInfo) {
            return matchInfo;
          }
        }
      }

      function getContentEditableSelectedPath(ctx) {
        var sel = getWindowSelection(ctx);
        var selected = sel.anchorNode;
        var path = [];
        var offset;
        if (selected != null) {
          var i;
          var ce = selected.contentEditable;
          while (selected !== null &amp;&amp; ce !== 'true') {
            i = getNodePositionInParent(ctx, selected);
            path.push(i);
            selected = selected.parentNode;
            if (selected !== null) {
              ce = selected.contentEditable;
            }
          }
          path.reverse();
          offset = sel.getRangeAt(0).startOffset;
          return {
            selected: selected,
            path: path,
            offset: offset
          };
        }
      }

      function getTriggerInfo(ctx, triggerCharSet, requireLeadingSpace, menuAlreadyActive, hasTrailingSpace) {
        var selected, path, offset;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          selected = getDocument(ctx).activeElement;
        } else {
          var selectionInfo = getContentEditableSelectedPath(ctx);
          if (selectionInfo) {
            selected = selectionInfo.selected;
            path = selectionInfo.path;
            offset = selectionInfo.offset;
          }
        }
        var effectiveRange = getTextPrecedingCurrentSelection(ctx);
        if (effectiveRange !== undefined &amp;&amp; effectiveRange !== null) {
          var mostRecentTriggerCharPos = -1;
          var triggerChar;
          triggerCharSet.forEach(function(c) {
            var idx = effectiveRange.lastIndexOf(c);
            if (idx &gt; mostRecentTriggerCharPos) {
              mostRecentTriggerCharPos = idx;
              triggerChar = c;
            }
          });
          if (mostRecentTriggerCharPos &gt;= 0 &amp;&amp;
            (
              mostRecentTriggerCharPos === 0 ||
              !requireLeadingSpace ||
              /[\xA0\s]/g.test(
                effectiveRange.substring(
                  mostRecentTriggerCharPos - 1,
                  mostRecentTriggerCharPos)
              )
            )
          ) {
            var currentTriggerSnippet = effectiveRange.substring(mostRecentTriggerCharPos + 1,
              effectiveRange.length);
            triggerChar = effectiveRange.substring(mostRecentTriggerCharPos, mostRecentTriggerCharPos + 1);
            var firstSnippetChar = currentTriggerSnippet.substring(0, 1);
            var leadingSpace = currentTriggerSnippet.length &gt; 0 &amp;&amp;
              (
                firstSnippetChar === ' ' ||
                firstSnippetChar === '\xA0'
              );
            if (hasTrailingSpace) {
              currentTriggerSnippet = currentTriggerSnippet.trim();
            }
            if (!leadingSpace &amp;&amp; (menuAlreadyActive || !(/[\xA0\s]/g.test(currentTriggerSnippet)))) {
              return {
                mentionPosition: mostRecentTriggerCharPos,
                mentionText: currentTriggerSnippet,
                mentionSelectedElement: selected,
                mentionSelectedPath: path,
                mentionSelectedOffset: offset,
                mentionTriggerChar: triggerChar
              };
            }
          }
        }
      }

      function getWindowSelection(ctx) {
        if (!ctx) {
          return window.getSelection();
        } else {
          return ctx.iframe.contentWindow.getSelection();
        }
      }

      function getDocument(ctx) {
        if (!ctx) {
          return document;
        } else {
          return ctx.iframe.contentWindow.document;
        }
      }

      function getTextPrecedingCurrentSelection(ctx) {
        var text;
        if (selectedElementIsTextAreaOrInput(ctx)) {
          var textComponent = getDocument(ctx).activeElement;
          var startPos = textComponent.selectionStart;
          text = textComponent.value.substring(0, startPos);
        } else {
          var selectedElem = getWindowSelection(ctx).anchorNode;
          if (selectedElem != null) {
            var workingNodeContent = selectedElem.textContent;
            var selectStartOffset = getWindowSelection(ctx).getRangeAt(0).startOffset;
            if (selectStartOffset &gt;= 0) {
              text = workingNodeContent.substring(0, selectStartOffset);
            }
          }
        }
        return text;
      }

      function getContentEditableCaretPosition(ctx, selectedNodePosition) {
        var markerTextChar = '\ufeff';
        var markerEl, markerId = 'sel_' + new Date().getTime() + '_' + Math.random().toString().substr(2);
        var range;
        var sel = getWindowSelection(ctx);
        var prevRange = sel.getRangeAt(0);
        range = getDocument(ctx).createRange();
        range.setStart(sel.anchorNode, selectedNodePosition);
        range.setEnd(sel.anchorNode, selectedNodePosition);
        range.collapse(false);
        markerEl = getDocument(ctx).createElement('span');
        markerEl.id = markerId;
        markerEl.appendChild(getDocument(ctx).createTextNode(markerTextChar));
        range.insertNode(markerEl);
        sel.removeAllRanges();
        sel.addRange(prevRange);
        var coordinates = {
          left: 0,
          top: markerEl.offsetHeight
        };
        localToGlobalCoordinates(ctx, markerEl, coordinates);
        markerEl.parentNode.removeChild(markerEl);
        return coordinates;
      }

      function localToGlobalCoordinates(ctx, element, coordinates) {
        var obj = element;
        var iframe = ctx ? ctx.iframe : null;
        while (obj) {
          coordinates.left += obj.offsetLeft;
          coordinates.top += obj.offsetTop;
          if (obj !== getDocument().body) {
            coordinates.top -= obj.scrollTop;
            coordinates.left -= obj.scrollLeft;
          }
          obj = obj.offsetParent;
          if (!obj &amp;&amp; iframe) {
            obj = iframe;
            iframe = null;
          }
        }
      }

      function getTextAreaOrInputUnderlinePosition(ctx, element, position) {
        var properties = [
          'direction',
          'boxSizing',
          'width',
          'height',
          'overflowX',
          'overflowY',
          'borderTopWidth',
          'borderRightWidth',
          'borderBottomWidth',
          'borderLeftWidth',
          'paddingTop',
          'paddingRight',
          'paddingBottom',
          'paddingLeft',
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'fontStretch',
          'fontSize',
          'fontSizeAdjust',
          'lineHeight',
          'fontFamily',
          'textAlign',
          'textTransform',
          'textIndent',
          'textDecoration',
          'letterSpacing',
          'wordSpacing'
        ];
        var isFirefox = (window.mozInnerScreenX !== null);
        var div = getDocument(ctx).createElement('div');
        div.id = 'input-textarea-caret-position-mirror-div';
        getDocument(ctx).body.appendChild(div);
        var style = div.style;
        var computed = window.getComputedStyle ? getComputedStyle(element) : element.currentStyle;
        style.whiteSpace = 'pre-wrap';
        if (element.nodeName !== 'INPUT') {
          style.wordWrap = 'break-word';
        }
        style.position = 'absolute';
        style.visibility = 'hidden';
        properties.forEach(function(prop) {
          style[prop] = computed[prop];
        });
        if (isFirefox) {
          style.width = (parseInt(computed.width) - 2) + 'px';
          if (element.scrollHeight &gt; parseInt(computed.height))
            style.overflowY = 'scroll';
        } else {
          style.overflow = 'hidden';
        }
        div.textContent = element.value.substring(0, position);
        if (element.nodeName === 'INPUT') {
          div.textContent = div.textContent.replace(/\s/g, '\u00a0');
        }
        var span = getDocument(ctx).createElement('span');
        span.textContent = element.value.substring(position) || '.';
        div.appendChild(span);
        var coordinates = {
          top: span.offsetTop + parseInt(computed.borderTopWidth) + parseInt(computed.fontSize),
          left: span.offsetLeft + parseInt(computed.borderLeftWidth)
        };
        localToGlobalCoordinates(ctx, element, coordinates);
        getDocument(ctx).body.removeChild(div);
        return coordinates;
      }
      return {
        popUnderMention: popUnderMention,
        replaceMacroText: replaceMacroText,
        replaceTriggerText: replaceTriggerText,
        getMacroMatch: getMacroMatch,
        getTriggerInfo: getTriggerInfo,
        selectElement: selectElement,
        getTextAreaOrInputUnderlinePosition: getTextAreaOrInputUnderlinePosition,
        getTextPrecedingCurrentSelection: getTextPrecedingCurrentSelection,
        getContentEditableSelectedPath: getContentEditableSelectedPath,
        getNodePositionInParent: getNodePositionInParent,
        getContentEditableCaretPosition: getContentEditableCaretPosition,
        pasteHtml: pasteHtml,
        resetSelection: resetSelection,
        scrollIntoView: scrollIntoView
      };
    }]);
  angular.module("mentio").run(["$templateCache", function($templateCache) {
    $templateCache.put("mentio-menu.tpl.html", "&lt;style&gt;\n.scrollable-menu {\n    height: auto;\n    max-height: 300px;\n    overflow: auto;\n}\n\n.menu-highlighted {\n    font-weight: bold;\n}\n&lt;/style&gt;\n&lt;ul class=\"dropdown-menu scrollable-menu\" style=\"display:block\"&gt;\n    &lt;li mentio-menu-item=\"item\" ng-repeat=\"item in items track by $index\"&gt;\n        &lt;a class=\"text-primary\" ng-bind-html=\"item.label | mentioHighlight:typedTerm:\'menu-highlighted\' | unsafe\"&gt;&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;");
  }]);
})();
/*! RESOURCE: /scripts/sn/common/stream/_module.js */
angular.module("sn.common.stream", ['sn.base', 'ng.amb', 'sn.messaging', 'sn.common.glide', 'ngSanitize',
  'sn.common.avatar', 'sn.common.ui.popover', 'mentio', 'sn.common.controls', 'sn.common.user_profile',
  'sn.common.datetime', 'sn.common.mention', 'sn.common.ui'
]);
angular.module("sn.stream.direct", ['sn.common.stream']);;
/*! RESOURCE: /scripts/sn/common/stream/controller.Stream.js */
angular.module("sn.common.stream").controller("Stream", function($scope, snRecordWatcher, $timeout) {
  var isForm = NOW.sysId.length &gt; 0;
  $scope.showCommentsAndWorkNotes = isForm;
  $scope.sessions = {};
  $scope.recordStreamOpen = false;
  $scope.streamHidden = true;
  $scope.recordSysId = '';
  $scope.recordDisplayValue = '';
  $scope.$on('record.updated', onRecordUpdated);
  $scope.$on('sn.sessions', onSessions);
  $timeout(function() {
    if (isForm)
      snRecordWatcher.initRecord(NOW.targetTable, NOW.sysId);
    else
      snRecordWatcher.initList(NOW.targetTable, NOW.tableQuery);
  }, 100);
  $scope.controls = {
    showRecord: function($event, entry, sysId) {
      if (sysId !== '')
        return;
      $scope.recordSysId = entry.document_id;
      $scope.recordDisplayValue = entry.display_value;
      $scope.recordStreamOpen = true;
      $scope.streamHidden = true;
    },
    openRecord: function() {
      var targetFrame = window.self;
      var url = NOW.targetTable + ".do?sys_id=" + $scope.recordSysId;
      if (NOW.linkTarget == 'form_pane') {
        url += "&amp;sysparm_clear_stack=true";
        window.parent.CustomEvent.fireTop(
          "glide:nav_open_url", {
            url: url,
            openInForm: true
          });
        return;
      }
      if (NOW.streamLinkTarget == 'parent' || NOW.concourse == 'true')
        targetFrame = window.parent;
      targetFrame.location = url;
    },
    openAttachment: function(event, sysId) {
      event.stopPropagation();
      var url = "/sys_attachment.do?view=true&amp;sys_id=" + sysId;
      var newTab = window.open(url, '_blank');
      newTab.focus();
    }
  };
  $scope.sessionCount = function() {
    $scope.sessions.length = Object.keys($scope.sessions.data).length;
    return $scope.sessions.length;
  };

  function onSessions(name, sessions) {
    $scope.sessions.data = sessions;
    $scope.sessionCount();
  }

  function onRecordUpdated(name, data) {}
  $scope.showListStream = function() {
    $scope.recordStreamOpen = false;
    $scope.recordHidden = false;
    $scope.streamHidden = false;
    angular.element('div.list-stream-record').velocity('snTransition.streamSlideRight', {
      duration: 400
    });
    angular.element('[streamType="list"]').velocity('snTransition.slideIn', {
      duration: 400,
      complete: function(element) {
        angular.element(element).css({
          display: 'block'
        });
      }
    });
  };
  $scope.$watch(function() {
    return angular.element('div.list-stream-record').length
  }, function(newValue, oldValue) {
    if (newValue == 1) {
      angular.element('div.list-stream-record').delay(100).velocity('snTransition.streamSlideLeft', {
        begin: function(element) {
          angular.element(element).css({
            visibility: 'visible'
          });
          angular.element('.list-stream-record-header').css({
            visibility: 'visible'
          });
        },
        duration: 400,
        complete: function(element) {
          angular.element(element).css({
            transform: "translateX(0)"
          });
          angular.element(element).scrollTop(0);
          angular.element(element).css({
            transform: "initial"
          });
        }
      });
    }
  });
});;
/*! RESOURCE: /scripts/sn/common/stream/directive.snStream.js */
angular.module("sn.common.stream").directive("snStream", function(getTemplateUrl, $http, $templateRequest, $compile) {
  "use strict";
  return {
    restrict: "E",
    replace: true,
    scope: {
      table: "=",
      query: "=?",
      sysId: "=?",
      active: "=",
      controls: "=?",
      showCommentsAndWorkNotes: "=?",
      previousActivity: "=?",
      sessions: "=",
      attachments: "=",
      board: "=",
      formJournalFields: "=",
      useMultipleInputs: "=",
      preferredInput: "=",
      labels: "=",
      subStream: "=",
      expandEntries: "=",
      pageSize: "=",
      maxEntries: "@"
    },
    templateUrl: getTemplateUrl("ng_activity_stream.xml"),
    controller: function($scope, $attrs, nowStream, snRecordPresence, snCustomEvent, userPreferences, $window, $q, $timeout, snMention) {
      var stream;
      var processor = $attrs.processor || "list_history";
      var interval;
      var FROM_LIST = 'from_list';
      var FROM_FORM = 'from_form';
      var source = $scope.sysId ? FROM_FORM : FROM_LIST;
      var amb = false;
      var _firstPoll = true;
      var _firstPollTimeout;
      var primaryJournalFieldOrder = ["comments", "work_notes"];
      var primaryJournalField = null;
      $scope.defaultShowCommentsAndWorkNotes = ($scope.sysId != null &amp;&amp; !angular.isUndefined($scope.sysId) &amp;&amp; $scope.sysId.length &gt; 0);
      $scope.canWriteWorkNotes = false;
      $scope.inputTypeValue = "";
      $scope.entryTemplate = getTemplateUrl($attrs.template || "list_stream_entry");
      $scope.allFields = null;
      $scope.fields = null;
      $scope.fieldColor = "transparent";
      $scope.multipleInputs = $scope.useMultipleInputs;
      $scope.members = [];
      $scope.members.loading = true;
      var mentionMap = {};
      $scope.selectAtMention = function(item) {
        if (item.termLengthIsZero)
          return (item.name || "") + "\n";
        mentionMap[item.name] = item.sys_id;
        return "@[" + item.name + "]";
      };
      var typingTimer;
      $scope.searchMembersAsync = function(term) {
        $scope.members = [];
        $scope.members.loading = true;
        $timeout.cancel(typingTimer);
        if (term.length === 0) {
          $scope.members = [{
            termLengthIsZero: true
          }];
          $scope.members.loading = false;
        } else {
          typingTimer = $timeout(function() {
            snMention.retrieveMembers($scope.table, $scope.sysId, term).then(function(members) {
              $scope.members = members;
              $scope.members.loading = false;
            }, function() {
              $scope.members = [{
                termLengthIsZero: true
              }];
              $scope.members.loading = false;
            });
          }, 500);
        }
      };
      $scope.expandMentions = function(text) {
        return stream.expandMentions(text, mentionMap)
      }
      $scope.reduceMentions = function(text) {
        if (!text)
          return text;
        var regexMentionParts = /[\w\d\s/\']+/gi;
        text = text.replace(/@\[[\w\d\s]+:[\w\d\s/\']+\]/gi, function(mention) {
          var mentionParts = mention.match(regexMentionParts);
          if (mentionParts.length === 2) {
            var name = mentionParts[1];
            var userID = mentionParts[0];
            mentionMap[name] = userID;
            return "@[" + name + "]";
          }
          return mentionParts;
        });
        return text;
      }
      $scope.parseMentions = function(entry) {
        var regexMentionParts = /[\w\d\s/\']+/gi;
        entry = entry.replace(/@\[[\w\d\s]+:[\w\d\s/\']+\]/gi, function(mention) {
          var mentionParts = mention.match(regexMentionParts);
          if (mentionParts.length === 2) {
            return '&lt;a class="at-mention at-mention-user-' + mentionParts[0] + '"&gt;@' + mentionParts[1] + '&lt;/a&gt;';
          }
          return mentionParts;
        });
        return entry;
      };
      $scope.parseLinks = function(text) {
        var regexLinks = /@L\[([^|]+?)\|([^\]]*)]/gi;
        return text.replace(regexLinks, "&lt;a href='$1' target='_blank'&gt;$2&lt;/a&gt;");
      };
      $scope.parseSpecial = function(text) {
        var parsedText = $scope.parseLinks(text);
        parsedText = $scope.parseMentions(parsedText);
        return parsedText;
      };
      $scope.$watch('active', function(n, o) {
        if (n === o)
          return;
        if ($scope.active)
          startPolling();
        else
          cancelStream();
      });
      $scope.defaultControls = {
        getTitle: function(entry) {
          if (entry &amp;&amp; entry.short_description) {
            return entry.short_description;
          } else if (entry &amp;&amp; entry.shortDescription) {
            return entry.shortDescription;
          }
        },
        showCreatedBy: function() {
          return true;
        },
        hideCommentLabel: function(journal) {
          return false;
        },
        showRecord: function($event, entry) {},
        showRecordLink: function() {
          return true;
        }
      };
      if ($scope.controls) {
        for (var attr in $scope.controls) {
          $scope.defaultControls[attr] = $scope.controls[attr];
        }
      }
      $scope.controls = $scope.defaultControls;
      if ($scope.showCommentsAndWorkNotes === undefined) {
        $scope.showCommentsAndWorkNotes = $scope.defaultShowCommentsAndWorkNotes;
      }
      snCustomEvent.observe('sn.stream.change_input_display', function(table, display) {
        if (table != $scope.table)
          return;
        $scope.showCommentsAndWorkNotes = display;
        $scope.$apply();
      });
      $scope.$on("$destroy", function() {
        cancelStream();
      });
      $scope.$on('sn.stream.interval', function($event, time) {
        interval = time;
        reschedulePoll();
      });
      $scope.$on("sn.stream.tap", function() {
        if (stream)
          stream.tap();
        else
          startPolling();
      });
      $scope.$on('window_visibility_change', function($event, hidden) {
        interval = (hidden) ? 120000 : undefined;
        reschedulePoll();
      });
      $scope.$on("sn.stream.refresh", function(event, data) {
        stream._successCallback(data.response);
      });
      $scope.$on("sn.stream.reload", function() {
        startPolling();
      });
      $scope.$on('sn.stream.input_value', function(otherScope, value) {
        $scope.inputTypeValue = value;
      });
      $scope.$watchCollection('[table, query, sysId]', startPolling);
      $scope.changeInputType = function(field) {
        $scope.inputType = field.checked ? field.name : primaryJournalField;
        userPreferences.setPreference('glide.ui.' + $scope.table + '.stream_input', $scope.preferredInput);
      };
      $scope.$watch('inputType', function() {
        if (!$scope.inputType || !$scope.preferredInput)
          return;
        $scope.preferredInput = $scope.inputType;
      });
      $scope.submitCheck = function(event) {
        var key = event.keyCode || event.which;
        if (key === 13) {
          $scope.postJournalEntryForCurrent(event);
        }
      };
      $scope.postJournalEntry = function(type, entry, event) {
        type = type || primaryJournalFieldOrder[0];
        event.stopPropagation();
        var requestTable = $scope.table || "board:" + $scope.board.sys_id;
        stream.insertForEntry(type, entry.journalText, requestTable, entry.document_id);
        entry.journalText = "";
        entry.commentBoxVisible = false;
        snRecordPresence.termPresence();
      };
      $scope.postJournalEntryForCurrent = function(event) {
        event.stopPropagation();
        var entries = [];
        if ($scope.multipleInputs) {
          angular.forEach($scope.fields, function(item) {
            if (!item.value)
              return;
            entries.push({
              field: item.name,
              text: item.value
            });
          })
        } else {
          entries.push({
            field: $scope.inputType,
            text: $scope.inputTypeValue
          })
        }
        var request = stream.insertEntries(entries, $scope.table, $scope.sysId, mentionMap);
        if (request) {
          request.then(function() {
            for (var i = 0; i &lt; entries.length; i++) {
              fireInsertEvent(entries[i].field, entries[i].text);
            }
          });
        }
        clearInputs();
        return false;
      };

      function fireInsertEvent(name, value) {
        snCustomEvent.fire('sn.stream.insert', name, value);
      }

      function clearInputs() {
        $scope.inputTypeValue = "";
        angular.forEach($scope.fields, function(item) {
          if (item.value)
            item.filled = true;
          item.value = "";
        });
      }
      $scope.showCommentBox = function(entry, event) {
        event.stopPropagation();
        if (entry !== $scope.selectedEntry)
          $scope.closeEntry();
        $scope.selectedEntry = entry;
        entry.commentBoxVisible = !entry.commentBoxVisible;
        if (entry.commentBoxVisible) {
          snRecordPresence.initPresence($scope.table, entry.document_id);
        }
      };
      $scope.showMore = function(journal, event) {
        event.stopPropagation();
        journal.showMore = true;
      };
      $scope.showLess = function(journal, event) {
        event.stopPropagation();
        journal.showMore = false;
      };
      $scope.closeEntry = function() {
        if ($scope.selectedEntry)
          $scope.selectedEntry.commentBoxVisible = false;
      };
      $scope.previewAttachment = function(evt, attachmentUrl) {
        snCustomEvent.fire('sn.attachment.preview', evt, attachmentUrl);
      }
      $scope.$on('sn.sessions', function(someOtherScope, sessions) {
        if ($scope.selectedEntry &amp;&amp; $scope.selectedEntry.commentBoxVisible)
          $scope.selectedEntry.sessions = sessions;
      });
      $scope.$watch("inputTypeValue", function() {
        emitTyping($scope.inputTypeValue);
      });
      $scope.$watch("selectedEntry.journalText", function(newValue) {
        if ($scope.selectedEntry)
          emitTyping(newValue || "");
      });
      $scope.$watch('useMultipleInputs', function() {
        setMultipleInputs();
      });

      function emitTyping(inputValue) {
        var status = inputValue.length ? "typing" : "viewing";
        $scope.$emit("record.typing", {
          status: status,
          value: inputValue,
          table: $scope.table,
          sys_id: $scope.sys_id
        });
      }

      function preloadedData() {
        if (typeof window.NOW.snActivityStreamData === 'object' &amp;&amp;
          window.NOW.snActivityStreamData[$scope.table + '_' + $scope.sysId]) {
          _firstPoll = false;
          var data = window.NOW.snActivityStreamData[$scope.table + '_' + $scope.sysId];
          stream = nowStream.create($scope.table, $scope.query, $scope.sysId,
            processor, interval, source, $scope.attachments);
          stream.callback = onPoll;
          stream.preRequestCallback = beforePoll;
          stream.lastTimestamp = data.sys_timestamp;
          if (data.entries &amp;&amp; data.entries.length) {
            stream.lastEntry = angular.copy(data.entries[0]);
          }
          _firstPollTimeout = setTimeout(function() {
            stream.poll(onPoll, beforePoll);
            _firstPollTimeout = false;
          }, NOW.stream_poll_interval * 1000 || 5000);
          beforePoll();
          onPoll(data);
          return true;
        }
        return false;
      }

      function scheduleNewPoll(lastTimestamp) {
        cancelStream();
        stream = nowStream.create($scope.table, $scope.query, $scope.sysId,
          processor, interval, source, $scope.attachments);
        stream.lastTimestamp = lastTimestamp;
        stream.poll(onPoll, beforePoll);
      }

      function reschedulePoll() {
        var lastTimestamp = stream ? stream.lastTimestamp : 0;
        if (cancelStream()) {
          scheduleNewPoll(lastTimestamp);
        }
      }

      function reset() {
        $scope.loaded = false;
        startPolling();
      }

      function startPolling() {
        if ($scope.loading &amp;&amp; !$scope.loaded)
          return;
        if (!$scope.active)
          return;
        $scope.entries = [];
        $scope.allEntries = [];
        $scope.showAllEntriesButton = false;
        $scope.loaded = false;
        $scope.loading = true;
        if (_firstPoll &amp;&amp; preloadedData()) {
          return;
        }
        scheduleNewPoll();
      }

      function onPoll(response) {
        $scope.loading = false;
        if (response.primary_fields)
          primaryJournalFieldOrder = response.primary_fields;
        if (!$scope.fields)
          processFields(response.fields);
        processEntries(response.entries);
        if (!$scope.loaded) {
          $scope.loaded = true;
          $scope.$emit("sn.stream.loaded", response);
        }
      }

      function beforePoll() {
        $scope.$emit("sn.stream.requested");
      }

      function processFields(fields) {
        if (!fields || !fields.length)
          return;
        $scope.fields = {};
        $scope.allFields = fields;
        setShowAllFields();
        $scope.fieldsVisible = 0;
        angular.forEach(fields, function(field) {
          if (!field.isJournal)
            return;
          $scope.fields[field.name] = field;
          $scope.fields[field.name].visible = $scope.formJournalFields ? false : true;
          if ($scope.fields[field.name].visible)
            $scope.fieldsVisible++;
          var fieldColor = field.color;
          if (fieldColor)
            fieldColor = field.color.replace(/background-color: /, '')
          if (!fieldColor || fieldColor == 'transparent')
            fieldColor = null;
          $scope.fields[field.name].color = fieldColor;
        });
        setFieldVisibility();
        setPrimaryJournalField();
        setMultipleInputs();
      }
      $scope.$watch('formJournalFields', function() {
        setFieldVisibility();
        setPrimaryJournalField();
        setMultipleInputs();
      }, true);

      function setFieldVisibility() {
        if (!$scope.formJournalFields || !$scope.fields || !$scope.showCommentsAndWorkNotes)
          return;
        $scope.fieldsVisible = 0;
        angular.forEach($scope.formJournalFields, function(formField) {
          if (!$scope.fields[formField.name])
            return;
          $scope.fields[formField.name].value = formField.value;
          $scope.fields[formField.name].mandatory = formField.mandatory;
          $scope.fields[formField.name].label = formField.label;
          $scope.fields[formField.name].messages = formField.messages;
          $scope.fields[formField.name].visible = formField.visible &amp;&amp; !formField.readonly;
          if ($scope.fields[formField.name].visible)
            $scope.fieldsVisible++;
        });
      }

      function setPrimaryJournalField() {
        if (!$scope.fields || !$scope.showCommentsAndWorkNotes)
          return;
        angular.forEach($scope.fields, function(item) {
          item.isPrimary = false;
        });
        var visibleFields = Object.keys($scope.fields).filter(function(item) {
          return $scope.fields[item].visible;
        });
        if (visibleFields.indexOf($scope.preferredInput) != -1) {
          $scope.inputType = $scope.preferredInput;
          $scope.fields[$scope.preferredInput].checked = true;
        }
        for (var i = 0; i &lt; primaryJournalFieldOrder.length; i++) {
          var fieldName = primaryJournalFieldOrder[i];
          if (visibleFields.indexOf(fieldName) != -1) {
            $scope.fields[fieldName].isPrimary = true;
            primaryJournalField = fieldName;
            if (!$scope.inputType)
              $scope.inputType = fieldName;
            break;
          }
        }
        if (!$scope.inputType &amp;&amp; visibleFields.length &gt; 0) {
          primaryJournalField = visibleFields[0];
          $scope.inputType = primaryJournalField;
          $scope.fields[primaryJournalField].isPrimary = true;
        }
      }

      function setShowAllFields() {
        $scope.showAllFields = $scope.allFields &amp;&amp; !$scope.allFields.some(function(item) {
          return !item.isActive;
        });
        $scope.hideAllFields = !$scope.allFields || !$scope.allFields.some(function(item) {
          return item.isActive;
        });
      }
      $scope.setPrimary = function(entry) {
        angular.forEach($scope.fields, function(item) {
          item.checked = false;
        });
        for (var i = 0; i &lt; primaryJournalFieldOrder.length; i++) {
          var fieldName = primaryJournalFieldOrder[i];
          if (entry.writable_journal_fields.indexOf(fieldName) != -1) {
            entry.primaryJournalField = fieldName;
            entry.inputType = fieldName;
            return;
          }
        }
        if (!entry.inputType) {
          var primaryField = entry.writable_journal_fields[0];
          entry.primaryJournalField = primaryField;
          entry.inputType = primaryField;
        }
      }
      $scope.updateFieldVisibilityAll = function() {
        $scope.showAllFields = !$scope.showAllFields;
        angular.forEach($scope.allFields, function(item) {
          item.isActive = $scope.showAllFields;
        });
        $scope.updateFieldVisibility();
      }
      $scope.updateFieldVisibility = function() {
        var activeFields = $scope.allFields.filter(function(item) {
          return item.isActive;
        }).map(function(item) {
          return item.name + ',' + item.isActive;
        });
        setShowAllFields();
        userPreferences
          .setPreference($scope.table + '.activity.filter', activeFields.join(';'))
          .then(function() {
            reset();
          })
      }
      $scope.configureAvailableFields = function() {
        $window.personalizer($scope.table, 'activity', $scope.sysId);
      }
      $scope.toggleMultipleInputs = function(val) {
        userPreferences.setPreference('glide.ui.activity_stream.multiple_inputs', val ? 'true' : 'false')
          .then(function() {
            $scope.useMultipleInputs = val;
            setMultipleInputs();
          });
      }
      $scope.changeEntryInputType = function(fieldName, entry) {
        var checked = $scope.fields[fieldName].checked;
        entry.inputType = checked ? fieldName : entry.primaryJournalField;
      }

      function processEntries(entries) {
        if (!entries || !entries.length)
          return;
        entries = entries.reverse();
        var newEntries = [];
        angular.forEach(entries, function(entry) {
          var entriesToAdd = [entry];
          if (entry.attachment) {
            entry.type = getAttachmentType(entry.attachment);
            entry.attachment.filesize = formatSize(entry.attachment.size_bytes);
            entry.attachment.extension = getAttachmentExt(entry.attachment);
          } else if (entry.is_email === true) {
            entry.email = {};
            var allFields = entry.entries.custom;
            for (var i = 0; i &lt; allFields.length; i++) {
              entry.email[allFields[i].field_name] = {
                label: allFields[i]['field_label'],
                displayValue: allFields[i]['new_value']
              };
            }
            entry['entries'].custom = [];
          } else if ($scope.sysId) {
            entriesToAdd = extractJournalEntries(entry);
          } else {
            entriesToAdd = handleJournalEntriesWithoutExtraction(entry);
          }
          if (entriesToAdd instanceof Array) {
            entriesToAdd.forEach(function(e) {
              $scope.entries.unshift(e);
              newEntries.unshift(e);
            });
          } else {
            $scope.entries.unshift(entriesToAdd);
            newEntries.unshift(entriesToAdd)
          }
          if (source != FROM_FORM)
            $scope.entries = $scope.entries.slice(0, 49);
          if ($scope.maxEntries != undefined) {
            var maxNumEntries = parseInt($scope.maxEntries, 10);
            $scope.entries = $scope.entries.slice(0, maxNumEntries);
          }
        });
        if ($scope.loaded) {
          $scope.$emit("sn.stream.new_entries", newEntries);
          triggerResize();
        } else if ($scope.pageSize &amp;&amp; $scope.entries.length &gt; $scope.pageSize)
          setUpPaging();
      }

      function setUpPaging() {
        $scope.showAllEntriesButton = true;
        $scope.allEntries = $scope.entries;
        $scope.entries = [];
        loadEntries(0, $scope.pageSize);
      }
      $scope.loadMore = function() {
        if ($scope.entries.length + $scope.pageSize &gt; $scope.allEntries.length) {
          $scope.loadAll();
          return;
        }
        loadEntries($scope.loadedEntries, $scope.loadedEntries + $scope.pageSize);
      }
      $scope.loadAll = function() {
        $scope.showAllEntriesButton = false;
        loadEntries($scope.loadedEntries, $scope.allEntries.length);
      }

      function loadEntries(start, end) {
        $scope.entries = $scope.entries.concat($scope.allEntries.slice(start, end));
        $scope.loadedEntries = $scope.entries.length;
      }

      function getAttachmentType(attachment) {
        if (attachment.content_type.startsWith('image/'))
          return 'attachment-image';
        return 'attachment';
      }

      function getAttachmentExt(attachment) {
        var filename = attachment.file_name;
        return filename.substring(filename.lastIndexOf('.') + 1);
      }

      function formatSize(bytes) {
        if (bytes &gt;= 1000000000)
          bytes = (bytes / 1000000000).toFixed(2) + ' GB';
        else if (bytes &gt;= 1000000)
          bytes = (bytes / 1000000).toFixed(2) + ' MB';
        else if (bytes &gt;= 1000)
          bytes = (bytes / 1000).toFixed(2) + ' KB';
        else if (bytes &gt; 1)
          bytes = bytes + ' bytes';
        else if (bytes == 1)
          bytes = bytes + ' byte';
        else
          bytes = '';
        return bytes;
      }

      function handleJournalEntriesWithoutExtraction(oneLargeEntry) {
        if (oneLargeEntry.entries.journal.length === 0)
          return oneLargeEntry;
        for (var i = 0; i &lt; oneLargeEntry.entries.journal.length; i++) {
          newLinesToBR(oneLargeEntry.entries.journal);
        }
        return oneLargeEntry;
      }

      function extractJournalEntries(oneLargeEntry) {
        var smallerEntries = [];
        if (oneLargeEntry.entries.journal.length === 0)
          return oneLargeEntry;
        for (var i = 0; i &lt; oneLargeEntry.entries.journal.length; i++) {
          var journalEntry = angular.copy(oneLargeEntry);
          journalEntry.entries.journal = journalEntry.entries.journal.slice(i, i + 1);
          newLinesToBR(journalEntry.entries.journal);
          journalEntry.entries.changes = [];
          journalEntry.type = 'journal';
          smallerEntries.unshift(journalEntry);
        }
        oneLargeEntry.entries.journal = [];
        oneLargeEntry.type = 'changes';
        if (oneLargeEntry.entries.changes.length &gt; 0)
          smallerEntries.unshift(oneLargeEntry);
        return smallerEntries;
      }

      function newLinesToBR(entries) {
        angular.forEach(entries, function(item) {
          if (!item.new_value)
            return;
          item.new_value = item.new_value.replace(/\n/g, '&lt;br/&gt;');
        });
      }

      function cancelStream() {
        if (_firstPollTimeout) {
          clearTimeout(_firstPollTimeout);
          _firstPollTimeout = false;
        }
        if (!stream)
          return false;
        stream.cancel();
        stream = null;
        return true;
      }

      function setMultipleInputs() {
        $scope.multipleInputs = $scope.useMultipleInputs;
        if ($scope.useMultipleInputs === true || !$scope.formJournalFields) {
          return;
        }
        var numAffectedFields = 0;
        angular.forEach($scope.formJournalFields, function(item) {
          if (item.mandatory || item.value)
            numAffectedFields++;
        });
        if (numAffectedFields &gt; 0)
          $scope.multipleInputs = true;
      }

      function triggerResize() {
        if (window._frameChanged)
          setTimeout(_frameChanged, 0);
      }
    },
    link: function(scope, element, attrs) {
      element.on("click", ".at-mention", function(evt) {
        var userID = angular.element(evt.target).attr('class').substring("at-mention at-mention-user-".length);
        $http({
          url: '/api/now/form/mention/user/' + userID,
          method: "GET"
        }).then(function(response) {
          scope.showPopover = true;
          scope.mentionPopoverProfile = response.data.result;
          scope.clickEvent = evt;
        }, function() {
          $http({
            url: '/api/now/live/profiles/' + userID,
            method: "GET"
          }).then(function(response) {
            scope.showPopover = true;
            var tempProfile = response.data.result;
            tempProfile.userID = tempProfile.sys_id = response.data.result.document;
            scope.mentionPopoverProfile = tempProfile;
            scope.mentionPopoverProfile.sysID = response.data.result["userID"];
            scope.clickEvent = evt;
          })
        });
      });
      scope.toggleEmailIframe = function(email, event) {
        email.expanded = email.expanded ? false : true;
        event.preventDefault();
      };
      $templateRequest(getTemplateUrl(attrs.template || "list_stream_entry")).then(function(template) {
        var elm = element.find("#activity-stream-unordered-list-entries");
        var entries = angular.element("&lt;li class=\"h-card h-card_md h-card_comments\" ng-click=\"controls.showRecord($event, entry, sysId)\" ng-repeat=\"entry in entries | orderBy:'-sys_created_on'\" ng-animate=\"'sn-animate-stream-entry'\"&gt;" + template + "&lt;/li&gt;");
        elm.append(entries);
        $compile(entries)(scope);
      });
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/stream/directive.snExpandedEmail.js */
angular.module("sn.common.stream").directive("snExpandedEmail", function() {
  "use strict";
  return {
    restrict: "E",
    replace: true,
    scope: {
      email: "="
    },
    template: "&lt;iframe style='width: 100%;' class='card' src='{{::emailBodySrc}}'&gt;&lt;/iframe&gt;",
    controller: function($scope) {
      $scope.emailBodySrc = "email_display.do?email_id=" + $scope.email.sys_id.displayValue;
    },
    link: function(scope, element) {
      element.load(function() {
        var bodyHeight = $j(this).get(0).contentWindow.document.body.scrollHeight + "px";
        $j(this).height(bodyHeight);
      });
    }
  };
});;;;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/js_includes_attachments.js */
/*! RESOURCE: /scripts/angularjs-1.4/thirdparty/angular-file-upload/angular-file-upload-all.js */
(function() {
  function patchXHR(fnName, newFn) {
    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
  }
  if (window.XMLHttpRequest &amp;&amp; !window.XMLHttpRequest.__isFileAPIShim) {
    patchXHR('setRequestHeader', function(orig) {
      return function(header, value) {
        if (header === '__setXHR_') {
          var val = value(this);
          if (val instanceof Function) {
            val(this);
          }
        } else {
          orig.apply(this, arguments);
        }
      }
    });
  }
  var angularFileUpload = angular.module('angularFileUpload', []);
  angularFileUpload.version = '3.1.2';
  angularFileUpload.service('$upload', ['$http', '$q', '$timeout', function($http, $q, $timeout) {
    function sendHttp(config) {
      config.method = config.method || 'POST';
      config.headers = config.headers || {};
      config.transformRequest = config.transformRequest || function(data, headersGetter) {
        if (window.ArrayBuffer &amp;&amp; data instanceof window.ArrayBuffer) {
          return data;
        }
        return $http.defaults.transformRequest[0](data, headersGetter);
      };
      var deferred = $q.defer();
      var promise = deferred.promise;
      config.headers['__setXHR_'] = function() {
        return function(xhr) {
          if (!xhr) return;
          config.__XHR = xhr;
          config.xhrFn &amp;&amp; config.xhrFn(xhr);
          xhr.upload.addEventListener('progress', function(e) {
            e.config = config;
            deferred.notify ? deferred.notify(e) : promise.progress_fn &amp;&amp; $timeout(function() {
              promise.progress_fn(e)
            });
          }, false);
          xhr.upload.addEventListener('load', function(e) {
            if (e.lengthComputable) {
              e.config = config;
              deferred.notify ? deferred.notify(e) : promise.progress_fn &amp;&amp; $timeout(function() {
                promise.progress_fn(e)
              });
            }
          }, false);
        };
      };
      $http(config).then(function(r) {
        deferred.resolve(r)
      }, function(e) {
        deferred.reject(e)
      }, function(n) {
        deferred.notify(n)
      });
      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };
      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };
      promise.progress = function(fn) {
        promise.progress_fn = fn;
        promise.then(null, null, function(update) {
          fn(update);
        });
        return promise;
      };
      promise.abort = function() {
        if (config.__XHR) {
          $timeout(function() {
            config.__XHR.abort();
          });
        }
        return promise;
      };
      promise.xhr = function(fn) {
        config.xhrFn = (function(origXhrFn) {
          return function() {
            origXhrFn &amp;&amp; origXhrFn.apply(promise, arguments);
            fn.apply(promise, arguments);
          }
        })(config.xhrFn);
        return promise;
      };
      return promise;
    }
    this.upload = function(config) {
      config.headers = config.headers || {};
      config.headers['Content-Type'] = undefined;
      var origTransformRequest = config.transformRequest;
      config.transformRequest = config.transformRequest ?
        (Object.prototype.toString.call(config.transformRequest) === '[object Array]' ?
          config.transformRequest : [config.transformRequest]) : [];
      config.transformRequest.push(function(data, headerGetter) {
        var formData = new FormData();
        var allFields = {};
        for (var key in config.fields) allFields[key] = config.fields[key];
        if (data) allFields['data'] = data;
        if (config.formDataAppender) {
          for (var key in allFields) {
            config.formDataAppender(formData, key, allFields[key]);
          }
        } else {
          for (var key in allFields) {
            var val = allFields[key];
            if (val !== undefined) {
              if (Object.prototype.toString.call(val) === '[object String]') {
                formData.append(key, val);
              } else {
                if (config.sendObjectsAsJsonBlob &amp;&amp; typeof val === 'object') {
                  formData.append(key, new Blob([val], {
                    type: 'application/json'
                  }));
                } else {
                  formData.append(key, JSON.stringify(val));
                }
              }
            }
          }
        }
        if (config.file != null) {
          var fileFormName = config.fileFormDataName || 'file';
          if (Object.prototype.toString.call(config.file) === '[object Array]') {
            var isFileFormNameString = Object.prototype.toString.call(fileFormName) === '[object String]';
            for (var i = 0; i &lt; config.file.length; i++) {
              formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i],
                (config.fileName &amp;&amp; config.fileName[i]) || config.file[i].name);
            }
          } else {
            formData.append(fileFormName, config.file, config.fileName || config.file.name);
          }
        }
        return formData;
      });
      return sendHttp(config);
    };
    this.http = function(config) {
      return sendHttp(config);
    };
  }]);
  angularFileUpload.directive('ngFileSelect', ['$parse', '$timeout', '$compile',
    function($parse, $timeout, $compile) {
      return {
        restrict: 'AEC',
        require: '?ngModel',
        link: function(scope, elem, attr, ngModel) {
          handleFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile);
        }
      }
    }
  ]);

  function handleFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile) {
    function isInputTypeFile() {
      return elem[0].tagName.toLowerCase() === 'input' &amp;&amp; elem.attr('type') &amp;&amp; elem.attr('type').toLowerCase() === 'file';
    }
    var watchers = [];

    function watchForRecompile(attrVal) {
      $timeout(function() {
        if (elem.parent().length) {
          watchers.push(scope.$watch(attrVal, function(val, oldVal) {
            if (val != oldVal) {
              recompileElem();
            }
          }));
        }
      });
    }

    function recompileElem() {
      var clone = elem.clone();
      if (elem.attr('__afu_gen__')) {
        angular.element(document.getElementById(elem.attr('id').substring(1))).remove();
      }
      if (elem.parent().length) {
        for (var i = 0; i &lt; watchers.length; i++) {
          watchers[i]();
        }
        elem.replaceWith(clone);
        $compile(clone)(scope);
      }
      return clone;
    }

    function bindAttr(bindAttr, attrName) {
      if (bindAttr) {
        watchForRecompile(bindAttr);
        var val = $parse(bindAttr)(scope);
        if (val) {
          elem.attr(attrName, val);
          attr[attrName] = val;
        } else {
          elem.attr(attrName, null);
          delete attr[attrName];
        }
      }
    }
    bindAttr(attr.ngMultiple, 'multiple');
    bindAttr(attr.ngAccept, 'ng-accept');
    bindAttr(attr.ngCapture, 'capture');
    if (attr['ngFileSelect'] != '') {
      attr.ngFileChange = attr.ngFileSelect;
    }

    function onChangeFn(evt) {
      var files = [],
        fileList, i;
      fileList = evt.__files_ || (evt.target &amp;&amp; evt.target.files);
      updateModel(fileList, attr, ngModel, scope, evt);
    };
    var fileElem = elem;
    if (!isInputTypeFile()) {
      fileElem = angular.element('&lt;input type="file"&gt;')
      if (elem.attr('multiple')) fileElem.attr('multiple', elem.attr('multiple'));
      if (elem.attr('accept')) fileElem.attr('accept', elem.attr('accept'));
      if (elem.attr('capture')) fileElem.attr('capture', elem.attr('capture'));
      for (var key in attr) {
        if (key.indexOf('inputFile') == 0) {
          var name = key.substring('inputFile'.length);
          name = name[0].toLowerCase() + name.substring(1);
          fileElem.attr(name, attr[key]);
        }
      }
      fileElem.css('width', '0px').css('height', '0px').css('position', 'absolute').css('padding', 0).css('margin', 0)
        .css('overflow', 'hidden').attr('tabindex', '-1').css('opacity', 0).attr('__afu_gen__', true);
      elem.attr('__refElem__', true);
      fileElem[0].__refElem__ = elem[0];
      elem.parent()[0].insertBefore(fileElem[0], elem[0])
      elem.css('overflow', 'hidden');
      elem.bind('click', function(e) {
        if (!resetAndClick(e)) {
          fileElem[0].click();
        }
      });
    } else {
      elem.bind('click', resetAndClick);
    }

    function resetAndClick(evt) {
      if (fileElem[0].value != null &amp;&amp; fileElem[0].value != '') {
        fileElem[0].value = null;
        if (navigator.userAgent.indexOf("Trident/7") === -1) {
          onChangeFn({
            target: {
              files: []
            }
          });
        }
      }
      if (!elem.attr('__afu_clone__')) {
        if (navigator.appVersion.indexOf("MSIE 10") !== -1 || navigator.userAgent.indexOf("Trident/7") !== -1) {
          var clone = recompileElem();
          clone.attr('__afu_clone__', true);
          clone[0].click();
          evt.preventDefault();
          evt.stopPropagation();
          return true;
        }
      } else {
        elem.attr('__afu_clone__', null);
      }
    }
    fileElem.bind('change', onChangeFn);
    elem.on('$destroy', function() {
      for (var i = 0; i &lt; watchers.length; i++) {
        watchers[i]();
      }
      if (elem[0] != fileElem[0]) fileElem.remove();
    });
    watchers.push(scope.$watch(attr.ngModel, function(val, oldVal) {
      if (val != oldVal &amp;&amp; (val == null || !val.length)) {
        if (navigator.appVersion.indexOf("MSIE 10") !== -1) {
          recompileElem();
        } else {
          fileElem[0].value = null;
        }
      }
    }));

    function updateModel(fileList, attr, ngModel, scope, evt) {
      var files = [],
        rejFiles = [];
      var accept = $parse(attr.ngAccept)(scope);
      var regexp = angular.isString(accept) &amp;&amp; accept ? new RegExp(globStringToRegex(accept), 'gi') : null;
      var acceptFn = regexp ? null : attr.ngAccept;
      for (var i = 0; i &lt; fileList.length; i++) {
        var file = fileList.item(i);
        if ((!regexp || file.type.match(regexp) || (file.name != null &amp;&amp; file.name.match(regexp))) &amp;&amp;
          (!acceptFn || $parse(acceptFn)(scope, {
            $file: file,
            $event: evt
          }))) {
          files.push(file);
        } else {
          rejFiles.push(file);
        }
      }
      $timeout(function() {
        if (ngModel) {
          $parse(attr.ngModel).assign(scope, files);
          ngModel &amp;&amp; ngModel.$setViewValue(files != null &amp;&amp; files.length == 0 ? '' : files);
          if (attr.ngModelRejected) {
            $parse(attr.ngModelRejected).assign(scope, rejFiles);
          }
        }
        if (attr.ngFileChange &amp;&amp; attr.ngFileChange != "") {
          $parse(attr.ngFileChange)(scope, {
            $files: files,
            $rejectedFiles: rejFiles,
            $event: evt
          });
        }
      });
    }
  }
  angularFileUpload.directive('ngFileDrop', ['$parse', '$timeout', '$location', function($parse, $timeout, $location) {
    return {
      restrict: 'AEC',
      require: '?ngModel',
      link: function(scope, elem, attr, ngModel) {
        handleDrop(scope, elem, attr, ngModel, $parse, $timeout, $location);
      }
    }
  }]);
  angularFileUpload.directive('ngNoFileDrop', function() {
    return function(scope, elem, attr) {
      if (dropAvailable()) elem.css('display', 'none')
    }
  });
  angularFileUpload.directive('ngFileDropAvailable', ['$parse', '$timeout', function($parse, $timeout) {
    return function(scope, elem, attr) {
      if (dropAvailable()) {
        var fn = $parse(attr['ngFileDropAvailable']);
        $timeout(function() {
          fn(scope);
        });
      }
    }
  }]);

  function handleDrop(scope, elem, attr, ngModel, $parse, $timeout, $location) {
    var available = dropAvailable();
    if (attr['dropAvailable']) {
      $timeout(function() {
        scope.dropAvailable ? scope.dropAvailable.value = available : scope.dropAvailable = available;
      });
    }
    if (!available) {
      if ($parse(attr.hideOnDropNotAvailable)(scope) != false) {
        elem.css('display', 'none');
      }
      return;
    }
    var leaveTimeout = null;
    var stopPropagation = $parse(attr.stopPropagation)(scope);
    var dragOverDelay = 1;
    var accept = $parse(attr.ngAccept)(scope) || attr.accept;
    var regexp = angular.isString(accept) &amp;&amp; accept ? new RegExp(globStringToRegex(accept), 'gi') : null;
    var acceptFn = regexp ? null : attr.ngAccept;
    var actualDragOverClass;
    elem[0].addEventListener('dragover', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
      if (navigator.userAgent.indexOf("Chrome") &gt; -1) {
        var b = evt.dataTransfer.effectAllowed;
        evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
      }
      $timeout.cancel(leaveTimeout);
      if (!scope.actualDragOverClass) {
        actualDragOverClass = calculateDragOverClass(scope, attr, evt);
      }
      elem.addClass(actualDragOverClass);
    }, false);
    elem[0].addEventListener('dragenter', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
    }, false);
    elem[0].addEventListener('dragleave', function(evt) {
      leaveTimeout = $timeout(function() {
        elem.removeClass(actualDragOverClass);
        actualDragOverClass = null;
      }, dragOverDelay || 1);
    }, false);
    if (attr['ngFileDrop'] != '') {
      attr.ngFileChange = attr['ngFileDrop'];
    }
    elem[0].addEventListener('drop', function(evt) {
      evt.preventDefault();
      if (stopPropagation) evt.stopPropagation();
      elem.removeClass(actualDragOverClass);
      actualDragOverClass = null;
      extractFiles(evt, function(files, rejFiles) {
        $timeout(function() {
          if (ngModel) {
            $parse(attr.ngModel).assign(scope, files);
            ngModel &amp;&amp; ngModel.$setViewValue(files != null &amp;&amp; files.length == 0 ? '' : files);
          }
          if (attr['ngModelRejected']) {
            if (scope[attr.ngModelRejected]) {
              $parse(attr.ngModelRejected).assign(scope, rejFiles);
            }
          }
        });
        $timeout(function() {
          $parse(attr.ngFileChange)(scope, {
            $files: files,
            $rejectedFiles: rejFiles,
            $event: evt
          });
        });
      }, $parse(attr.allowDir)(scope) != false, attr.multiple || $parse(attr.ngMultiple)(scope));
    }, false);

    function calculateDragOverClass(scope, attr, evt) {
      var valid = true;
      if (regexp || acceptFn) {
        var items = evt.dataTransfer.items;
        if (items != null) {
          for (var i = 0; i &lt; items.length &amp;&amp; valid; i++) {
            valid = valid &amp;&amp; (items[i].kind == 'file' || items[i].kind == '') &amp;&amp;
              ((acceptFn &amp;&amp; $parse(acceptFn)(scope, {
                  $file: items[i],
                  $event: evt
                })) ||
                (regexp &amp;&amp; (items[i].type != null &amp;&amp; items[i].type.match(regexp)) ||
                  (items[i].name != null &amp;&amp; items[i].name.match(regexp))));
          }
        }
      }
      var clazz = $parse(attr.dragOverClass)(scope, {
        $event: evt
      });
      if (clazz) {
        if (clazz.delay) dragOverDelay = clazz.delay;
        if (clazz.accept) clazz = valid ? clazz.accept : clazz.reject;
      }
      return clazz || attr['dragOverClass'] || 'dragover';
    }

    function extractFiles(evt, callback, allowDir, multiple) {
      var files = [],
        rejFiles = [],
        items = evt.dataTransfer.items,
        processing = 0;

      function addFile(file) {
        if ((!regexp || file.type.match(regexp) || (file.name != null &amp;&amp; file.name.match(regexp))) &amp;&amp;
          (!acceptFn || $parse(acceptFn)(scope, {
            $file: file,
            $event: evt
          }))) {
          files.push(file);
        } else {
          rejFiles.push(file);
        }
      }
      if (items &amp;&amp; items.length &gt; 0 &amp;&amp; $location.protocol() != 'file') {
        for (var i = 0; i &lt; items.length; i++) {
          if (items[i].webkitGetAsEntry &amp;&amp; items[i].webkitGetAsEntry() &amp;&amp; items[i].webkitGetAsEntry().isDirectory) {
            var entry = items[i].webkitGetAsEntry();
            if (entry.isDirectory &amp;&amp; !allowDir) {
              continue;
            }
            if (entry != null) {
              traverseFileTree(files, entry);
            }
          } else {
            var f = items[i].getAsFile();
            if (f != null) addFile(f);
          }
          if (!multiple &amp;&amp; files.length &gt; 0) break;
        }
      } else {
        var fileList = evt.dataTransfer.files;
        if (fileList != null) {
          for (var i = 0; i &lt; fileList.length; i++) {
            addFile(fileList.item(i));
            if (!multiple &amp;&amp; files.length &gt; 0) break;
          }
        }
      }
      var delays = 0;
      (function waitForProcess(delay) {
        $timeout(function() {
          if (!processing) {
            if (!multiple &amp;&amp; files.length &gt; 1) {
              var i = 0;
              while (files[i].type == 'directory') i++;
              files = [files[i]];
            }
            callback(files, rejFiles);
          } else {
            if (delays++ * 10 &lt; 20 * 1000) {
              waitForProcess(10);
            }
          }
        }, delay || 0)
      })();

      function traverseFileTree(files, entry, path) {
        if (entry != null) {
          if (entry.isDirectory) {
            var filePath = (path || '') + entry.name;
            addFile({
              name: entry.name,
              type: 'directory',
              path: filePath
            });
            var dirReader = entry.createReader();
            var entries = [];
            processing++;
            var readEntries = function() {
              dirReader.readEntries(function(results) {
                try {
                  if (!results.length) {
                    for (var i = 0; i &lt; entries.length; i++) {
                      traverseFileTree(files, entries[i], (path ? path : '') + entry.name + '/');
                    }
                    processing--;
                  } else {
                    entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                    readEntries();
                  }
                } catch (e) {
                  processing--;
                  console.error(e);
                }
              }, function() {
                processing--;
              });
            };
            readEntries();
          } else {
            processing++;
            entry.file(function(file) {
              try {
                processing--;
                file.path = (path ? path : '') + file.name;
                addFile(file);
              } catch (e) {
                processing--;
                console.error(e);
              }
            }, function(e) {
              processing--;
            });
          }
        }
      }
    }
  }

  function dropAvailable() {
    var div = document.createElement('div');
    return ('draggable' in div) &amp;&amp; ('ondrop' in div);
  }

  function globStringToRegex(str) {
    if (str.length &gt; 2 &amp;&amp; str[0] === '/' &amp;&amp; str[str.length - 1] === '/') {
      return str.substring(1, str.length - 1);
    }
    var split = str.split(','),
      result = '';
    if (split.length &gt; 1) {
      for (var i = 0; i &lt; split.length; i++) {
        result += '(' + globStringToRegex(split[i]) + ')';
        if (i &lt; split.length - 1) {
          result += '|'
        }
      }
    } else {
      if (str.indexOf('.') == 0) {
        str = '*' + str;
      }
      result = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!&lt;&gt;|:\\' + '-]', 'g'), '\\$&amp;') + '$';
      result = result.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
    }
    return result;
  }
  var ngFileUpload = angular.module('ngFileUpload', []);
  for (var key in angularFileUpload) {
    ngFileUpload[key] = angularFileUpload[key];
  }
})();
(function() {
  var hasFlash = function() {
    try {
      var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
      if (fo) return true;
    } catch (e) {
      if (navigator.mimeTypes['application/x-shockwave-flash'] != undefined) return true;
    }
    return false;
  }

  function patchXHR(fnName, newFn) {
    window.XMLHttpRequest.prototype[fnName] = newFn(window.XMLHttpRequest.prototype[fnName]);
  };
  if ((window.XMLHttpRequest &amp;&amp; !window.FormData) || (window.FileAPI &amp;&amp; FileAPI.forceLoad)) {
    var initializeUploadListener = function(xhr) {
      if (!xhr.__listeners) {
        if (!xhr.upload) xhr.upload = {};
        xhr.__listeners = [];
        var origAddEventListener = xhr.upload.addEventListener;
        xhr.upload.addEventListener = function(t, fn, b) {
          xhr.__listeners[t] = fn;
          origAddEventListener &amp;&amp; origAddEventListener.apply(this, arguments);
        };
      }
    }
    patchXHR('open', function(orig) {
      return function(m, url, b) {
        initializeUploadListener(this);
        this.__url = url;
        try {
          orig.apply(this, [m, url, b]);
        } catch (e) {
          if (e.message.indexOf('Access is denied') &gt; -1) {
            this.__origError = e;
            orig.apply(this, [m, '_fix_for_ie_crossdomain__', b]);
          }
        }
      }
    });
    patchXHR('getResponseHeader', function(orig) {
      return function(h) {
        return this.__fileApiXHR &amp;&amp; this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(h) : (orig == null ? null : orig.apply(this, [h]));
      };
    });
    patchXHR('getAllResponseHeaders', function(orig) {
      return function() {
        return this.__fileApiXHR &amp;&amp; this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : (orig == null ? null : orig.apply(this));
      }
    });
    patchXHR('abort', function(orig) {
      return function() {
        return this.__fileApiXHR &amp;&amp; this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : (orig == null ? null : orig.apply(this));
      }
    });
    patchXHR('setRequestHeader', function(orig) {
      return function(header, value) {
        if (header === '__setXHR_') {
          initializeUploadListener(this);
          var val = value(this);
          if (val instanceof Function) {
            val(this);
          }
        } else {
          this.__requestHeaders = this.__requestHeaders || {};
          this.__requestHeaders[header] = value;
          orig.apply(this, arguments);
        }
      }
    });

    function redefineProp(xhr, prop, fn) {
      try {
        Object.defineProperty(xhr, prop, {
          get: fn
        });
      } catch (e) {}
    }
    patchXHR('send', function(orig) {
      return function() {
        var xhr = this;
        if (arguments[0] &amp;&amp; arguments[0].__isFileAPIShim) {
          var formData = arguments[0];
          var config = {
            url: xhr.__url,
            jsonp: false,
            cache: true,
            complete: function(err, fileApiXHR) {
              xhr.__completed = true;
              if (!err &amp;&amp; xhr.__listeners['load'])
                xhr.__listeners['load']({
                  type: 'load',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (!err &amp;&amp; xhr.__listeners['loadend'])
                xhr.__listeners['loadend']({
                  type: 'loadend',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (err === 'abort' &amp;&amp; xhr.__listeners['abort'])
                xhr.__listeners['abort']({
                  type: 'abort',
                  loaded: xhr.__loaded,
                  total: xhr.__total,
                  target: xhr,
                  lengthComputable: true
                });
              if (fileApiXHR.status !== undefined) redefineProp(xhr, 'status', function() {
                return (fileApiXHR.status == 0 &amp;&amp; err &amp;&amp; err !== 'abort') ? 500 : fileApiXHR.status
              });
              if (fileApiXHR.statusText !== undefined) redefineProp(xhr, 'statusText', function() {
                return fileApiXHR.statusText
              });
              redefineProp(xhr, 'readyState', function() {
                return 4
              });
              if (fileApiXHR.response !== undefined) redefineProp(xhr, 'response', function() {
                return fileApiXHR.response
              });
              var resp = fileApiXHR.responseText || (err &amp;&amp; fileApiXHR.status == 0 &amp;&amp; err !== 'abort' ? err : undefined);
              redefineProp(xhr, 'responseText', function() {
                return resp
              });
              redefineProp(xhr, 'response', function() {
                return resp
              });
              if (err) redefineProp(xhr, 'err', function() {
                return err
              });
              xhr.__fileApiXHR = fileApiXHR;
              if (xhr.onreadystatechange) xhr.onreadystatechange();
              if (xhr.onload) xhr.onload();
            },
            fileprogress: function(e) {
              e.target = xhr;
              xhr.__listeners['progress'] &amp;&amp; xhr.__listeners['progress'](e);
              xhr.__total = e.total;
              xhr.__loaded = e.loaded;
              if (e.total === e.loaded) {
                var _this = this
                setTimeout(function() {
                  if (!xhr.__completed) {
                    xhr.getAllResponseHeaders = function() {};
                    _this.complete(null, {
                      status: 204,
                      statusText: 'No Content'
                    });
                  }
                }, FileAPI.noContentTimeout || 10000);
              }
            },
            headers: xhr.__requestHeaders
          }
          config.data = {};
          config.files = {}
          for (var i = 0; i &lt; formData.data.length; i++) {
            var item = formData.data[i];
            if (item.val != null &amp;&amp; item.val.name != null &amp;&amp; item.val.size != null &amp;&amp; item.val.type != null) {
              config.files[item.key] = item.val;
            } else {
              config.data[item.key] = item.val;
            }
          }
          setTimeout(function() {
            if (!hasFlash()) {
              throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
            }
            xhr.__fileApiXHR = FileAPI.upload(config);
          }, 1);
        } else {
          if (this.__origError) {
            throw this.__origError;
          }
          orig.apply(xhr, arguments);
        }
      }
    });
    window.XMLHttpRequest.__isFileAPIShim = true;
    var addFlash = function(elem) {
      if (!hasFlash()) {
        throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"';
      }
      var el = angular.element(elem);
      if (!el.attr('disabled')) {
        var hasFileSelect = false;
        for (var i = 0; i &lt; el[0].attributes.length; i++) {
          var attrib = el[0].attributes[i];
          if (attrib.name.indexOf('file-select') !== -1) {
            hasFileSelect = true;
            break;
          }
        }
        if (!el.hasClass('js-fileapi-wrapper') &amp;&amp; (hasFileSelect || el.attr('__afu_gen__') != null)) {
          el.addClass('js-fileapi-wrapper');
          if (el.attr('__afu_gen__') != null) {
            var ref = (el[0].__refElem__ &amp;&amp; angular.element(el[0].__refElem__)) || el;
            while (ref &amp;&amp; !ref.attr('__refElem__')) {
              ref = angular.element(ref[0].nextSibling);
            }
            ref.bind('mouseover', function() {
              if (el.parent().css('position') === '' || el.parent().css('position') === 'static') {
                el.parent().css('position', 'relative');
              }
              el.css('position', 'absolute').css('top', ref[0].offsetTop + 'px').css('left', ref[0].offsetLeft + 'px')
                .css('width', ref[0].offsetWidth + 'px').css('height', ref[0].offsetHeight + 'px')
                .css('padding', ref.css('padding')).css('margin', ref.css('margin')).css('filter', 'alpha(opacity=0)');
              ref.attr('onclick', '');
              el.css('z-index', '1000');
            });
          }
        }
      }
    };
    var changeFnWrapper = function(fn) {
      return function(evt) {
        var files = FileAPI.getFiles(evt);
        for (var i = 0; i &lt; files.length; i++) {
          if (files[i].size === undefined) files[i].size = 0;
          if (files[i].name === undefined) files[i].name = 'file';
          if (files[i].type === undefined) files[i].type = 'undefined';
        }
        if (!evt.target) {
          evt.target = {};
        }
        evt.target.files = files;
        if (evt.target.files != files) {
          evt.__files_ = files;
        }
        (evt.__files_ || evt.target.files).item = function(i) {
          return (evt.__files_ || evt.target.files)[i] || null;
        }
        if (fn) fn.apply(this, [evt]);
      };
    };
    var isFileChange = function(elem, e) {
      return (e.toLowerCase() === 'change' || e.toLowerCase() === 'onchange') &amp;&amp; elem.getAttribute('type') == 'file';
    }
    if (HTMLInputElement.prototype.addEventListener) {
      HTMLInputElement.prototype.addEventListener = (function(origAddEventListener) {
        return function(e, fn, b, d) {
          if (isFileChange(this, e)) {
            addFlash(this);
            origAddEventListener.apply(this, [e, changeFnWrapper(fn), b, d]);
          } else {
            origAddEventListener.apply(this, [e, fn, b, d]);
          }
        }
      })(HTMLInputElement.prototype.addEventListener);
    }
    if (HTMLInputElement.prototype.attachEvent) {
      HTMLInputElement.prototype.attachEvent = (function(origAttachEvent) {
        return function(e, fn) {
          if (isFileChange(this, e)) {
            addFlash(this);
            if (window.jQuery) {
              angular.element(this).bind('change', changeFnWrapper(null));
            } else {
              origAttachEvent.apply(this, [e, changeFnWrapper(fn)]);
            }
          } else {
            origAttachEvent.apply(this, [e, fn]);
          }
        }
      })(HTMLInputElement.prototype.attachEvent);
    }
    window.FormData = FormData = function() {
      return {
        append: function(key, val, name) {
          if (val.__isFileAPIBlobShim) {
            val = val.data[0];
          }
          this.data.push({
            key: key,
            val: val,
            name: name
          });
        },
        data: [],
        __isFileAPIShim: true
      };
    };
    window.Blob = Blob = function(b) {
      return {
        data: b,
        __isFileAPIBlobShim: true
      };
    };
    (function() {
      if (!window.FileAPI) {
        window.FileAPI = {};
      }
      if (FileAPI.forceLoad) {
        FileAPI.html5 = false;
      }
      if (!FileAPI.upload) {
        var jsUrl, basePath, script = document.createElement('script'),
          allScripts = document.getElementsByTagName('script'),
          i, index, src;
        if (window.FileAPI.jsUrl) {
          jsUrl = window.FileAPI.jsUrl;
        } else if (window.FileAPI.jsPath) {
          basePath = window.FileAPI.jsPath;
        } else {
          for (i = 0; i &lt; allScripts.length; i++) {
            src = allScripts[i].src;
            index = src.search(/\/angular\-file\-upload[\-a-zA-z0-9\.]*\.js/)
            if (index &gt; -1) {
              basePath = src.substring(0, index + 1);
              break;
            }
          }
        }
        if (FileAPI.staticPath == null) FileAPI.staticPath = basePath;
        script.setAttribute('src', jsUrl || basePath + 'FileAPI.min.js');
        document.getElementsByTagName('head')[0].appendChild(script);
        FileAPI.hasFlash = hasFlash();
      }
    })();
    FileAPI.disableFileInput = function(elem, disable) {
      if (disable) {
        elem.removeClass('js-fileapi-wrapper')
      } else {
        elem.addClass('js-fileapi-wrapper');
      }
    }
  }
  if (!window.FileReader) {
    window.FileReader = function() {
      var _this = this,
        loadStarted = false;
      this.listeners = {};
      this.addEventListener = function(type, fn) {
        _this.listeners[type] = _this.listeners[type] || [];
        _this.listeners[type].push(fn);
      };
      this.removeEventListener = function(type, fn) {
        _this.listeners[type] &amp;&amp; _this.listeners[type].splice(_this.listeners[type].indexOf(fn), 1);
      };
      this.dispatchEvent = function(evt) {
        var list = _this.listeners[evt.type];
        if (list) {
          for (var i = 0; i &lt; list.length; i++) {
            list[i].call(_this, evt);
          }
        }
      };
      this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null;
      var constructEvent = function(type, evt) {
        var e = {
          type: type,
          target: _this,
          loaded: evt.loaded,
          total: evt.total,
          error: evt.error
        };
        if (evt.result != null) e.target.result = evt.result;
        return e;
      };
      var listener = function(evt) {
        if (!loadStarted) {
          loadStarted = true;
          _this.onloadstart &amp;&amp; _this.onloadstart(constructEvent('loadstart', evt));
        }
        if (evt.type === 'load') {
          _this.onloadend &amp;&amp; _this.onloadend(constructEvent('loadend', evt));
          var e = constructEvent('load', evt);
          _this.onload &amp;&amp; _this.onload(e);
          _this.dispatchEvent(e);
        } else if (evt.type === 'progress') {
          var e = constructEvent('progress', evt);
          _this.onprogress &amp;&amp; _this.onprogress(e);
          _this.dispatchEvent(e);
        } else {
          var e = constructEvent('error', evt);
          _this.onerror &amp;&amp; _this.onerror(e);
          _this.dispatchEvent(e);
        }
      };
      this.readAsArrayBuffer = function(file) {
        FileAPI.readAsBinaryString(file, listener);
      }
      this.readAsBinaryString = function(file) {
        FileAPI.readAsBinaryString(file, listener);
      }
      this.readAsDataURL = function(file) {
        FileAPI.readAsDataURL(file, listener);
      }
      this.readAsText = function(file) {
        FileAPI.readAsText(file, listener);
      }
    }
  }
})();;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/_module.js */
angular.module('sn.common.attachments', [
  'angularFileUpload',
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/factory.nowAttachmentHandler.js */
angular.module("sn.common.attachments").factory("nowAttachmentHandler", function($http, nowServer, $upload, $rootScope, $timeout,
  snNotification) {
  "use strict";
  return function(setAttachments, appendError) {
    var self = this;
    self.cardUploading = '';
    self.setAttachments = setAttachments;
    self.appendError = appendError;
    self.ADDED = 'added';
    self.DELETED = 'deleted';
    self.RENAMED = 'renamed';
    self.getAttachmentList = function(action) {
      var url = nowServer.getURL('ngk_attachments', {
        action: 'list',
        sys_id: self.tableId,
        table: self.tableName
      });
      $http.get(url).then(function(response) {
        var attachments = response.data.files || [];
        self.setAttachments(attachments, action);
        if (self.startedUploadingTimeout || self.errorTimeout) {
          self.stopAllUploading();
          $rootScope.$broadcast('board.uploading.end');
        }
      });
    };
    self.stopAllUploading = function() {
      $timeout.cancel(self.errorTimeout);
      $timeout.cancel(self.startedUploadingTimeout);
      hideProgressBar();
      $rootScope.$broadcast("attachment.upload.stop");
    };
    self.onFileSelect = function($files) {
      if (!$files.length)
        return;
      var url = nowServer.getURL('ngk_attachments', {
        sys_id: self.tableId,
        table: self.tableName,
        action: 'add'
      });
      self.cardUploading = self.tableId;
      self.maxfiles = $files.length;
      self.fileCount = 1;
      self.filesUploaded = self.maxfiles;
      self.startedUploadingTimeout = $timeout(showUploaderDialog, 1500);
      for (var i = 0; i &lt; self.maxfiles; i++) {
        if (parseInt($files[i].size) &gt; parseInt(self.fileUploadSizeLimit)) {
          self.stopAllUploading();
          $rootScope.$broadcast('dialog.upload_too_large.show');
          return;
        }
      }
      for (var i = 0; i &lt; self.maxfiles; i++) {
        $rootScope.$broadcast("attachment.upload.start");
        var file = $files[i];
        self.filesUploaded--;
        self.upload = $upload.upload({
          url: url,
          fields: {
            attachments_modified: 'true',
            sysparm_table: self.tableName,
            sysparm_sys_id: self.tableId,
            sysparm_nostack: 'yes',
            sysparm_encryption_context: '',
            sysparm_ck: window.g_ck
          },
          fileFormDataName: 'attachFile',
          file: file
        }).progress(function(evt) {
          var percent = parseInt(100.0 * evt.loaded / evt.total, 10);
          updateProgress(percent);
        }).success(function(data, status, headers, config) {
          processError(data);
          self.stopAllUploading();
          self.getAttachmentList(self.ADDED);
          if (self.filesUploaded &lt;= 0) {
            self.cardUploading = '';
          }
        });
      }
    };
    self.downloadAttachment = function(attachment) {
      window.location.href = '/sys_attachment.do?sys_id=' + attachment.sys_id;
    };
    self.viewAttachment = function($event, attachment) {
      var url = window.location.protocol + '//' + window.location.host;
      url += '/sys_attachment.do?sysparm_referring_url=tear_off&amp;view=true&amp;sys_id=' + attachment.sys_id;
      window.open(url, attachment.sys_id,
        "toolbar=no,menubar=no,personalbar=no,width=800,height=600,scrollbars=yes,resizable=yes");
    };
    self.editAttachment = function($event, attachment) {
      var parent = $($event.currentTarget).closest('.file-attachment');
      var thumbnail = parent.find('.thumbnail');
      var input = parent.find('input');
      var tools = parent.find('.tools');
      var fileName = attachment.file_name;
      if (attachment.file_name.indexOf('.') !== -1) {
        attachment.ext = fileName.match(/(\.[^\.]+)$/i)[0];
        fileName = attachment.file_name.replace(/(\.[^\.]+)$/i, '');
      }
      input.val(fileName);
      var w = input.prev().width();
      input.width(w);
      input.prev().hide();
      input.css('display', 'block');
      thumbnail.addClass('state-locked');
      tools.find('.delete-edit').hide();
      tools.find('.rename-cancel').css('display', 'inline-block');
      input.focus();
    }
    self.onKeyDown = function($event, attachment) {
      var keyCode = $event.keyCode;
      if (keyCode === 13) {
        $event.stopPropagation();
        $event.preventDefault();
        self.updateAttachment($event, attachment);
      } else if (keyCode === 27) {
        $event.stopPropagation();
        self.updateAttachment($event);
      }
    };
    self.updateAttachment = function($event, attachment) {
      var el = $($event.currentTarget);
      var parent = el.closest('.file-attachment');
      var thumbnail = parent.find('.thumbnail');
      var input = parent.find('input');
      var link = parent.find('a');
      var tools = parent.find('.tools');
      if (attachment) {
        var fileName = input.val();
        if (fileName.length) {
          fileName += attachment.ext;
          if (fileName !== attachment.file_name) {
            link.text(fileName);
            self.renameAttachment(attachment, fileName);
          }
        }
      }
      input.hide();
      input.prev().show();
      tools.find('.rename-cancel').hide();
      thumbnail.removeClass('state-locked');
      tools.find('.delete-edit').css('display', 'inline-block');
    };
    self.dismissMsg = function($event, $index, errorMessages) {
      var msg = $($event.currentTarget);
      msg.addClass('remove');
      setTimeout(function() {
        msg.remove();
        errorMessages.splice($index, 1);
      }, 500);
    };
    $rootScope.$on("dialog.comment_form.close", function() {
      hideProgressBar();
    });
    self.openSelector = function($event) {
      $event.stopPropagation();
      var target = $($event.currentTarget);
      var input = target.parent().find('input[type=file]');
      input.click();
    }
    self.deleteAttachment = function(attachment) {
      if (attachment &amp;&amp; attachment.sys_id) {
        $('#' + attachment.sys_id).hide();
        var url = nowServer.getURL('ngk_attachments', {
          action: 'delete',
          sys_id: attachment.sys_id
        });
        $http.get(url).then(function(response) {
          processError(response.data);
          self.getAttachmentList(self.DELETED);
        });
      }
    };
    self.renameAttachment = function(attachment, newName) {
      $http({
        url: nowServer.getURL('ngk_attachments'),
        method: 'POST',
        params: {
          action: 'rename',
          sys_id: attachment.sys_id,
          new_name: newName
        }
      }).then(function(response) {
        processError(response.data);
        self.getAttachmentList(self.RENAMED);
      });
    };

    function showUploaderDialog() {
      $rootScope.$broadcast('board.uploading.start', self.tableId);
    }

    function updateProgress(percent) {
      if (self.prevPercent === percent &amp;&amp; self.fileCount &lt;= self.maxfiles)
        return;
      if (self.fileCount &lt;= self.maxfiles) {
        if (percent &gt; 99)
          self.fileCount++;
        if (self.fileCount &lt;= self.maxfiles) {
          $timeout.cancel(self.errorTimeout);
          self.errorTimeout = $timeout(broadcastError, 15000);
          $('.progress-label').text('Uploading file ' + self.fileCount + ' of ' + self.maxfiles);
          $('.upload-progress').val(percent);
          $('.progress-wrapper').show();
        }
      }
      self.prevPercent = percent;
    }

    function hideProgressBar() {
      try {
        $('.progress-wrapper').hide();
      } catch (e) {}
    }
    self.setParams = function(tableName, tableId, fileUploadSizeLimit) {
      self.tableName = tableName;
      self.tableId = tableId;
      self.fileUploadSizeLimit = fileUploadSizeLimit;
    };

    function broadcastError() {
      $rootScope.$broadcast('board.uploading.end');
      snNotification.show('error', 'An error occured when trying to upload your file. Please try again.');
      self.stopAllUploading();
    }

    function processError(data) {
      if (data.error) {
        self.appendError({
          msg: data.error + ' : ',
          fileName: '"' + data.fileName + '"'
        });
      }
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.nowAttachmentsList.js */
angular.module('sn.common.attachments').directive('nowAttachmentsList', function(getTemplateUrl) {
  'use strict';
  return {
    restrict: 'E',
    replace: true,
    templateUrl: getTemplateUrl("attachments_list.xml"),
    link: function(scope, elem, attrs, $parse) {
      scope.icons = {
        preview: attrs.previewIcon,
        edit: attrs.editIcon,
        delete: attrs.deleteIcon,
        ok: attrs.okIcon,
        cancel: attrs.cancelIcon
      };
      scope.listClass = "list-group";
      var inline = scope.$eval(attrs.inline);
      if (inline)
        scope.listClass = "list-inline";
      scope.entryTemplate = getTemplateUrl(attrs.template || "attachment");
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/factory.snAttachmentHandler.js */
angular.module('sn.common.attachments').factory('snAttachmentHandler', function(urlTools, $http, $upload, $window, $q) {
  "use strict";
  return {
    getViewUrl: getViewUrl,
    create: createAttachmentHandler,
    deleteAttachment: deleteAttachmentBySysID,
    renameAttachment: renameAttachmentBySysID
  };

  function getViewUrl(sysId) {
    return '/sys_attachment.do?sys_id=' + sysId;
  }

  function deleteAttachmentBySysID(sysID) {
    var url = urlTools.getURL('ngk_attachments', {
      action: 'delete',
      sys_id: sysID
    });
    return $http.get(url);
  }

  function renameAttachmentBySysID(sysID, newName) {
    var url = urlTools.getURL('ngk_attachments', {
      action: 'rename',
      sys_id: sysID,
      new_name: newName
    });
    return $http.post(url);
  }

  function createAttachmentHandler(tableName, sysID) {
    var _tableName = tableName;
    var _sysID = sysID;
    var _files = [];

    function getTableName() {
      return _tableName;
    }

    function getSysID() {
      return _sysID;
    }

    function getAttachments() {
      var url = urlTools.getURL('ngk_attachments', {
        action: 'list',
        sys_id: _sysID,
        table: _tableName
      });
      return $http.get(url).then(function(response) {
        var files = response.data.files;
        if (_files.length == 0) {
          files.forEach(function(file) {
            _transformFileResponse(file);
            _files.push(file);
          })
        } else {
          _files = files;
        }
        return _files;
      });
    }

    function addAttachment(attachment) {
      _files.unshift(attachment);
    }

    function deleteAttachment(attachment) {
      var index = _files.indexOf(attachment);
      if (index !== -1) {
        return deleteAttachmentBySysID(attachment.sys_id).then(function() {
          _files.splice(index, 1);
        });
      }
    }

    function uploadAttachments(files, uploadFields) {
      var defer = $q.defer();
      var promises = [];
      var fileData = [];
      angular.forEach(files, function(file) {
        promises.push(uploadAttachment(file, uploadFields).then(function(response) {
          fileData.push(response);
        }));
      });
      $q.all(promises).then(function() {
        defer.resolve(fileData);
      });
      return defer.promise;
    }

    function uploadAttachment(file, uploadFields, uploadMethods) {
      var url = urlTools.getURL('ngk_attachments', {
        action: 'add',
        sys_id: _sysID,
        table: _tableName,
        load_attachment_record: 'true'
      });
      var fields = {
        attachments_modified: 'true',
        sysparm_table: _tableName,
        sysparm_sys_id: _sysID,
        sysparm_nostack: 'yes',
        sysparm_encryption_context: ''
      };
      if (typeof $window.g_ck !== 'undefined') {
        fields['sysparm_ck'] = $window.g_ck;
      }
      if (uploadFields) {
        angular.extend(fields, uploadFields);
      }
      var upload = $upload.upload({
        url: url,
        fields: fields,
        fileFormDataName: 'attachFile',
        file: file
      });
      if (uploadMethods !== undefined) {
        if (uploadMethods.hasOwnProperty('progress')) {
          upload.progress(uploadMethods.progress);
        }
        if (uploadMethods.hasOwnProperty('success')) {
          upload.success(uploadMethods.success);
        }
        if (uploadMethods.hasOwnProperty('error')) {
          upload.error(uploadMethods.error);
        }
      }
      return upload.then(function(response) {
        var sysFile = response.data;
        if (sysFile.error) {
          return $q.reject("Exception when adding attachment: " + sysFile.error);
        }
        _transformFileResponse(sysFile);
        addAttachment(sysFile);
        return sysFile;
      });
    }

    function _transformFileResponse(file) {
      file.isImage = false;
      file.canPreview = false;
      if (file.content_type.indexOf('image') !== -1) {
        file.isImage = true;
        if (!file.thumbSrc) {} else if (file.thumbSrc[0] !== '/') {
          file.thumbSrc = '/' + file.thumbSrc;
        }
        file.canPreview = file.content_type.indexOf('tiff') === -1;
      }
      file.viewUrl = getViewUrl(file.sys_id);
    }
    return {
      getSysID: getSysID,
      getTableName: getTableName,
      getAttachments: getAttachments,
      addAttachment: addAttachment,
      deleteAttachment: deleteAttachment,
      uploadAttachment: uploadAttachment,
      uploadAttachments: uploadAttachments
    };
  }
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snFileUploadInput.js */
angular.module('sn.common.attachments').directive('snFileUploadInput', function(cabrillo, $document) {
  'use strict';
  return {
    restrict: 'E',
    scope: {
      attachmentHandler: '='
    },
    template: function() {
      var inputTemplate;
      if (cabrillo.isNative()) {
        inputTemplate = '&lt;button class="{{classNames}}" ng-click="showAttachOptions($event)"&gt;&lt;span class="upload-label"&gt;{{:: "Add Attachment" | translate}}&lt;/span&gt;&lt;/button&gt;';
      } else {
        inputTemplate = '&lt;button class="{{classNames}}" ng-file-select="onFileSelect($files)"&gt;&lt;span class="upload-label"&gt;{{:: "Add Attachment" | translate}}&lt;/span&gt;&lt;/button&gt;';
      }
      return [
        '&lt;div class="file-upload-input"&gt;',
        inputTemplate,
        '&lt;/div&gt;'
      ].join('');
    },
    controller: function($element, $scope) {
      $scope.classNames = 'btn btn-icon attachment-btn icon-paperclip';
      $scope.showAttachOptions = function($event) {
        var handler = $scope.attachmentHandler;
        var target = angular.element($event.currentTarget);
        var elRect = target[0].getBoundingClientRect();
        var body = $document[0].body;
        var rect = {
          x: elRect.left + body.scrollLeft,
          y: elRect.top + body.scrollTop,
          width: elRect.width,
          height: elRect.height
        };
        var options = {
          sourceRect: rect
        };
        cabrillo.attachments.addFile(
          handler.getTableName(),
          handler.getSysID(),
          null,
          options
        ).then(function(data) {
          console.log('Attached new file', data);
          handler.addAttachment(data);
        }, function() {
          console.log('Failed to attach new file');
        });
      };
      $scope.onFileSelect = function($files) {
        $scope.attachmentHandler.uploadAttachments($files);
      };
      $scope.showFileSelector = function($event) {
        $event.stopPropagation();
        var target = angular.element($event.currentTarget);
        var input = target.parent().find('input');
        input.triggerHandler('click');
      };
    }
  }
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snPasteImageHandler.js */
angular.module('sn.common.attachments').directive('snPasteImageHandler', function($parse) {
  'use strict';
  return {
    restrict: 'A',
    replace: true,
    link: function(scope, element, attrs) {
      var handleFiles = $parse(attrs.snPasteImageHandler);
      element.bind("paste", function(e) {
        e = e.originalEvent || e;
        var item = e.clipboardData.items[0];
        if (!item.kind)
          return;
        if (item.kind !== "file")
          return;
        var file = item.getAsFile();
        file.name = "Pasted File - " + new Date();
        handleFiles(scope, {
          file: file
        });
        e.preventDefault();
        e.stopPropagation();
      });
    }
  };
});;
/*! RESOURCE: /scripts/angularjs-1.4/sn/common/attachments/directive.snAttachmentList.js */
angular.module('sn.common.attachments').directive('snAttachmentList', function(getTemplateUrl, snAttachmentHandler, $rootScope, $window, $timeout, $q) {
    'use strict';
    return {
      restrict: 'E',
      replace: true,
      templateUrl: getTemplateUrl("sn_attachment_list.xml"),
      scope: {
        tableName: "=?",
        sysID: "=?sysId",
        attachmentList: "=?",
        uploadFileFn: "&amp;",
        deleteFileFn: "=?",
        canEdit: "=?",
        canRemove: "=?",
        canAdd: "=?",
        canDownload: "=?",
        showHeader: "=?",
        clickImageFn: "&amp;?",
        confirmDelete: "=?"
      },
      controller: function($scope) {
        $scope.canEdit = $scope.canEdit || false;
        $scope.canDownload = $scope.canDownload || false;
        $scope.canRemove = $scope.canRemove || false;
        $scope.canAdd = $scope.canAdd || false;
        $scope.showHeader = $scope.showHeader || false;
        $scope.clickImageFn = $scope.clickImageFn || function() {};
        $scope.confirmDelete = $scope.confirmDelete || false;
        $scope.filesInProgress = {};
        $scope.attachmentToDelete = null;

        function refreshResources() {
          var handler = snAttachmentHandler.create($scope.tableName, $scope.sysID);
          handler.getAttachments().then(function(files) {
            $scope.attachmentList = files;
          });
        }
        if (!$scope.attachmentList) {
          $scope.attachmentList = [];
          refreshResources();
        }
        $scope.$on('attachments_list.update', function(e, tableName, sysID) {
          if (tableName === $scope.tableName &amp;&amp; sysID === $scope.sysID) {
            refreshResources();
          }
        });

        function removeFromFileProgress(fileName) {
          delete $scope.filesInProgress[fileName];
        }

        function updateFileProgress(file) {
          if (!$scope.filesInProgress[file.name])
            $scope.filesInProgress[file.name] = file;
        }
        $scope.$on('attachments_list.upload.progress', function(e, file) {
          updateFileProgress(file);
        });
        $scope.$on('attachments_list.upload.success', function(e, file) {
          removeFromFileProgress(file.name);
        });
        $scope.attachFiles = function(files) {
          if ($scope.tableName &amp;&amp; $scope.sysID) {
            var handler = snAttachmentHandler.create($scope.tableName, $scope.sysID);
            var promises = [];
            files.forEach(function(file) {
              var promise = handler.uploadAttachment(file, null, {
                progress: function(e) {
                  var file = e.config.file;
                  file.progress = 100.0 * event.loaded / event.total;
                  updateFileProgress(file);
                },
                success: function(data) {
                  removeFromFileProgress(data.file_name);
                }
              });
              promises.push(promise);
            });
            $q.all(promises).then(function() {
              refreshResources();
            });
          } else {
            if ($scope.uploadFileFn)
              $scope.uploadFileFn({
                files: files
              });
          }
        };
        $scope.getProgressStyle = function(fileName) {
          return {
            'width': $scope.filesInProgress[fileName].progress + '%'
          };
        };
        $scope.openSelector = function($event) {
          $event.stopPropagation();
          var target = angular.element($event.currentTarget);
          $timeout(function() {
            target.parent().find('input').click();
          });
        };
        $scope.confirmDeleteAttachment = function(attachment) {
          $scope.attachmentToDelete = attachment;
          $scope.$broadcast('dialog.confirm-delete.show');
        };
        $scope.deleteAttachment = function() {
          snAttachmentHandler.deleteAttachment($scope.attachmentToDelete.sys_id).then(function() {
            var index = $scope.attachmentList.indexOf($scope.attachmentToDelete);
            $scope.attachmentList.splice(index, 1);
          });
        };
      }
    };
  })
  .directive('snAttachmentListItem', function(getTemplateUrl, snAttachmentHandler, $rootScope, $window, $timeout, $parse) {
    'use strict';
    return {
      restrict: "E",
      replace: true,
      templateUrl: getTemplateUrl("sn_attachment_list_item.xml"),
      link: function(scope, element, attrs) {
        function translateAttachment(att) {
          return {
            content_type: att.content_type,
            file_name: att.file_name,
            image: (att.thumbSrc !== undefined),
            size_bytes: att.size,
            sys_created_by: "",
            sys_created_on: "",
            sys_id: att.sys_id,
            thumb_src: att.thumbSrc
          };
        }
        scope.attachment = ($parse(attrs.attachment.size_bytes)) ?
          scope.$eval(attrs.attachment) :
          translateAttachment(attrs.attachment);
        var fileNameView = element.find('.sn-widget-list-title_view');
        var fileNameEdit = element.find('.sn-widget-list-title_edit');

        function editFileName() {
          fileNameView.hide();
          fileNameEdit.show();
          element.find('.edit-text-input').focus();
        }

        function viewFileName() {
          fileNameView.show();
          fileNameEdit.hide();
        }
        viewFileName();
        scope.editModeToggle = function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          scope.editMode = !scope.editMode;
          if (scope.editMode)
            editFileName();
          else
            viewFileName();
        };
        scope.updateName = function() {
          scope.editMode = false;
          viewFileName();
          snAttachmentHandler.renameAttachment(scope.attachment.sys_id, scope.attachment.file_name);
        };
      },
      controller: function($scope, snCustomEvent) {
        $scope.editMode = false;
        $scope.removeAttachment = function(attachment, index) {
          if ($scope.deleteFileFn !== undefined &amp;&amp; $scope.deleteFileFn instanceof Function) {
            $scope.deleteFileFn.apply(null, arguments);
            return;
          }
          if ($scope.confirmDelete) {
            $scope.confirmDeleteAttachment($scope.attachment);
            return;
          }
          snAttachmentHandler.deleteAttachment($scope.attachment.sys_id).then(function() {
            $scope.attachmentList.splice($scope.$index, 1);
          });
        };
        var contentTypeMap = {
          "application/pdf": "icon-document-pdf",
          "text/plain": "icon-document-txt",
          "application/zip": "icon-document-zip",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "icon-document-doc",
          "application/vnd.openxmlformats-officedocument.presentationml.presentation": "icon-document-ppt",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "icon-document-xls",
          "application/vnd.ms-powerpoint": "icon-document-ppt"
        };
        $scope.getDocumentType = function(contentType) {
          return contentTypeMap[contentType] || "icon-document";
        };
        $scope.handleAttachmentClick = function(event) {
          if (event.keyCode === 9)
            return;
          if ($scope.editMode)
            return;
          if (!$scope.attachment)
            return;
          if ($scope.attachment.image)
            openImageInLightBox(event);
          else
            downloadAttachment();
        };

        function downloadAttachment() {
          if (!$scope.attachment.sys_id)
            return;
          $window.location.href = 'sys_attachment.do?sys_id=' + $scope.attachment.sys_id;
        }

        function openImageInLightBox(event) {
          if (!$scope.attachment.size)
            $scope.attachment.size = $scope.getSize($scope.attachment.size_bytes, 2);
          $scope.clickImageFn({
            file: $scope.attachment
          });
          snCustomEvent.fire('sn.attachment.preview', event, $scope.attachment);
        }
        $scope.getSize = function(bytes, precision) {
          if (typeof bytes === 'string' &amp;&amp; bytes.slice(-1) === 'B')
            return bytes;
          var kb = 1024;
          var mb = kb * 1024;
          var gb = mb * 1024;
          if ((bytes &gt;= 0) &amp;&amp; (bytes &lt; kb))
            return bytes + ' B';
          else if ((bytes &gt;= kb) &amp;&amp; (bytes &lt; mb))
            return (bytes / kb).toFixed(precision) + ' KB';
          else if ((bytes &gt;= mb) &amp;&amp; (bytes &lt; gb))
            return (bytes / mb).toFixed(precision) + ' MB';
          else if (bytes &gt;= gb)
            return (bytes / gb).toFixed(precision) + ' GB';
          else
            return bytes + ' B';
        }
      }
    };
  });;;
/*! RESOURCE: /scripts/bootstrap_336.js */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
} +
function($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] &lt; 2 &amp;&amp; version[1] &lt; 9) || (version[0] == 1 &amp;&amp; version[1] == 9 &amp;&amp; version[2] &lt; 1) || (version[0] &gt; 2)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')
  }
}(jQuery); +
function($) {
  'use strict';

  function transitionEnd() {
    var el = document.createElement('bootstrap')
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    }
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return {
          end: transEndEventNames[name]
        }
      }
    }
    return false
  }
  $.fn.emulateTransitionEnd = function(duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function() {
      called = true
    })
    var callback = function() {
      if (!called) $($el).trigger($.support.transition.end)
    }
    setTimeout(callback, duration)
    return this
  }
  $(function() {
    $.support.transition = transitionEnd()
    if (!$.support.transition) return
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function(e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })
}(jQuery); +
function($) {
  'use strict';
  var dismiss = '[data-dismiss="alert"]'
  var Alert = function(el) {
    $(el).on('click', dismiss, this.close)
  }
  Alert.VERSION = '3.3.6'
  Alert.TRANSITION_DURATION = 150
  Alert.prototype.close = function(e) {
    var $this = $(this)
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    var $parent = $(selector)
    if (e) e.preventDefault()
    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }
    $parent.trigger(e = $.Event('close.bs.alert'))
    if (e.isDefaultPrevented()) return
    $parent.removeClass('in')

    function removeElement() {
      $parent.detach().trigger('closed.bs.alert').remove()
    }
    $.support.transition &amp;&amp; $parent.hasClass('fade') ?
      $parent
      .one('bsTransitionEnd', removeElement)
      .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.alert')
      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.alert
  $.fn.alert = Plugin
  $.fn.alert.Constructor = Alert
  $.fn.alert.noConflict = function() {
    $.fn.alert = old
    return this
  }
  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
}(jQuery); +
function($) {
  'use strict';
  var Button = function(element, options) {
    this.$element = $(element)
    this.options = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }
  Button.VERSION = '3.3.6'
  Button.DEFAULTS = {
    loadingText: 'loading...'
  }
  Button.prototype.setState = function(state) {
    var d = 'disabled'
    var $el = this.$element
    var val = $el.is('input') ? 'val' : 'html'
    var data = $el.data()
    state += 'Text'
    if (data.resetText == null) $el.data('resetText', $el[val]())
    setTimeout($.proxy(function() {
      $el[val](data[state] == null ? this.options[state] : data[state])
      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }
  Button.prototype.toggle = function() {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')
    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.button')
      var options = typeof option == 'object' &amp;&amp; option
      if (!data) $this.data('bs.button', (data = new Button(this, options)))
      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }
  var old = $.fn.button
  $.fn.button = Plugin
  $.fn.button.Constructor = Button
  $.fn.button.noConflict = function() {
    $.fn.button = old
    return this
  }
  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })
}(jQuery); +
function($) {
  'use strict';
  var Carousel = function(element, options) {
    this.$element = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options = options
    this.paused = null
    this.sliding = null
    this.interval = null
    this.$active = null
    this.$items = null
    this.options.keyboard &amp;&amp; this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
    this.options.pause == 'hover' &amp;&amp; !('ontouchstart' in document.documentElement) &amp;&amp; this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }
  Carousel.VERSION = '3.3.6'
  Carousel.TRANSITION_DURATION = 600
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }
  Carousel.prototype.keydown = function(e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37:
        this.prev();
        break
      case 39:
        this.next();
        break
      default:
        return
    }
    e.preventDefault()
  }
  Carousel.prototype.cycle = function(e) {
    e || (this.paused = false)
    this.interval &amp;&amp; clearInterval(this.interval)
    this.options.interval &amp;&amp;
      !this.paused &amp;&amp;
      (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
    return this
  }
  Carousel.prototype.getItemIndex = function(item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }
  Carousel.prototype.getItemForDirection = function(direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' &amp;&amp; activeIndex === 0) ||
      (direction == 'next' &amp;&amp; activeIndex == (this.$items.length - 1))
    if (willWrap &amp;&amp; !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }
  Carousel.prototype.to = function(pos) {
    var that = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
    if (pos &gt; (this.$items.length - 1) || pos &lt; 0) return
    if (this.sliding) return this.$element.one('slid.bs.carousel', function() {
      that.to(pos)
    })
    if (activeIndex == pos) return this.pause().cycle()
    return this.slide(pos &gt; activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }
  Carousel.prototype.pause = function(e) {
    e || (this.paused = true)
    if (this.$element.find('.next, .prev').length &amp;&amp; $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }
    this.interval = clearInterval(this.interval)
    return this
  }
  Carousel.prototype.next = function() {
    if (this.sliding) return
    return this.slide('next')
  }
  Carousel.prototype.prev = function() {
    if (this.sliding) return
    return this.slide('prev')
  }
  Carousel.prototype.slide = function(type, next) {
    var $active = this.$element.find('.item.active')
    var $next = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that = this
    if ($next.hasClass('active')) return (this.sliding = false)
    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return
    this.sliding = true
    isCycling &amp;&amp; this.pause()
    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator &amp;&amp; $nextIndicator.addClass('active')
    }
    var slidEvent = $.Event('slid.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    if ($.support.transition &amp;&amp; this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function() {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function() {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }
    isCycling &amp;&amp; this.cycle()
    return this
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)
      var action = typeof option == 'string' ? option : options.slide
      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }
  var old = $.fn.carousel
  $.fn.carousel = Plugin
  $.fn.carousel.Constructor = Carousel
  $.fn.carousel.noConflict = function() {
    $.fn.carousel = old
    return this
  }
  var clickHandler = function(e) {
    var href
    var $this = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, ''))
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false
    Plugin.call($target, options)
    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }
    e.preventDefault()
  }
  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
  $(window).on('load', function() {
    $('[data-ride="carousel"]').each(function() {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })
}(jQuery); +
function($) {
  'use strict';
  var Collapse = function(element, options) {
    this.$element = $(element)
    this.options = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
      '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null
    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }
    if (this.options.toggle) this.toggle()
  }
  Collapse.VERSION = '3.3.6'
  Collapse.TRANSITION_DURATION = 350
  Collapse.DEFAULTS = {
    toggle: true
  }
  Collapse.prototype.dimension = function() {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }
  Collapse.prototype.show = function() {
    if (this.transitioning || this.$element.hasClass('in')) return
    var activesData
    var actives = this.$parent &amp;&amp; this.$parent.children('.panel').children('.in, .collapsing')
    if (actives &amp;&amp; actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData &amp;&amp; activesData.transitioning) return
    }
    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    if (actives &amp;&amp; actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }
    var dimension = this.dimension()
    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)
    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)
    this.transitioning = 1
    var complete = function() {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    var scrollSize = $.camelCase(['scroll', dimension].join('-'))
    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }
  Collapse.prototype.hide = function() {
    if (this.transitioning || !this.$element.hasClass('in')) return
    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return
    var dimension = this.dimension()
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight
    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)
    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)
    this.transitioning = 1
    var complete = function() {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }
    if (!$.support.transition) return complete.call(this)
    this.$element[dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }
  Collapse.prototype.toggle = function() {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }
  Collapse.prototype.getParent = function() {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function(i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }
  Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
    var isOpen = $element.hasClass('in')
    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target') ||
      (href = $trigger.attr('href')) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, '')
    return $(target)
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)
      if (!data &amp;&amp; options.toggle &amp;&amp; /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.collapse
  $.fn.collapse = Plugin
  $.fn.collapse.Constructor = Collapse
  $.fn.collapse.noConflict = function() {
    $.fn.collapse = old
    return this
  }
  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
    var $this = $(this)
    if (!$this.attr('data-target')) e.preventDefault()
    var $target = getTargetFromTrigger($this)
    var data = $target.data('bs.collapse')
    var option = data ? 'toggle' : $this.data()
    Plugin.call($target, option)
  })
}(jQuery); +
function($) {
  'use strict';
  var backdrop = '.dropdown-backdrop'
  var toggle = '[data-toggle="dropdown"]'
  var Dropdown = function(element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }
  Dropdown.VERSION = '3.3.6'

  function getParent($this) {
    var selector = $this.attr('data-target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; /#[A-Za-z]/.test(selector) &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    var $parent = selector &amp;&amp; $(selector)
    return $parent &amp;&amp; $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e &amp;&amp; e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function() {
      var $this = $(this)
      var $parent = getParent($this)
      var relatedTarget = {
        relatedTarget: this
      }
      if (!$parent.hasClass('open')) return
      if (e &amp;&amp; e.type == 'click' &amp;&amp; /input|textarea/i.test(e.target.tagName) &amp;&amp; $.contains($parent[0], e.target)) return
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }
  Dropdown.prototype.toggle = function(e) {
    var $this = $(this)
    if ($this.is('.disabled, :disabled')) return
    var $parent = getParent($this)
    var isActive = $parent.hasClass('open')
    clearMenus()
    if (!isActive) {
      if ('ontouchstart' in document.documentElement &amp;&amp; !$parent.closest('.navbar-nav').length) {
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }
      var relatedTarget = {
        relatedTarget: this
      }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
      if (e.isDefaultPrevented()) return
      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')
      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }
    return false
  }
  Dropdown.prototype.keydown = function(e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
    var $this = $(this)
    e.preventDefault()
    e.stopPropagation()
    if ($this.is('.disabled, :disabled')) return
    var $parent = getParent($this)
    var isActive = $parent.hasClass('open')
    if (!isActive &amp;&amp; e.which != 27 || isActive &amp;&amp; e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }
    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)
    if (!$items.length) return
    var index = $items.index(e.target)
    if (e.which == 38 &amp;&amp; index &gt; 0) index--
      if (e.which == 40 &amp;&amp; index &lt; $items.length - 1) index++
        if (!~index) index = 0
    $items.eq(index).trigger('focus')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.dropdown')
      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }
  var old = $.fn.dropdown
  $.fn.dropdown = Plugin
  $.fn.dropdown.Constructor = Dropdown
  $.fn.dropdown.noConflict = function() {
    $.fn.dropdown = old
    return this
  }
  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
      e.stopPropagation()
    })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)
}(jQuery); +
function($) {
  'use strict';
  var Modal = function(element, options) {
    this.options = options
    this.$body = $(document.body)
    this.$element = $(element)
    this.$dialog = this.$element.find('.modal-dialog')
    this.$backdrop = null
    this.isShown = null
    this.originalBodyPad = null
    this.scrollbarWidth = 0
    this.ignoreBackdropClick = false
    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function() {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }
  Modal.VERSION = '3.3.6'
  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }
  Modal.prototype.toggle = function(_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }
  Modal.prototype.show = function(_relatedTarget) {
    var that = this
    var e = $.Event('show.bs.modal', {
      relatedTarget: _relatedTarget
    })
    this.$element.trigger(e)
    if (this.isShown || e.isDefaultPrevented()) return
    this.isShown = true
    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')
    this.escape()
    this.resize()
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
    this.$dialog.on('mousedown.dismiss.bs.modal', function() {
      that.$element.one('mouseup.dismiss.bs.modal', function(e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })
    this.backdrop(function() {
      var transition = $.support.transition &amp;&amp; that.$element.hasClass('fade')
      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body)
      }
      that.$element
        .show()
        .scrollTop(0)
      that.adjustDialog()
      if (transition) {
        that.$element[0].offsetWidth
      }
      that.$element.addClass('in')
      that.enforceFocus()
      var e = $.Event('shown.bs.modal', {
        relatedTarget: _relatedTarget
      })
      transition ?
        that.$dialog
        .one('bsTransitionEnd', function() {
          that.$element.trigger('focus').trigger(e)
        })
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }
  Modal.prototype.hide = function(e) {
    if (e) e.preventDefault()
    e = $.Event('hide.bs.modal')
    this.$element.trigger(e)
    if (!this.isShown || e.isDefaultPrevented()) return
    this.isShown = false
    this.escape()
    this.resize()
    $(document).off('focusin.bs.modal')
    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')
    this.$dialog.off('mousedown.dismiss.bs.modal')
    $.support.transition &amp;&amp; this.$element.hasClass('fade') ?
      this.$element
      .one('bsTransitionEnd', $.proxy(this.hideModal, this))
      .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }
  Modal.prototype.enforceFocus = function() {
    $(document)
      .off('focusin.bs.modal')
      .on('focusin.bs.modal', $.proxy(function(e) {
        if (this.$element[0] !== e.target &amp;&amp; !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }
  Modal.prototype.escape = function() {
    if (this.isShown &amp;&amp; this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
        e.which == 27 &amp;&amp; this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }
  Modal.prototype.resize = function() {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }
  Modal.prototype.hideModal = function() {
    var that = this
    this.$element.hide()
    this.backdrop(function() {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }
  Modal.prototype.removeBackdrop = function() {
    this.$backdrop &amp;&amp; this.$backdrop.remove()
    this.$backdrop = null
  }
  Modal.prototype.backdrop = function(callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''
    if (this.isShown &amp;&amp; this.options.backdrop) {
      var doAnimate = $.support.transition &amp;&amp; animate
      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)
      this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static' ?
          this.$element[0].focus() :
          this.hide()
      }, this))
      if (doAnimate) this.$backdrop[0].offsetWidth
      this.$backdrop.addClass('in')
      if (!callback) return
      doAnimate ?
        this.$backdrop
        .one('bsTransitionEnd', callback)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()
    } else if (!this.isShown &amp;&amp; this.$backdrop) {
      this.$backdrop.removeClass('in')
      var callbackRemove = function() {
        that.removeBackdrop()
        callback &amp;&amp; callback()
      }
      $.support.transition &amp;&amp; this.$element.hasClass('fade') ?
        this.$backdrop
        .one('bsTransitionEnd', callbackRemove)
        .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()
    } else if (callback) {
      callback()
    }
  }
  Modal.prototype.handleUpdate = function() {
    this.adjustDialog()
  }
  Modal.prototype.adjustDialog = function() {
    var modalIsOverflowing = this.$element[0].scrollHeight &gt; document.documentElement.clientHeight
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing &amp;&amp; modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing &amp;&amp; !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }
  Modal.prototype.resetAdjustments = function() {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }
  Modal.prototype.checkScrollbar = function() {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) {
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }
  Modal.prototype.setScrollbar = function() {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }
  Modal.prototype.resetScrollbar = function() {
    this.$body.css('padding-right', this.originalBodyPad)
  }
  Modal.prototype.measureScrollbar = function() {
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }

  function Plugin(option, _relatedTarget) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)
      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }
  var old = $.fn.modal
  $.fn.modal = Plugin
  $.fn.modal.Constructor = Modal
  $.fn.modal.noConflict = function() {
    $.fn.modal = old
    return this
  }
  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
    var $this = $(this)
    var href = $this.attr('href')
    var $target = $($this.attr('data-target') || (href &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, '')))
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({
      remote: !/#/.test(href) &amp;&amp; href
    }, $target.data(), $this.data())
    if ($this.is('a')) e.preventDefault()
    $target.one('show.bs.modal', function(showEvent) {
      if (showEvent.isDefaultPrevented()) return
      $target.one('hidden.bs.modal', function() {
        $this.is(':visible') &amp;&amp; $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })
}(jQuery); +
function($) {
  'use strict';
  var Tooltip = function(element, options) {
    this.type = null
    this.options = null
    this.enabled = null
    this.timeout = null
    this.hoverState = null
    this.$element = null
    this.inState = null
    this.init('tooltip', element, options)
  }
  Tooltip.VERSION = '3.3.6'
  Tooltip.TRANSITION_DURATION = 150
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '&lt;div class="tooltip" role="tooltip"&gt;&lt;div class="tooltip-arrow"&gt;&lt;/div&gt;&lt;div class="tooltip-inner"&gt;&lt;/div&gt;&lt;/div&gt;',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }
  Tooltip.prototype.init = function(type, element, options) {
    this.enabled = true
    this.type = type
    this.$element = $(element)
    this.options = this.getOptions(options)
    this.$viewport = this.options.viewport &amp;&amp; $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState = {
      click: false,
      hover: false,
      focus: false
    }
    if (this.$element[0] instanceof document.constructor &amp;&amp; !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }
    var triggers = this.options.trigger.split(' ')
    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]
      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }
    this.options.selector ?
      (this._options = $.extend({}, this.options, {
        trigger: 'manual',
        selector: ''
      })) :
      this.fixTitle()
  }
  Tooltip.prototype.getDefaults = function() {
    return Tooltip.DEFAULTS
  }
  Tooltip.prototype.getOptions = function(options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
    if (options.delay &amp;&amp; typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }
    return options
  }
  Tooltip.prototype.getDelegateOptions = function() {
    var options = {}
    var defaults = this.getDefaults()
    this._options &amp;&amp; $.each(this._options, function(key, value) {
      if (defaults[key] != value) options[key] = value
    })
    return options
  }
  Tooltip.prototype.enter = function(obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }
    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }
    clearTimeout(self.timeout)
    self.hoverState = 'in'
    if (!self.options.delay || !self.options.delay.show) return self.show()
    self.timeout = setTimeout(function() {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }
  Tooltip.prototype.isInStateTrue = function() {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }
    return false
  }
  Tooltip.prototype.leave = function(obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)
    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }
    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }
    if (self.isInStateTrue()) return
    clearTimeout(self.timeout)
    self.hoverState = 'out'
    if (!self.options.delay || !self.options.delay.hide) return self.hide()
    self.timeout = setTimeout(function() {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }
  Tooltip.prototype.show = function() {
    var e = $.Event('show.bs.' + this.type)
    if (this.hasContent() &amp;&amp; this.enabled) {
      this.$element.trigger(e)
      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this
      var $tip = this.tip()
      var tipId = this.getUID(this.type)
      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)
      if (this.options.animation) $tip.addClass('fade')
      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement
      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
      $tip
        .detach()
        .css({
          top: 0,
          left: 0,
          display: 'block'
        })
        .addClass(placement)
        .data('bs.' + this.type, this)
      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)
      var pos = this.getPosition()
      var actualWidth = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight
      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)
        placement = placement == 'bottom' &amp;&amp; pos.bottom + actualHeight &gt; viewportDim.bottom ? 'top' :
          placement == 'top' &amp;&amp; pos.top - actualHeight &lt; viewportDim.top ? 'bottom' :
          placement == 'right' &amp;&amp; pos.right + actualWidth &gt; viewportDim.width ? 'left' :
          placement == 'left' &amp;&amp; pos.left - actualWidth &lt; viewportDim.left ? 'right' :
          placement
        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }
      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
      this.applyPlacement(calculatedOffset, placement)
      var complete = function() {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null
        if (prevHoverState == 'out') that.leave(that)
      }
      $.support.transition &amp;&amp; this.$tip.hasClass('fade') ?
        $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }
  Tooltip.prototype.applyPlacement = function(offset, placement) {
    var $tip = this.tip()
    var width = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)
    if (isNaN(marginTop)) marginTop = 0
    if (isNaN(marginLeft)) marginLeft = 0
    offset.top += marginTop
    offset.left += marginLeft
    $.offset.setOffset($tip[0], $.extend({
      using: function(props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)
    $tip.addClass('in')
    var actualWidth = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight
    if (placement == 'top' &amp;&amp; actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }
    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
    if (delta.left) offset.left += delta.left
    else offset.top += delta.top
    var isVertical = /top|bottom/.test(placement)
    var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }
  Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }
  Tooltip.prototype.setContent = function() {
    var $tip = this.tip()
    var title = this.getTitle()
    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }
  Tooltip.prototype.hide = function(callback) {
    var that = this
    var $tip = $(this.$tip)
    var e = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback &amp;&amp; callback()
    }
    this.$element.trigger(e)
    if (e.isDefaultPrevented()) return
    $tip.removeClass('in')
    $.support.transition &amp;&amp; $tip.hasClass('fade') ?
      $tip
      .one('bsTransitionEnd', complete)
      .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()
    this.hoverState = null
    return this
  }
  Tooltip.prototype.fixTitle = function() {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }
  Tooltip.prototype.hasContent = function() {
    return this.getTitle()
  }
  Tooltip.prototype.getPosition = function($element) {
    $element = $element || this.$element
    var el = $element[0]
    var isBody = el.tagName == 'BODY'
    var elRect = el.getBoundingClientRect()
    if (elRect.width == null) {
      elRect = $.extend({}, elRect, {
        width: elRect.right - elRect.left,
        height: elRect.bottom - elRect.top
      })
    }
    var elOffset = isBody ? {
      top: 0,
      left: 0
    } : $element.offset()
    var scroll = {
      scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
    }
    var outerDims = isBody ? {
      width: $(window).width(),
      height: $(window).height()
    } : null
    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }
  Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? {
        top: pos.top + pos.height,
        left: pos.left + pos.width / 2 - actualWidth / 2
      } :
      placement == 'top' ? {
        top: pos.top - actualHeight,
        left: pos.left + pos.width / 2 - actualWidth / 2
      } :
      placement == 'left' ? {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left - actualWidth
      } : {
        top: pos.top + pos.height / 2 - actualHeight / 2,
        left: pos.left + pos.width
      }
  }
  Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
    var delta = {
      top: 0,
      left: 0
    }
    if (!this.$viewport) return delta
    var viewportPadding = this.options.viewport &amp;&amp; this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)
    if (/right|left/.test(placement)) {
      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset &lt; viewportDimensions.top) {
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset &gt; viewportDimensions.top + viewportDimensions.height) {
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset &lt; viewportDimensions.left) {
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset &gt; viewportDimensions.right) {
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }
    return delta
  }
  Tooltip.prototype.getTitle = function() {
    var title
    var $e = this.$element
    var o = this.options
    title = $e.attr('data-original-title') ||
      (typeof o.title == 'function' ? o.title.call($e[0]) : o.title)
    return title
  }
  Tooltip.prototype.getUID = function(prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }
  Tooltip.prototype.tip = function() {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }
  Tooltip.prototype.arrow = function() {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }
  Tooltip.prototype.enable = function() {
    this.enabled = true
  }
  Tooltip.prototype.disable = function() {
    this.enabled = false
  }
  Tooltip.prototype.toggleEnabled = function() {
    this.enabled = !this.enabled
  }
  Tooltip.prototype.toggle = function(e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }
    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }
  Tooltip.prototype.destroy = function() {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function() {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.tooltip')
      var options = typeof option == 'object' &amp;&amp; option
      if (!data &amp;&amp; /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tooltip
  $.fn.tooltip = Plugin
  $.fn.tooltip.Constructor = Tooltip
  $.fn.tooltip.noConflict = function() {
    $.fn.tooltip = old
    return this
  }
}(jQuery); +
function($) {
  'use strict';
  var Popover = function(element, options) {
    this.init('popover', element, options)
  }
  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
  Popover.VERSION = '3.3.6'
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '&lt;div class="popover" role="tooltip"&gt;&lt;div class="arrow"&gt;&lt;/div&gt;&lt;h3 class="popover-title"&gt;&lt;/h3&gt;&lt;div class="popover-content"&gt;&lt;/div&gt;&lt;/div&gt;'
  })
  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
  Popover.prototype.constructor = Popover
  Popover.prototype.getDefaults = function() {
    return Popover.DEFAULTS
  }
  Popover.prototype.setContent = function() {
    var $tip = this.tip()
    var title = this.getTitle()
    var content = this.getContent()
    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)
    $tip.removeClass('fade top bottom left right in')
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }
  Popover.prototype.hasContent = function() {
    return this.getTitle() || this.getContent()
  }
  Popover.prototype.getContent = function() {
    var $e = this.$element
    var o = this.options
    return $e.attr('data-content') ||
      (typeof o.content == 'function' ?
        o.content.call($e[0]) :
        o.content)
  }
  Popover.prototype.arrow = function() {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.popover')
      var options = typeof option == 'object' &amp;&amp; option
      if (!data &amp;&amp; /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.popover
  $.fn.popover = Plugin
  $.fn.popover.Constructor = Popover
  $.fn.popover.noConflict = function() {
    $.fn.popover = old
    return this
  }
}(jQuery); +
function($) {
  'use strict';

  function ScrollSpy(element, options) {
    this.$body = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector = (this.options.target || '') + ' .nav li &gt; a'
    this.offsets = []
    this.targets = []
    this.activeTarget = null
    this.scrollHeight = 0
    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }
  ScrollSpy.VERSION = '3.3.6'
  ScrollSpy.DEFAULTS = {
    offset: 10
  }
  ScrollSpy.prototype.getScrollHeight = function() {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }
  ScrollSpy.prototype.refresh = function() {
    var that = this
    var offsetMethod = 'offset'
    var offsetBase = 0
    this.offsets = []
    this.targets = []
    this.scrollHeight = this.getScrollHeight()
    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase = this.$scrollElement.scrollTop()
    }
    this.$body
      .find(this.selector)
      .map(function() {
        var $el = $(this)
        var href = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) &amp;&amp; $(href)
        return ($href &amp;&amp;
          $href.length &amp;&amp;
          $href.is(':visible') &amp;&amp;
          [
            [$href[offsetMethod]().top + offsetBase, href]
          ]) || null
      })
      .sort(function(a, b) {
        return a[0] - b[0]
      })
      .each(function() {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }
  ScrollSpy.prototype.process = function() {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets = this.offsets
    var targets = this.targets
    var activeTarget = this.activeTarget
    var i
    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }
    if (scrollTop &gt;= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)
    }
    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }
    for (i = offsets.length; i--;) {
      activeTarget != targets[i] &amp;&amp;
        scrollTop &gt;= offsets[i] &amp;&amp;
        (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1]) &amp;&amp;
        this.activate(targets[i])
    }
  }
  ScrollSpy.prototype.activate = function(target) {
    this.activeTarget = target
    this.clear()
    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'
    var active = $(selector)
      .parents('li')
      .addClass('active')
    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }
    active.trigger('activate.bs.scrollspy')
  }
  ScrollSpy.prototype.clear = function() {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.scrollspy')
      var options = typeof option == 'object' &amp;&amp; option
      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.scrollspy
  $.fn.scrollspy = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy
  $.fn.scrollspy.noConflict = function() {
    $.fn.scrollspy = old
    return this
  }
  $(window).on('load.bs.scrollspy.data-api', function() {
    $('[data-spy="scroll"]').each(function() {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })
}(jQuery); +
function($) {
  'use strict';
  var Tab = function(element) {
    this.element = $(element)
  }
  Tab.VERSION = '3.3.6'
  Tab.TRANSITION_DURATION = 150
  Tab.prototype.show = function() {
    var $this = this.element
    var $ul = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')
    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '')
    }
    if ($this.parent('li').hasClass('active')) return
    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })
    $previous.trigger(hideEvent)
    $this.trigger(showEvent)
    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
    var $target = $(selector)
    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function() {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }
  Tab.prototype.activate = function(element, container, callback) {
    var $active = container.find('&gt; .active')
    var transition = callback &amp;&amp;
      $.support.transition &amp;&amp;
      ($active.length &amp;&amp; $active.hasClass('fade') || !!container.find('&gt; .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('&gt; .dropdown-menu &gt; .active')
        .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
        .attr('aria-expanded', false)
      element
        .addClass('active')
        .find('[data-toggle="tab"]')
        .attr('aria-expanded', true)
      if (transition) {
        element[0].offsetWidth
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }
      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
          .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)
      }
      callback &amp;&amp; callback()
    }
    $active.length &amp;&amp; transition ?
      $active
      .one('bsTransitionEnd', next)
      .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()
    $active.removeClass('in')
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.tab')
      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.tab
  $.fn.tab = Plugin
  $.fn.tab.Constructor = Tab
  $.fn.tab.noConflict = function() {
    $.fn.tab = old
    return this
  }
  var clickHandler = function(e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }
  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
}(jQuery); +
function($) {
  'use strict';
  var Affix = function(element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)
    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this))
    this.$element = $(element)
    this.affixed = null
    this.unpin = null
    this.pinnedOffset = null
    this.checkPosition()
  }
  Affix.VERSION = '3.3.6'
  Affix.RESET = 'affix affix-top affix-bottom'
  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }
  Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop = this.$target.scrollTop()
    var position = this.$element.offset()
    var targetHeight = this.$target.height()
    if (offsetTop != null &amp;&amp; this.affixed == 'top') return scrollTop &lt; offsetTop ? 'top' : false
    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : 'bottom'
    }
    var initializing = this.affixed == null
    var colliderTop = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height
    if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return 'top'
    if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight &gt;= scrollHeight - offsetBottom)) return 'bottom'
    return false
  }
  Affix.prototype.getPinnedOffset = function() {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }
  Affix.prototype.checkPositionWithEventLoop = function() {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }
  Affix.prototype.checkPosition = function() {
    if (!this.$element.is(':visible')) return
    var height = this.$element.height()
    var offset = this.options.offset
    var offsetTop = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())
    if (typeof offset != 'object') offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')
      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e = $.Event(affixType + '.bs.affix')
      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return
      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }
    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }

  function Plugin(option) {
    return this.each(function() {
      var $this = $(this)
      var data = $this.data('bs.affix')
      var options = typeof option == 'object' &amp;&amp; option
      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }
  var old = $.fn.affix
  $.fn.affix = Plugin
  $.fn.affix.Constructor = Affix
  $.fn.affix.noConflict = function() {
    $.fn.affix = old
    return this
  }
  $(window).on('load', function() {
    $('[data-spy="affix"]').each(function() {
      var $spy = $(this)
      var data = $spy.data()
      data.offset = data.offset || {}
      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop != null) data.offset.top = data.offsetTop
      Plugin.call($spy, data)
    })
  })
}(jQuery);;
/*! RESOURCE: /scripts/iconset-fontawesome-4.2.0.js */
;
(function($) {
  $.iconset_fontawesome = {
    iconClass: 'fa',
    iconClassFix: 'fa-',
    icons: [
      '',
      'adjust',
      'anchor',
      'archive',
      'area-chart',
      'arrows',
      'arrows-h',
      'arrows-v',
      'automobile',
      'asterisk',
      'at',
      'ban',
      'bank',
      'bar-chart-o',
      'barcode',
      'bars',
      'beer',
      'bell',
      'bell-o',
      'bell-slash',
      'bell-slash-o',
      'bicycle',
      'binoculars',
      'birthday-cake',
      'bolt',
      'bomb',
      'book',
      'bookmark',
      'bookmark-o',
      'briefcase',
      'bug',
      'building',
      'building-o',
      'bullhorn',
      'bullseye',
      'bus',
      'cab',
      'calculator',
      'calendar',
      'calendar-o',
      'camera',
      'camera-retro',
      'car',
      'caret-square-o-down',
      'caret-square-o-left',
      'caret-square-o-right',
      'caret-square-o-up',
      'cc',
      'cc-amex',
      'cc-discover',
      'cc-mastercard',
      'cc-paypal',
      'cc-stripe',
      'cc-visa',
      'certificate',
      'check',
      'check-circle',
      'check-circle-o',
      'check-square',
      'check-square-o',
      'child',
      'circle',
      'circle-o',
      'circle-thin',
      'clock-o',
      'cloud',
      'cloud-download',
      'cloud-upload',
      'code',
      'code-fork',
      'coffee',
      'cog',
      'cogs',
      'comment',
      'comment-o',
      'comments',
      'comments-o',
      'compass',
      'copyright',
      'credit-card',
      'crop',
      'crosshairs',
      'cube',
      'cubes',
      'cutlery',
      'dashboard',
      'desktop',
      'dashboard',
      'database',
      'desktop',
      'dot-circle-o',
      'download',
      'edit',
      'ellipsis-h',
      'ellipsis-v',
      'envelope',
      'envelope-o',
      'envelope-square',
      'eraser',
      'exchange',
      'exclamation',
      'exclamation-circle',
      'exclamation-triangle',
      'external-link',
      'external-link-square',
      'eye',
      'eye-slash',
      'eyedropper',
      'fax',
      'female',
      'fighter-jet',
      'file-archive-o',
      'file-audio-o',
      'file-code-o',
      'file-excel-o',
      'file-image-o',
      'file-movie-o',
      'file-pdf-o',
      'file-photo-o',
      'file-picture-o',
      'file-powerpoint-o',
      'file-sound-o',
      'file-video-o',
      'file-word-o',
      'file-zip-o',
      'film',
      'filter',
      'fire',
      'fire-extinguisher',
      'flag',
      'flag-checkered',
      'flag-o',
      'flash',
      'flask',
      'folder',
      'folder-o',
      'folder-open',
      'folder-open-o',
      'frown-o',
      'futbol-o',
      'gamepad',
      'gavel',
      'gear',
      'gears',
      'gift',
      'glass',
      'globe',
      'graduation-cap',
      'group',
      'hdd-o',
      'headphones',
      'heart',
      'heart-o',
      'history',
      'home',
      'image',
      'inbox',
      'info',
      'info-circle',
      'institution',
      'key',
      'keyboard-o',
      'language',
      'laptop',
      'leaf',
      'legal',
      'lemon-o',
      'level-down',
      'level-up',
      'life-bouy',
      'life-ring',
      'life-saver',
      'lightbulb-o',
      'line-chart',
      'location-arrow',
      'lock',
      'magic',
      'magnet',
      'mail-forward',
      'mail-reply',
      'mail-reply-all',
      'male',
      'map-marker',
      'meh-o',
      'microphone',
      'microphone-slash',
      'minus',
      'minus-circle',
      'minus-square',
      'minus-square-o',
      'mobile',
      'mobile-phone',
      'money',
      'moon-o',
      'mortar-board',
      'music',
      'navicon',
      'newspaper-o',
      'paint-brush',
      'paper-plane',
      'paper-plane-o',
      'paw',
      'pencil',
      'pencil-square',
      'pencil-square-o',
      'phone',
      'phone-square',
      'photo',
      'picture-o',
      'pie-chart',
      'plane',
      'plug',
      'plus',
      'plus-circle',
      'plus-square',
      'plus-square-o',
      'power-off',
      'print',
      'puzzle-piece',
      'qrcode',
      'question',
      'question-circle',
      'quote-left',
      'quote-right',
      'random',
      'refresh',
      'reorder',
      'reply',
      'reply-all',
      'retweet',
      'road',
      'rocket',
      'rss',
      'rss-square',
      'search',
      'search-minus',
      'search-plus',
      'send',
      'send-o',
      'share',
      'share-alt',
      'share-alt-square',
      'share-square',
      'share-square-o',
      'shield',
      'shopping-cart',
      'sign-in',
      'sign-out',
      'signal',
      'sitemap',
      'sliders',
      'smile-o',
      'soccer-ball-o',
      'sort',
      'sort-alpha-asc',
      'sort-alpha-desc',
      'sort-amount-asc',
      'sort-amount-desc',
      'sort-asc',
      'sort-desc',
      'sort-down',
      'sort-numeric-asc',
      'sort-numeric-desc',
      'sort-up',
      'space-shuttle',
      'spinner',
      'spoon',
      'square',
      'square-o',
      'star',
      'star-half',
      'star-half-empty',
      'star-half-full',
      'star-half-o',
      'star-o',
      'suitcase',
      'sun-o',
      'support',
      'tablet',
      'tachometer',
      'tag',
      'tags',
      'tasks',
      'taxi',
      'terminal',
      'thumb-tack',
      'thumbs-down',
      'thumbs-o-down',
      'thumbs-o-up',
      'thumbs-up',
      'ticket',
      'times',
      'times-circle',
      'times-circle-o',
      'tint',
      'toggle-down',
      'toggle-left',
      'toggle-off',
      'toggle-on',
      'toggle-right',
      'toggle-up',
      'trash',
      'trash-o',
      'tree',
      'trophy',
      'truck',
      'tty',
      'umbrella',
      'university',
      'unlock',
      'unlock-alt',
      'unsorted',
      'upload',
      'user',
      'users',
      'video-camera',
      'volume-down',
      'volume-off',
      'volume-up',
      'warning',
      'wheelchair',
      'wifi',
      'wrench',
      'check-square',
      'check-square-o',
      'circle',
      'circle-o',
      'dot-circle-o',
      'minus-square',
      'minus-square-o',
      'plus-square',
      'plus-square-o',
      'square',
      'square-o',
      'bitcoin',
      'btc',
      'cny',
      'dollar',
      'eur',
      'euro',
      'gbp',
      'ils',
      'inr',
      'jpy',
      'krw',
      'money',
      'rmb',
      'rouble',
      'rub',
      'ruble',
      'rupee',
      'shekel',
      'sheqel',
      'try',
      'turkish-lira',
      'usd',
      'won',
      'yen',
      'align-center',
      'align-justify',
      'align-left',
      'align-right',
      'bold',
      'chain',
      'chain-broken',
      'clipboard',
      'columns',
      'copy',
      'cut',
      'dedent',
      'eraser',
      'file',
      'file-o',
      'file-text',
      'file-text-o',
      'files-o',
      'floppy-o',
      'font',
      'header',
      'indent',
      'italic',
      'link',
      'list',
      'list-alt',
      'list-ol',
      'list-ul',
      'outdent',
      'paperclip',
      'paragraph',
      'paste',
      'repeat',
      'rotate-left',
      'rotate-right',
      'save',
      'scissors',
      'strikethrough',
      'subscript',
      'superscript',
      'table',
      'text-height',
      'text-width',
      'th',
      'th-large',
      'th-list',
      'underline',
      'undo',
      'unlink',
      'angle-double-down',
      'angle-double-left',
      'angle-double-right',
      'angle-double-up',
      'angle-down',
      'angle-left',
      'angle-right',
      'angle-up',
      'arrow-circle-down',
      'arrow-circle-left',
      'arrow-circle-o-down',
      'arrow-circle-o-left',
      'arrow-circle-o-right',
      'arrow-circle-o-up',
      'arrow-circle-right',
      'arrow-circle-up',
      'arrow-down',
      'arrow-left',
      'arrow-right',
      'arrow-up',
      'arrows',
      'arrows-alt',
      'arrows-h',
      'arrows-v',
      'caret-down',
      'caret-left',
      'caret-right',
      'caret-square-o-down',
      'caret-square-o-left',
      'caret-square-o-right',
      'caret-square-o-up',
      'caret-up',
      'chevron-circle-down',
      'chevron-circle-left',
      'chevron-circle-right',
      'chevron-circle-up',
      'chevron-down',
      'chevron-left',
      'chevron-right',
      'chevron-up',
      'hand-o-down',
      'hand-o-left',
      'hand-o-right',
      'hand-o-up',
      'long-arrow-down',
      'long-arrow-left',
      'long-arrow-right',
      'long-arrow-up',
      'toggle-down',
      'toggle-left',
      'toggle-right',
      'toggle-up',
      'arrows-alt',
      'backward',
      'compress',
      'eject',
      'expand',
      'fast-backward',
      'fast-forward',
      'forward',
      'pause',
      'play',
      'play-circle',
      'play-circle-o',
      'step-backward',
      'step-forward',
      'stop',
      'youtube-play',
      'adn',
      'android',
      'angellist',
      'apple',
      'behance',
      'behance-square',
      'bitbucket',
      'bitbucket-square',
      'bitcoin',
      'btc',
      'css3',
      'delicious',
      'digg',
      'dribbble',
      'dropbox',
      'drupal',
      'empire',
      'facebook',
      'facebook-square',
      'flickr',
      'foursquare',
      'ge',
      'git',
      'git-square',
      'github',
      'github-alt',
      'github-square',
      'gittip',
      'google',
      'google-plus',
      'google-plus-square',
      'google-wallet',
      'hacker-news',
      'html5',
      'instagram',
      'ioxhost',
      'joomla',
      'jsfiddle',
      'lastfm',
      'lastfm-square',
      'linkedin',
      'linkedin-square',
      'linux',
      'maxcdn',
      'meanpath',
      'openid',
      'pagelines',
      'paypal',
      'pied-piper',
      'pied-piper-alt',
      'pinterest',
      'pinterest-square',
      'qq',
      'ra',
      'rebel',
      'reddit',
      'reddit-square',
      'renren',
      'share-alt',
      'share-alt-square',
      'skype',
      'slack',
      'slideshare',
      'soundcloud',
      'spotify',
      'stack-exchange',
      'stack-overflow',
      'steam',
      'steam-square',
      'stumbleupon',
      'stumbleupon-circle',
      'tencent-weibo',
      'trello',
      'tumblr',
      'tumblr-square',
      'twitch',
      'twitter',
      'twitter-square',
      'vimeo-square',
      'vine',
      'vk',
      'wechat',
      'weibo',
      'weixin',
      'windows',
      'wordpress',
      'xing',
      'xing-square',
      'yahoo',
      'yelp',
      'youtube',
      'youtube-play',
      'youtube-square',
      'ambulance',
      'h-square',
      'hospital-o',
      'medkit',
      'plus-square',
      'stethoscope',
      'user-md',
      'wheelchair'
    ]
  };
})(jQuery);;
/*! RESOURCE: /scripts/bootstrap-iconpicker.js */
;
(function($) {
  "use strict";
  var Iconpicker = function(element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Iconpicker.DEFAULTS, this.$element.data());
    this.options = $.extend({}, this.options, options);
  };
  Iconpicker.ICONSET_EMPTY = {
    iconClass: '',
    iconClassFix: '',
    icons: []
  };
  Iconpicker.ICONSET = {
    _custom: null,
    elusiveicon: $.iconset_elusiveicon || Iconpicker.ICONSET_EMPTY,
    fontawesome: $.iconset_fontawesome || Iconpicker.ICONSET_EMPTY,
    ionicon: $.iconset_ionicon || Iconpicker.ICONSET_EMPTY,
    glyphicon: $.iconset_glyphicon || Iconpicker.ICONSET_EMPTY,
    mapicon: $.iconset_mapicon || Iconpicker.ICONSET_EMPTY,
    materialdesign: $.iconset_materialdesign || Iconpicker.ICONSET_EMPTY,
    octicon: $.iconset_octicon || Iconpicker.ICONSET_EMPTY,
    typicon: $.iconset_typicon || Iconpicker.ICONSET_EMPTY,
    weathericon: $.iconset_weathericon || Iconpicker.ICONSET_EMPTY
  };
  Iconpicker.DEFAULTS = {
    align: 'center',
    arrowClass: 'btn-primary',
    arrowNextIconClass: 'glyphicon glyphicon-arrow-right',
    arrowPrevIconClass: 'glyphicon glyphicon-arrow-left',
    cols: 4,
    icon: '',
    iconset: 'glyphicon',
    header: true,
    labelHeader: '{0} / {1}',
    footer: true,
    labelFooter: '{0} - {1} of {2}',
    placement: 'bottom',
    rows: 4,
    search: true,
    searchText: 'Search icon',
    selectedClass: 'btn-warning',
    unselectedClass: 'btn-default'
  };
  Iconpicker.prototype.bindEvents = function() {
    var op = this.options;
    var el = this;
    op.table.find('.btn-previous, .btn-next').off('click').on('click', function(e) {
      e.preventDefault();
      var inc = parseInt($(this).val(), 10);
      el.changeList(op.page + inc);
    });
    op.table.find('.btn-icon').off('click').on('click', function(e) {
      e.preventDefault();
      el.select($(this).val());
      if (op.inline === false) {
        el.$element.popover('destroy');
      } else {
        op.table.find('i.' + $(this).val()).parent().addClass(op.selectedClass);
      }
    });
    op.table.find('.search-control').off('keyup').on('keyup', function() {
      el.changeList(1);
    });
  };
  Iconpicker.prototype.changeList = function(page) {
    this.filterIcons();
    this.updateLabels(page);
    this.updateIcons(page);
    this.options.page = page;
    this.bindEvents();
  };
  Iconpicker.prototype.filterIcons = function() {
    var op = this.options;
    var search = op.table.find('.search-control').val();
    if (search === "") {
      op.icons = Iconpicker.ICONSET[op.iconset].icons;
    } else {
      var result = [];
      $.each(Iconpicker.ICONSET[op.iconset].icons, function(i, v) {
        if (v.indexOf(search) &gt; -1) {
          result.push(v);
        }
      });
      op.icons = result;
    }
  };
  Iconpicker.prototype.removeAddClass = function(target, remove, add) {
    this.options.table.find(target).removeClass(remove).addClass(add);
    return add;
  };
  Iconpicker.prototype.reset = function() {
    this.updatePicker();
    this.changeList(1);
  };
  Iconpicker.prototype.select = function(icon) {
    var op = this.options;
    var el = this.$element;
    op.selected = $.inArray(icon.replace(op.iconClassFix, ''), op.icons);
    if (op.selected === -1) {
      op.selected = 0;
      icon = op.iconClassFix + op.icons[op.selected];
    }
    if (icon !== '' &amp;&amp; op.selected &gt;= 0) {
      op.icon = icon;
      if (op.inline === false) {
        el.find('input').val(icon);
        el.find('i').attr('class', '').addClass(op.iconClass).addClass(icon);
      }
      if (icon === op.iconClassFix) {
        el.trigger({
          type: "change",
          icon: 'empty'
        });
      } else {
        el.trigger({
          type: "change",
          icon: icon
        });
      }
      op.table.find('button.' + op.selectedClass).removeClass(op.selectedClass);
    }
  };
  Iconpicker.prototype.switchPage = function(icon) {
    var op = this.options;
    op.selected = $.inArray(icon.replace(op.iconClassFix, ''), op.icons);
    if (op.selected &gt;= 0) {
      var page = Math.ceil((op.selected + 1) / this.totalIconsPerPage());
      this.changeList(page);
    }
    if (icon === '') {
      op.table.find('i.' + op.iconClassFix).parent().addClass(op.selectedClass);
    } else {
      op.table.find('i.' + icon).parent().addClass(op.selectedClass);
    }
  };
  Iconpicker.prototype.totalPages = function() {
    return Math.ceil(this.totalIcons() / this.totalIconsPerPage());
  };
  Iconpicker.prototype.totalIcons = function() {
    return this.options.icons.length;
  };
  Iconpicker.prototype.totalIconsPerPage = function() {
    if (this.options.rows === 0) {
      return this.options.icons.length;
    } else {
      return this.options.cols * this.options.rows;
    }
  };
  Iconpicker.prototype.updateArrows = function(page) {
    var op = this.options;
    var total_pages = this.totalPages();
    if (page === 1) {
      op.table.find('.btn-previous').addClass('disabled');
    } else {
      op.table.find('.btn-previous').removeClass('disabled');
    }
    if (page === total_pages || total_pages === 0) {
      op.table.find('.btn-next').addClass('disabled');
    } else {
      op.table.find('.btn-next').removeClass('disabled');
    }
  };
  Iconpicker.prototype.updateIcons = function(page) {
    var op = this.options;
    var tbody = op.table.find('tbody').empty();
    var offset = (page - 1) * this.totalIconsPerPage();
    var length = op.rows;
    if (op.rows === 0) {
      length = op.icons.length;
    }
    for (var i = 0; i &lt; length; i++) {
      var tr = $('&lt;tr&gt;&lt;/tr&gt;');
      for (var j = 0; j &lt; op.cols; j++) {
        var pos = offset + (i * op.cols) + j;
        var btn = $('&lt;button class="btn ' + op.unselectedClass + ' btn-icon"&gt;&lt;/button&gt;').hide();
        if (pos &lt; op.icons.length) {
          var v = op.iconClassFix + op.icons[pos];
          btn.val(v).attr('title', v).append('&lt;i class="' + op.iconClass + ' ' + v + '"&gt;&lt;/i&gt;').show();
          if (op.icon === v) {
            btn.addClass(op.selectedClass).addClass('btn-icon-selected');
          }
        }
        tr.append($('&lt;td&gt;&lt;/td&gt;').append(btn));
      }
      tbody.append(tr);
    }
  };
  Iconpicker.prototype.updateIconsCount = function() {
    var op = this.options;
    if (op.footer === true) {
      var icons_count = [
        '&lt;tr&gt;',
        '   &lt;td colspan="' + op.cols + '" class="text-center"&gt;',
        '       &lt;span class="icons-count"&gt;&lt;/span&gt;',
        '   &lt;/td&gt;',
        '&lt;/tr&gt;'
      ];
      op.table.find('tfoot').empty().append(icons_count.join(''));
    }
  };
  Iconpicker.prototype.updateLabels = function(page) {
    var op = this.options;
    var total_icons = this.totalIcons();
    var total_pages = this.totalPages();
    op.table.find('.page-count').html(op.labelHeader.replace('{0}', (total_pages === 0) ? 0 : page).replace('{1}', total_pages));
    var offset = (page - 1) * this.totalIconsPerPage();
    var total = page * this.totalIconsPerPage();
    op.table.find('.icons-count').html(op.labelFooter.replace('{0}', total_icons ? offset + 1 : 0).replace('{1}', (total &lt; total_icons) ? total : total_icons).replace('{2}', total_icons));
    this.updateArrows(page);
  };
  Iconpicker.prototype.updatePagesCount = function() {
    var op = this.options;
    if (op.header === true) {
      var tr = $('&lt;tr&gt;&lt;/tr&gt;');
      for (var i = 0; i &lt; op.cols; i++) {
        var td = $('&lt;td class="text-center"&gt;&lt;/td&gt;');
        if (i === 0 || i === op.cols - 1) {
          var arrow = [
            '&lt;button class="btn btn-arrow ' + ((i === 0) ? 'btn-previous' : 'btn-next') + ' ' + op.arrowClass + '" value="' + ((i === 0) ? -1 : 1) + '"&gt;',
            '&lt;span class="' + ((i === 0) ? op.arrowPrevIconClass : op.arrowNextIconClass) + '"&gt;&lt;/span&gt;',
            '&lt;/button&gt;'
          ];
          td.append(arrow.join(''));
          tr.append(td);
        } else if (tr.find('.page-count').length === 0) {
          td.attr('colspan', op.cols - 2).append('&lt;span class="page-count"&gt;&lt;/span&gt;');
          tr.append(td);
        }
      }
      op.table.find('thead').empty().append(tr);
    }
  };
  Iconpicker.prototype.updatePicker = function() {
    var op = this.options;
    if (op.cols &lt; 4) {
      throw 'Iconpicker =&gt; The number of columns must be greater than or equal to 4. [option.cols = ' + op.cols + ']';
    } else if (op.rows &lt; 0) {
      throw 'Iconpicker =&gt; The number of rows must be greater than or equal to 0. [option.rows = ' + op.rows + ']';
    } else {
      this.updatePagesCount();
      this.updateSearch();
      this.updateIconsCount();
    }
  };
  Iconpicker.prototype.updateSearch = function() {
    var op = this.options;
    var search = [
      '&lt;tr style="display: table-row;"&gt;',
      '   &lt;td colspan="' + op.cols + '"&gt;',
      '       &lt;input type="text" class="form-control search-control" style="width: ' + op.cols * 39 + 'px;" placeholder="' + op.searchText + '"&gt;',
      '   &lt;/td&gt;',
      '&lt;/tr&gt;'
    ];
    search = $(search.join(''));
    if (op.search === true) {
      search.show();
    } else {
      search.hide();
    }
    op.table.find('thead').append(search);
  };
  Iconpicker.prototype.setAlign = function(value) {
    this.$element.removeClass(this.options.align).addClass(value);
    this.options.align = value;
  };
  Iconpicker.prototype.setArrowClass = function(value) {
    this.options.arrowClass = this.removeAddClass('.btn-arrow', this.options.arrowClass, value);
  };
  Iconpicker.prototype.setArrowNextIconClass = function(value) {
    this.options.arrowNextIconClass = this.removeAddClass('.btn-next &gt; span', this.options.arrowNextIconClass, value);
  };
  Iconpicker.prototype.setArrowPrevIconClass = function(value) {
    this.options.arrowPrevIconClass = this.removeAddClass('.btn-previous &gt; span', this.options.arrowPrevIconClass, value);
  };
  Iconpicker.prototype.setCols = function(value) {
    this.options.cols = value;
    this.reset();
  };
  Iconpicker.prototype.setFooter = function(value) {
    var footer = this.options.table.find('tfoot');
    if (value === true) {
      footer.show();
    } else {
      footer.hide();
    }
    this.options.footer = value;
  };
  Iconpicker.prototype.setHeader = function(value) {
    var header = this.options.table.find('thead');
    if (value === true) {
      header.show();
    } else {
      header.hide();
    }
    this.options.header = value;
  };
  Iconpicker.prototype.setIcon = function(value) {
    this.select(value);
  };
  Iconpicker.prototype.setIconset = function(value) {
    var op = this.options;
    if ($.isPlainObject(value)) {
      Iconpicker.ICONSET._custom = $.extend(Iconpicker.ICONSET_EMPTY, value);
      op.iconset = '_custom';
    } else if (!Iconpicker.ICONSET.hasOwnProperty(value)) {
      op.iconset = Iconpicker.DEFAULTS.iconset;
    } else {
      op.iconset = value;
    }
    op = $.extend(op, Iconpicker.ICONSET[op.iconset]);
    this.reset();
    this.select(op.icon);
  };
  Iconpicker.prototype.setLabelHeader = function(value) {
    this.options.labelHeader = value;
    this.updateLabels(this.options.page);
  };
  Iconpicker.prototype.setLabelFooter = function(value) {
    this.options.labelFooter = value;
    this.updateLabels(this.options.page);
  };
  Iconpicker.prototype.setPlacement = function(value) {
    this.options.placement = value;
  };
  Iconpicker.prototype.setRows = function(value) {
    this.options.rows = value;
    this.reset();
  };
  Iconpicker.prototype.setSearch = function(value) {
    var search = this.options.table.find('.search-control');
    if (value === true) {
      search.show();
    } else {
      search.hide();
    }
    search.val('');
    this.changeList(1);
    this.options.search = value;
  };
  Iconpicker.prototype.setSearchText = function(value) {
    this.options.table.find('.search-control').attr('placeholder', value);
    this.options.searchText = value;
  };
  Iconpicker.prototype.setSelectedClass = function(value) {
    this.options.selectedClass = this.removeAddClass('.btn-icon-selected', this.options.selectedClass, value);
  };
  Iconpicker.prototype.setUnselectedClass = function(value) {
    this.options.unselectedClass = this.removeAddClass('.btn-icon', this.options.unselectedClass, value);
  };
  var old = $.fn.iconpicker;
  $.fn.iconpicker = function(option, params) {
    return this.each(function() {
      var $this = $(this);
      var data = $this.data('bs.iconpicker');
      var options = typeof option === 'object' &amp;&amp; option;
      if (!data) {
        $this.data('bs.iconpicker', (data = new Iconpicker(this, options)));
      }
      if (typeof option === 'string') {
        if (typeof data[option] === 'undefined') {
          throw 'Iconpicker =&gt; The "' + option + '" method does not exists.';
        } else {
          data[option](params);
        }
      } else {
        var op = data.options;
        op = $.extend(op, {
          inline: false,
          page: 1,
          selected: -1,
          table: $('&lt;table class="table-icons"&gt;&lt;thead&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;tfoot&gt;&lt;/tfoot&gt;&lt;/table&gt;')
        });
        var name = (typeof $this.attr('name') !== 'undefined') ? 'name="' + $this.attr('name') + '"' : '';
        if ($this.prop('tagName') === 'BUTTON') {
          $this.empty()
            .append('&lt;i&gt;&lt;/i&gt;')
            .append('&lt;input type="hidden" ' + name + '&gt;&lt;/input&gt;')
            .append('&lt;span class="caret"&gt;&lt;/span&gt;')
            .addClass('iconpicker');
          data.setIconset(op.iconset);
          $this.on('click', function(e) {
            e.preventDefault();
            $this.popover({
              animation: false,
              trigger: 'manual',
              html: true,
              content: op.table,
              container: 'body',
              placement: op.placement
            }).on('shown.bs.popover', function() {
              data.switchPage(op.icon);
              data.bindEvents();
            });
            $this.data('bs.popover').tip().addClass('iconpicker-popover');
            $this.popover('show');
          });
        } else {
          op.inline = true;
          data.setIconset(op.iconset);
          $this.empty()
            .append('&lt;input type="hidden" ' + name + '&gt;&lt;/input&gt;')
            .append(op.table)
            .addClass('iconpicker')
            .addClass(op.align);
          data.switchPage(op.icon);
          data.bindEvents();
        }
      }
    });
  };
  $.fn.iconpicker.Constructor = Iconpicker;
  $.fn.iconpicker.noConflict = function() {
    $.fn.iconpicker = old;
    return this;
  };
  $(document).on('click', 'body', function(e) {
    $('.iconpicker').each(function() {
      if (!$(this).is(e.target) &amp;&amp; $(this).has(e.target).length === 0 &amp;&amp; $('.popover').has(e.target).length === 0) {
        $(this).popover('destroy');
      }
    });
  });
  $('button[role="iconpicker"],div[role="iconpicker"]').iconpicker();
})(jQuery);;
/*! RESOURCE: /scripts/angularjs-1.4/thirdparty/angular-ui-bootstrap/ui-bootstrap-tpls-1.1.2.js */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/popup.html", "uib/template/datepicker/year.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])
  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed);
        if (!scope.$eval(attrs.uibCollapse)) {
          element.addClass('in')
            .addClass('collapse')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false)
            .css({
              height: 'auto'
            });
        }

        function expand() {
          if (element.hasClass('collapse') &amp;&amp; element.hasClass('in')) {
            return;
          }
          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);
              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  to: {
                    height: element[0].scrollHeight + 'px'
                  }
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  to: {
                    height: element[0].scrollHeight + 'px'
                  }
                }).then(expandDone);
              }
            });
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css({
              height: 'auto'
            });
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') &amp;&amp; !element.hasClass('in')) {
            return collapseDone();
          }
          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
                .css({
                  height: element[0].scrollHeight + 'px'
                })
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: {
                    height: '0'
                  }
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: {
                    height: '0'
                  }
                }).then(collapseDone);
              }
            });
        }

        function collapseDone() {
          element.css({
            height: '0'
          });
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }
        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);
angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])
  .constant('uibAccordionConfig', {
    closeOthers: true
  })
  .controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
    this.groups = [];
    this.closeOthers = function(openGroup) {
      var closeOthers = angular.isDefined($attrs.closeOthers) ?
        $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
      if (closeOthers) {
        angular.forEach(this.groups, function(group) {
          if (group !== openGroup) {
            group.isOpen = false;
          }
        });
      }
    };
    this.addGroup = function(groupScope) {
      var that = this;
      this.groups.push(groupScope);
      groupScope.$on('$destroy', function(event) {
        that.removeGroup(groupScope);
      });
    };
    this.removeGroup = function(group) {
      var index = this.groups.indexOf(group);
      if (index !== -1) {
        this.groups.splice(index, 1);
      }
    };
  }])
  .directive('uibAccordion', function() {
    return {
      controller: 'UibAccordionController',
      controllerAs: 'accordion',
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion.html';
      }
    };
  })
  .directive('uibAccordionGroup', function() {
    return {
      require: '^uibAccordion',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
      },
      scope: {
        heading: '@',
        isOpen: '=?',
        isDisabled: '=?'
      },
      controller: function() {
        this.setHeading = function(element) {
          this.heading = element;
        };
      },
      link: function(scope, element, attrs, accordionCtrl) {
        accordionCtrl.addGroup(scope);
        scope.openClass = attrs.openClass || 'panel-open';
        scope.panelClass = attrs.panelClass || 'panel-default';
        scope.$watch('isOpen', function(value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });
        scope.toggleOpen = function($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
        var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        scope.headingId = id + '-tab';
        scope.panelId = id + '-panel';
      }
    };
  })
  .directive('uibAccordionHeading', function() {
    return {
      transclude: true,
      template: '',
      replace: true,
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      }
    };
  })
  .directive('uibAccordionTransclude', function() {
    return {
      require: '^uibAccordionGroup',
      link: function(scope, element, attrs, controller) {
        scope.$watch(function() {
          return controller[attrs.uibAccordionTransclude];
        }, function(heading) {
          if (heading) {
            element.find('span').html('');
            element.find('span').append(heading);
          }
        });
      }
    };
  });
angular.module('ui.bootstrap.alert', [])
  .controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close;
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
      $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    if (dismissOnTimeout) {
      $timeout(function() {
        $scope.close();
      }, parseInt(dismissOnTimeout, 10));
    }
  }])
  .directive('uibAlert', function() {
    return {
      controller: 'UibAlertController',
      controllerAs: 'alert',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/alert/alert.html';
      },
      transclude: true,
      replace: true,
      scope: {
        type: '@',
        close: '&amp;'
      }
    };
  });
angular.module('ui.bootstrap.buttons', [])
  .constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
  })
  .controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || 'active';
    this.toggleEvent = buttonConfig.toggleEvent || 'click';
  }])
  .directive('uibBtnRadio', ['$parse', function($parse) {
    return {
      require: ['uibBtnRadio', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'buttons',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        var uncheckableExpr = $parse(attrs.uibUncheckable);
        element.find('input').css({
          display: 'none'
        });
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          var isActive = element.hasClass(buttonsCtrl.activeClass);
          if (!isActive || angular.isDefined(attrs.uncheckable)) {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
              ngModelCtrl.$render();
            });
          }
        });
        if (attrs.uibUncheckable) {
          scope.$watch(uncheckableExpr, function(uncheckable) {
            attrs.$set('uncheckable', uncheckable ? '' : null);
          });
        }
      }
    };
  }])
  .directive('uibBtnCheckbox', function() {
    return {
      require: ['uibBtnCheckbox', 'ngModel'],
      controller: 'UibButtonsController',
      controllerAs: 'button',
      link: function(scope, element, attrs, ctrls) {
        var buttonsCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        element.find('input').css({
          display: 'none'
        });

        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }

        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }

        function getCheckboxValue(attribute, defaultValue) {
          return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
        }
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
        };
        element.on(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });
      }
    };
  });
angular.module('ui.bootstrap.carousel', [])
  .controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
    var self = this,
      slides = self.slides = $scope.slides = [],
      SLIDE_DIRECTION = 'uib-slideDirection',
      currentIndex = -1,
      currentInterval, isPlaying, bufferedTransitions = [];
    self.currentSlide = null;
    var destroyed = false;
    self.addSlide = function(slide, element) {
      slide.$element = element;
      slides.push(slide);
      if (slides.length === 1 || slide.active) {
        if ($scope.$currentTransition) {
          $scope.$currentTransition = null;
        }
        self.select(slides[slides.length - 1]);
        if (slides.length === 1) {
          $scope.play();
        }
      } else {
        slide.active = false;
      }
    };
    self.getCurrentIndex = function() {
      if (self.currentSlide &amp;&amp; angular.isDefined(self.currentSlide.index)) {
        return +self.currentSlide.index;
      }
      return currentIndex;
    };
    self.next = $scope.next = function() {
      var newIndex = (self.getCurrentIndex() + 1) % slides.length;
      if (newIndex === 0 &amp;&amp; $scope.noWrap()) {
        $scope.pause();
        return;
      }
      return self.select(getSlideByIndex(newIndex), 'next');
    };
    self.prev = $scope.prev = function() {
      var newIndex = self.getCurrentIndex() - 1 &lt; 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
      if ($scope.noWrap() &amp;&amp; newIndex === slides.length - 1) {
        $scope.pause();
        return;
      }
      return self.select(getSlideByIndex(newIndex), 'prev');
    };
    self.removeSlide = function(slide) {
      if (angular.isDefined(slide.index)) {
        slides.sort(function(a, b) {
          return +a.index &gt; +b.index;
        });
      }
      var bufferedIndex = bufferedTransitions.indexOf(slide);
      if (bufferedIndex !== -1) {
        bufferedTransitions.splice(bufferedIndex, 1);
      }
      var index = slides.indexOf(slide);
      slides.splice(index, 1);
      $timeout(function() {
        if (slides.length &gt; 0 &amp;&amp; slide.active) {
          if (index &gt;= slides.length) {
            self.select(slides[index - 1]);
          } else {
            self.select(slides[index]);
          }
        } else if (currentIndex &gt; index) {
          currentIndex--;
        }
      });
      if (slides.length === 0) {
        self.currentSlide = null;
        clearBufferedTransitions();
      }
    };
    self.select = $scope.select = function(nextSlide, direction) {
      var nextIndex = $scope.indexOfSlide(nextSlide);
      if (direction === undefined) {
        direction = nextIndex &gt; self.getCurrentIndex() ? 'next' : 'prev';
      }
      if (nextSlide &amp;&amp; nextSlide !== self.currentSlide &amp;&amp; !$scope.$currentTransition) {
        goNext(nextSlide, nextIndex, direction);
      } else if (nextSlide &amp;&amp; nextSlide !== self.currentSlide &amp;&amp; $scope.$currentTransition) {
        bufferedTransitions.push(nextSlide);
        nextSlide.active = false;
      }
    };
    $scope.indexOfSlide = function(slide) {
      return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
    };
    $scope.isActive = function(slide) {
      return self.currentSlide === slide;
    };
    $scope.pause = function() {
      if (!$scope.noPause) {
        isPlaying = false;
        resetTimer();
      }
    };
    $scope.play = function() {
      if (!isPlaying) {
        isPlaying = true;
        restartTimer();
      }
    };
    $scope.$on('$destroy', function() {
      destroyed = true;
      resetTimer();
    });
    $scope.$watch('noTransition', function(noTransition) {
      $animate.enabled($element, !noTransition);
    });
    $scope.$watch('interval', restartTimer);
    $scope.$watchCollection('slides', resetTransition);

    function clearBufferedTransitions() {
      while (bufferedTransitions.length) {
        bufferedTransitions.shift();
      }
    }

    function getSlideByIndex(index) {
      if (angular.isUndefined(slides[index].index)) {
        return slides[index];
      }
      for (var i = 0, l = slides.length; i &lt; l; ++i) {
        if (slides[i].index === index) {
          return slides[i];
        }
      }
    }

    function goNext(slide, index, direction) {
      if (destroyed) {
        return;
      }
      angular.extend(slide, {
        direction: direction,
        active: true
      });
      angular.extend(self.currentSlide || {}, {
        direction: direction,
        active: false
      });
      if ($animate.enabled($element) &amp;&amp; !$scope.$currentTransition &amp;&amp;
        slide.$element &amp;&amp; self.slides.length &gt; 1) {
        slide.$element.data(SLIDE_DIRECTION, slide.direction);
        if (self.currentSlide &amp;&amp; self.currentSlide.$element) {
          self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
        }
        $scope.$currentTransition = true;
        $animate.on('addClass', slide.$element, function(element, phase) {
          if (phase === 'close') {
            $scope.$currentTransition = null;
            $animate.off('addClass', element);
            if (bufferedTransitions.length) {
              var nextSlide = bufferedTransitions.pop();
              var nextIndex = $scope.indexOfSlide(nextSlide);
              var nextDirection = nextIndex &gt; self.getCurrentIndex() ? 'next' : 'prev';
              clearBufferedTransitions();
              goNext(nextSlide, nextIndex, nextDirection);
            }
          }
        });
      }
      self.currentSlide = slide;
      currentIndex = index;
      restartTimer();
    }

    function resetTimer() {
      if (currentInterval) {
        $interval.cancel(currentInterval);
        currentInterval = null;
      }
    }

    function resetTransition(slides) {
      if (!slides.length) {
        $scope.$currentTransition = null;
        clearBufferedTransitions();
      }
    }

    function restartTimer() {
      resetTimer();
      var interval = +$scope.interval;
      if (!isNaN(interval) &amp;&amp; interval &gt; 0) {
        currentInterval = $interval(timerFn, interval);
      }
    }

    function timerFn() {
      var interval = +$scope.interval;
      if (isPlaying &amp;&amp; !isNaN(interval) &amp;&amp; interval &gt; 0 &amp;&amp; slides.length) {
        $scope.next();
      } else {
        $scope.pause();
      }
    }
  }])
  .directive('uibCarousel', function() {
    return {
      transclude: true,
      replace: true,
      controller: 'UibCarouselController',
      controllerAs: 'carousel',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/carousel.html';
      },
      scope: {
        interval: '=',
        noTransition: '=',
        noPause: '=',
        noWrap: '&amp;'
      }
    };
  })
  .directive('uibSlide', function() {
    return {
      require: '^uibCarousel',
      transclude: true,
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/carousel/slide.html';
      },
      scope: {
        active: '=?',
        actual: '=?',
        index: '=?'
      },
      link: function(scope, element, attrs, carouselCtrl) {
        carouselCtrl.addSlide(scope, element);
        scope.$on('$destroy', function() {
          carouselCtrl.removeSlide(scope);
        });
        scope.$watch('active', function(active) {
          if (active) {
            carouselCtrl.select(scope);
          }
        });
      }
    };
  })
  .animation('.item', ['$animateCss',
    function($animateCss) {
      var SLIDE_DIRECTION = 'uib-slideDirection';

      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element,
              directionClass + ' ' + direction, done);
            element.addClass(direction);
            $animateCss(element, {
                addClass: directionClass
              })
              .start()
              .done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);
            $animateCss(element, {
                addClass: directionClass
              })
              .start()
              .done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }
  ]);
angular.module('ui.bootstrap.dateparser', [])
  .service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var localeId;
    var formatCodeToRegex;
    this.init = function() {
      localeId = $locale.id;
      this.parsers = {};
      this.formatters = {};
      formatCodeToRegex = [{
          key: 'yyyy',
          regex: '\\d{4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yyyy');
          }
        },
        {
          key: 'yy',
          regex: '\\d{2}',
          apply: function(value) {
            this.year = +value + 2000;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yy');
          }
        },
        {
          key: 'y',
          regex: '\\d{1,4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'y');
          }
        },
        {
          key: 'M!',
          regex: '0?[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, 'MM');
            }
            return dateFilter(date, 'M');
          }
        },
        {
          key: 'MMMM',
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMMM');
          }
        },
        {
          key: 'MMM',
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMM');
          }
        },
        {
          key: 'MM',
          regex: '0[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'MM');
          }
        },
        {
          key: 'M',
          regex: '[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'M');
          }
        },
        {
          key: 'd!',
          regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, 'dd');
            }
            return dateFilter(date, 'd');
          }
        },
        {
          key: 'dd',
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'dd');
          }
        },
        {
          key: 'd',
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'd');
          }
        },
        {
          key: 'EEEE',
          regex: $locale.DATETIME_FORMATS.DAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEEE');
          }
        },
        {
          key: 'EEE',
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEE');
          }
        },
        {
          key: 'HH',
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'HH');
          }
        },
        {
          key: 'hh',
          regex: '0[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'hh');
          }
        },
        {
          key: 'H',
          regex: '1?[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'H');
          }
        },
        {
          key: 'h',
          regex: '[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'h');
          }
        },
        {
          key: 'mm',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'mm');
          }
        },
        {
          key: 'm',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'm');
          }
        },
        {
          key: 'sss',
          regex: '[0-9][0-9][0-9]',
          apply: function(value) {
            this.milliseconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'sss');
          }
        },
        {
          key: 'ss',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'ss');
          }
        },
        {
          key: 's',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 's');
          }
        },
        {
          key: 'a',
          regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
          apply: function(value) {
            if (this.hours === 12) {
              this.hours = 0;
            }
            if (value === 'PM') {
              this.hours += 12;
            }
          },
          formatter: function(date) {
            return dateFilter(date, 'a');
          }
        },
        {
          key: 'Z',
          regex: '[+-]\\d{4}',
          apply: function(value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
              sign = matches[1],
              hours = matches[2],
              minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function(date) {
            return dateFilter(date, 'Z');
          }
        },
        {
          key: 'ww',
          regex: '[0-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'ww');
          }
        },
        {
          key: 'w',
          regex: '[0-9]|[1-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'w');
          }
        },
        {
          key: 'GGGG',
          regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
          formatter: function(date) {
            return dateFilter(date, 'GGGG');
          }
        },
        {
          key: 'GGG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GGG');
          }
        },
        {
          key: 'GG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GG');
          }
        },
        {
          key: 'G',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'G');
          }
        }
      ];
    };
    this.init();

    function createParser(format, func) {
      var map = [],
        regex = format.split('');
      var quoteIndex = format.indexOf('\'');
      if (quoteIndex &gt; -1) {
        var inLiteral = false;
        format = format.split('');
        for (var i = quoteIndex; i &lt; format.length; i++) {
          if (inLiteral) {
            if (format[i] === '\'') {
              if (i + 1 &lt; format.length &amp;&amp; format[i + 1] === '\'') {
                format[i + 1] = '$';
                regex[i + 1] = '';
              } else {
                regex[i] = '';
                inLiteral = false;
              }
            }
            format[i] = '$';
          } else {
            if (format[i] === '\'') {
              format[i] = '$';
              regex[i] = '';
              inLiteral = true;
            }
          }
        }
        format = format.join('');
      }
      angular.forEach(formatCodeToRegex, function(data) {
        var index = format.indexOf(data.key);
        if (index &gt; -1) {
          format = format.split('');
          regex[index] = '(' + data.regex + ')';
          format[index] = '$';
          for (var i = index + 1, n = index + data.key.length; i &lt; n; i++) {
            regex[i] = '';
            format[i] = '$';
          }
          format = format.join('');
          map.push({
            index: index,
            key: data.key,
            apply: data[func],
            matcher: data.regex
          });
        }
      });
      return {
        regex: new RegExp('^' + regex.join('') + '$'),
        map: orderByFilter(map, 'index')
      };
    }
    this.filter = function(date, format) {
      if (!angular.isDate(date) || isNaN(date) || !format) {
        return '';
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.formatters[format]) {
        this.formatters[format] = createParser(format, 'formatter');
      }
      var parser = this.formatters[format],
        map = parser.map;
      var _format = format;
      return map.reduce(function(str, mapper, i) {
        var match = _format.match(new RegExp('(.*)' + mapper.key));
        if (match &amp;&amp; angular.isString(match[1])) {
          str += match[1];
          _format = _format.replace(match[1] + mapper.key, '');
        }
        if (mapper.apply) {
          return str + mapper.apply.call(null, date);
        }
        return str;
      }, '');
    };
    this.parse = function(input, format, baseDate) {
      if (!angular.isString(input) || !format) {
        return input;
      }
      format = $locale.DATETIME_FORMATS[format] || format;
      format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&amp;');
      if ($locale.id !== localeId) {
        this.init();
      }
      if (!this.parsers[format]) {
        this.parsers[format] = createParser(format, 'apply');
      }
      var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
      if (results &amp;&amp; results.length) {
        var fields, dt;
        if (angular.isDate(baseDate) &amp;&amp; !isNaN(baseDate.getTime())) {
          fields = {
            year: baseDate.getFullYear(),
            month: baseDate.getMonth(),
            date: baseDate.getDate(),
            hours: baseDate.getHours(),
            minutes: baseDate.getMinutes(),
            seconds: baseDate.getSeconds(),
            milliseconds: baseDate.getMilliseconds()
          };
        } else {
          if (baseDate) {
            $log.warn('dateparser:', 'baseDate is not a valid date');
          }
          fields = {
            year: 1900,
            month: 0,
            date: 1,
            hours: 0,
            minutes: 0,
            seconds: 0,
            milliseconds: 0
          };
        }
        for (var i = 1, n = results.length; i &lt; n; i++) {
          var mapper = map[i - 1];
          if (mapper.matcher === 'Z') {
            tzOffset = true;
          }
          if (mapper.apply) {
            mapper.apply.call(fields, results[i]);
          }
        }
        var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
          Date.prototype.setFullYear;
        var timesetter = tzOffset ? Date.prototype.setUTCHours :
          Date.prototype.setHours;
        if (isValid(fields.year, fields.month, fields.date)) {
          if (angular.isDate(baseDate) &amp;&amp; !isNaN(baseDate.getTime()) &amp;&amp; !tzOffset) {
            dt = new Date(baseDate);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours, fields.minutes,
              fields.seconds, fields.milliseconds);
          } else {
            dt = new Date(0);
            datesetter.call(dt, fields.year, fields.month, fields.date);
            timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
              fields.seconds || 0, fields.milliseconds || 0);
          }
        }
        return dt;
      }
    };

    function isValid(year, month, date) {
      if (date &lt; 1) {
        return false;
      }
      if (month === 1 &amp;&amp; date &gt; 28) {
        return date === 29 &amp;&amp; (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0);
      }
      if (month === 3 || month === 5 || month === 8 || month === 10) {
        return date &lt; 31;
      }
      return true;
    }

    function toInt(str) {
      return parseInt(str, 10);
    }
    this.toTimezone = toTimezone;
    this.fromTimezone = fromTimezone;
    this.timezoneToOffset = timezoneToOffset;
    this.addDateMinutes = addDateMinutes;
    this.convertTimezoneToLocal = convertTimezoneToLocal;

    function toTimezone(date, timezone) {
      return date &amp;&amp; timezone ? convertTimezoneToLocal(date, timezone) : date;
    }

    function fromTimezone(date, timezone) {
      return date &amp;&amp; timezone ? convertTimezoneToLocal(date, timezone, true) : date;
    }

    function timezoneToOffset(timezone, fallback) {
      var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
      return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }

    function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }

    function convertTimezoneToLocal(date, timezone, reverse) {
      reverse = reverse ? -1 : 1;
      var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
  }]);
angular.module('ui.bootstrap.isClass', [])
  .directive('uibIsClass', [
    '$animate',
    function($animate) {
      var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
      var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
      var dataPerTracked = {};
      return {
        restrict: 'A',
        compile: function(tElement, tAttrs) {
          var linkedScopes = [];
          var instances = [];
          var expToData = {};
          var lastActivated = null;
          var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
          var onExp = onExpMatches[2];
          var expsStr = onExpMatches[1];
          var exps = expsStr.split(',');
          return linkFn;

          function linkFn(scope, element, attrs) {
            linkedScopes.push(scope);
            instances.push({
              scope: scope,
              element: element
            });
            exps.forEach(function(exp, k) {
              addForExp(exp, scope);
            });
            scope.$on('$destroy', removeScope);
          }

          function addForExp(exp, scope) {
            var matches = exp.match(IS_REGEXP);
            var clazz = scope.$eval(matches[1]);
            var compareWithExp = matches[2];
            var data = expToData[exp];
            if (!data) {
              var watchFn = function(compareWithVal) {
                var newActivated = null;
                instances.some(function(instance) {
                  var thisVal = instance.scope.$eval(onExp);
                  if (thisVal === compareWithVal) {
                    newActivated = instance;
                    return true;
                  }
                });
                if (data.lastActivated !== newActivated) {
                  if (data.lastActivated) {
                    $animate.removeClass(data.lastActivated.element, clazz);
                  }
                  if (newActivated) {
                    $animate.addClass(newActivated.element, clazz);
                  }
                  data.lastActivated = newActivated;
                }
              };
              expToData[exp] = data = {
                lastActivated: null,
                scope: scope,
                watchFn: watchFn,
                compareWithExp: compareWithExp,
                watcher: scope.$watch(compareWithExp, watchFn)
              };
            }
            data.watchFn(scope.$eval(compareWithExp));
          }

          function removeScope(e) {
            var removedScope = e.targetScope;
            var index = linkedScopes.indexOf(removedScope);
            linkedScopes.splice(index, 1);
            instances.splice(index, 1);
            if (linkedScopes.length) {
              var newWatchScope = linkedScopes[0];
              angular.forEach(expToData, function(data) {
                if (data.scope === removedScope) {
                  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                  data.scope = newWatchScope;
                }
              });
            } else {
              expToData = {};
            }
          }
        }
      };
    }
  ]);
angular.module('ui.bootstrap.position', [])
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    var SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    return {
      getRawNode: function(elem) {
        return elem[0] || elem;
      },
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);
        var offsetParent = elem.offsetParent || $document[0].documentElement;

        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }
        while (offsetParent &amp;&amp; offsetParent !== $document[0].documentElement &amp;&amp; isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || $document[0].documentElement;
      },
      scrollbarWidth: function() {
        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('&lt;div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"&gt;&lt;/div&gt;');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }
        return SCROLLBAR_WIDTH;
      },
      scrollParent: function(elem, includeHidden) {
        elem = this.getRawNode(elem);
        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;
        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }
        while (scrollParent.parentElement &amp;&amp; scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic &amp;&amp; spStyle.position !== 'static') {
            excludeStatic = false;
          }
          if (!excludeStatic &amp;&amp; overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }
        return scrollParent;
      },
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);
        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {
          top: 0,
          left: 0
        };
        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }
        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },
      offset: function(elem) {
        elem = this.getRawNode(elem);
        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;
        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();
        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }
        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }
        placement = placement.split('-');
        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }
        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }
        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }
        return placement;
      },
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
        placement = this.parsePlacement(placement);
        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {
          top: 0,
          left: 0,
          placement: ''
        };
        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem);
          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };
          placement[0] = placement[0] === 'top' &amp;&amp; adjustedSize.height &gt; viewportOffset.top &amp;&amp; adjustedSize.height &lt;= viewportOffset.bottom ? 'bottom' :
            placement[0] === 'bottom' &amp;&amp; adjustedSize.height &gt; viewportOffset.bottom &amp;&amp; adjustedSize.height &lt;= viewportOffset.top ? 'top' :
            placement[0] === 'left' &amp;&amp; adjustedSize.width &gt; viewportOffset.left &amp;&amp; adjustedSize.width &lt;= viewportOffset.right ? 'right' :
            placement[0] === 'right' &amp;&amp; adjustedSize.width &gt; viewportOffset.right &amp;&amp; adjustedSize.width &lt;= viewportOffset.left ? 'left' :
            placement[0];
          placement[1] = placement[1] === 'top' &amp;&amp; adjustedSize.height - hostElemPos.height &gt; viewportOffset.bottom &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.top ? 'bottom' :
            placement[1] === 'bottom' &amp;&amp; adjustedSize.height - hostElemPos.height &gt; viewportOffset.top &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.bottom ? 'top' :
            placement[1] === 'left' &amp;&amp; adjustedSize.width - hostElemPos.width &gt; viewportOffset.right &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.left ? 'right' :
            placement[1] === 'right' &amp;&amp; adjustedSize.width - hostElemPos.width &gt; viewportOffset.left &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.right ? 'left' :
            placement[1];
          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow &lt; 0 &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow &lt; 0 &amp;&amp; adjustedSize.width - hostElemPos.width &lt;= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow &lt; 0 &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow &lt; 0 &amp;&amp; adjustedSize.height - hostElemPos.height &lt;= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }
        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }
        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }
        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
        return targetElemPos;
      },
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);
        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }
        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }
        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          angular.element(arrowElem).css({
            top: '',
            bottom: '',
            right: '',
            left: '',
            margin: ''
          });
          return;
        }
        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
        var arrowCss = {
          top: 'auto',
          bottom: 'auto',
          left: 'auto',
          right: 'auto',
          margin: 0
        };
        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }
        arrowCss[placement[1]] = borderRadius;
        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])
  .value('$datepickerSuppressError', false)
  .constant('uibDatepickerConfig', {
    datepickerMode: 'day',
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    maxDate: null,
    maxMode: 'year',
    minDate: null,
    minMode: 'day',
    ngModelOptions: {},
    shortcutPropagation: false,
    showWeeks: true,
    yearColumns: 5,
    yearRows: 4
  })
  .controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser',
    function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, dateParser) {
      var self = this,
        ngModelCtrl = {
          $setViewValue: angular.noop
        },
        ngModelOptions = {},
        watchListeners = [];
      this.modes = ['day', 'month', 'year'];
      if ($attrs.datepickerOptions) {
        angular.forEach([
          'formatDay',
          'formatDayHeader',
          'formatDayTitle',
          'formatMonth',
          'formatMonthTitle',
          'formatYear',
          'initDate',
          'maxDate',
          'maxMode',
          'minDate',
          'minMode',
          'showWeeks',
          'shortcutPropagation',
          'startingDay',
          'yearColumns',
          'yearRows'
        ], function(key) {
          switch (key) {
            case 'formatDay':
            case 'formatDayHeader':
            case 'formatDayTitle':
            case 'formatMonth':
            case 'formatMonthTitle':
            case 'formatYear':
              self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
              break;
            case 'showWeeks':
            case 'shortcutPropagation':
            case 'yearColumns':
            case 'yearRows':
              self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
                $scope.datepickerOptions[key] : datepickerConfig[key];
              break;
            case 'startingDay':
              if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                self.startingDay = $scope.datepickerOptions.startingDay;
              } else if (angular.isNumber(datepickerConfig.startingDay)) {
                self.startingDay = datepickerConfig.startingDay;
              } else {
                self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
              }
              break;
            case 'maxDate':
            case 'minDate':
              if ($scope.datepickerOptions[key]) {
                $scope.$watch(function() {
                  return $scope.datepickerOptions[key];
                }, function(value) {
                  if (value) {
                    if (angular.isDate(value)) {
                      self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                    } else {
                      self[key] = new Date(dateFilter(value, 'medium'));
                    }
                  } else {
                    self[key] = null;
                  }
                  self.refreshView();
                });
              } else {
                self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
              }
              break;
            case 'maxMode':
            case 'minMode':
              if ($scope.datepickerOptions[key]) {
                $scope.$watch(function() {
                  return $scope.datepickerOptions[key];
                }, function(value) {
                  self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
                  if (key === 'minMode' &amp;&amp; self.modes.indexOf($scope.datepickerMode) &lt; self.modes.indexOf(self[key]) ||
                    key === 'maxMode' &amp;&amp; self.modes.indexOf($scope.datepickerMode) &gt; self.modes.indexOf(self[key])) {
                    $scope.datepickerMode = self[key];
                  }
                });
              } else {
                self[key] = $scope[key] = datepickerConfig[key] || null;
              }
              break;
            case 'initDate':
              if ($scope.datepickerOptions.initDate) {
                this.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
                $scope.$watch(function() {
                  return $scope.datepickerOptions.initDate;
                }, function(initDate) {
                  if (initDate &amp;&amp; (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                    self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
                    self.refreshView();
                  }
                });
              } else {
                this.activeDate = new Date();
              }
          }
        });
      } else {
        angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {
          self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];
        });
        angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {
          self[key] = angular.isDefined($attrs[key]) ?
            $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
        });
        if (angular.isDefined($attrs.startingDay)) {
          self.startingDay = $scope.$parent.$eval($attrs.startingDay);
        } else if (angular.isNumber(datepickerConfig.startingDay)) {
          self.startingDay = datepickerConfig.startingDay;
        } else {
          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
        }
        angular.forEach(['minDate', 'maxDate'], function(key) {
          if ($attrs[key]) {
            watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  self[key] = new Date(dateFilter(value, 'medium'));
                }
              } else {
                self[key] = null;
              }
              self.refreshView();
            }));
          } else {
            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
          }
        });
        angular.forEach(['minMode', 'maxMode'], function(key) {
          if ($attrs[key]) {
            watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {
              self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];
              if (key === 'minMode' &amp;&amp; self.modes.indexOf($scope.datepickerMode) &lt; self.modes.indexOf(self[key]) ||
                key === 'maxMode' &amp;&amp; self.modes.indexOf($scope.datepickerMode) &gt; self.modes.indexOf(self[key])) {
                $scope.datepickerMode = self[key];
              }
            }));
          } else {
            self[key] = $scope[key] = datepickerConfig[key] || null;
          }
        });
        if (angular.isDefined($attrs.initDate)) {
          this.activeDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone) || new Date();
          watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {
            if (initDate &amp;&amp; (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
              self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
              self.refreshView();
            }
          }));
        } else {
          this.activeDate = new Date();
        }
      }
      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
          $scope.disabled = disabled;
          self.refreshView();
        }));
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
        if (ngModelCtrl.$modelValue) {
          this.activeDate = ngModelCtrl.$modelValue;
        }
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
            isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity('dateDisabled', !date ||
            this.element &amp;&amp; !this.isDisabled(date));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model &amp;&amp; this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          current: this.compare(date, new Date()) === 0,
          customClass: this.customClass(date) || null
        };
        if (model &amp;&amp; this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }
        if (self.activeDate &amp;&amp; this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }
        return dt;
      };
      this.isDisabled = function(date) {
        return $scope.disabled ||
          this.minDate &amp;&amp; this.compare(date, this.minDate) &lt; 0 ||
          this.maxDate &amp;&amp; this.compare(date, this.maxDate) &gt; 0 ||
          $attrs.dateDisabled &amp;&amp; $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
          });
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length &gt; 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
          month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if ($scope.datepickerMode === self.maxMode &amp;&amp; direction === 1 ||
          $scope.datepickerMode === self.minMode &amp;&amp; direction === -1) {
          return;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey &amp;&amp; (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
      $scope.$on("$destroy", function() {
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
    }
  ])
  .controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    this.step = {
      months: 1
    };
    this.element = $element;

    function getDaysInMonth(year, month) {
      return month === 1 &amp;&amp; year % 4 === 0 &amp;&amp;
        (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
    }
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      scope.showWeeks = ctrl.showWeeks;
      ctrl.refreshView();
    };
    this.getDates = function(startDate, n) {
      var dates = new Array(n),
        current = new Date(startDate),
        i = 0,
        date;
      while (i &lt; n) {
        date = new Date(current);
        dates[i++] = date;
        current.setDate(current.getDate() + 1);
      }
      return dates;
    };
    this._refreshView = function() {
      var year = this.activeDate.getFullYear(),
        month = this.activeDate.getMonth(),
        firstDayOfMonth = new Date(this.activeDate);
      firstDayOfMonth.setFullYear(year, month, 1);
      var difference = this.startingDay - firstDayOfMonth.getDay(),
        numDisplayedFromPreviousMonth = difference &gt; 0 ?
        7 - difference : -difference,
        firstDate = new Date(firstDayOfMonth);
      if (numDisplayedFromPreviousMonth &gt; 0) {
        firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
      }
      var days = this.getDates(firstDate, 42);
      for (var i = 0; i &lt; 42; i++) {
        days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
          secondary: days[i].getMonth() !== month,
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.labels = new Array(7);
      for (var j = 0; j &lt; 7; j++) {
        scope.labels[j] = {
          abbr: dateFilter(days[j].date, this.formatDayHeader),
          full: dateFilter(days[j].date, 'EEEE')
        };
      }
      scope.title = dateFilter(this.activeDate, this.formatDayTitle);
      scope.rows = this.split(days, 7);
      if (scope.showWeeks) {
        scope.weekNumbers = [];
        var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
        for (var curWeek = 0; curWeek &lt; numWeeks; curWeek++) {
          scope.weekNumbers.push(
            getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
      }
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };

    function getISO8601WeekNumber(date) {
      var checkDate = new Date(date);
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      var time = checkDate.getTime();
      checkDate.setMonth(0);
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    }
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getDate();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 7;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 7;
      } else if (key === 'pageup' || key === 'pagedown') {
        var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setMonth(month, 1);
        date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
      } else if (key === 'home') {
        date = 1;
      } else if (key === 'end') {
        date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
      }
      this.activeDate.setDate(date);
    };
  }])
  .controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    this.step = {
      years: 1
    };
    this.element = $element;
    this.init = function(ctrl) {
      angular.extend(ctrl, this);
      ctrl.refreshView();
    };
    this._refreshView = function() {
      var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;
      for (var i = 0; i &lt; 12; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(year, i, 1);
        months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
      scope.rows = this.split(months, 3);
    };
    this.compare = function(date1, date2) {
      var _date1 = new Date(date1.getFullYear(), date1.getMonth());
      var _date2 = new Date(date2.getFullYear(), date2.getMonth());
      _date1.setFullYear(date1.getFullYear());
      _date2.setFullYear(date2.getFullYear());
      return _date1 - _date2;
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getMonth();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - 3;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + 3;
      } else if (key === 'pageup' || key === 'pagedown') {
        var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
        this.activeDate.setFullYear(year);
      } else if (key === 'home') {
        date = 0;
      } else if (key === 'end') {
        date = 11;
      }
      this.activeDate.setMonth(date);
    };
  }])
  .controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
    var columns, range;
    this.element = $element;

    function getStartingYear(year) {
      return parseInt((year - 1) / range, 10) * range + 1;
    }
    this.yearpickerInit = function() {
      columns = this.yearColumns;
      range = this.yearRows * columns;
      this.step = {
        years: range
      };
    };
    this._refreshView = function() {
      var years = new Array(range),
        date;
      for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i &lt; range; i++) {
        date = new Date(this.activeDate);
        date.setFullYear(start + i, 0, 1);
        years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
          uid: scope.uniqueId + '-' + i
        });
      }
      scope.title = [years[0].label, years[range - 1].label].join(' - ');
      scope.rows = this.split(years, columns);
      scope.columns = columns;
    };
    this.compare = function(date1, date2) {
      return date1.getFullYear() - date2.getFullYear();
    };
    this.handleKeyDown = function(key, evt) {
      var date = this.activeDate.getFullYear();
      if (key === 'left') {
        date = date - 1;
      } else if (key === 'up') {
        date = date - columns;
      } else if (key === 'right') {
        date = date + 1;
      } else if (key === 'down') {
        date = date + columns;
      } else if (key === 'pageup' || key === 'pagedown') {
        date += (key === 'pageup' ? -1 : 1) * range;
      } else if (key === 'home') {
        date = getStartingYear(this.activeDate.getFullYear());
      } else if (key === 'end') {
        date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
      }
      this.activeDate.setFullYear(date);
    };
  }])
  .directive('uibDatepicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
      },
      scope: {
        datepickerMode: '=?',
        datepickerOptions: '=?',
        dateDisabled: '&amp;',
        customClass: '&amp;',
        shortcutPropagation: '&amp;?'
      },
      require: ['uibDatepicker', '^ngModel'],
      controller: 'UibDatepickerController',
      controllerAs: 'datepicker',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        datepickerCtrl.init(ngModelCtrl);
      }
    };
  })
  .directive('uibDaypicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/day.html';
      },
      require: ['^uibDatepicker', 'uibDaypicker'],
      controller: 'UibDaypickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          daypickerCtrl = ctrls[1];
        daypickerCtrl.init(datepickerCtrl);
      }
    };
  })
  .directive('uibMonthpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/month.html';
      },
      require: ['^uibDatepicker', 'uibMonthpicker'],
      controller: 'UibMonthpickerController',
      link: function(scope, element, attrs, ctrls) {
        var datepickerCtrl = ctrls[0],
          monthpickerCtrl = ctrls[1];
        monthpickerCtrl.init(datepickerCtrl);
      }
    };
  })
  .directive('uibYearpicker', function() {
    return {
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/year.html';
      },
      require: ['^uibDatepicker', 'uibYearpicker'],
      controller: 'UibYearpickerController',
      link: function(scope, element, attrs, ctrls) {
        var ctrl = ctrls[0];
        angular.extend(ctrl, ctrls[1]);
        ctrl.yearpickerInit();
        ctrl.refreshView();
      }
    };
  })
  .constant('uibDatepickerPopupConfig', {
    altInputFormats: [],
    appendToBody: false,
    clearText: 'Clear',
    closeOnDateSelection: true,
    closeText: 'Done',
    currentText: 'Today',
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',
    datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
    html5Types: {
      date: 'yyyy-MM-dd',
      'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
      'month': 'yyyy-MM'
    },
    onOpenFocus: true,
    showButtonBar: true
  })
  .controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig',
    function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig) {
      var cache = {},
        isHtml5DateInput = false;
      var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
        datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
        ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];
      scope.watchData = {};
      this.init = function(_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;
        closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined(attrs.altInputFormats) ? scope.$parent.$eval(attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }
        if (isHtml5DateInput &amp;&amp; attrs.uibDatepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }
        popupEl = angular.element('&lt;div uib-datepicker-popup-wrap&gt;&lt;div uib-datepicker&gt;&lt;/div&gt;&lt;/div&gt;');
        scope.ngModelOptions = angular.copy(ngModelOptions);
        scope.ngModelOptions.timezone = null;
        popupEl.attr({
          'ng-model': 'date',
          'ng-model-options': 'ngModelOptions',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);
        if (isHtml5DateInput) {
          if (attrs.type === 'month') {
            datepickerEl.attr('datepicker-mode', '"month"');
            datepickerEl.attr('min-mode', 'month');
          }
        }
        if (scope.datepickerOptions) {
          angular.forEach(scope.datepickerOptions, function(value, option) {
            if (['minDate', 'maxDate', 'minMode', 'maxMode', 'initDate', 'datepickerMode'].indexOf(option) === -1) {
              datepickerEl.attr(cameltoDash(option), value);
            } else {
              datepickerEl.attr(cameltoDash(option), 'datepickerOptions.' + option);
            }
          });
        }
        angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {
          if (attrs[key]) {
            var getAttribute = $parse(attrs[key]);
            var propConfig = {
              get: function() {
                return getAttribute(scope.$parent);
              }
            };
            datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
            if (key === 'datepickerMode') {
              var setAttribute = getAttribute.assign;
              propConfig.set = function(v) {
                setAttribute(scope.$parent, v);
              };
            }
            Object.defineProperty(scope.watchData, key, propConfig);
          }
        });
        angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {
          if (attrs[key]) {
            var getAttribute = $parse(attrs[key]);
            watchListeners.push(scope.$parent.$watch(getAttribute, function(value) {
              if (key === 'minDate' || key === 'maxDate') {
                if (value === null) {
                  cache[key] = null;
                } else if (angular.isDate(value)) {
                  cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  cache[key] = new Date(dateFilter(value, 'medium'));
                }
                scope.watchData[key] = value === null ? null : cache[key];
              } else {
                scope.watchData[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
              }
            }));
            datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
          }
        });
        if (attrs.dateDisabled) {
          datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
        }
        angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {
          if (angular.isDefined(attrs[key])) {
            datepickerEl.attr(cameltoDash(key), attrs[key]);
          }
        });
        if (attrs.customClass) {
          datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
        }
        if (!isHtml5DateInput) {
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function(value) {
            if (ngModel.$isEmpty(value)) {
              scope.date = value;
              return value;
            }
            scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
            if (angular.isNumber(scope.date)) {
              scope.date = new Date(scope.date);
            }
            return dateParser.filter(scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function(value) {
            scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function() {
          scope.date = parseDateString(ngModel.$viewValue);
        });
        element.on('keydown', inputKeydownBind);
        $popup = $compile(popupEl)(scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          element.after($popup);
        }
        scope.$on('$destroy', function() {
          if (scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              scope.$apply(function() {
                scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          element.off('keydown', inputKeydownBind);
          $document.off('click', documentClickBind);
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };
      scope.getText = function(key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };
      scope.isDisabled = function(date) {
        if (date === 'today') {
          date = new Date();
        }
        return scope.watchData.minDate &amp;&amp; scope.compare(date, cache.minDate) &lt; 0 ||
          scope.watchData.maxDate &amp;&amp; scope.compare(date, cache.maxDate) &gt; 0;
      };
      scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateParser.filter(scope.date, dateFormat) : null;
        element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.select = function(date) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };
      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };
      scope.disabled = angular.isDefined(attrs.disabled) || false;
      if (attrs.ngDisabled) {
        watchListeners.push(scope.$parent.$watch($parse(attrs.ngDisabled), function(disabled) {
          scope.disabled = disabled;
        }));
      }
      scope.$watch('isOpen', function(value) {
        if (value) {
          if (!scope.disabled) {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top = scope.position.top + element.prop('offsetHeight');
            $timeout(function() {
              if (onOpenFocus) {
                scope.$broadcast('uib:datepicker.focus');
              }
              $document.on('click', documentClickBind);
            }, 0, false);
          } else {
            scope.isOpen = false;
          }
        } else {
          $document.off('click', documentClickBind);
        }
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
          return '-' + $1.toLowerCase();
        });
      }

      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, scope.date);
        if (isNaN(date)) {
          for (var i = 0; i &lt; altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        }
        if (angular.isDate(viewValue) &amp;&amp; !isNaN(viewValue)) {
          return viewValue;
        }
        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return dateParser.toTimezone(date, ngModelOptions.timezone);
          }
        }
        return ngModel.$options &amp;&amp; ngModel.$options.allowInvalid ? viewValue : undefined;
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!attrs.ngRequired &amp;&amp; !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        }
        if (angular.isDate(value) &amp;&amp; !isNaN(value)) {
          return true;
        }
        if (angular.isString(value)) {
          return !isNaN(parseDateString(viewValue));
        }
        return false;
      }

      function documentClickBind(event) {
        if (!scope.isOpen &amp;&amp; scope.disabled) {
          return;
        }
        var popup = $popup[0];
        var dpContainsTarget = element[0].contains(event.target);
        var popupContainsTarget = popup.contains !== undefined &amp;&amp; popup.contains(event.target);
        if (scope.isOpen &amp;&amp; !(dpContainsTarget || popupContainsTarget)) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      }

      function inputKeydownBind(evt) {
        if (evt.which === 27 &amp;&amp; scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = false;
          });
          element[0].focus();
        } else if (evt.which === 40 &amp;&amp; !scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = true;
          });
        }
      }
    }
  ])
  .directive('uibDatepickerPopup', function() {
    return {
      require: ['ngModel', 'uibDatepickerPopup'],
      controller: 'UibDatepickerPopupController',
      scope: {
        datepickerOptions: '=?',
        isOpen: '=?',
        currentText: '@',
        clearText: '@',
        closeText: '@',
        dateDisabled: '&amp;',
        customClass: '&amp;'
      },
      link: function(scope, element, attrs, ctrls) {
        var ngModel = ctrls[0],
          ctrl = ctrls[1];
        ctrl.init(ngModel);
      }
    };
  })
  .directive('uibDatepickerPopupWrap', function() {
    return {
      replace: true,
      transclude: true,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/datepicker/popup.html';
      }
    };
  });
angular.module('ui.bootstrap.debounce', [])
  .factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;
      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);
angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])
  .constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
  })
  .service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope) {
      if (!openScope) {
        $document.on('click', closeDropdown);
        $document.on('keydown', keybindFilter);
      }
      if (openScope &amp;&amp; openScope !== dropdownScope) {
        openScope.isOpen = false;
      }
      openScope = dropdownScope;
    };
    this.close = function(dropdownScope) {
      if (openScope === dropdownScope) {
        openScope = null;
        $document.off('click', closeDropdown);
        $document.off('keydown', keybindFilter);
      }
    };
    var closeDropdown = function(evt) {
      if (!openScope) {
        return;
      }
      if (evt &amp;&amp; openScope.getAutoClose() === 'disabled') {
        return;
      }
      if (evt &amp;&amp; evt.which === 3) {
        return;
      }
      var toggleElement = openScope.getToggleElement();
      if (evt &amp;&amp; toggleElement &amp;&amp; toggleElement[0].contains(evt.target)) {
        return;
      }
      var dropdownElement = openScope.getDropdownElement();
      if (evt &amp;&amp; openScope.getAutoClose() === 'outsideClick' &amp;&amp;
        dropdownElement &amp;&amp; dropdownElement[0].contains(evt.target)) {
        return;
      }
      openScope.isOpen = false;
      if (!$rootScope.$$phase) {
        openScope.$apply();
      }
    };
    var keybindFilter = function(evt) {
      if (evt.which === 27) {
        openScope.focusToggleElement();
        closeDropdown();
      } else if (openScope.isKeynavEnabled() &amp;&amp; [38, 40].indexOf(evt.which) !== -1 &amp;&amp; openScope.isOpen) {
        evt.preventDefault();
        evt.stopPropagation();
        openScope.focusDropdownEntry(evt.which);
      }
    };
  }])
  .controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var self = this,
      scope = $scope.$new(),
      templateScope,
      appendToOpenClass = dropdownConfig.appendToOpenClass,
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
      appendToBody = false,
      appendTo = null,
      keynavEnabled = false,
      selectedOption = null,
      body = $document.find('body');
    $element.addClass('dropdown');
    this.init = function() {
      if ($attrs.isOpen) {
        getIsOpen = $parse($attrs.isOpen);
        setIsOpen = getIsOpen.assign;
        $scope.$watch(getIsOpen, function(value) {
          scope.isOpen = !!value;
        });
      }
      if (angular.isDefined($attrs.dropdownAppendTo)) {
        var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
        if (appendToEl) {
          appendTo = angular.element(appendToEl);
        }
      }
      appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
      keynavEnabled = angular.isDefined($attrs.keyboardNav);
      if (appendToBody &amp;&amp; !appendTo) {
        appendTo = body;
      }
      if (appendTo &amp;&amp; self.dropdownMenu) {
        appendTo.append(self.dropdownMenu);
        $element.on('$destroy', function handleDestroyEvent() {
          self.dropdownMenu.remove();
        });
      }
    };
    this.toggle = function(open) {
      return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    };
    this.isOpen = function() {
      return scope.isOpen;
    };
    scope.getToggleElement = function() {
      return self.toggleElement;
    };
    scope.getAutoClose = function() {
      return $attrs.autoClose || 'always';
    };
    scope.getElement = function() {
      return $element;
    };
    scope.isKeynavEnabled = function() {
      return keynavEnabled;
    };
    scope.focusDropdownEntry = function(keyCode) {
      var elems = self.dropdownMenu ?
        angular.element(self.dropdownMenu).find('a') :
        $element.find('ul').eq(0).find('a');
      switch (keyCode) {
        case 40:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = 0;
            } else {
              self.selectedOption = self.selectedOption === elems.length - 1 ?
                self.selectedOption :
                self.selectedOption + 1;
            }
            break;
          }
        case 38:
          {
            if (!angular.isNumber(self.selectedOption)) {
              self.selectedOption = elems.length - 1;
            } else {
              self.selectedOption = self.selectedOption === 0 ?
                0 : self.selectedOption - 1;
            }
            break;
          }
      }
      elems[self.selectedOption].focus();
    };
    scope.getDropdownElement = function() {
      return self.dropdownMenu;
    };
    scope.focusToggleElement = function() {
      if (self.toggleElement) {
        self.toggleElement[0].focus();
      }
    };
    scope.$watch('isOpen', function(isOpen, wasOpen) {
      if (appendTo &amp;&amp; self.dropdownMenu) {
        var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
          css,
          rightalign;
        css = {
          top: pos.top + 'px',
          display: isOpen ? 'block' : 'none'
        };
        rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
        if (!rightalign) {
          css.left = pos.left + 'px';
          css.right = 'auto';
        } else {
          css.left = 'auto';
          css.right = window.innerWidth -
            (pos.left + $element.prop('offsetWidth')) + 'px';
        }
        if (!appendToBody) {
          var appendOffset = $position.offset(appendTo);
          css.top = pos.top - appendOffset.top + 'px';
          if (!rightalign) {
            css.left = pos.left - appendOffset.left + 'px';
          } else {
            css.right = window.innerWidth -
              (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
          }
        }
        self.dropdownMenu.css(css);
      }
      var openContainer = appendTo ? appendTo : $element;
      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
        if (angular.isDefined(isOpen) &amp;&amp; isOpen !== wasOpen) {
          toggleInvoker($scope, {
            open: !!isOpen
          });
        }
      });
      if (isOpen) {
        if (self.dropdownMenuTemplateUrl) {
          $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new();
            $compile(tplContent.trim())(templateScope, function(dropdownElement) {
              var newEl = dropdownElement;
              self.dropdownMenu.replaceWith(newEl);
              self.dropdownMenu = newEl;
            });
          });
        }
        scope.focusToggleElement();
        uibDropdownService.open(scope);
      } else {
        if (self.dropdownMenuTemplateUrl) {
          if (templateScope) {
            templateScope.$destroy();
          }
          var newEl = angular.element('&lt;ul class="dropdown-menu"&gt;&lt;/ul&gt;');
          self.dropdownMenu.replaceWith(newEl);
          self.dropdownMenu = newEl;
        }
        uibDropdownService.close(scope);
        self.selectedOption = null;
      }
      if (angular.isFunction(setIsOpen)) {
        setIsOpen($scope, isOpen);
      }
    });
    $scope.$on('$locationChangeSuccess', function() {
      if (scope.getAutoClose() !== 'disabled') {
        scope.isOpen = false;
      }
    });
  }])
  .directive('uibDropdown', function() {
    return {
      controller: 'UibDropdownController',
      link: function(scope, element, attrs, dropdownCtrl) {
        dropdownCtrl.init();
      }
    };
  })
  .directive('uibDropdownMenu', function() {
    return {
      restrict: 'A',
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
          return;
        }
        element.addClass('dropdown-menu');
        var tplUrl = attrs.templateUrl;
        if (tplUrl) {
          dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
        }
        if (!dropdownCtrl.dropdownMenu) {
          dropdownCtrl.dropdownMenu = element;
        }
      }
    };
  })
  .directive('uibDropdownToggle', function() {
    return {
      require: '?^uibDropdown',
      link: function(scope, element, attrs, dropdownCtrl) {
        if (!dropdownCtrl) {
          return;
        }
        element.addClass('dropdown-toggle');
        dropdownCtrl.toggleElement = element;
        var toggleDropdown = function(event) {
          event.preventDefault();
          if (!element.hasClass('disabled') &amp;&amp; !attrs.disabled) {
            scope.$apply(function() {
              dropdownCtrl.toggle();
            });
          }
        };
        element.bind('click', toggleDropdown);
        element.attr({
          'aria-haspopup': true,
          'aria-expanded': false
        });
        scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
          element.attr('aria-expanded', !!isOpen);
        });
        scope.$on('$destroy', function() {
          element.unbind('click', toggleDropdown);
        });
      }
    };
  });
angular.module('ui.bootstrap.stackedMap', [])
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];
        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i &lt; stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i &lt; stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i &lt; stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};
        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }
            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];
            if (!values) {
              return;
            }
            var idx = values.indexOf(value);
            if (idx !== -1) {
              values.splice(idx, 1);
            }
            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })
  .provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;
    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };
    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {
        resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }
          var promises = [];
          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });
          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });
            return resolveObj;
          });
        }
      };
    }];
  })
  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',
    function($animateCss, $injector, $modalStack) {
      return {
        replace: true,
        templateUrl: 'uib/template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };

      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            } else {
              done();
            }
          });
        }
      }
    }
  ])
  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',
    function($modalStack, $q, $animate, $animateCss, $document) {
      return {
        scope: {
          index: '@'
        },
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'uib/template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal &amp;&amp; modal.value.backdrop &amp;&amp;
              modal.value.backdrop !== 'static' &amp;&amp;
              evt.target === evt.currentTarget) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value === 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {
                    removeClass: attrs.modalInClass
                  }).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }
            $q.when(animationPromise).then(function() {
              if (!($document[0].activeElement &amp;&amp; element[0].contains($document[0].activeElement))) {
                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }
  ])
  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })
  .directive('uibModalTransclude', function() {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          element.append(clone);
        });
      }
    };
  })
  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
        'iframe, object, embed, *[tabindex], *[contenteditable=true]';

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i &lt; opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();
        if (elementToReceiveFocus &amp;&amp; elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() &gt; 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        if (backdropDomEl &amp;&amp; backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          $animateCss(domEl, {
            event: 'leave'
          }).start().then(function() {
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }
      $document.on('keydown', keydownListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27:
              {
                if (modal.value.keyboard) {
                  evt.preventDefault();
                  $rootScope.$apply(function() {
                    $modalStack.dismiss(modal.key, 'escape key press');
                  });
                }
                break;
              }
            case 9:
              {
                $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {
                    focusChanged = $modalStack.focusLastFocusableElement();
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt)) {
                    focusChanged = $modalStack.focusFirstFocusableElement();
                  }
                }
                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }
                break;
              }
          }
        }
      }
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo,
          currBackdropIndex = backdropIndex();
        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }
        if (currBackdropIndex &gt;= 0 &amp;&amp; !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('&lt;div uib-modal-backdrop="modal-backdrop"&gt;&lt;/div&gt;');
          backdropDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
        }
        var angularDomEl = angular.element('&lt;div uib-modal-window="modal-window"&gt;&lt;/div&gt;');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)
          .then(function() {
            $animate.addClass(appendToElement, modalBodyClass);
          });
        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        $modalStack.clearFocusListCache();
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal &amp;&amp; this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length &gt; 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length &gt; 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt &amp;&amp; modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl &amp;&amp; modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length &gt; 0) {
          return (evt.target || evt.srcElement) === focusableElementList[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length &gt; 0) {
          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };
      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };
      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 &amp;&amp; modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };
      return $modalStack;
    }
  ])
  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true,
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ?
                options.templateUrl() : options.templateUrl);
          }
          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
            if (!modalOptions.template &amp;&amp; !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {
                var providedScope = modalOptions.scope || $rootScope;
                var modalScope = providedScope.$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;
                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });
                var ctrlInstance, ctrlLocals = {};
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$uibModalInstance = modalInstance;
                  angular.forEach(tplAndVars[1], function(value, key) {
                    ctrlLocals[key] = value;
                  });
                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                  if (modalOptions.controllerAs) {
                    if (modalOptions.bindToController) {
                      ctrlInstance.$close = modalScope.$close;
                      ctrlInstance.$dismiss = modalScope.$dismiss;
                      angular.extend(ctrlInstance, providedScope);
                    }
                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }
                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  closedDeferred: modalClosedDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass,
                  appendTo: modalOptions.appendTo
                });
                modalOpenedDeferred.resolve(true);
              }, function resolveError(reason) {
                modalOpenedDeferred.reject(reason);
                modalResultDeferred.reject(reason);
              })['finally'](function() {
                if (promiseChain === samePromise) {
                  promiseChain = null;
                }
              });
            return modalInstance;
          };
          return $modal;
        }
      ]
    };
    return $modalProvider;
  });
angular.module('ui.bootstrap.paging', [])
  .factory('uibPaging', ['$parse', function($parse) {
    return {
      create: function(ctrl, $scope, $attrs) {
        ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
        ctrl.ngModelCtrl = {
          $setViewValue: angular.noop
        };
        ctrl._watchers = [];
        ctrl.init = function(ngModelCtrl, config) {
          ctrl.ngModelCtrl = ngModelCtrl;
          ctrl.config = config;
          ngModelCtrl.$render = function() {
            ctrl.render();
          };
          if ($attrs.itemsPerPage) {
            ctrl._watchers.push($scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
              ctrl.itemsPerPage = parseInt(value, 10);
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }));
          } else {
            ctrl.itemsPerPage = config.itemsPerPage;
          }
          $scope.$watch('totalItems', function(newTotal, oldTotal) {
            if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
              $scope.totalPages = ctrl.calculateTotalPages();
              ctrl.updatePage();
            }
          });
        };
        ctrl.calculateTotalPages = function() {
          var totalPages = ctrl.itemsPerPage &lt; 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
          return Math.max(totalPages || 0, 1);
        };
        ctrl.render = function() {
          $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
        };
        $scope.selectPage = function(page, evt) {
          if (evt) {
            evt.preventDefault();
          }
          var clickAllowed = !$scope.ngDisabled || !evt;
          if (clickAllowed &amp;&amp; $scope.page !== page &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= $scope.totalPages) {
            if (evt &amp;&amp; evt.target) {
              evt.target.blur();
            }
            ctrl.ngModelCtrl.$setViewValue(page);
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.getText = function(key) {
          return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
        };
        $scope.noPrevious = function() {
          return $scope.page === 1;
        };
        $scope.noNext = function() {
          return $scope.page === $scope.totalPages;
        };
        ctrl.updatePage = function() {
          ctrl.setNumPages($scope.$parent, $scope.totalPages);
          if ($scope.page &gt; $scope.totalPages) {
            $scope.selectPage($scope.totalPages);
          } else {
            ctrl.ngModelCtrl.$render();
          }
        };
        $scope.$on('$destroy', function() {
          while (ctrl._watchers.length) {
            ctrl._watchers.shift()();
          }
        });
      }
    };
  }]);
angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])
  .controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
    uibPaging.create(this, $scope, $attrs);
  }])
  .constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: ' Previous',
    nextText: 'Next ',
    align: true
  })
  .directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
    return {
      scope: {
        totalItems: '=',
        previousText: '@',
        nextText: '@',
        ngDisabled: '='
      },
      require: ['uibPager', '?ngModel'],
      controller: 'UibPagerController',
      controllerAs: 'pager',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pager/pager.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPagerConfig);
      }
    };
  }]);
angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])
  .controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    var ctrl = this;
    var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
      rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
      forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
      boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
    uibPaging.create(this, $scope, $attrs);
    if ($attrs.maxSize) {
      ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10);
        ctrl.render();
      }));
    }

    function makePage(number, text, isActive) {
      return {
        number: number,
        text: text,
        active: isActive
      };
    }

    function getPages(currentPage, totalPages) {
      var pages = [];
      var startPage = 1,
        endPage = totalPages;
      var isMaxSized = angular.isDefined(maxSize) &amp;&amp; maxSize &lt; totalPages;
      if (isMaxSized) {
        if (rotate) {
          startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
          endPage = startPage + maxSize - 1;
          if (endPage &gt; totalPages) {
            endPage = totalPages;
            startPage = endPage - maxSize + 1;
          }
        } else {
          startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
          endPage = Math.min(startPage + maxSize - 1, totalPages);
        }
      }
      for (var number = startPage; number &lt;= endPage; number++) {
        var page = makePage(number, number, number === currentPage);
        pages.push(page);
      }
      if (isMaxSized &amp;&amp; maxSize &gt; 0 &amp;&amp; (!rotate || forceEllipses || boundaryLinkNumbers)) {
        if (startPage &gt; 1) {
          if (!boundaryLinkNumbers || startPage &gt; 3) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }
          if (boundaryLinkNumbers) {
            if (startPage === 3) {
              var secondPageLink = makePage(2, '2', false);
              pages.unshift(secondPageLink);
            }
            var firstPageLink = makePage(1, '1', false);
            pages.unshift(firstPageLink);
          }
        }
        if (endPage &lt; totalPages) {
          if (!boundaryLinkNumbers || endPage &lt; totalPages - 2) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
          if (boundaryLinkNumbers) {
            if (endPage === totalPages - 2) {
              var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
              pages.push(secondToLastPageLink);
            }
            var lastPageLink = makePage(totalPages, totalPages, false);
            pages.push(lastPageLink);
          }
        }
      }
      return pages;
    }
    var originalRender = this.render;
    this.render = function() {
      originalRender();
      if ($scope.page &gt; 0 &amp;&amp; $scope.page &lt;= $scope.totalPages) {
        $scope.pages = getPages($scope.page, $scope.totalPages);
      }
    };
  }])
  .constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
  })
  .directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
    return {
      scope: {
        totalItems: '=',
        firstText: '@',
        previousText: '@',
        nextText: '@',
        lastText: '@',
        ngDisabled: '='
      },
      require: ['uibPagination', '?ngModel'],
      controller: 'UibPaginationController',
      controllerAs: 'pagination',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'uib/template/pagination/pagination.html';
      },
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var paginationCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
          return;
        }
        paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
      }
    };
  }]);
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])
  .provider('$uibTooltip', function() {
    var defaultOptions = {
      placement: 'top',
      placementClassPrefix: '',
      animation: true,
      popupDelay: 0,
      popupCloseDelay: 0,
      useContentExp: false
    };
    var triggerMap = {
      'mouseenter': 'mouseleave',
      'click': 'click',
      'outsideClick': 'outsideClick',
      'focus': 'blur',
      'none': ''
    };
    var globalOptions = {};
    this.options = function(value) {
      angular.extend(globalOptions, value);
    };
    this.setTriggers = function setTriggers(triggers) {
      angular.extend(triggerMap, triggers);
    };

    function snake_case(name) {
      var regexp = /[A-Z]/g;
      var separator = '-';
      return name.replace(regexp, function(letter, pos) {
        return (pos ? separator : '') + letter.toLowerCase();
      });
    }
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
      var openedTooltips = $$stackedMap.createNew();
      $document.on('keypress', keypressListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keypress', keypressListener);
      });

      function keypressListener(e) {
        if (e.which === 27) {
          var last = openedTooltips.top();
          if (last) {
            last.value.close();
            openedTooltips.removeTop();
            last = null;
          }
        }
      }
      return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
        options = angular.extend({}, defaultOptions, globalOptions, options);

        function getTriggers(trigger) {
          var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
          var hide = show.map(function(trigger) {
            return triggerMap[trigger] || trigger;
          });
          return {
            show: show,
            hide: hide
          };
        }
        var directiveName = snake_case(ttType);
        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();
        var template =
          '&lt;div ' + directiveName + '-popup ' +
          'title="' + startSym + 'title' + endSym + '" ' +
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'placement="' + startSym + 'placement' + endSym + '" ' +
          'popup-class="' + startSym + 'popupClass' + endSym + '" ' +
          'animation="animation" ' +
          'is-open="isOpen"' +
          'origin-scope="origScope" ' +
          'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
          '&gt;' +
          '&lt;/div&gt;';
        return {
          compile: function(tElem, tAttrs) {
            var tooltipLinker = $compile(template);
            return function link(scope, element, attrs, tooltipCtrl) {
              var tooltip;
              var tooltipLinkedScope;
              var transitionTimeout;
              var showTimeout;
              var hideTimeout;
              var positionTimeout;
              var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
              var triggers = getTriggers(undefined);
              var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
              var ttScope = scope.$new(true);
              var repositionScheduled = false;
              var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
              var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
              var observers = [];
              var positionTooltip = function() {
                if (!tooltip || !tooltip.html()) {
                  return;
                }
                if (!positionTimeout) {
                  positionTimeout = $timeout(function() {
                    tooltip.css({
                      top: 0,
                      left: 0
                    });
                    var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                    tooltip.css({
                      top: ttPosition.top + 'px',
                      left: ttPosition.left + 'px',
                      visibility: 'visible'
                    });
                    if (options.placementClassPrefix) {
                      tooltip.removeClass('top bottom left right');
                    }
                    tooltip.removeClass(
                      options.placementClassPrefix + 'top ' +
                      options.placementClassPrefix + 'top-left ' +
                      options.placementClassPrefix + 'top-right ' +
                      options.placementClassPrefix + 'bottom ' +
                      options.placementClassPrefix + 'bottom-left ' +
                      options.placementClassPrefix + 'bottom-right ' +
                      options.placementClassPrefix + 'left ' +
                      options.placementClassPrefix + 'left-top ' +
                      options.placementClassPrefix + 'left-bottom ' +
                      options.placementClassPrefix + 'right ' +
                      options.placementClassPrefix + 'right-top ' +
                      options.placementClassPrefix + 'right-bottom');
                    var placement = ttPosition.placement.split('-');
                    tooltip.addClass(placement[0] + ' ' + options.placementClassPrefix + ttPosition.placement);
                    $position.positionArrow(tooltip, ttPosition.placement);
                    positionTimeout = null;
                  }, 0, false);
                }
              };
              ttScope.origScope = scope;
              ttScope.isOpen = false;
              openedTooltips.add(ttScope, {
                close: hide
              });

              function toggleTooltipBind() {
                if (!ttScope.isOpen) {
                  showTooltipBind();
                } else {
                  hideTooltipBind();
                }
              }

              function showTooltipBind() {
                if (hasEnableExp &amp;&amp; !scope.$eval(attrs[prefix + 'Enable'])) {
                  return;
                }
                cancelHide();
                prepareTooltip();
                if (ttScope.popupDelay) {
                  if (!showTimeout) {
                    showTimeout = $timeout(show, ttScope.popupDelay, false);
                  }
                } else {
                  show();
                }
              }

              function hideTooltipBind() {
                cancelShow();
                if (ttScope.popupCloseDelay) {
                  if (!hideTimeout) {
                    hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                  }
                } else {
                  hide();
                }
              }

              function show() {
                cancelShow();
                cancelHide();
                if (!ttScope.content) {
                  return angular.noop;
                }
                createTooltip();
                ttScope.$evalAsync(function() {
                  ttScope.isOpen = true;
                  assignIsOpen(true);
                  positionTooltip();
                });
              }

              function cancelShow() {
                if (showTimeout) {
                  $timeout.cancel(showTimeout);
                  showTimeout = null;
                }
                if (positionTimeout) {
                  $timeout.cancel(positionTimeout);
                  positionTimeout = null;
                }
              }

              function hide() {
                if (!ttScope) {
                  return;
                }
                ttScope.$evalAsync(function() {
                  if (ttScope) {
                    ttScope.isOpen = false;
                    assignIsOpen(false);
                    if (ttScope.animation) {
                      if (!transitionTimeout) {
                        transitionTimeout = $timeout(removeTooltip, 150, false);
                      }
                    } else {
                      removeTooltip();
                    }
                  }
                });
              }

              function cancelHide() {
                if (hideTimeout) {
                  $timeout.cancel(hideTimeout);
                  hideTimeout = null;
                }
                if (transitionTimeout) {
                  $timeout.cancel(transitionTimeout);
                  transitionTimeout = null;
                }
              }

              function createTooltip() {
                if (tooltip) {
                  return;
                }
                tooltipLinkedScope = ttScope.$new();
                tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                  if (appendToBody) {
                    $document.find('body').append(tooltip);
                  } else {
                    element.after(tooltip);
                  }
                });
                prepObservers();
              }

              function removeTooltip() {
                cancelShow();
                cancelHide();
                unregisterObservers();
                if (tooltip) {
                  tooltip.remove();
                  tooltip = null;
                }
                if (tooltipLinkedScope) {
                  tooltipLinkedScope.$destroy();
                  tooltipLinkedScope = null;
                }
              }

              function prepareTooltip() {
                ttScope.title = attrs[prefix + 'Title'];
                if (contentParse) {
                  ttScope.content = contentParse(scope);
                } else {
                  ttScope.content = attrs[ttType];
                }
                ttScope.popupClass = attrs[prefix + 'Class'];
                ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
              }

              function assignIsOpen(isOpen) {
                if (isOpenParse &amp;&amp; angular.isFunction(isOpenParse.assign)) {
                  isOpenParse.assign(scope, isOpen);
                }
              }
              ttScope.contentExp = function() {
                return ttScope.content;
              };
              attrs.$observe('disabled', function(val) {
                if (val) {
                  cancelShow();
                }
                if (val &amp;&amp; ttScope.isOpen) {
                  hide();
                }
              });
              if (isOpenParse) {
                scope.$watch(isOpenParse, function(val) {
                  if (ttScope &amp;&amp; !val === ttScope.isOpen) {
                    toggleTooltipBind();
                  }
                });
              }

              function prepObservers() {
                observers.length = 0;
                if (contentParse) {
                  observers.push(
                    scope.$watch(contentParse, function(val) {
                      ttScope.content = val;
                      if (!val &amp;&amp; ttScope.isOpen) {
                        hide();
                      }
                    })
                  );
                  observers.push(
                    tooltipLinkedScope.$watch(function() {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function() {
                          repositionScheduled = false;
                          if (ttScope &amp;&amp; ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    })
                  );
                } else {
                  observers.push(
                    attrs.$observe(ttType, function(val) {
                      ttScope.content = val;
                      if (!val &amp;&amp; ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    })
                  );
                }
                observers.push(
                  attrs.$observe(prefix + 'Title', function(val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  })
                );
                observers.push(
                  attrs.$observe(prefix + 'Placement', function(val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  })
                );
              }

              function unregisterObservers() {
                if (observers.length) {
                  angular.forEach(observers, function(observer) {
                    observer();
                  });
                  observers.length = 0;
                }
              }

              function bodyHideTooltipBind(e) {
                if (!ttScope || !ttScope.isOpen || !tooltip) {
                  return;
                }
                if (!element[0].contains(e.target) &amp;&amp; !tooltip[0].contains(e.target)) {
                  hideTooltipBind();
                }
              }
              var unregisterTriggers = function() {
                triggers.show.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    element.off('click', toggleTooltipBind);
                  } else {
                    element.off(trigger, showTooltipBind);
                    element.off(trigger, toggleTooltipBind);
                  }
                });
                triggers.hide.forEach(function(trigger) {
                  if (trigger === 'outsideClick') {
                    $document.off('click', bodyHideTooltipBind);
                  } else {
                    element.off(trigger, hideTooltipBind);
                  }
                });
              };

              function prepTriggers() {
                var val = attrs[prefix + 'Trigger'];
                unregisterTriggers();
                triggers = getTriggers(val);
                if (triggers.show !== 'none') {
                  triggers.show.forEach(function(trigger, idx) {
                    if (trigger === 'outsideClick') {
                      element.on('click', toggleTooltipBind);
                      $document.on('click', bodyHideTooltipBind);
                    } else if (trigger === triggers.hide[idx]) {
                      element.on(trigger, toggleTooltipBind);
                    } else if (trigger) {
                      element.on(trigger, showTooltipBind);
                      element.on(triggers.hide[idx], hideTooltipBind);
                    }
                    element.on('keypress', function(e) {
                      if (e.which === 27) {
                        hideTooltipBind();
                      }
                    });
                  });
                }
              }
              prepTriggers();
              var animation = scope.$eval(attrs[prefix + 'Animation']);
              ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
              var appendToBodyVal;
              var appendKey = prefix + 'AppendToBody';
              if (appendKey in attrs &amp;&amp; attrs[appendKey] === undefined) {
                appendToBodyVal = true;
              } else {
                appendToBodyVal = scope.$eval(attrs[appendKey]);
              }
              appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
              scope.$on('$destroy', function onDestroyTooltip() {
                unregisterTriggers();
                removeTooltip();
                openedTooltips.remove(ttScope);
                ttScope = null;
              });
            };
          }
        };
      };
    }];
  })
  .directive('uibTooltipTemplateTransclude', [
    '$animate', '$sce', '$compile', '$templateRequest',
    function($animate, $sce, $compile, $templateRequest) {
      return {
        link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
            currentScope,
            previousElement,
            currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }
      };
    }
  ])
  .directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        if (scope.placement) {
          var position = $uibPosition.parsePlacement(scope.placement);
          element.addClass(position[0]);
        } else {
          element.addClass('top');
        }
        if (scope.popupClass) {
          element.addClass(scope.popupClass);
        }
        if (scope.animation()) {
          element.addClass(attrs.tooltipAnimationClass);
        }
      }
    };
  }])
  .directive('uibTooltipPopup', function() {
    return {
      replace: true,
      scope: {
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;'
      },
      templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
  })
  .directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
  }])
  .directive('uibTooltipTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&amp;',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;',
        originScope: '&amp;'
      },
      templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
  })
  .directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
      useContentExp: true
    });
  }])
  .directive('uibTooltipHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&amp;',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;'
      },
      templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
  })
  .directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
      useContentExp: true
    });
  }]);
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
  .directive('uibPopoverTemplatePopup', function() {
    return {
      replace: true,
      scope: {
        title: '@',
        contentExp: '&amp;',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;',
        originScope: '&amp;'
      },
      templateUrl: 'uib/template/popover/popover-template.html'
    };
  })
  .directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
      useContentExp: true
    });
  }])
  .directive('uibPopoverHtmlPopup', function() {
    return {
      replace: true,
      scope: {
        contentExp: '&amp;',
        title: '@',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;'
      },
      templateUrl: 'uib/template/popover/popover-html.html'
    };
  })
  .directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
      useContentExp: true
    });
  }])
  .directive('uibPopoverPopup', function() {
    return {
      replace: true,
      scope: {
        title: '@',
        content: '@',
        placement: '@',
        popupClass: '@',
        animation: '&amp;',
        isOpen: '&amp;'
      },
      templateUrl: 'uib/template/popover/popover.html'
    };
  })
  .directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
    return $uibTooltip('uibPopover', 'popover', 'click');
  }]);
angular.module('ui.bootstrap.progressbar', [])
  .constant('uibProgressConfig', {
    animate: true,
    max: 100
  })
  .controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
    var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
    this.addBar = function(bar, element, attrs) {
      if (!animate) {
        element.css({
          'transition': 'none'
        });
      }
      this.bars.push(bar);
      bar.max = $scope.max;
      bar.title = attrs &amp;&amp; angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
      bar.$watch('value', function(value) {
        bar.recalculatePercentage();
      });
      bar.recalculatePercentage = function() {
        var totalPercentage = self.bars.reduce(function(total, bar) {
          bar.percent = +(100 * bar.value / bar.max).toFixed(2);
          return total + bar.percent;
        }, 0);
        if (totalPercentage &gt; 100) {
          bar.percent -= totalPercentage - 100;
        }
      };
      bar.$on('$destroy', function() {
        element = null;
        self.removeBar(bar);
      });
    };
    this.removeBar = function(bar) {
      this.bars.splice(this.bars.indexOf(bar), 1);
      this.bars.forEach(function(bar) {
        bar.recalculatePercentage();
      });
    };
    $scope.$watch('max', function(max) {
      self.bars.forEach(function(bar) {
        bar.max = $scope.max;
        bar.recalculatePercentage();
      });
    });
  }])
  .directive('uibProgress', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      require: 'uibProgress',
      scope: {
        max: '=?'
      },
      templateUrl: 'uib/template/progressbar/progress.html'
    };
  })
  .directive('uibBar', function() {
    return {
      replace: true,
      transclude: true,
      require: '^uibProgress',
      scope: {
        value: '=',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/bar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, element, attrs);
      }
    };
  })
  .directive('uibProgressbar', function() {
    return {
      replace: true,
      transclude: true,
      controller: 'UibProgressController',
      scope: {
        value: '=',
        max: '=?',
        type: '@'
      },
      templateUrl: 'uib/template/progressbar/progressbar.html',
      link: function(scope, element, attrs, progressCtrl) {
        progressCtrl.addBar(scope, angular.element(element.children()[0]), {
          title: attrs.title
        });
      }
    };
  });
angular.module('ui.bootstrap.rating', [])
  .constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    titles: ['one', 'two', 'three', 'four', 'five']
  })
  .controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
      $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.push(function(value) {
        if (angular.isNumber(value) &amp;&amp; value &lt;&lt; 0 !== value) {
          value = Math.round(value);
        }
        return value;
      });
      this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
      this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
      var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
      this.titles = angular.isArray(tmpTitles) &amp;&amp; tmpTitles.length &gt; 0 ?
        tmpTitles : ratingConfig.titles;
      var ratingStates = angular.isDefined($attrs.ratingStates) ?
        $scope.$parent.$eval($attrs.ratingStates) :
        new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
      $scope.range = this.buildTemplateObjects(ratingStates);
    };
    this.buildTemplateObjects = function(states) {
      for (var i = 0, n = states.length; i &lt; n; i++) {
        states[i] = angular.extend({
          index: i
        }, {
          stateOn: this.stateOn,
          stateOff: this.stateOff,
          title: this.getTitle(i)
        }, states[i]);
      }
      return states;
    };
    this.getTitle = function(index) {
      if (index &gt;= this.titles.length) {
        return index + 1;
      }
      return this.titles[index];
    };
    $scope.rate = function(value) {
      if (!$scope.readonly &amp;&amp; value &gt;= 0 &amp;&amp; value &lt;= $scope.range.length) {
        ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
        ngModelCtrl.$render();
      }
    };
    $scope.enter = function(value) {
      if (!$scope.readonly) {
        $scope.value = value;
      }
      $scope.onHover({
        value: value
      });
    };
    $scope.reset = function() {
      $scope.value = ngModelCtrl.$viewValue;
      $scope.onLeave();
    };
    $scope.onKeydown = function(evt) {
      if (/(37|38|39|40)/.test(evt.which)) {
        evt.preventDefault();
        evt.stopPropagation();
        $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
      }
    };
    this.render = function() {
      $scope.value = ngModelCtrl.$viewValue;
    };
  }])
  .directive('uibRating', function() {
    return {
      require: ['uibRating', 'ngModel'],
      scope: {
        readonly: '=?',
        onHover: '&amp;',
        onLeave: '&amp;'
      },
      controller: 'UibRatingController',
      templateUrl: 'uib/template/rating/rating.html',
      replace: true,
      link: function(scope, element, attrs, ctrls) {
        var ratingCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        ratingCtrl.init(ngModelCtrl);
      }
    };
  });
angular.module('ui.bootstrap.tabs', [])
  .controller('UibTabsetController', ['$scope', function($scope) {
    var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
      angular.forEach(tabs, function(tab) {
        if (tab.active &amp;&amp; tab !== selectedTab) {
          tab.active = false;
          tab.onDeselect();
          selectedTab.selectCalled = false;
        }
      });
      selectedTab.active = true;
      if (!selectedTab.selectCalled) {
        selectedTab.onSelect();
        selectedTab.selectCalled = true;
      }
    };
    ctrl.addTab = function addTab(tab) {
      tabs.push(tab);
      if (tabs.length === 1 &amp;&amp; tab.active !== false) {
        tab.active = true;
      } else if (tab.active) {
        ctrl.select(tab);
      } else {
        tab.active = false;
      }
    };
    ctrl.removeTab = function removeTab(tab) {
      var index = tabs.indexOf(tab);
      if (tab.active &amp;&amp; tabs.length &gt; 1 &amp;&amp; !destroyed) {
        var newActiveIndex = index === tabs.length - 1 ? index - 1 : index + 1;
        ctrl.select(tabs[newActiveIndex]);
      }
      tabs.splice(index, 1);
    };
    var destroyed;
    $scope.$on('$destroy', function() {
      destroyed = true;
    });
  }])
  .directive('uibTabset', function() {
    return {
      transclude: true,
      replace: true,
      scope: {
        type: '@'
      },
      controller: 'UibTabsetController',
      templateUrl: 'uib/template/tabs/tabset.html',
      link: function(scope, element, attrs) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
      }
    };
  })
  .directive('uibTab', ['$parse', function($parse) {
    return {
      require: '^uibTabset',
      replace: true,
      templateUrl: 'uib/template/tabs/tab.html',
      transclude: true,
      scope: {
        active: '=?',
        heading: '@',
        onSelect: '&amp;select',
        onDeselect: '&amp;deselect'
      },
      controller: function() {},
      controllerAs: 'tab',
      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });
        scope.disabled = false;
        if (attrs.disable) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !!value;
          });
        }
        scope.select = function() {
          if (!scope.disabled) {
            scope.active = true;
          }
        };
        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });
        scope.$transcludeFn = transclude;
      }
    };
  }])
  .directive('uibTabHeadingTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTab',
      link: function(scope, elm) {
        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  })
  .directive('uibTabContentTransclude', function() {
    return {
      restrict: 'A',
      require: '^uibTabset',
      link: function(scope, elm, attrs) {
        var tab = scope.$eval(attrs.uibTabContentTransclude);
        tab.$transcludeFn(tab.$parent, function(contents) {
          angular.forEach(contents, function(node) {
            if (isTabHeading(node)) {
              tab.headingElement = node;
            } else {
              elm.append(node);
            }
          });
        });
      }
    };

    function isTabHeading(node) {
      return node.tagName &amp;&amp; (
        node.hasAttribute('uib-tab-heading') ||
        node.hasAttribute('data-uib-tab-heading') ||
        node.hasAttribute('x-uib-tab-heading') ||
        node.tagName.toLowerCase() === 'uib-tab-heading' ||
        node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
        node.tagName.toLowerCase() === 'x-uib-tab-heading'
      );
    }
  });
angular.module('ui.bootstrap.timepicker', [])
  .constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true,
    templateUrl: 'uib/template/timepicker/timepicker.html'
  })
  .controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date(),
      watchers = [],
      ngModelCtrl = {
        $setViewValue: angular.noop
      },
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
    $element.removeAttr('tabindex');
    this.init = function(ngModelCtrl_, inputs) {
      ngModelCtrl = ngModelCtrl_;
      ngModelCtrl.$render = this.render;
      ngModelCtrl.$formatters.unshift(function(modelValue) {
        return modelValue ? new Date(modelValue) : null;
      });
      var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);
      var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
      if (mousewheel) {
        this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
      if (arrowkeys) {
        this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      }
      $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
      this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    if ($attrs.hourStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
      }));
    }
    var minuteStep = timepickerConfig.minuteStep;
    if ($attrs.minuteStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
      }));
    }
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
      var dt = new Date(value);
      min = isNaN(dt) ? undefined : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
      var dt = new Date(value);
      max = isNaN(dt) ? undefined : dt;
    }));
    var disabled = false;
    if ($attrs.ngDisabled) {
      watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
      }));
    }
    $scope.noIncrementHours = function() {
      var incrementedSelected = addMinutes(selected, hourStep * 60);
      return disabled || incrementedSelected &gt; max ||
        incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
    };
    $scope.noDecrementHours = function() {
      var decrementedSelected = addMinutes(selected, -hourStep * 60);
      return disabled || decrementedSelected &lt; min ||
        decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
    };
    $scope.noIncrementMinutes = function() {
      var incrementedSelected = addMinutes(selected, minuteStep);
      return disabled || incrementedSelected &gt; max ||
        incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
    };
    $scope.noDecrementMinutes = function() {
      var decrementedSelected = addMinutes(selected, -minuteStep);
      return disabled || decrementedSelected &lt; min ||
        decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
    };
    $scope.noIncrementSeconds = function() {
      var incrementedSelected = addSeconds(selected, secondStep);
      return disabled || incrementedSelected &gt; max ||
        incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min;
    };
    $scope.noDecrementSeconds = function() {
      var decrementedSelected = addSeconds(selected, -secondStep);
      return disabled || decrementedSelected &lt; min ||
        decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max;
    };
    $scope.noToggleMeridian = function() {
      if (selected.getHours() &lt; 12) {
        return disabled || addMinutes(selected, 12 * 60) &gt; max;
      }
      return disabled || addMinutes(selected, -12 * 60) &lt; min;
    };
    var secondStep = timepickerConfig.secondStep;
    if ($attrs.secondStep) {
      watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
      }));
    }
    $scope.showSeconds = timepickerConfig.showSeconds;
    if ($attrs.showSeconds) {
      watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
      }));
    }
    $scope.showMeridian = timepickerConfig.showMeridian;
    if ($attrs.showMeridian) {
      watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        $scope.showMeridian = !!value;
        if (ngModelCtrl.$error.time) {
          var hours = getHoursFromTemplate(),
            minutes = getMinutesFromTemplate();
          if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
            selected.setHours(hours);
            refresh();
          }
        } else {
          updateTemplate();
        }
      }));
    }

    function getHoursFromTemplate() {
      var hours = +$scope.hours;
      var valid = $scope.showMeridian ? hours &gt; 0 &amp;&amp; hours &lt; 13 :
        hours &gt;= 0 &amp;&amp; hours &lt; 24;
      if (!valid) {
        return undefined;
      }
      if ($scope.showMeridian) {
        if (hours === 12) {
          hours = 0;
        }
        if ($scope.meridian === meridians[1]) {
          hours = hours + 12;
        }
      }
      return hours;
    }

    function getMinutesFromTemplate() {
      var minutes = +$scope.minutes;
      return minutes &gt;= 0 &amp;&amp; minutes &lt; 60 ? minutes : undefined;
    }

    function getSecondsFromTemplate() {
      var seconds = +$scope.seconds;
      return seconds &gt;= 0 &amp;&amp; seconds &lt; 60 ? seconds : undefined;
    }

    function pad(value) {
      if (value === null) {
        return '';
      }
      return angular.isDefined(value) &amp;&amp; value.toString().length &lt; 2 ?
        '0' + value : value.toString();
    }
    this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      var isScrollingUp = function(e) {
        if (e.originalEvent) {
          e = e.originalEvent;
        }
        var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
        return e.detail || delta &gt; 0;
      };
      hoursInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
        }
        e.preventDefault();
      });
      minutesInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
        }
        e.preventDefault();
      });
      secondsInputEl.bind('mousewheel wheel', function(e) {
        if (!disabled) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
        }
        e.preventDefault();
      });
    };
    this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      hoursInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementHours();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementHours();
            $scope.$apply();
          }
        }
      });
      minutesInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementMinutes();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementMinutes();
            $scope.$apply();
          }
        }
      });
      secondsInputEl.bind('keydown', function(e) {
        if (!disabled) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementSeconds();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementSeconds();
            $scope.$apply();
          }
        }
      });
    };
    this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
      if ($scope.readonlyInput) {
        $scope.updateHours = angular.noop;
        $scope.updateMinutes = angular.noop;
        $scope.updateSeconds = angular.noop;
        return;
      }
      var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
        ngModelCtrl.$setViewValue(null);
        ngModelCtrl.$setValidity('time', false);
        if (angular.isDefined(invalidHours)) {
          $scope.invalidHours = invalidHours;
        }
        if (angular.isDefined(invalidMinutes)) {
          $scope.invalidMinutes = invalidMinutes;
        }
        if (angular.isDefined(invalidSeconds)) {
          $scope.invalidSeconds = invalidSeconds;
        }
      };
      $scope.updateHours = function() {
        var hours = getHoursFromTemplate(),
          minutes = getMinutesFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected &lt; min || selected &gt; max) {
            invalidate(true);
          } else {
            refresh('h');
          }
        } else {
          invalidate(true);
        }
      };
      hoursInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if ($scope.hours === null || $scope.hours === '') {
          invalidate(true);
        } else if (!$scope.invalidHours &amp;&amp; $scope.hours &lt; 10) {
          $scope.$apply(function() {
            $scope.hours = pad($scope.hours);
          });
        }
      });
      $scope.updateMinutes = function() {
        var minutes = getMinutesFromTemplate(),
          hours = getHoursFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(minutes) &amp;&amp; angular.isDefined(hours)) {
          selected.setHours(hours);
          selected.setMinutes(minutes);
          if (selected &lt; min || selected &gt; max) {
            invalidate(undefined, true);
          } else {
            refresh('m');
          }
        } else {
          invalidate(undefined, true);
        }
      };
      minutesInputEl.bind('blur', function(e) {
        ngModelCtrl.$setTouched();
        if ($scope.minutes === null) {
          invalidate(undefined, true);
        } else if (!$scope.invalidMinutes &amp;&amp; $scope.minutes &lt; 10) {
          $scope.$apply(function() {
            $scope.minutes = pad($scope.minutes);
          });
        }
      });
      $scope.updateSeconds = function() {
        var seconds = getSecondsFromTemplate();
        ngModelCtrl.$setDirty();
        if (angular.isDefined(seconds)) {
          selected.setSeconds(seconds);
          refresh('s');
        } else {
          invalidate(undefined, undefined, true);
        }
      };
      secondsInputEl.bind('blur', function(e) {
        if (!$scope.invalidSeconds &amp;&amp; $scope.seconds &lt; 10) {
          $scope.$apply(function() {
            $scope.seconds = pad($scope.seconds);
          });
        }
      });
    };
    this.render = function() {
      var date = ngModelCtrl.$viewValue;
      if (isNaN(date)) {
        ngModelCtrl.$setValidity('time', false);
        $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      } else {
        if (date) {
          selected = date;
        }
        if (selected &lt; min || selected &gt; max) {
          ngModelCtrl.$setValidity('time', false);
          $scope.invalidHours = true;
          $scope.invalidMinutes = true;
        } else {
          makeValid();
        }
        updateTemplate();
      }
    };

    function refresh(keyboardChange) {
      makeValid();
      ngModelCtrl.$setViewValue(new Date(selected));
      updateTemplate(keyboardChange);
    }

    function makeValid() {
      ngModelCtrl.$setValidity('time', true);
      $scope.invalidHours = false;
      $scope.invalidMinutes = false;
      $scope.invalidSeconds = false;
    }

    function updateTemplate(keyboardChange) {
      if (!ngModelCtrl.$modelValue) {
        $scope.hours = null;
        $scope.minutes = null;
        $scope.seconds = null;
        $scope.meridian = meridians[0];
      } else {
        var hours = selected.getHours(),
          minutes = selected.getMinutes(),
          seconds = selected.getSeconds();
        if ($scope.showMeridian) {
          hours = hours === 0 || hours === 12 ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
        if (keyboardChange !== 'm') {
          $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];
        if (keyboardChange !== 's') {
          $scope.seconds = pad(seconds);
        }
        $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];
      }
    }

    function addSecondsToSelected(seconds) {
      selected = addSeconds(selected, seconds);
      refresh();
    }

    function addMinutes(selected, minutes) {
      return addSeconds(selected, minutes * 60);
    }

    function addSeconds(date, seconds) {
      var dt = new Date(date.getTime() + seconds * 1000);
      var newDate = new Date(date);
      newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
      return newDate;
    }
    $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
      $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
    $scope.incrementHours = function() {
      if (!$scope.noIncrementHours()) {
        addSecondsToSelected(hourStep * 60 * 60);
      }
    };
    $scope.decrementHours = function() {
      if (!$scope.noDecrementHours()) {
        addSecondsToSelected(-hourStep * 60 * 60);
      }
    };
    $scope.incrementMinutes = function() {
      if (!$scope.noIncrementMinutes()) {
        addSecondsToSelected(minuteStep * 60);
      }
    };
    $scope.decrementMinutes = function() {
      if (!$scope.noDecrementMinutes()) {
        addSecondsToSelected(-minuteStep * 60);
      }
    };
    $scope.incrementSeconds = function() {
      if (!$scope.noIncrementSeconds()) {
        addSecondsToSelected(secondStep);
      }
    };
    $scope.decrementSeconds = function() {
      if (!$scope.noDecrementSeconds()) {
        addSecondsToSelected(-secondStep);
      }
    };
    $scope.toggleMeridian = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();
      if (!$scope.noToggleMeridian()) {
        if (angular.isDefined(minutes) &amp;&amp; angular.isDefined(hours)) {
          addSecondsToSelected(12 * 60 * (selected.getHours() &lt; 12 ? 60 : -60));
        } else {
          $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
        }
      }
    };
    $scope.blur = function() {
      ngModelCtrl.$setTouched();
    };
    $scope.$on('$destroy', function() {
      while (watchers.length) {
        watchers.shift()();
      }
    });
  }])
  .directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
    return {
      require: ['uibTimepicker', '?^ngModel'],
      controller: 'UibTimepickerController',
      controllerAs: 'timepicker',
      replace: true,
      scope: {},
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || uibTimepickerConfig.templateUrl;
      },
      link: function(scope, element, attrs, ctrls) {
        var timepickerCtrl = ctrls[0],
          ngModelCtrl = ctrls[1];
        if (ngModelCtrl) {
          timepickerCtrl.init(ngModelCtrl, element.find('input'));
        }
      }
    };
  }]);
angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
            ' but got "' + input + '".');
        }
        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])
  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl, ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength &amp;&amp; minLength !== 0) {
        minLength = 1;
      }
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== false;
      });
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
      var appendTo = attrs.typeaheadAppendTo ?
        originalScope.$eval(attrs.typeaheadAppendTo) : null;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) &amp;&amp;
          ngModelOptions &amp;&amp; ngModelOptions.$options &amp;&amp; ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, {
            $$$p: newValue
          });
        }
        return parsedModel.assign(scope, newValue);
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });
      var inputsContainer, hintInputElem;
      if (showHint) {
        inputsContainer = angular.element('&lt;div&gt;&lt;/div&gt;');
        inputsContainer.css('position', 'relative');
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr('placeholder', '');
        hintInputElem.val('');
        hintInputElem.css({
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'border-color': 'transparent',
          'box-shadow': 'none',
          'opacity': 1,
          'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
          'color': '#999'
        });
        element.css({
          'position': 'relative',
          'vertical-align': 'top',
          'background-color': 'transparent'
        });
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }
      var popUpEl = angular.element('&lt;div uib-typeahead-popup&gt;&lt;/div&gt;');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx, evt)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position',
        'assign-is-open': 'assignIsOpen(isOpen)',
        debounce: 'debounceUpdate'
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }
      var resetHint = function() {
        if (showHint) {
          hintInputElem.val('');
        }
      };
      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
        resetHint();
      };
      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };
      scope.$watch('activeIdx', function(index) {
        if (index &lt; 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });
      var inputIsExactMatch = function(inputValue, index) {
        if (scope.matches.length &gt; index &amp;&amp; inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }
        return false;
      };
      var getMatchesAsync = function(inputValue, evt) {
        var locals = {
          $viewValue: inputValue
        };
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest &amp;&amp; hasFocus) {
            if (matches &amp;&amp; matches.length &gt; 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;
              for (var i = 0; i &lt; matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }
              scope.query = inputValue;
              recalculatePosition();
              element.attr('aria-expanded', true);
              if (selectOnExact &amp;&amp; scope.matches.length === 1 &amp;&amp; inputIsExactMatch(inputValue, 0)) {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function() {
                    scope.select(0, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(0, evt);
                }
              }
              if (showHint) {
                var firstLabel = scope.matches[0].label;
                if (angular.isString(inputValue) &amp;&amp;
                  inputValue.length &gt; 0 &amp;&amp;
                  firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                  hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                } else {
                  hintInputElem.val('');
                }
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function() {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };
      if (appendToBody) {
        angular.element($window).on('resize', fireRecalculating);
        $document.find('body').on('scroll', fireRecalculating);
      }
      var debouncedRecalculate = $$debounce(function() {
        if (scope.matches.length) {
          recalculatePosition();
        }
        scope.moveInProgress = false;
      }, eventDebounceTime);
      scope.moveInProgress = false;

      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        debouncedRecalculate();
      }

      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
      };
      scope.select = function(activeIdx, evt) {
        var locals = {};
        var model, item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function() {
            element[0].focus();
          }, 0, false);
        }
      };
      element.on('keydown', function(evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        if (scope.activeIdx === -1 &amp;&amp; (evt.which === 9 || evt.which === 13)) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 9:
          case 13:
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(scope.activeIdx, evt);
              }
            });
            break;
          case 27:
            evt.stopPropagation();
            resetMatches();
            scope.$digest();
            break;
          case 38:
            scope.activeIdx = (scope.activeIdx &gt; 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
        }
      });
      element.bind('focus', function(evt) {
        hasFocus = true;
        if (minLength === 0 &amp;&amp; !modelCtrl.$viewValue) {
          $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });
      element.bind('blur', function(evt) {
        if (isSelectOnBlur &amp;&amp; scope.matches.length &amp;&amp; scope.activeIdx !== -1 &amp;&amp; !selected) {
          selected = true;
          scope.$apply(function() {
            if (angular.isObject(scope.debounceUpdate) &amp;&amp; angular.isNumber(scope.debounceUpdate.blur)) {
              $$debounce(function() {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable &amp;&amp; modelCtrl.$error.editable) {
          modelCtrl.$viewValue = '';
          element.val('');
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function(evt) {
        if (element[0] !== evt.target &amp;&amp; evt.which !== 3 &amp;&amp; scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            scope.$digest();
          }
        }
      };
      $document.on('click', dismissClickHandler);
      originalScope.$on('$destroy', function() {
        $document.off('click', dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).off('resize', fireRecalculating);
          $document.find('body').off('scroll', fireRecalculating);
        }
        popUpEl.remove();
        if (showHint) {
          inputsContainer.remove();
        }
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        scope.debounceUpdate = modelCtrl.$options &amp;&amp; $parse(modelCtrl.$options.debounce)(originalScope);
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;
          if (minLength === 0 || inputValue &amp;&amp; inputValue.length &gt;= minLength) {
            if (waitTime &gt; 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          }
          if (!inputValue) {
            modelCtrl.$setValidity('editable', true);
            return null;
          }
          modelCtrl.$setValidity('editable', false);
          return undefined;
        });
        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);
          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        });
      };
    }
  ])
  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  })
  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&amp;',
        moveInProgress: '=',
        select: '&amp;',
        assignIsOpen: '&amp;',
        debounce: '&amp;'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;
        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length &gt; 0;
          scope.assignIsOpen({
            isOpen: isDropdownOpen
          });
          return isDropdownOpen;
        };
        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };
        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };
        scope.selectMatch = function(activeIdx, evt) {
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({
                activeIdx: activeIdx,
                evt: evt
              });
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({
              activeIdx: activeIdx,
              evt: evt
            });
          }
        };
      }
    };
  }])
  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }])
  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /&lt;.*&gt;/g.test(matchItem);
    }
    return function(matchItem, query) {
      if (!isSanitizePresent &amp;&amp; containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize');
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '&lt;strong&gt;$&amp;&lt;/strong&gt;') : matchItem;
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem);
      }
      return matchItem;
    };
  }]);
angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
    "&lt;div class=\"panel\" ng-class=\"panelClass || 'panel-default'\"&gt;\n" +
    "  &lt;div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\"&gt;\n" +
    "    &lt;h4 class=\"panel-title\"&gt;\n" +
    "      &lt;a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"&gt;&lt;span ng-class=\"{'text-muted': isDisabled}\"&gt;{{heading}}&lt;/span&gt;&lt;/a&gt;\n" +
    "    &lt;/h4&gt;\n" +
    "  &lt;/div&gt;\n" +
    "  &lt;div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\"&gt;\n" +
    "    &lt;div class=\"panel-body\" ng-transclude&gt;&lt;/div&gt;\n" +
    "  &lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
    "&lt;div role=\"tablist\" class=\"panel-group\" ng-transclude&gt;&lt;/div&gt;");
}]);
angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
    "&lt;div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\"&gt;\n" +
    "    &lt;button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\"&gt;\n" +
    "        &lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;\n" +
    "        &lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;\n" +
    "    &lt;/button&gt;\n" +
    "    &lt;div ng-transclude&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
    "&lt;div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\"&gt;\n" +
    "  &lt;div class=\"carousel-inner\" ng-transclude&gt;&lt;/div&gt;\n" +
    "  &lt;a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length &gt; 1\"&gt;\n" +
    "    &lt;span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/span&gt;\n" +
    "    &lt;span class=\"sr-only\"&gt;previous&lt;/span&gt;\n" +
    "  &lt;/a&gt;\n" +
    "  &lt;a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length &gt; 1\"&gt;\n" +
    "    &lt;span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/span&gt;\n" +
    "    &lt;span class=\"sr-only\"&gt;next&lt;/span&gt;\n" +
    "  &lt;/a&gt;\n" +
    "  &lt;ol class=\"carousel-indicators\" ng-show=\"slides.length &gt; 1\"&gt;\n" +
    "    &lt;li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\"&gt;\n" +
    "      &lt;span class=\"sr-only\"&gt;slide {{ $index + 1 }} of {{ slides.length }}&lt;span ng-if=\"isActive(slide)\"&gt;, currently active&lt;/span&gt;&lt;/span&gt;\n" +
    "    &lt;/li&gt;\n" +
    "  &lt;/ol&gt;\n" +
    "&lt;/div&gt;");
}]);
angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
    "&lt;div ng-class=\"{\n" +
    "    'active': active\n" +
    "  }\" class=\"item text-center\" ng-transclude&gt;&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
    "&lt;div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\"&gt;\n" +
    "  &lt;uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"&gt;&lt;/uib-daypicker&gt;\n" +
    "  &lt;uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"&gt;&lt;/uib-monthpicker&gt;\n" +
    "  &lt;uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"&gt;&lt;/uib-yearpicker&gt;\n" +
    "&lt;/div&gt;");
}]);
angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
    "&lt;table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\"&gt;\n" +
    "  &lt;thead&gt;\n" +
    "    &lt;tr&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th colspan=\"{{::5 + showWeeks}}\"&gt;&lt;button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "    &lt;tr&gt;\n" +
    "      &lt;th ng-if=\"showWeeks\" class=\"text-center\"&gt;&lt;/th&gt;\n" +
    "      &lt;th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"&gt;&lt;small aria-label=\"{{::label.full}}\"&gt;{{::label.abbr}}&lt;/small&gt;&lt;/th&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/thead&gt;\n" +
    "  &lt;tbody&gt;\n" +
    "    &lt;tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\"&gt;\n" +
    "      &lt;td ng-if=\"showWeeks\" class=\"text-center h6\"&gt;&lt;em&gt;{{ weekNumbers[$index] }}&lt;/em&gt;&lt;/td&gt;\n" +
    "      &lt;td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\"&gt;\n" +
    "        &lt;button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"&gt;&lt;span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\"&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n" +
    "      &lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/tbody&gt;\n" +
    "&lt;/table&gt;\n" +
    "");
}]);
angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
    "&lt;table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\"&gt;\n" +
    "  &lt;thead&gt;\n" +
    "    &lt;tr&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th&gt;&lt;button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/thead&gt;\n" +
    "  &lt;tbody&gt;\n" +
    "    &lt;tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\"&gt;\n" +
    "      &lt;td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\"&gt;\n" +
    "        &lt;button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"&gt;&lt;span ng-class=\"::{'text-info': dt.current}\"&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n" +
    "      &lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/tbody&gt;\n" +
    "&lt;/table&gt;\n" +
    "");
}]);
angular.module("uib/template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/popup.html",
    "&lt;div&gt;\n" +
    "  &lt;ul class=\"uib-datepicker-popup dropdown-menu\" dropdown-nested ng-if=\"isOpen\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\"&gt;\n" +
    "    &lt;li ng-transclude&gt;&lt;/li&gt;\n" +
    "    &lt;li ng-if=\"showButtonBar\" class=\"uib-button-bar\"&gt;\n" +
    "    &lt;span class=\"btn-group pull-left\"&gt;\n" +
    "      &lt;button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\"&gt;{{ getText('current') }}&lt;/button&gt;\n" +
    "      &lt;button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null)\"&gt;{{ getText('clear') }}&lt;/button&gt;\n" +
    "    &lt;/span&gt;\n" +
    "      &lt;button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close()\"&gt;{{ getText('close') }}&lt;/button&gt;\n" +
    "    &lt;/li&gt;\n" +
    "  &lt;/ul&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
    "&lt;table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\"&gt;\n" +
    "  &lt;thead&gt;\n" +
    "    &lt;tr&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th colspan=\"{{::columns - 2}}\"&gt;&lt;button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"&gt;&lt;strong&gt;{{title}}&lt;/strong&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "      &lt;th&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"&gt;&lt;i class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/th&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/thead&gt;\n" +
    "  &lt;tbody&gt;\n" +
    "    &lt;tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\"&gt;\n" +
    "      &lt;td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\"&gt;\n" +
    "        &lt;button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"&gt;&lt;span ng-class=\"::{'text-info': dt.current}\"&gt;{{::dt.label}}&lt;/span&gt;&lt;/button&gt;\n" +
    "      &lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/tbody&gt;\n" +
    "&lt;/table&gt;\n" +
    "");
}]);
angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/backdrop.html",
    "&lt;div class=\"modal-backdrop\"\n" +
    "     uib-modal-animation-class=\"fade\"\n" +
    "     modal-in-class=\"in\"\n" +
    "     ng-style=\"{'z-index': 1040 + (index &amp;&amp; 1 || 0) + index*10}\"\n" +
    "&gt;&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
    "&lt;div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
    "    uib-modal-animation-class=\"fade\"\n" +
    "    modal-in-class=\"in\"\n" +
    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\"&gt;\n" +
    "    &lt;div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"&gt;&lt;div class=\"modal-content\" uib-modal-transclude&gt;&lt;/div&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
    "&lt;ul class=\"pager\"&gt;\n" +
    "  &lt;li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"&gt;&lt;a href ng-click=\"selectPage(page - 1, $event)\"&gt;{{::getText('previous')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "  &lt;li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"&gt;&lt;a href ng-click=\"selectPage(page + 1, $event)\"&gt;{{::getText('next')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "&lt;/ul&gt;\n" +
    "");
}]);
angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
    "&lt;ul class=\"pagination\"&gt;\n" +
    "  &lt;li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"&gt;&lt;a href ng-click=\"selectPage(1, $event)\"&gt;{{::getText('first')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "  &lt;li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"&gt;&lt;a href ng-click=\"selectPage(page - 1, $event)\"&gt;{{::getText('previous')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "  &lt;li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&amp;&amp;!page.active}\" class=\"pagination-page\"&gt;&lt;a href ng-click=\"selectPage(page.number, $event)\"&gt;{{page.text}}&lt;/a&gt;&lt;/li&gt;\n" +
    "  &lt;li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"&gt;&lt;a href ng-click=\"selectPage(page + 1, $event)\"&gt;{{::getText('next')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "  &lt;li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"&gt;&lt;a href ng-click=\"selectPage(totalPages, $event)\"&gt;{{::getText('last')}}&lt;/a&gt;&lt;/li&gt;\n" +
    "&lt;/ul&gt;\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
    "&lt;div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"tooltip-arrow\"&gt;&lt;/div&gt;\n" +
    "  &lt;div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
    "&lt;div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"tooltip-arrow\"&gt;&lt;/div&gt;\n" +
    "  &lt;div class=\"tooltip-inner\" ng-bind=\"content\"&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
    "&lt;div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"tooltip-arrow\"&gt;&lt;/div&gt;\n" +
    "  &lt;div class=\"tooltip-inner\"\n" +
    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "    tooltip-template-transclude-scope=\"originScope()\"&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
    "&lt;div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"arrow\"&gt;&lt;/div&gt;\n" +
    "\n" +
    "  &lt;div class=\"popover-inner\"&gt;\n" +
    "      &lt;h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"&gt;&lt;/h3&gt;\n" +
    "      &lt;div class=\"popover-content\" ng-bind-html=\"contentExp()\"&gt;&lt;/div&gt;\n" +
    "  &lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
    "&lt;div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"arrow\"&gt;&lt;/div&gt;\n" +
    "\n" +
    "  &lt;div class=\"popover-inner\"&gt;\n" +
    "      &lt;h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"&gt;&lt;/h3&gt;\n" +
    "      &lt;div class=\"popover-content\"\n" +
    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "        tooltip-template-transclude-scope=\"originScope()\"&gt;&lt;/div&gt;\n" +
    "  &lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
    "&lt;div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\"&gt;\n" +
    "  &lt;div class=\"arrow\"&gt;&lt;/div&gt;\n" +
    "\n" +
    "  &lt;div class=\"popover-inner\"&gt;\n" +
    "      &lt;h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"&gt;&lt;/h3&gt;\n" +
    "      &lt;div class=\"popover-content\" ng-bind=\"content\"&gt;&lt;/div&gt;\n" +
    "  &lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
    "&lt;div class=\"progress-bar\" ng-class=\"type &amp;&amp; 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent &lt; 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude&gt;&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
    "&lt;div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"&gt;&lt;/div&gt;");
}]);
angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
    "&lt;div class=\"progress\"&gt;\n" +
    "  &lt;div class=\"progress-bar\" ng-class=\"type &amp;&amp; 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent &lt; 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude&gt;&lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
    "&lt;span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\"&gt;\n" +
    "    &lt;span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\"&gt;({{ $index &lt; value ? '*' : ' ' }})&lt;/span&gt;\n" +
    "    &lt;i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index &lt; value &amp;&amp; (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"&gt;&lt;/i&gt;\n" +
    "&lt;/span&gt;\n" +
    "");
}]);
angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
    "&lt;li ng-class=\"{active: active, disabled: disabled}\" class=\"uib-tab\"&gt;\n" +
    "  &lt;a href ng-click=\"select()\" uib-tab-heading-transclude&gt;{{heading}}&lt;/a&gt;\n" +
    "&lt;/li&gt;\n" +
    "");
}]);
angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
    "&lt;div&gt;\n" +
    "  &lt;ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude&gt;&lt;/ul&gt;\n" +
    "  &lt;div class=\"tab-content\"&gt;\n" +
    "    &lt;div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         uib-tab-content-transclude=\"tab\"&gt;\n" +
    "    &lt;/div&gt;\n" +
    "  &lt;/div&gt;\n" +
    "&lt;/div&gt;\n" +
    "");
}]);
angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
    "&lt;table class=\"uib-timepicker\"&gt;\n" +
    "  &lt;tbody&gt;\n" +
    "    &lt;tr class=\"text-center\" ng-show=\"::showSpinners\"&gt;\n" +
    "      &lt;td class=\"uib-increment hours\"&gt;&lt;a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-up\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td&gt;&amp;nbsp;&lt;/td&gt;\n" +
    "      &lt;td class=\"uib-increment minutes\"&gt;&lt;a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-up\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showSeconds\"&gt;&amp;nbsp;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showSeconds\" class=\"uib-increment seconds\"&gt;&lt;a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-up\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showMeridian\"&gt;&lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "    &lt;tr&gt;\n" +
    "      &lt;td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\"&gt;\n" +
    "        &lt;input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\"&gt;\n" +
    "      &lt;/td&gt;\n" +
    "      &lt;td class=\"uib-separator\"&gt;:&lt;/td&gt;\n" +
    "      &lt;td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\"&gt;\n" +
    "        &lt;input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\"&gt;\n" +
    "      &lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showSeconds\" class=\"uib-separator\"&gt;:&lt;/td&gt;\n" +
    "      &lt;td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\"&gt;\n" +
    "        &lt;input style=\"width:50px;\" type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\"&gt;\n" +
    "      &lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showMeridian\" class=\"uib-time am-pm\"&gt;&lt;button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\"&gt;{{meridian}}&lt;/button&gt;&lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "    &lt;tr class=\"text-center\" ng-show=\"::showSpinners\"&gt;\n" +
    "      &lt;td class=\"uib-decrement hours\"&gt;&lt;a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-down\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td&gt;&amp;nbsp;&lt;/td&gt;\n" +
    "      &lt;td class=\"uib-decrement minutes\"&gt;&lt;a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-down\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showSeconds\"&gt;&amp;nbsp;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"&gt;&lt;a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"&gt;&lt;span class=\"glyphicon glyphicon-chevron-down\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;\n" +
    "      &lt;td ng-show=\"showMeridian\"&gt;&lt;/td&gt;\n" +
    "    &lt;/tr&gt;\n" +
    "  &lt;/tbody&gt;\n" +
    "&lt;/table&gt;\n" +
    "");
}]);
angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
    "&lt;a href\n" +
    "   tabindex=\"-1\"\n" +
    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
    "   ng-attr-title=\"{{match.label}}\"&gt;&lt;/a&gt;\n" +
    "");
}]);
angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
    "&lt;ul class=\"dropdown-menu\" ng-show=\"isOpen() &amp;&amp; !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\"&gt;\n" +
    "    &lt;li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\"&gt;\n" +
    "        &lt;div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"&gt;&lt;/div&gt;\n" +
    "    &lt;/li&gt;\n" +
    "&lt;/ul&gt;\n" +
    "");
}]);
angular.module('ui.bootstrap.carousel').run(function() {
  !angular.$$csp().noInlineStyle &amp;&amp; angular.element(document).find('head').prepend('&lt;style type="text/css"&gt;.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}&lt;/style&gt;');
});
angular.module('ui.bootstrap.datepicker').run(function() {
  !angular.$$csp().noInlineStyle &amp;&amp; angular.element(document).find('head').prepend('&lt;style type="text/css"&gt;.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}&lt;/style&gt;');
});
angular.module('ui.bootstrap.timepicker').run(function() {
  !angular.$$csp().noInlineStyle &amp;&amp; angular.element(document).find('head').prepend('&lt;style type="text/css"&gt;.uib-time input{width:50px;}&lt;/style&gt;');
});
angular.module('ui.bootstrap.typeahead').run(function() {
  !angular.$$csp().noInlineStyle &amp;&amp; angular.element(document).find('head').prepend('&lt;style type="text/css"&gt;[uib-typeahead-popup].dropdown-menu{display:block;}&lt;/style&gt;');
});;
/*! RESOURCE: /scripts/moment-2.8.3.js */
(function(undefined) {
  var moment,
    VERSION = '2.8.3',
    globalScope = typeof global !== 'undefined' ? global : this,
    oldGlobalMoment,
    round = Math.round,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    i,
    YEAR = 0,
    MONTH = 1,
    DATE = 2,
    HOUR = 3,
    MINUTE = 4,
    SECOND = 5,
    MILLISECOND = 6,
    locales = {},
    momentProperties = [],
    hasModule = (typeof module !== 'undefined' &amp;&amp; module.exports),
    aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
    aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
    isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
    formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
    localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,
    parseTokenOneOrTwoDigits = /\d\d?/,
    parseTokenOneToThreeDigits = /\d{1,3}/,
    parseTokenOneToFourDigits = /\d{1,4}/,
    parseTokenOneToSixDigits = /[+\-]?\d{1,6}/,
    parseTokenDigits = /\d+/,
    parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
    parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi,
    parseTokenT = /T/i,
    parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/,
    parseTokenOrdinal = /\d{1,2}/,
    parseTokenOneDigit = /\d/,
    parseTokenTwoDigits = /\d\d/,
    parseTokenThreeDigits = /\d{3}/,
    parseTokenFourDigits = /\d{4}/,
    parseTokenSixDigits = /[+-]?\d{6}/,
    parseTokenSignedNumber = /[+-]?\d+/,
    isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',
    isoDates = [
      ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
      ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
      ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
      ['GGGG-[W]WW', /\d{4}-W\d{2}/],
      ['YYYY-DDD', /\d{4}-\d{3}/]
    ],
    isoTimes = [
      ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
      ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
      ['HH:mm', /(T| )\d\d:\d\d/],
      ['HH', /(T| )\d\d/]
    ],
    parseTimezoneChunker = /([\+\-]|\d\d)/gi,
    proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
    unitMillisecondFactors = {
      'Milliseconds': 1,
      'Seconds': 1e3,
      'Minutes': 6e4,
      'Hours': 36e5,
      'Days': 864e5,
      'Months': 2592e6,
      'Years': 31536e6
    },
    unitAliases = {
      ms: 'millisecond',
      s: 'second',
      m: 'minute',
      h: 'hour',
      d: 'day',
      D: 'date',
      w: 'week',
      W: 'isoWeek',
      M: 'month',
      Q: 'quarter',
      y: 'year',
      DDD: 'dayOfYear',
      e: 'weekday',
      E: 'isoWeekday',
      gg: 'weekYear',
      GG: 'isoWeekYear'
    },
    camelFunctions = {
      dayofyear: 'dayOfYear',
      isoweekday: 'isoWeekday',
      isoweek: 'isoWeek',
      weekyear: 'weekYear',
      isoweekyear: 'isoWeekYear'
    },
    formatFunctions = {},
    relativeTimeThresholds = {
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      M: 11
    },
    ordinalizeTokens = 'DDD w W M D d'.split(' '),
    paddedTokens = 'M D H h m s w W'.split(' '),
    formatTokenFunctions = {
      M: function() {
        return this.month() + 1;
      },
      MMM: function(format) {
        return this.localeData().monthsShort(this, format);
      },
      MMMM: function(format) {
        return this.localeData().months(this, format);
      },
      D: function() {
        return this.date();
      },
      DDD: function() {
        return this.dayOfYear();
      },
      d: function() {
        return this.day();
      },
      dd: function(format) {
        return this.localeData().weekdaysMin(this, format);
      },
      ddd: function(format) {
        return this.localeData().weekdaysShort(this, format);
      },
      dddd: function(format) {
        return this.localeData().weekdays(this, format);
      },
      w: function() {
        return this.week();
      },
      W: function() {
        return this.isoWeek();
      },
      YY: function() {
        return leftZeroFill(this.year() % 100, 2);
      },
      YYYY: function() {
        return leftZeroFill(this.year(), 4);
      },
      YYYYY: function() {
        return leftZeroFill(this.year(), 5);
      },
      YYYYYY: function() {
        var y = this.year(),
          sign = y &gt;= 0 ? '+' : '-';
        return sign + leftZeroFill(Math.abs(y), 6);
      },
      gg: function() {
        return leftZeroFill(this.weekYear() % 100, 2);
      },
      gggg: function() {
        return leftZeroFill(this.weekYear(), 4);
      },
      ggggg: function() {
        return leftZeroFill(this.weekYear(), 5);
      },
      GG: function() {
        return leftZeroFill(this.isoWeekYear() % 100, 2);
      },
      GGGG: function() {
        return leftZeroFill(this.isoWeekYear(), 4);
      },
      GGGGG: function() {
        return leftZeroFill(this.isoWeekYear(), 5);
      },
      e: function() {
        return this.weekday();
      },
      E: function() {
        return this.isoWeekday();
      },
      a: function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), true);
      },
      A: function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), false);
      },
      H: function() {
        return this.hours();
      },
      h: function() {
        return this.hours() % 12 || 12;
      },
      m: function() {
        return this.minutes();
      },
      s: function() {
        return this.seconds();
      },
      S: function() {
        return toInt(this.milliseconds() / 100);
      },
      SS: function() {
        return leftZeroFill(toInt(this.milliseconds() / 10), 2);
      },
      SSS: function() {
        return leftZeroFill(this.milliseconds(), 3);
      },
      SSSS: function() {
        return leftZeroFill(this.milliseconds(), 3);
      },
      Z: function() {
        var a = -this.zone(),
          b = '+';
        if (a &lt; 0) {
          a = -a;
          b = '-';
        }
        return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
      },
      ZZ: function() {
        var a = -this.zone(),
          b = '+';
        if (a &lt; 0) {
          a = -a;
          b = '-';
        }
        return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
      },
      z: function() {
        return this.zoneAbbr();
      },
      zz: function() {
        return this.zoneName();
      },
      X: function() {
        return this.unix();
      },
      Q: function() {
        return this.quarter();
      }
    },
    deprecations = {},
    lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

  function dfl(a, b, c) {
    switch (arguments.length) {
      case 2:
        return a != null ? a : b;
      case 3:
        return a != null ? a : b != null ? b : c;
      default:
        throw new Error('Implement me');
    }
  }

  function hasOwnProp(a, b) {
    return hasOwnProperty.call(a, b);
  }

  function defaultParsingFlags() {
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false
    };
  }

  function printMsg(msg) {
    if (moment.suppressDeprecationWarnings === false &amp;&amp;
      typeof console !== 'undefined' &amp;&amp; console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }

  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function() {
      if (firstTime) {
        printMsg(msg);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }

  function deprecateSimple(name, msg) {
    if (!deprecations[name]) {
      printMsg(msg);
      deprecations[name] = true;
    }
  }

  function padToken(func, count) {
    return function(a) {
      return leftZeroFill(func.call(this, a), count);
    };
  }

  function ordinalizeToken(func, period) {
    return function(a) {
      return this.localeData().ordinal(func.call(this, a), period);
    };
  }
  while (ordinalizeTokens.length) {
    i = ordinalizeTokens.pop();
    formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
  }
  while (paddedTokens.length) {
    i = paddedTokens.pop();
    formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
  }
  formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);

  function Locale() {}

  function Moment(config, skipOverflow) {
    if (skipOverflow !== false) {
      checkOverflow(config);
    }
    copyConfig(this, config);
    this._d = new Date(+config._d);
  }

  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
      years = normalizedInput.year || 0,
      quarters = normalizedInput.quarter || 0,
      months = normalizedInput.month || 0,
      weeks = normalizedInput.week || 0,
      days = normalizedInput.day || 0,
      hours = normalizedInput.hour || 0,
      minutes = normalizedInput.minute || 0,
      seconds = normalizedInput.second || 0,
      milliseconds = normalizedInput.millisecond || 0;
    this._milliseconds = +milliseconds +
      seconds * 1e3 +
      minutes * 6e4 +
      hours * 36e5;
    this._days = +days +
      weeks * 7;
    this._months = +months +
      quarters * 3 +
      years * 12;
    this._data = {};
    this._locale = moment.localeData();
    this._bubble();
  }

  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }

  function copyConfig(to, from) {
    var i, prop, val;
    if (typeof from._isAMomentObject !== 'undefined') {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (typeof from._i !== 'undefined') {
      to._i = from._i;
    }
    if (typeof from._f !== 'undefined') {
      to._f = from._f;
    }
    if (typeof from._l !== 'undefined') {
      to._l = from._l;
    }
    if (typeof from._strict !== 'undefined') {
      to._strict = from._strict;
    }
    if (typeof from._tzm !== 'undefined') {
      to._tzm = from._tzm;
    }
    if (typeof from._isUTC !== 'undefined') {
      to._isUTC = from._isUTC;
    }
    if (typeof from._offset !== 'undefined') {
      to._offset = from._offset;
    }
    if (typeof from._pf !== 'undefined') {
      to._pf = from._pf;
    }
    if (typeof from._locale !== 'undefined') {
      to._locale = from._locale;
    }
    if (momentProperties.length &gt; 0) {
      for (i in momentProperties) {
        prop = momentProperties[i];
        val = from[prop];
        if (typeof val !== 'undefined') {
          to[prop] = val;
        }
      }
    }
    return to;
  }

  function absRound(number) {
    if (number &lt; 0) {
      return Math.ceil(number);
    } else {
      return Math.floor(number);
    }
  }

  function leftZeroFill(number, targetLength, forceSign) {
    var output = '' + Math.abs(number),
      sign = number &gt;= 0;
    while (output.length &lt; targetLength) {
      output = '0' + output;
    }
    return (sign ? (forceSign ? '+' : '') : '-') + output;
  }

  function positiveMomentsDifference(base, other) {
    var res = {
      milliseconds: 0,
      months: 0
    };
    res.months = other.month() - base.month() +
      (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    return res;
  }

  function momentsDifference(base, other) {
    var res;
    other = makeAs(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }

  function createAdder(direction, name) {
    return function(val, period) {
      var dur, tmp;
      if (period !== null &amp;&amp; !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = moment.duration(val, period);
      addOrSubtractDurationFromMoment(this, dur, direction);
      return this;
    };
  }

  function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
      days = duration._days,
      months = duration._months;
    updateOffset = updateOffset == null ? true : updateOffset;
    if (milliseconds) {
      mom._d.setTime(+mom._d + milliseconds * isAdding);
    }
    if (days) {
      rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
    }
    if (months) {
      rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
      moment.updateOffset(mom, days || months);
    }
  }

  function isArray(input) {
    return Object.prototype.toString.call(input) === '[object Array]';
  }

  function isDate(input) {
    return Object.prototype.toString.call(input) === '[object Date]' ||
      input instanceof Date;
  }

  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
      lengthDiff = Math.abs(array1.length - array2.length),
      diffs = 0,
      i;
    for (i = 0; i &lt; len; i++) {
      if ((dontConvert &amp;&amp; array1[i] !== array2[i]) ||
        (!dontConvert &amp;&amp; toInt(array1[i]) !== toInt(array2[i]))) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }

  function normalizeUnits(units) {
    if (units) {
      var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
      units = unitAliases[units] || camelFunctions[lowered] || lowered;
    }
    return units;
  }

  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
      normalizedProp,
      prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }

  function makeList(field) {
    var count, setter;
    if (field.indexOf('week') === 0) {
      count = 7;
      setter = 'day';
    } else if (field.indexOf('month') === 0) {
      count = 12;
      setter = 'month';
    } else {
      return;
    }
    moment[field] = function(format, index) {
      var i, getter,
        method = moment._locale[field],
        results = [];
      if (typeof format === 'number') {
        index = format;
        format = undefined;
      }
      getter = function(i) {
        var m = moment().utc().set(setter, i);
        return method.call(moment._locale, m, format || '');
      };
      if (index != null) {
        return getter(index);
      } else {
        for (i = 0; i &lt; count; i++) {
          results.push(getter(i));
        }
        return results;
      }
    };
  }

  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
      value = 0;
    if (coercedNumber !== 0 &amp;&amp; isFinite(coercedNumber)) {
      if (coercedNumber &gt;= 0) {
        value = Math.floor(coercedNumber);
      } else {
        value = Math.ceil(coercedNumber);
      }
    }
    return value;
  }

  function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
  }

  function weeksInYear(year, dow, doy) {
    return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
  }

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  function isLeapYear(year) {
    return (year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0;
  }

  function checkOverflow(m) {
    var overflow;
    if (m._a &amp;&amp; m._pf.overflow === -2) {
      overflow =
        m._a[MONTH] &lt; 0 || m._a[MONTH] &gt; 11 ? MONTH :
        m._a[DATE] &lt; 1 || m._a[DATE] &gt; daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
        m._a[HOUR] &lt; 0 || m._a[HOUR] &gt; 23 ? HOUR :
        m._a[MINUTE] &lt; 0 || m._a[MINUTE] &gt; 59 ? MINUTE :
        m._a[SECOND] &lt; 0 || m._a[SECOND] &gt; 59 ? SECOND :
        m._a[MILLISECOND] &lt; 0 || m._a[MILLISECOND] &gt; 999 ? MILLISECOND :
        -1;
      if (m._pf._overflowDayOfYear &amp;&amp; (overflow &lt; YEAR || overflow &gt; DATE)) {
        overflow = DATE;
      }
      m._pf.overflow = overflow;
    }
  }

  function isValid(m) {
    if (m._isValid == null) {
      m._isValid = !isNaN(m._d.getTime()) &amp;&amp;
        m._pf.overflow &lt; 0 &amp;&amp;
        !m._pf.empty &amp;&amp;
        !m._pf.invalidMonth &amp;&amp;
        !m._pf.nullInput &amp;&amp;
        !m._pf.invalidFormat &amp;&amp;
        !m._pf.userInvalidated;
      if (m._strict) {
        m._isValid = m._isValid &amp;&amp;
          m._pf.charsLeftOver === 0 &amp;&amp;
          m._pf.unusedTokens.length === 0;
      }
    }
    return m._isValid;
  }

  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }

  function chooseLocale(names) {
    var i = 0,
      j, next, locale, split;
    while (i &lt; names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j &gt; 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next &amp;&amp; next.length &gt;= j &amp;&amp; compareArrays(split, next, true) &gt;= j - 1) {
          break;
        }
        j--;
      }
      i++;
    }
    return null;
  }

  function loadLocale(name) {
    var oldLocale = null;
    if (!locales[name] &amp;&amp; hasModule) {
      try {
        oldLocale = moment.locale();
        require('./locale/' + name);
        moment.locale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }

  function makeAs(input, model) {
    return model._isUTC ? moment(input).zone(model._offset || 0) :
      moment(input).local();
  }
  extend(Locale.prototype, {
    set: function(config) {
      var prop, i;
      for (i in config) {
        prop = config[i];
        if (typeof prop === 'function') {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
    },
    _months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    months: function(m) {
      return this._months[m.month()];
    },
    _monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    monthsShort: function(m) {
      return this._monthsShort[m.month()];
    },
    monthsParse: function(monthName) {
      var i, mom, regex;
      if (!this._monthsParse) {
        this._monthsParse = [];
      }
      for (i = 0; i &lt; 12; i++) {
        if (!this._monthsParse[i]) {
          mom = moment.utc([2000, i]);
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    },
    _weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdays: function(m) {
      return this._weekdays[m.day()];
    },
    _weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysShort: function(m) {
      return this._weekdaysShort[m.day()];
    },
    _weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    weekdaysMin: function(m) {
      return this._weekdaysMin[m.day()];
    },
    weekdaysParse: function(weekdayName) {
      var i, mom, regex;
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
      }
      for (i = 0; i &lt; 7; i++) {
        if (!this._weekdaysParse[i]) {
          mom = moment([2000, 1]).day(i);
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        if (this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    },
    _longDateFormat: {
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY LT',
      LLLL: 'dddd, MMMM D, YYYY LT'
    },
    longDateFormat: function(key) {
      var output = this._longDateFormat[key];
      if (!output &amp;&amp; this._longDateFormat[key.toUpperCase()]) {
        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
          return val.slice(1);
        });
        this._longDateFormat[key] = output;
      }
      return output;
    },
    isPM: function(input) {
      return ((input + '').toLowerCase().charAt(0) === 'p');
    },
    _meridiemParse: /[ap]\.?m?\.?/i,
    meridiem: function(hours, minutes, isLower) {
      if (hours &gt; 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    },
    _calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    calendar: function(key, mom) {
      var output = this._calendar[key];
      return typeof output === 'function' ? output.apply(mom) : output;
    },
    _relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    relativeTime: function(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return (typeof output === 'function') ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
    },
    pastFuture: function(diff, output) {
      var format = this._relativeTime[diff &gt; 0 ? 'future' : 'past'];
      return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    },
    ordinal: function(number) {
      return this._ordinal.replace('%d', number);
    },
    _ordinal: '%d',
    preparse: function(string) {
      return string;
    },
    postformat: function(string) {
      return string;
    },
    week: function(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    },
    _week: {
      dow: 0,
      doy: 6
    },
    _invalidDate: 'Invalid date',
    invalidDate: function() {
      return this._invalidDate;
    }
  });

  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
      i, length;
    for (i = 0, length = array.length; i &lt; length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function(mom) {
      var output = '';
      for (i = 0; i &lt; length; i++) {
        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }

  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    if (!formatFunctions[format]) {
      formatFunctions[format] = makeFormatFunction(format);
    }
    return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i &gt;= 0 &amp;&amp; localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }

  function getParseRegexForToken(token, config) {
    var a, strict = config._strict;
    switch (token) {
      case 'Q':
        return parseTokenOneDigit;
      case 'DDDD':
        return parseTokenThreeDigits;
      case 'YYYY':
      case 'GGGG':
      case 'gggg':
        return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
      case 'Y':
      case 'G':
      case 'g':
        return parseTokenSignedNumber;
      case 'YYYYYY':
      case 'YYYYY':
      case 'GGGGG':
      case 'ggggg':
        return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
      case 'S':
        if (strict) {
          return parseTokenOneDigit;
        }
      case 'SS':
        if (strict) {
          return parseTokenTwoDigits;
        }
      case 'SSS':
        if (strict) {
          return parseTokenThreeDigits;
        }
      case 'DDD':
        return parseTokenOneToThreeDigits;
      case 'MMM':
      case 'MMMM':
      case 'dd':
      case 'ddd':
      case 'dddd':
        return parseTokenWord;
      case 'a':
      case 'A':
        return config._locale._meridiemParse;
      case 'X':
        return parseTokenTimestampMs;
      case 'Z':
      case 'ZZ':
        return parseTokenTimezone;
      case 'T':
        return parseTokenT;
      case 'SSSS':
        return parseTokenDigits;
      case 'MM':
      case 'DD':
      case 'YY':
      case 'GG':
      case 'gg':
      case 'HH':
      case 'hh':
      case 'mm':
      case 'ss':
      case 'ww':
      case 'WW':
        return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
      case 'M':
      case 'D':
      case 'd':
      case 'H':
      case 'h':
      case 'm':
      case 's':
      case 'w':
      case 'W':
      case 'e':
      case 'E':
        return parseTokenOneOrTwoDigits;
      case 'Do':
        return parseTokenOrdinal;
      default:
        a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
        return a;
    }
  }

  function timezoneMinutesFromString(string) {
    string = string || '';
    var possibleTzMatches = (string.match(parseTokenTimezone) || []),
      tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
      parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
      minutes = +(parts[1] * 60) + toInt(parts[2]);
    return parts[0] === '+' ? -minutes : minutes;
  }

  function addTimeToArrayFromToken(token, input, config) {
    var a, datePartArray = config._a;
    switch (token) {
      case 'Q':
        if (input != null) {
          datePartArray[MONTH] = (toInt(input) - 1) * 3;
        }
        break;
      case 'M':
      case 'MM':
        if (input != null) {
          datePartArray[MONTH] = toInt(input) - 1;
        }
        break;
      case 'MMM':
      case 'MMMM':
        a = config._locale.monthsParse(input);
        if (a != null) {
          datePartArray[MONTH] = a;
        } else {
          config._pf.invalidMonth = input;
        }
        break;
      case 'D':
      case 'DD':
        if (input != null) {
          datePartArray[DATE] = toInt(input);
        }
        break;
      case 'Do':
        if (input != null) {
          datePartArray[DATE] = toInt(parseInt(input, 10));
        }
        break;
      case 'DDD':
      case 'DDDD':
        if (input != null) {
          config._dayOfYear = toInt(input);
        }
        break;
      case 'YY':
        datePartArray[YEAR] = moment.parseTwoDigitYear(input);
        break;
      case 'YYYY':
      case 'YYYYY':
      case 'YYYYYY':
        datePartArray[YEAR] = toInt(input);
        break;
      case 'a':
      case 'A':
        config._isPm = config._locale.isPM(input);
        break;
      case 'H':
      case 'HH':
      case 'h':
      case 'hh':
        datePartArray[HOUR] = toInt(input);
        break;
      case 'm':
      case 'mm':
        datePartArray[MINUTE] = toInt(input);
        break;
      case 's':
      case 'ss':
        datePartArray[SECOND] = toInt(input);
        break;
      case 'S':
      case 'SS':
      case 'SSS':
      case 'SSSS':
        datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
        break;
      case 'X':
        config._d = new Date(parseFloat(input) * 1000);
        break;
      case 'Z':
      case 'ZZ':
        config._useUTC = true;
        config._tzm = timezoneMinutesFromString(input);
        break;
      case 'dd':
      case 'ddd':
      case 'dddd':
        a = config._locale.weekdaysParse(input);
        if (a != null) {
          config._w = config._w || {};
          config._w['d'] = a;
        } else {
          config._pf.invalidWeekday = input;
        }
        break;
      case 'w':
      case 'ww':
      case 'W':
      case 'WW':
      case 'd':
      case 'e':
      case 'E':
        token = token.substr(0, 1);
      case 'gggg':
      case 'GGGG':
      case 'GGGGG':
        token = token.substr(0, 2);
        if (input) {
          config._w = config._w || {};
          config._w[token] = toInt(input);
        }
        break;
      case 'gg':
      case 'GG':
        config._w = config._w || {};
        config._w[token] = moment.parseTwoDigitYear(input);
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;
      weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
      week = dfl(w.W, 1);
      weekday = dfl(w.E, 1);
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
      week = dfl(w.w, 1);
      if (w.d != null) {
        weekday = w.d;
        if (weekday &lt; dow) {
          ++week;
        }
      } else if (w.e != null) {
        weekday = w.e + dow;
      } else {
        weekday = dow;
      }
    }
    temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }

  function dateFromConfig(config) {
    var i, date, input = [],
      currentDate, yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);
    if (config._w &amp;&amp; config._a[DATE] == null &amp;&amp; config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }
    if (config._dayOfYear) {
      yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear &gt; daysInYear(yearToUse)) {
        config._pf._overflowDayOfYear = true;
      }
      date = makeUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }
    for (i = 0; i &lt; 3 &amp;&amp; config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }
    for (; i &lt; 7; i++) {
      config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }
    config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
    }
  }

  function dateFromObject(config) {
    var normalizedInput;
    if (config._d) {
      return;
    }
    normalizedInput = normalizeObjectUnits(config._i);
    config._a = [
      normalizedInput.year,
      normalizedInput.month,
      normalizedInput.day,
      normalizedInput.hour,
      normalizedInput.minute,
      normalizedInput.second,
      normalizedInput.millisecond
    ];
    dateFromConfig(config);
  }

  function currentDateArray(config) {
    var now = new Date();
    if (config._useUTC) {
      return [
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate()
      ];
    } else {
      return [now.getFullYear(), now.getMonth(), now.getDate()];
    }
  }

  function makeDateFromStringAndFormat(config) {
    if (config._f === moment.ISO_8601) {
      parseISO(config);
      return;
    }
    config._a = [];
    config._pf.empty = true;
    var string = '' + config._i,
      i, parsedInput, tokens, token, skipped,
      stringLength = string.length,
      totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i &lt; tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length &gt; 0) {
          config._pf.unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          config._pf.empty = false;
        } else {
          config._pf.unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict &amp;&amp; !parsedInput) {
        config._pf.unusedTokens.push(token);
      }
    }
    config._pf.charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length &gt; 0) {
      config._pf.unusedInput.push(string);
    }
    if (config._isPm &amp;&amp; config._a[HOUR] &lt; 12) {
      config._a[HOUR] += 12;
    }
    if (config._isPm === false &amp;&amp; config._a[HOUR] === 12) {
      config._a[HOUR] = 0;
    }
    dateFromConfig(config);
    checkOverflow(config);
  }

  function unescapeFormat(s) {
    return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    });
  }

  function regexpEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;');
  }

  function makeDateFromStringAndArray(config) {
    var tempConfig,
      bestMoment,
      scoreToBeat,
      i,
      currentScore;
    if (config._f.length === 0) {
      config._pf.invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i &lt; config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._pf = defaultParsingFlags();
      tempConfig._f = config._f[i];
      makeDateFromStringAndFormat(tempConfig);
      if (!isValid(tempConfig)) {
        continue;
      }
      currentScore += tempConfig._pf.charsLeftOver;
      currentScore += tempConfig._pf.unusedTokens.length * 10;
      tempConfig._pf.score = currentScore;
      if (scoreToBeat == null || currentScore &lt; scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }

  function parseISO(config) {
    var i, l,
      string = config._i,
      match = isoRegex.exec(string);
    if (match) {
      config._pf.iso = true;
      for (i = 0, l = isoDates.length; i &lt; l; i++) {
        if (isoDates[i][1].exec(string)) {
          config._f = isoDates[i][0] + (match[6] || ' ');
          break;
        }
      }
      for (i = 0, l = isoTimes.length; i &lt; l; i++) {
        if (isoTimes[i][1].exec(string)) {
          config._f += isoTimes[i][0];
          break;
        }
      }
      if (string.match(parseTokenTimezone)) {
        config._f += 'Z';
      }
      makeDateFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }

  function makeDateFromString(config) {
    parseISO(config);
    if (config._isValid === false) {
      delete config._isValid;
      moment.createFromInputFallback(config);
    }
  }

  function map(arr, fn) {
    var res = [],
      i;
    for (i = 0; i &lt; arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }

  function makeDateFromInput(config) {
    var input = config._i,
      matched;
    if (input === undefined) {
      config._d = new Date();
    } else if (isDate(input)) {
      config._d = new Date(+input);
    } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
      config._d = new Date(+matched[1]);
    } else if (typeof input === 'string') {
      makeDateFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function(obj) {
        return parseInt(obj, 10);
      });
      dateFromConfig(config);
    } else if (typeof(input) === 'object') {
      dateFromObject(config);
    } else if (typeof(input) === 'number') {
      config._d = new Date(input);
    } else {
      moment.createFromInputFallback(config);
    }
  }

  function makeDate(y, m, d, h, M, s, ms) {
    var date = new Date(y, m, d, h, M, s, ms);
    if (y &lt; 1970) {
      date.setFullYear(y);
    }
    return date;
  }

  function makeUTCDate(y) {
    var date = new Date(Date.UTC.apply(null, arguments));
    if (y &lt; 1970) {
      date.setUTCFullYear(y);
    }
    return date;
  }

  function parseWeekday(input, locale) {
    if (typeof input === 'string') {
      if (!isNaN(input)) {
        input = parseInt(input, 10);
      } else {
        input = locale.weekdaysParse(input);
        if (typeof input !== 'number') {
          return null;
        }
      }
    }
    return input;
  }

  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime(posNegDuration, withoutSuffix, locale) {
    var duration = moment.duration(posNegDuration).abs(),
      seconds = round(duration.as('s')),
      minutes = round(duration.as('m')),
      hours = round(duration.as('h')),
      days = round(duration.as('d')),
      months = round(duration.as('M')),
      years = round(duration.as('y')),
      args = seconds &lt; relativeTimeThresholds.s &amp;&amp; ['s', seconds] ||
      minutes === 1 &amp;&amp; ['m'] ||
      minutes &lt; relativeTimeThresholds.m &amp;&amp; ['mm', minutes] ||
      hours === 1 &amp;&amp; ['h'] ||
      hours &lt; relativeTimeThresholds.h &amp;&amp; ['hh', hours] ||
      days === 1 &amp;&amp; ['d'] ||
      days &lt; relativeTimeThresholds.d &amp;&amp; ['dd', days] ||
      months === 1 &amp;&amp; ['M'] ||
      months &lt; relativeTimeThresholds.M &amp;&amp; ['MM', months] ||
      years === 1 &amp;&amp; ['y'] || ['yy', years];
    args[2] = withoutSuffix;
    args[3] = +posNegDuration &gt; 0;
    args[4] = locale;
    return substituteTimeAgo.apply({}, args);
  }

  function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
    var end = firstDayOfWeekOfYear - firstDayOfWeek,
      daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
      adjustedMoment;
    if (daysToDayOfWeek &gt; end) {
      daysToDayOfWeek -= 7;
    }
    if (daysToDayOfWeek &lt; end - 7) {
      daysToDayOfWeek += 7;
    }
    adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
    return {
      week: Math.ceil(adjustedMoment.dayOfYear() / 7),
      year: adjustedMoment.year()
    };
  }

  function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
    var d = makeUTCDate(year, 0, 1).getUTCDay(),
      daysToAdd, dayOfYear;
    d = d === 0 ? 7 : d;
    weekday = weekday != null ? weekday : firstDayOfWeek;
    daysToAdd = firstDayOfWeek - d + (d &gt; firstDayOfWeekOfYear ? 7 : 0) - (d &lt; firstDayOfWeek ? 7 : 0);
    dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
    return {
      year: dayOfYear &gt; 0 ? year : year - 1,
      dayOfYear: dayOfYear &gt; 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
    };
  }

  function makeMoment(config) {
    var input = config._i,
      format = config._f;
    config._locale = config._locale || moment.localeData(config._l);
    if (input === null || (format === undefined &amp;&amp; input === '')) {
      return moment.invalid({
        nullInput: true
      });
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (moment.isMoment(input)) {
      return new Moment(input, true);
    } else if (format) {
      if (isArray(format)) {
        makeDateFromStringAndArray(config);
      } else {
        makeDateFromStringAndFormat(config);
      }
    } else {
      makeDateFromInput(config);
    }
    return new Moment(config);
  }
  moment = function(input, format, locale, strict) {
    var c;
    if (typeof(locale) === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    c = {};
    c._isAMomentObject = true;
    c._i = input;
    c._f = format;
    c._l = locale;
    c._strict = strict;
    c._isUTC = false;
    c._pf = defaultParsingFlags();
    return makeMoment(c);
  };
  moment.suppressDeprecationWarnings = false;
  moment.createFromInputFallback = deprecate(
    'moment construction falls back to js Date. This is ' +
    'discouraged and will be removed in upcoming major ' +
    'release. Please refer to ' +
    'https://github.com/moment/moment/issues/1407 for more info.',
    function(config) {
      config._d = new Date(config._i);
    }
  );

  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 &amp;&amp; isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return moment();
    }
    res = moments[0];
    for (i = 1; i &lt; moments.length; ++i) {
      if (moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }
  moment.min = function() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  };
  moment.max = function() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  };
  moment.utc = function(input, format, locale, strict) {
    var c;
    if (typeof(locale) === 'boolean') {
      strict = locale;
      locale = undefined;
    }
    c = {};
    c._isAMomentObject = true;
    c._useUTC = true;
    c._isUTC = true;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    c._pf = defaultParsingFlags();
    return makeMoment(c).utc();
  };
  moment.unix = function(input) {
    return moment(input * 1000);
  };
  moment.duration = function(input, key) {
    var duration = input,
      match = null,
      sign,
      ret,
      parseIso,
      diffRes;
    if (moment.isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (typeof input === 'number') {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(match[MILLISECOND]) * sign
      };
    } else if (!!(match = isoDurationRegex.exec(input))) {
      sign = (match[1] === '-') ? -1 : 1;
      parseIso = function(inp) {
        var res = inp &amp;&amp; parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
      };
      duration = {
        y: parseIso(match[2]),
        M: parseIso(match[3]),
        d: parseIso(match[4]),
        h: parseIso(match[5]),
        m: parseIso(match[6]),
        s: parseIso(match[7]),
        w: parseIso(match[8])
      };
    } else if (typeof duration === 'object' &amp;&amp;
      ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(moment(duration.from), moment(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (moment.isDuration(input) &amp;&amp; hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  };
  moment.version = VERSION;
  moment.defaultFormat = isoFormat;
  moment.ISO_8601 = function() {};
  moment.momentProperties = momentProperties;
  moment.updateOffset = function() {};
  moment.relativeTimeThreshold = function(threshold, limit) {
    if (relativeTimeThresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return relativeTimeThresholds[threshold];
    }
    relativeTimeThresholds[threshold] = limit;
    return true;
  };
  moment.lang = deprecate(
    'moment.lang is deprecated. Use moment.locale instead.',
    function(key, value) {
      return moment.locale(key, value);
    }
  );
  moment.locale = function(key, values) {
    var data;
    if (key) {
      if (typeof(values) !== 'undefined') {
        data = moment.defineLocale(key, values);
      } else {
        data = moment.localeData(key);
      }
      if (data) {
        moment.duration._locale = moment._locale = data;
      }
    }
    return moment._locale._abbr;
  };
  moment.defineLocale = function(name, values) {
    if (values !== null) {
      values.abbr = name;
      if (!locales[name]) {
        locales[name] = new Locale();
      }
      locales[name].set(values);
      moment.locale(name);
      return locales[name];
    } else {
      delete locales[name];
      return null;
    }
  };
  moment.langData = deprecate(
    'moment.langData is deprecated. Use moment.localeData instead.',
    function(key) {
      return moment.localeData(key);
    }
  );
  moment.localeData = function(key) {
    var locale;
    if (key &amp;&amp; key._locale &amp;&amp; key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return moment._locale;
    }
    if (!isArray(key)) {
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  };
  moment.isMoment = function(obj) {
    return obj instanceof Moment ||
      (obj != null &amp;&amp; hasOwnProp(obj, '_isAMomentObject'));
  };
  moment.isDuration = function(obj) {
    return obj instanceof Duration;
  };
  for (i = lists.length - 1; i &gt;= 0; --i) {
    makeList(lists[i]);
  }
  moment.normalizeUnits = function(units) {
    return normalizeUnits(units);
  };
  moment.invalid = function(flags) {
    var m = moment.utc(NaN);
    if (flags != null) {
      extend(m._pf, flags);
    } else {
      m._pf.userInvalidated = true;
    }
    return m;
  };
  moment.parseZone = function() {
    return moment.apply(null, arguments).parseZone();
  };
  moment.parseTwoDigitYear = function(input) {
    return toInt(input) + (toInt(input) &gt; 68 ? 1900 : 2000);
  };
  extend(moment.fn = Moment.prototype, {
    clone: function() {
      return moment(this);
    },
    valueOf: function() {
      return +this._d + ((this._offset || 0) * 60000);
    },
    unix: function() {
      return Math.floor(+this / 1000);
    },
    toString: function() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    },
    toDate: function() {
      return this._offset ? new Date(+this) : this._d;
    },
    toISOString: function() {
      var m = moment(this).utc();
      if (0 &lt; m.year() &amp;&amp; m.year() &lt;= 9999) {
        return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
      }
    },
    toArray: function() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hours(),
        m.minutes(),
        m.seconds(),
        m.milliseconds()
      ];
    },
    isValid: function() {
      return isValid(this);
    },
    isDSTShifted: function() {
      if (this._a) {
        return this.isValid() &amp;&amp; compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) &gt; 0;
      }
      return false;
    },
    parsingFlags: function() {
      return extend({}, this._pf);
    },
    invalidAt: function() {
      return this._pf.overflow;
    },
    utc: function(keepLocalTime) {
      return this.zone(0, keepLocalTime);
    },
    local: function(keepLocalTime) {
      if (this._isUTC) {
        this.zone(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.add(this._dateTzOffset(), 'm');
        }
      }
      return this;
    },
    format: function(inputString) {
      var output = formatMoment(this, inputString || moment.defaultFormat);
      return this.localeData().postformat(output);
    },
    add: createAdder(1, 'add'),
    subtract: createAdder(-1, 'subtract'),
    diff: function(input, units, asFloat) {
      var that = makeAs(input, this),
        zoneDiff = (this.zone() - that.zone()) * 6e4,
        diff, output, daysAdjust;
      units = normalizeUnits(units);
      if (units === 'year' || units === 'month') {
        diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
        output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
        daysAdjust = (this - moment(this).startOf('month')) -
          (that - moment(that).startOf('month'));
        daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
          (that.zone() - moment(that).startOf('month').zone())) * 6e4;
        output += daysAdjust / diff;
        if (units === 'year') {
          output = output / 12;
        }
      } else {
        diff = (this - that);
        output = units === 'second' ? diff / 1e3 :
          units === 'minute' ? diff / 6e4 :
          units === 'hour' ? diff / 36e5 :
          units === 'day' ? (diff - zoneDiff) / 864e5 :
          units === 'week' ? (diff - zoneDiff) / 6048e5 :
          diff;
      }
      return asFloat ? output : absRound(output);
    },
    from: function(time, withoutSuffix) {
      return moment.duration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    },
    fromNow: function(withoutSuffix) {
      return this.from(moment(), withoutSuffix);
    },
    calendar: function(time) {
      var now = time || moment(),
        sod = makeAs(now, this).startOf('day'),
        diff = this.diff(sod, 'days', true),
        format = diff &lt; -6 ? 'sameElse' :
        diff &lt; -1 ? 'lastWeek' :
        diff &lt; 0 ? 'lastDay' :
        diff &lt; 1 ? 'sameDay' :
        diff &lt; 2 ? 'nextDay' :
        diff &lt; 7 ? 'nextWeek' : 'sameElse';
      return this.format(this.localeData().calendar(format, this));
    },
    isLeapYear: function() {
      return isLeapYear(this.year());
    },
    isDST: function() {
      return (this.zone() &lt; this.clone().month(0).zone() ||
        this.zone() &lt; this.clone().month(5).zone());
    },
    day: function(input) {
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    },
    month: makeAccessor('Month', true),
    startOf: function(units) {
      units = normalizeUnits(units);
      switch (units) {
        case 'year':
          this.month(0);
        case 'quarter':
        case 'month':
          this.date(1);
        case 'week':
        case 'isoWeek':
        case 'day':
          this.hours(0);
        case 'hour':
          this.minutes(0);
        case 'minute':
          this.seconds(0);
        case 'second':
          this.milliseconds(0);
      }
      if (units === 'week') {
        this.weekday(0);
      } else if (units === 'isoWeek') {
        this.isoWeekday(1);
      }
      if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
      }
      return this;
    },
    endOf: function(units) {
      units = normalizeUnits(units);
      return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    },
    isAfter: function(input, units) {
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = moment.isMoment(input) ? input : moment(input);
        return +this &gt; +input;
      } else {
        return +this.clone().startOf(units) &gt; +moment(input).startOf(units);
      }
    },
    isBefore: function(input, units) {
      units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
      if (units === 'millisecond') {
        input = moment.isMoment(input) ? input : moment(input);
        return +this &lt; +input;
      } else {
        return +this.clone().startOf(units) &lt; +moment(input).startOf(units);
      }
    },
    isSame: function(input, units) {
      units = normalizeUnits(units || 'millisecond');
      if (units === 'millisecond') {
        input = moment.isMoment(input) ? input : moment(input);
        return +this === +input;
      } else {
        return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
      }
    },
    min: deprecate(
      'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
      function(other) {
        other = moment.apply(null, arguments);
        return other &lt; this ? this : other;
      }
    ),
    max: deprecate(
      'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
      function(other) {
        other = moment.apply(null, arguments);
        return other &gt; this ? this : other;
      }
    ),
    zone: function(input, keepLocalTime) {
      var offset = this._offset || 0,
        localAdjust;
      if (input != null) {
        if (typeof input === 'string') {
          input = timezoneMinutesFromString(input);
        }
        if (Math.abs(input) &lt; 16) {
          input = input * 60;
        }
        if (!this._isUTC &amp;&amp; keepLocalTime) {
          localAdjust = this._dateTzOffset();
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.subtract(localAdjust, 'm');
        }
        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addOrSubtractDurationFromMoment(this,
              moment.duration(offset - input, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            moment.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
      } else {
        return this._isUTC ? offset : this._dateTzOffset();
      }
      return this;
    },
    zoneAbbr: function() {
      return this._isUTC ? 'UTC' : '';
    },
    zoneName: function() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    },
    parseZone: function() {
      if (this._tzm) {
        this.zone(this._tzm);
      } else if (typeof this._i === 'string') {
        this.zone(this._i);
      }
      return this;
    },
    hasAlignedHourOffset: function(input) {
      if (!input) {
        input = 0;
      } else {
        input = moment(input).zone();
      }
      return (this.zone() - input) % 60 === 0;
    },
    daysInMonth: function() {
      return daysInMonth(this.year(), this.month());
    },
    dayOfYear: function(input) {
      var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    },
    quarter: function(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    },
    weekYear: function(input) {
      var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
      return input == null ? year : this.add((input - year), 'y');
    },
    isoWeekYear: function(input) {
      var year = weekOfYear(this, 1, 4).year;
      return input == null ? year : this.add((input - year), 'y');
    },
    week: function(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    },
    isoWeek: function(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    },
    weekday: function(input) {
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    },
    isoWeekday: function(input) {
      return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    },
    isoWeeksInYear: function() {
      return weeksInYear(this.year(), 1, 4);
    },
    weeksInYear: function() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    },
    get: function(units) {
      units = normalizeUnits(units);
      return this[units]();
    },
    set: function(units, value) {
      units = normalizeUnits(units);
      if (typeof this[units] === 'function') {
        this[units](value);
      }
      return this;
    },
    locale: function(key) {
      var newLocaleData;
      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = moment.localeData(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    },
    lang: deprecate(
      'moment().lang() is deprecated. Use moment().localeData() instead.',
      function(key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    ),
    localeData: function() {
      return this._locale;
    },
    _dateTzOffset: function() {
      return Math.round(this._d.getTimezoneOffset() / 15) * 15;
    }
  });

  function rawMonthSetter(mom, value) {
    var dayOfMonth;
    if (typeof value === 'string') {
      value = mom.localeData().monthsParse(value);
      if (typeof value !== 'number') {
        return mom;
      }
    }
    dayOfMonth = Math.min(mom.date(),
      daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }

  function rawGetter(mom, unit) {
    return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
  }

  function rawSetter(mom, unit, value) {
    if (unit === 'Month') {
      return rawMonthSetter(mom, value);
    } else {
      return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
  }

  function makeAccessor(unit, keepTime) {
    return function(value) {
      if (value != null) {
        rawSetter(this, unit, value);
        moment.updateOffset(this, keepTime);
        return this;
      } else {
        return rawGetter(this, unit);
      }
    };
  }
  moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
  moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
  moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
  moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
  moment.fn.date = makeAccessor('Date', true);
  moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
  moment.fn.year = makeAccessor('FullYear', true);
  moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));
  moment.fn.days = moment.fn.day;
  moment.fn.months = moment.fn.month;
  moment.fn.weeks = moment.fn.week;
  moment.fn.isoWeeks = moment.fn.isoWeek;
  moment.fn.quarters = moment.fn.quarter;
  moment.fn.toJSON = moment.fn.toISOString;

  function daysToYears(days) {
    return days * 400 / 146097;
  }

  function yearsToDays(years) {
    return years * 146097 / 400;
  }
  extend(moment.duration.fn = Duration.prototype, {
    _bubble: function() {
      var milliseconds = this._milliseconds,
        days = this._days,
        months = this._months,
        data = this._data,
        seconds, minutes, hours, years = 0;
      data.milliseconds = milliseconds % 1000;
      seconds = absRound(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absRound(seconds / 60);
      data.minutes = minutes % 60;
      hours = absRound(minutes / 60);
      data.hours = hours % 24;
      days += absRound(hours / 24);
      years = absRound(daysToYears(days));
      days -= absRound(yearsToDays(years));
      months += absRound(days / 30);
      days %= 30;
      years += absRound(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
    },
    abs: function() {
      this._milliseconds = Math.abs(this._milliseconds);
      this._days = Math.abs(this._days);
      this._months = Math.abs(this._months);
      this._data.milliseconds = Math.abs(this._data.milliseconds);
      this._data.seconds = Math.abs(this._data.seconds);
      this._data.minutes = Math.abs(this._data.minutes);
      this._data.hours = Math.abs(this._data.hours);
      this._data.months = Math.abs(this._data.months);
      this._data.years = Math.abs(this._data.years);
      return this;
    },
    weeks: function() {
      return absRound(this.days() / 7);
    },
    valueOf: function() {
      return this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6;
    },
    humanize: function(withSuffix) {
      var output = relativeTime(this, !withSuffix, this.localeData());
      if (withSuffix) {
        output = this.localeData().pastFuture(+this, output);
      }
      return this.localeData().postformat(output);
    },
    add: function(input, val) {
      var dur = moment.duration(input, val);
      this._milliseconds += dur._milliseconds;
      this._days += dur._days;
      this._months += dur._months;
      this._bubble();
      return this;
    },
    subtract: function(input, val) {
      var dur = moment.duration(input, val);
      this._milliseconds -= dur._milliseconds;
      this._days -= dur._days;
      this._months -= dur._months;
      this._bubble();
      return this;
    },
    get: function(units) {
      units = normalizeUnits(units);
      return this[units.toLowerCase() + 's']();
    },
    as: function(units) {
      var days, months;
      units = normalizeUnits(units);
      if (units === 'month' || units === 'year') {
        days = this._days + this._milliseconds / 864e5;
        months = this._months + daysToYears(days) * 12;
        return units === 'month' ? months : months / 12;
      } else {
        days = this._days + yearsToDays(this._months / 12);
        switch (units) {
          case 'week':
            return days / 7 + this._milliseconds / 6048e5;
          case 'day':
            return days + this._milliseconds / 864e5;
          case 'hour':
            return days * 24 + this._milliseconds / 36e5;
          case 'minute':
            return days * 24 * 60 + this._milliseconds / 6e4;
          case 'second':
            return days * 24 * 60 * 60 + this._milliseconds / 1000;
          case 'millisecond':
            return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    },
    lang: moment.fn.lang,
    locale: moment.fn.locale,
    toIsoString: deprecate(
      'toIsoString() is deprecated. Please use toISOString() instead ' +
      '(notice the capitals)',
      function() {
        return this.toISOString();
      }
    ),
    toISOString: function() {
      var years = Math.abs(this.years()),
        months = Math.abs(this.months()),
        days = Math.abs(this.days()),
        hours = Math.abs(this.hours()),
        minutes = Math.abs(this.minutes()),
        seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);
      if (!this.asSeconds()) {
        return 'P0D';
      }
      return (this.asSeconds() &lt; 0 ? '-' : '') +
        'P' +
        (years ? years + 'Y' : '') +
        (months ? months + 'M' : '') +
        (days ? days + 'D' : '') +
        ((hours || minutes || seconds) ? 'T' : '') +
        (hours ? hours + 'H' : '') +
        (minutes ? minutes + 'M' : '') +
        (seconds ? seconds + 'S' : '');
    },
    localeData: function() {
      return this._locale;
    }
  });
  moment.duration.fn.toString = moment.duration.fn.toISOString;

  function makeDurationGetter(name) {
    moment.duration.fn[name] = function() {
      return this._data[name];
    };
  }
  for (i in unitMillisecondFactors) {
    if (hasOwnProp(unitMillisecondFactors, i)) {
      makeDurationGetter(i.toLowerCase());
    }
  }
  moment.duration.fn.asMilliseconds = function() {
    return this.as('ms');
  };
  moment.duration.fn.asSeconds = function() {
    return this.as('s');
  };
  moment.duration.fn.asMinutes = function() {
    return this.as('m');
  };
  moment.duration.fn.asHours = function() {
    return this.as('h');
  };
  moment.duration.fn.asDays = function() {
    return this.as('d');
  };
  moment.duration.fn.asWeeks = function() {
    return this.as('weeks');
  };
  moment.duration.fn.asMonths = function() {
    return this.as('M');
  };
  moment.duration.fn.asYears = function() {
    return this.as('y');
  };
  moment.locale('en', {
    ordinal: function(number) {
      var b = number % 10,
        output = (toInt(number % 100 / 10) === 1) ? 'th' :
        (b === 1) ? 'st' :
        (b === 2) ? 'nd' :
        (b === 3) ? 'rd' : 'th';
      return number + output;
    }
  });

  function makeGlobal(shouldDeprecate) {
    if (typeof ender !== 'undefined') {
      return;
    }
    oldGlobalMoment = globalScope.moment;
    if (shouldDeprecate) {
      globalScope.moment = deprecate(
        'Accessing Moment through the global scope is ' +
        'deprecated, and will be removed in an upcoming ' +
        'release.',
        moment);
    } else {
      globalScope.moment = moment;
    }
  }
  if (hasModule) {
    module.exports = moment;
  } else if (typeof define === 'function' &amp;&amp; define.amd) {
    define('moment', function(require, exports, module) {
      if (module.config &amp;&amp; module.config() &amp;&amp; module.config().noGlobal === true) {
        globalScope.moment = oldGlobalMoment;
      }
      return moment;
    });
    makeGlobal(true);
  } else {
    makeGlobal();
  }
}).call(this);;
/*! RESOURCE: /scripts/thirdparty/select2/select2.js */
(function($) {
  if (typeof $.fn.each2 == "undefined") {
    $.extend($.fn, {
      each2: function(c) {
        var j = $([0]),
          i = -1,
          l = this.length;
        while (
          ++i &lt; l &amp;&amp;
          (j.context = j[0] = this[i]) &amp;&amp;
          c.call(j[0], i, j) !== false
        );
        return this;
      }
    });
  }
})(jQuery);
(function($, undefined) {
  "use strict";
  if (window.Select2 !== undefined) {
    return;
  }
  var KEY, AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
    lastMousePosition = {
      x: 0,
      y: 0
    },
    $document, scrollBarDimensions,
    KEY = {
      TAB: 9,
      ENTER: 13,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      HOME: 36,
      END: 35,
      BACKSPACE: 8,
      DELETE: 46,
      isArrow: function(k) {
        k = k.which ? k.which : k;
        switch (k) {
          case KEY.LEFT:
          case KEY.RIGHT:
          case KEY.UP:
          case KEY.DOWN:
            return true;
        }
        return false;
      },
      isControl: function(e) {
        var k = e.which;
        switch (k) {
          case KEY.SHIFT:
          case KEY.CTRL:
          case KEY.ALT:
            return true;
        }
        if (e.metaKey) return true;
        return false;
      },
      isFunctionKey: function(k) {
        k = k.which ? k.which : k;
        return k &gt;= 112 &amp;&amp; k &lt;= 123;
      }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "&lt;div class='select2-measure-scrollbar'&gt;&lt;/div&gt;",
    DIACRITICS = {
      "\u24B6": "A",
      "\uFF21": "A",
      "\u00C0": "A",
      "\u00C1": "A",
      "\u00C2": "A",
      "\u1EA6": "A",
      "\u1EA4": "A",
      "\u1EAA": "A",
      "\u1EA8": "A",
      "\u00C3": "A",
      "\u0100": "A",
      "\u0102": "A",
      "\u1EB0": "A",
      "\u1EAE": "A",
      "\u1EB4": "A",
      "\u1EB2": "A",
      "\u0226": "A",
      "\u01E0": "A",
      "\u00C4": "A",
      "\u01DE": "A",
      "\u1EA2": "A",
      "\u00C5": "A",
      "\u01FA": "A",
      "\u01CD": "A",
      "\u0200": "A",
      "\u0202": "A",
      "\u1EA0": "A",
      "\u1EAC": "A",
      "\u1EB6": "A",
      "\u1E00": "A",
      "\u0104": "A",
      "\u023A": "A",
      "\u2C6F": "A",
      "\uA732": "AA",
      "\u00C6": "AE",
      "\u01FC": "AE",
      "\u01E2": "AE",
      "\uA734": "AO",
      "\uA736": "AU",
      "\uA738": "AV",
      "\uA73A": "AV",
      "\uA73C": "AY",
      "\u24B7": "B",
      "\uFF22": "B",
      "\u1E02": "B",
      "\u1E04": "B",
      "\u1E06": "B",
      "\u0243": "B",
      "\u0182": "B",
      "\u0181": "B",
      "\u24B8": "C",
      "\uFF23": "C",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u00C7": "C",
      "\u1E08": "C",
      "\u0187": "C",
      "\u023B": "C",
      "\uA73E": "C",
      "\u24B9": "D",
      "\uFF24": "D",
      "\u1E0A": "D",
      "\u010E": "D",
      "\u1E0C": "D",
      "\u1E10": "D",
      "\u1E12": "D",
      "\u1E0E": "D",
      "\u0110": "D",
      "\u018B": "D",
      "\u018A": "D",
      "\u0189": "D",
      "\uA779": "D",
      "\u01F1": "DZ",
      "\u01C4": "DZ",
      "\u01F2": "Dz",
      "\u01C5": "Dz",
      "\u24BA": "E",
      "\uFF25": "E",
      "\u00C8": "E",
      "\u00C9": "E",
      "\u00CA": "E",
      "\u1EC0": "E",
      "\u1EBE": "E",
      "\u1EC4": "E",
      "\u1EC2": "E",
      "\u1EBC": "E",
      "\u0112": "E",
      "\u1E14": "E",
      "\u1E16": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u00CB": "E",
      "\u1EBA": "E",
      "\u011A": "E",
      "\u0204": "E",
      "\u0206": "E",
      "\u1EB8": "E",
      "\u1EC6": "E",
      "\u0228": "E",
      "\u1E1C": "E",
      "\u0118": "E",
      "\u1E18": "E",
      "\u1E1A": "E",
      "\u0190": "E",
      "\u018E": "E",
      "\u24BB": "F",
      "\uFF26": "F",
      "\u1E1E": "F",
      "\u0191": "F",
      "\uA77B": "F",
      "\u24BC": "G",
      "\uFF27": "G",
      "\u01F4": "G",
      "\u011C": "G",
      "\u1E20": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u01E6": "G",
      "\u0122": "G",
      "\u01E4": "G",
      "\u0193": "G",
      "\uA7A0": "G",
      "\uA77D": "G",
      "\uA77E": "G",
      "\u24BD": "H",
      "\uFF28": "H",
      "\u0124": "H",
      "\u1E22": "H",
      "\u1E26": "H",
      "\u021E": "H",
      "\u1E24": "H",
      "\u1E28": "H",
      "\u1E2A": "H",
      "\u0126": "H",
      "\u2C67": "H",
      "\u2C75": "H",
      "\uA78D": "H",
      "\u24BE": "I",
      "\uFF29": "I",
      "\u00CC": "I",
      "\u00CD": "I",
      "\u00CE": "I",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u0130": "I",
      "\u00CF": "I",
      "\u1E2E": "I",
      "\u1EC8": "I",
      "\u01CF": "I",
      "\u0208": "I",
      "\u020A": "I",
      "\u1ECA": "I",
      "\u012E": "I",
      "\u1E2C": "I",
      "\u0197": "I",
      "\u24BF": "J",
      "\uFF2A": "J",
      "\u0134": "J",
      "\u0248": "J",
      "\u24C0": "K",
      "\uFF2B": "K",
      "\u1E30": "K",
      "\u01E8": "K",
      "\u1E32": "K",
      "\u0136": "K",
      "\u1E34": "K",
      "\u0198": "K",
      "\u2C69": "K",
      "\uA740": "K",
      "\uA742": "K",
      "\uA744": "K",
      "\uA7A2": "K",
      "\u24C1": "L",
      "\uFF2C": "L",
      "\u013F": "L",
      "\u0139": "L",
      "\u013D": "L",
      "\u1E36": "L",
      "\u1E38": "L",
      "\u013B": "L",
      "\u1E3C": "L",
      "\u1E3A": "L",
      "\u0141": "L",
      "\u023D": "L",
      "\u2C62": "L",
      "\u2C60": "L",
      "\uA748": "L",
      "\uA746": "L",
      "\uA780": "L",
      "\u01C7": "LJ",
      "\u01C8": "Lj",
      "\u24C2": "M",
      "\uFF2D": "M",
      "\u1E3E": "M",
      "\u1E40": "M",
      "\u1E42": "M",
      "\u2C6E": "M",
      "\u019C": "M",
      "\u24C3": "N",
      "\uFF2E": "N",
      "\u01F8": "N",
      "\u0143": "N",
      "\u00D1": "N",
      "\u1E44": "N",
      "\u0147": "N",
      "\u1E46": "N",
      "\u0145": "N",
      "\u1E4A": "N",
      "\u1E48": "N",
      "\u0220": "N",
      "\u019D": "N",
      "\uA790": "N",
      "\uA7A4": "N",
      "\u01CA": "NJ",
      "\u01CB": "Nj",
      "\u24C4": "O",
      "\uFF2F": "O",
      "\u00D2": "O",
      "\u00D3": "O",
      "\u00D4": "O",
      "\u1ED2": "O",
      "\u1ED0": "O",
      "\u1ED6": "O",
      "\u1ED4": "O",
      "\u00D5": "O",
      "\u1E4C": "O",
      "\u022C": "O",
      "\u1E4E": "O",
      "\u014C": "O",
      "\u1E50": "O",
      "\u1E52": "O",
      "\u014E": "O",
      "\u022E": "O",
      "\u0230": "O",
      "\u00D6": "O",
      "\u022A": "O",
      "\u1ECE": "O",
      "\u0150": "O",
      "\u01D1": "O",
      "\u020C": "O",
      "\u020E": "O",
      "\u01A0": "O",
      "\u1EDC": "O",
      "\u1EDA": "O",
      "\u1EE0": "O",
      "\u1EDE": "O",
      "\u1EE2": "O",
      "\u1ECC": "O",
      "\u1ED8": "O",
      "\u01EA": "O",
      "\u01EC": "O",
      "\u00D8": "O",
      "\u01FE": "O",
      "\u0186": "O",
      "\u019F": "O",
      "\uA74A": "O",
      "\uA74C": "O",
      "\u01A2": "OI",
      "\uA74E": "OO",
      "\u0222": "OU",
      "\u24C5": "P",
      "\uFF30": "P",
      "\u1E54": "P",
      "\u1E56": "P",
      "\u01A4": "P",
      "\u2C63": "P",
      "\uA750": "P",
      "\uA752": "P",
      "\uA754": "P",
      "\u24C6": "Q",
      "\uFF31": "Q",
      "\uA756": "Q",
      "\uA758": "Q",
      "\u024A": "Q",
      "\u24C7": "R",
      "\uFF32": "R",
      "\u0154": "R",
      "\u1E58": "R",
      "\u0158": "R",
      "\u0210": "R",
      "\u0212": "R",
      "\u1E5A": "R",
      "\u1E5C": "R",
      "\u0156": "R",
      "\u1E5E": "R",
      "\u024C": "R",
      "\u2C64": "R",
      "\uA75A": "R",
      "\uA7A6": "R",
      "\uA782": "R",
      "\u24C8": "S",
      "\uFF33": "S",
      "\u1E9E": "S",
      "\u015A": "S",
      "\u1E64": "S",
      "\u015C": "S",
      "\u1E60": "S",
      "\u0160": "S",
      "\u1E66": "S",
      "\u1E62": "S",
      "\u1E68": "S",
      "\u0218": "S",
      "\u015E": "S",
      "\u2C7E": "S",
      "\uA7A8": "S",
      "\uA784": "S",
      "\u24C9": "T",
      "\uFF34": "T",
      "\u1E6A": "T",
      "\u0164": "T",
      "\u1E6C": "T",
      "\u021A": "T",
      "\u0162": "T",
      "\u1E70": "T",
      "\u1E6E": "T",
      "\u0166": "T",
      "\u01AC": "T",
      "\u01AE": "T",
      "\u023E": "T",
      "\uA786": "T",
      "\uA728": "TZ",
      "\u24CA": "U",
      "\uFF35": "U",
      "\u00D9": "U",
      "\u00DA": "U",
      "\u00DB": "U",
      "\u0168": "U",
      "\u1E78": "U",
      "\u016A": "U",
      "\u1E7A": "U",
      "\u016C": "U",
      "\u00DC": "U",
      "\u01DB": "U",
      "\u01D7": "U",
      "\u01D5": "U",
      "\u01D9": "U",
      "\u1EE6": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u01D3": "U",
      "\u0214": "U",
      "\u0216": "U",
      "\u01AF": "U",
      "\u1EEA": "U",
      "\u1EE8": "U",
      "\u1EEE": "U",
      "\u1EEC": "U",
      "\u1EF0": "U",
      "\u1EE4": "U",
      "\u1E72": "U",
      "\u0172": "U",
      "\u1E76": "U",
      "\u1E74": "U",
      "\u0244": "U",
      "\u24CB": "V",
      "\uFF36": "V",
      "\u1E7C": "V",
      "\u1E7E": "V",
      "\u01B2": "V",
      "\uA75E": "V",
      "\u0245": "V",
      "\uA760": "VY",
      "\u24CC": "W",
      "\uFF37": "W",
      "\u1E80": "W",
      "\u1E82": "W",
      "\u0174": "W",
      "\u1E86": "W",
      "\u1E84": "W",
      "\u1E88": "W",
      "\u2C72": "W",
      "\u24CD": "X",
      "\uFF38": "X",
      "\u1E8A": "X",
      "\u1E8C": "X",
      "\u24CE": "Y",
      "\uFF39": "Y",
      "\u1EF2": "Y",
      "\u00DD": "Y",
      "\u0176": "Y",
      "\u1EF8": "Y",
      "\u0232": "Y",
      "\u1E8E": "Y",
      "\u0178": "Y",
      "\u1EF6": "Y",
      "\u1EF4": "Y",
      "\u01B3": "Y",
      "\u024E": "Y",
      "\u1EFE": "Y",
      "\u24CF": "Z",
      "\uFF3A": "Z",
      "\u0179": "Z",
      "\u1E90": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u1E92": "Z",
      "\u1E94": "Z",
      "\u01B5": "Z",
      "\u0224": "Z",
      "\u2C7F": "Z",
      "\u2C6B": "Z",
      "\uA762": "Z",
      "\u24D0": "a",
      "\uFF41": "a",
      "\u1E9A": "a",
      "\u00E0": "a",
      "\u00E1": "a",
      "\u00E2": "a",
      "\u1EA7": "a",
      "\u1EA5": "a",
      "\u1EAB": "a",
      "\u1EA9": "a",
      "\u00E3": "a",
      "\u0101": "a",
      "\u0103": "a",
      "\u1EB1": "a",
      "\u1EAF": "a",
      "\u1EB5": "a",
      "\u1EB3": "a",
      "\u0227": "a",
      "\u01E1": "a",
      "\u00E4": "a",
      "\u01DF": "a",
      "\u1EA3": "a",
      "\u00E5": "a",
      "\u01FB": "a",
      "\u01CE": "a",
      "\u0201": "a",
      "\u0203": "a",
      "\u1EA1": "a",
      "\u1EAD": "a",
      "\u1EB7": "a",
      "\u1E01": "a",
      "\u0105": "a",
      "\u2C65": "a",
      "\u0250": "a",
      "\uA733": "aa",
      "\u00E6": "ae",
      "\u01FD": "ae",
      "\u01E3": "ae",
      "\uA735": "ao",
      "\uA737": "au",
      "\uA739": "av",
      "\uA73B": "av",
      "\uA73D": "ay",
      "\u24D1": "b",
      "\uFF42": "b",
      "\u1E03": "b",
      "\u1E05": "b",
      "\u1E07": "b",
      "\u0180": "b",
      "\u0183": "b",
      "\u0253": "b",
      "\u24D2": "c",
      "\uFF43": "c",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u00E7": "c",
      "\u1E09": "c",
      "\u0188": "c",
      "\u023C": "c",
      "\uA73F": "c",
      "\u2184": "c",
      "\u24D3": "d",
      "\uFF44": "d",
      "\u1E0B": "d",
      "\u010F": "d",
      "\u1E0D": "d",
      "\u1E11": "d",
      "\u1E13": "d",
      "\u1E0F": "d",
      "\u0111": "d",
      "\u018C": "d",
      "\u0256": "d",
      "\u0257": "d",
      "\uA77A": "d",
      "\u01F3": "dz",
      "\u01C6": "dz",
      "\u24D4": "e",
      "\uFF45": "e",
      "\u00E8": "e",
      "\u00E9": "e",
      "\u00EA": "e",
      "\u1EC1": "e",
      "\u1EBF": "e",
      "\u1EC5": "e",
      "\u1EC3": "e",
      "\u1EBD": "e",
      "\u0113": "e",
      "\u1E15": "e",
      "\u1E17": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u00EB": "e",
      "\u1EBB": "e",
      "\u011B": "e",
      "\u0205": "e",
      "\u0207": "e",
      "\u1EB9": "e",
      "\u1EC7": "e",
      "\u0229": "e",
      "\u1E1D": "e",
      "\u0119": "e",
      "\u1E19": "e",
      "\u1E1B": "e",
      "\u0247": "e",
      "\u025B": "e",
      "\u01DD": "e",
      "\u24D5": "f",
      "\uFF46": "f",
      "\u1E1F": "f",
      "\u0192": "f",
      "\uA77C": "f",
      "\u24D6": "g",
      "\uFF47": "g",
      "\u01F5": "g",
      "\u011D": "g",
      "\u1E21": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u01E7": "g",
      "\u0123": "g",
      "\u01E5": "g",
      "\u0260": "g",
      "\uA7A1": "g",
      "\u1D79": "g",
      "\uA77F": "g",
      "\u24D7": "h",
      "\uFF48": "h",
      "\u0125": "h",
      "\u1E23": "h",
      "\u1E27": "h",
      "\u021F": "h",
      "\u1E25": "h",
      "\u1E29": "h",
      "\u1E2B": "h",
      "\u1E96": "h",
      "\u0127": "h",
      "\u2C68": "h",
      "\u2C76": "h",
      "\u0265": "h",
      "\u0195": "hv",
      "\u24D8": "i",
      "\uFF49": "i",
      "\u00EC": "i",
      "\u00ED": "i",
      "\u00EE": "i",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u00EF": "i",
      "\u1E2F": "i",
      "\u1EC9": "i",
      "\u01D0": "i",
      "\u0209": "i",
      "\u020B": "i",
      "\u1ECB": "i",
      "\u012F": "i",
      "\u1E2D": "i",
      "\u0268": "i",
      "\u0131": "i",
      "\u24D9": "j",
      "\uFF4A": "j",
      "\u0135": "j",
      "\u01F0": "j",
      "\u0249": "j",
      "\u24DA": "k",
      "\uFF4B": "k",
      "\u1E31": "k",
      "\u01E9": "k",
      "\u1E33": "k",
      "\u0137": "k",
      "\u1E35": "k",
      "\u0199": "k",
      "\u2C6A": "k",
      "\uA741": "k",
      "\uA743": "k",
      "\uA745": "k",
      "\uA7A3": "k",
      "\u24DB": "l",
      "\uFF4C": "l",
      "\u0140": "l",
      "\u013A": "l",
      "\u013E": "l",
      "\u1E37": "l",
      "\u1E39": "l",
      "\u013C": "l",
      "\u1E3D": "l",
      "\u1E3B": "l",
      "\u017F": "l",
      "\u0142": "l",
      "\u019A": "l",
      "\u026B": "l",
      "\u2C61": "l",
      "\uA749": "l",
      "\uA781": "l",
      "\uA747": "l",
      "\u01C9": "lj",
      "\u24DC": "m",
      "\uFF4D": "m",
      "\u1E3F": "m",
      "\u1E41": "m",
      "\u1E43": "m",
      "\u0271": "m",
      "\u026F": "m",
      "\u24DD": "n",
      "\uFF4E": "n",
      "\u01F9": "n",
      "\u0144": "n",
      "\u00F1": "n",
      "\u1E45": "n",
      "\u0148": "n",
      "\u1E47": "n",
      "\u0146": "n",
      "\u1E4B": "n",
      "\u1E49": "n",
      "\u019E": "n",
      "\u0272": "n",
      "\u0149": "n",
      "\uA791": "n",
      "\uA7A5": "n",
      "\u01CC": "nj",
      "\u24DE": "o",
      "\uFF4F": "o",
      "\u00F2": "o",
      "\u00F3": "o",
      "\u00F4": "o",
      "\u1ED3": "o",
      "\u1ED1": "o",
      "\u1ED7": "o",
      "\u1ED5": "o",
      "\u00F5": "o",
      "\u1E4D": "o",
      "\u022D": "o",
      "\u1E4F": "o",
      "\u014D": "o",
      "\u1E51": "o",
      "\u1E53": "o",
      "\u014F": "o",
      "\u022F": "o",
      "\u0231": "o",
      "\u00F6": "o",
      "\u022B": "o",
      "\u1ECF": "o",
      "\u0151": "o",
      "\u01D2": "o",
      "\u020D": "o",
      "\u020F": "o",
      "\u01A1": "o",
      "\u1EDD": "o",
      "\u1EDB": "o",
      "\u1EE1": "o",
      "\u1EDF": "o",
      "\u1EE3": "o",
      "\u1ECD": "o",
      "\u1ED9": "o",
      "\u01EB": "o",
      "\u01ED": "o",
      "\u00F8": "o",
      "\u01FF": "o",
      "\u0254": "o",
      "\uA74B": "o",
      "\uA74D": "o",
      "\u0275": "o",
      "\u01A3": "oi",
      "\u0223": "ou",
      "\uA74F": "oo",
      "\u24DF": "p",
      "\uFF50": "p",
      "\u1E55": "p",
      "\u1E57": "p",
      "\u01A5": "p",
      "\u1D7D": "p",
      "\uA751": "p",
      "\uA753": "p",
      "\uA755": "p",
      "\u24E0": "q",
      "\uFF51": "q",
      "\u024B": "q",
      "\uA757": "q",
      "\uA759": "q",
      "\u24E1": "r",
      "\uFF52": "r",
      "\u0155": "r",
      "\u1E59": "r",
      "\u0159": "r",
      "\u0211": "r",
      "\u0213": "r",
      "\u1E5B": "r",
      "\u1E5D": "r",
      "\u0157": "r",
      "\u1E5F": "r",
      "\u024D": "r",
      "\u027D": "r",
      "\uA75B": "r",
      "\uA7A7": "r",
      "\uA783": "r",
      "\u24E2": "s",
      "\uFF53": "s",
      "\u00DF": "s",
      "\u015B": "s",
      "\u1E65": "s",
      "\u015D": "s",
      "\u1E61": "s",
      "\u0161": "s",
      "\u1E67": "s",
      "\u1E63": "s",
      "\u1E69": "s",
      "\u0219": "s",
      "\u015F": "s",
      "\u023F": "s",
      "\uA7A9": "s",
      "\uA785": "s",
      "\u1E9B": "s",
      "\u24E3": "t",
      "\uFF54": "t",
      "\u1E6B": "t",
      "\u1E97": "t",
      "\u0165": "t",
      "\u1E6D": "t",
      "\u021B": "t",
      "\u0163": "t",
      "\u1E71": "t",
      "\u1E6F": "t",
      "\u0167": "t",
      "\u01AD": "t",
      "\u0288": "t",
      "\u2C66": "t",
      "\uA787": "t",
      "\uA729": "tz",
      "\u24E4": "u",
      "\uFF55": "u",
      "\u00F9": "u",
      "\u00FA": "u",
      "\u00FB": "u",
      "\u0169": "u",
      "\u1E79": "u",
      "\u016B": "u",
      "\u1E7B": "u",
      "\u016D": "u",
      "\u00FC": "u",
      "\u01DC": "u",
      "\u01D8": "u",
      "\u01D6": "u",
      "\u01DA": "u",
      "\u1EE7": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u01D4": "u",
      "\u0215": "u",
      "\u0217": "u",
      "\u01B0": "u",
      "\u1EEB": "u",
      "\u1EE9": "u",
      "\u1EEF": "u",
      "\u1EED": "u",
      "\u1EF1": "u",
      "\u1EE5": "u",
      "\u1E73": "u",
      "\u0173": "u",
      "\u1E77": "u",
      "\u1E75": "u",
      "\u0289": "u",
      "\u24E5": "v",
      "\uFF56": "v",
      "\u1E7D": "v",
      "\u1E7F": "v",
      "\u028B": "v",
      "\uA75F": "v",
      "\u028C": "v",
      "\uA761": "vy",
      "\u24E6": "w",
      "\uFF57": "w",
      "\u1E81": "w",
      "\u1E83": "w",
      "\u0175": "w",
      "\u1E87": "w",
      "\u1E85": "w",
      "\u1E98": "w",
      "\u1E89": "w",
      "\u2C73": "w",
      "\u24E7": "x",
      "\uFF58": "x",
      "\u1E8B": "x",
      "\u1E8D": "x",
      "\u24E8": "y",
      "\uFF59": "y",
      "\u1EF3": "y",
      "\u00FD": "y",
      "\u0177": "y",
      "\u1EF9": "y",
      "\u0233": "y",
      "\u1E8F": "y",
      "\u00FF": "y",
      "\u1EF7": "y",
      "\u1E99": "y",
      "\u1EF5": "y",
      "\u01B4": "y",
      "\u024F": "y",
      "\u1EFF": "y",
      "\u24E9": "z",
      "\uFF5A": "z",
      "\u017A": "z",
      "\u1E91": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u1E93": "z",
      "\u1E95": "z",
      "\u01B6": "z",
      "\u0225": "z",
      "\u0240": "z",
      "\u2C6C": "z",
      "\uA763": "z",
      "\u0386": "\u0391",
      "\u0388": "\u0395",
      "\u0389": "\u0397",
      "\u038A": "\u0399",
      "\u03AA": "\u0399",
      "\u038C": "\u039F",
      "\u038E": "\u03A5",
      "\u03AB": "\u03A5",
      "\u038F": "\u03A9",
      "\u03AC": "\u03B1",
      "\u03AD": "\u03B5",
      "\u03AE": "\u03B7",
      "\u03AF": "\u03B9",
      "\u03CA": "\u03B9",
      "\u0390": "\u03B9",
      "\u03CC": "\u03BF",
      "\u03CD": "\u03C5",
      "\u03CB": "\u03C5",
      "\u03B0": "\u03C5",
      "\u03C9": "\u03C9",
      "\u03C2": "\u03C3"
    };
  $document = $(document);
  nextUid = (function() {
    var counter = 1;
    return function() {
      return counter++;
    };
  }());

  function reinsertElement(element) {
    var placeholder = $(document.createTextNode(''));
    element.before(placeholder);
    placeholder.before(element);
    placeholder.remove();
  }

  function stripDiacritics(str) {
    function match(a) {
      return DIACRITICS[a] || a;
    }
    return str.replace(/[^\u0000-\u007E]/g, match);
  }

  function indexOf(value, array) {
    var i = 0,
      l = array.length;
    for (; i &lt; l; i = i + 1) {
      if (equal(value, array[i])) return i;
    }
    return -1;
  }

  function measureScrollbar() {
    var $template = $(MEASURE_SCROLLBAR_TEMPLATE);
    $template.appendTo('body');
    var dim = {
      width: $template.width() - $template[0].clientWidth,
      height: $template.height() - $template[0].clientHeight
    };
    $template.remove();
    return dim;
  }

  function equal(a, b) {
    if (a === b) return true;
    if (a === undefined || b === undefined) return false;
    if (a === null || b === null) return false;
    if (a.constructor === String) return a + '' === b + '';
    if (b.constructor === String) return b + '' === a + '';
    return false;
  }

  function splitVal(string, separator) {
    var val, i, l;
    if (string === null || string.length &lt; 1) return [];
    val = string.split(separator);
    for (i = 0, l = val.length; i &lt; l; i = i + 1) val[i] = $.trim(val[i]);
    return val;
  }

  function getSideBorderPadding(element) {
    return element.outerWidth(false) - element.width();
  }

  function installKeyUpChangeEvent(element) {
    var key = "keyup-change-value";
    element.on("keydown", function() {
      if ($.data(element, key) === undefined) {
        $.data(element, key, element.val());
      }
    });
    element.on("keyup", function() {
      var val = $.data(element, key);
      if (val !== undefined &amp;&amp; element.val() !== val) {
        $.removeData(element, key);
        element.trigger("keyup-change");
      }
    });
  }

  function installFilteredMouseMove(element) {
    element.on("mousemove", function(e) {
      var lastpos = lastMousePosition;
      if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
        $(e.target).trigger("mousemove-filtered", e);
      }
    });
  }

  function debounce(quietMillis, fn, ctx) {
    ctx = ctx || undefined;
    var timeout;
    return function() {
      var args = arguments;
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function() {
        fn.apply(ctx, args);
      }, quietMillis);
    };
  }

  function installDebouncedScroll(threshold, element) {
    var notify = debounce(threshold, function(e) {
      element.trigger("scroll-debounced", e);
    });
    element.on("scroll", function(e) {
      if (indexOf(e.target, element.get()) &gt;= 0) notify(e);
    });
  }

  function focus($el) {
    if ($el[0] === document.activeElement) return;
    window.setTimeout(function() {
      var el = $el[0],
        pos = $el.val().length,
        range;
      $el.focus();
      var isVisible = (el.offsetWidth &gt; 0 || el.offsetHeight &gt; 0);
      if (isVisible &amp;&amp; el === document.activeElement) {
        if (el.setSelectionRange) {
          el.setSelectionRange(pos, pos);
        } else if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
      }
    }, 0);
  }

  function getCursorInfo(el) {
    el = $(el)[0];
    var offset = 0;
    var length = 0;
    if ('selectionStart' in el) {
      offset = el.selectionStart;
      length = el.selectionEnd - offset;
    } else if ('selection' in document) {
      el.focus();
      var sel = document.selection.createRange();
      length = document.selection.createRange().text.length;
      sel.moveStart('character', -el.value.length);
      offset = sel.text.length - length;
    }
    return {
      offset: offset,
      length: length
    };
  }

  function killEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function killEventImmediately(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  function measureTextWidth(e) {
    if (!sizer) {
      var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
      sizer = $(document.createElement("div")).css({
        position: "absolute",
        left: "-10000px",
        top: "-10000px",
        display: "none",
        fontSize: style.fontSize,
        fontFamily: style.fontFamily,
        fontStyle: style.fontStyle,
        fontWeight: style.fontWeight,
        letterSpacing: style.letterSpacing,
        textTransform: style.textTransform,
        whiteSpace: "nowrap"
      });
      sizer.attr("class", "select2-sizer");
      $("body").append(sizer);
    }
    sizer.text(e.val());
    return sizer.width();
  }

  function syncCssClasses(dest, src, adapter) {
    var classes, replacements = [],
      adapted;
    classes = $.trim(dest.attr("class"));
    if (classes) {
      classes = '' + classes;
      $(classes.split(/\s+/)).each2(function() {
        if (this.indexOf("select2-") === 0) {
          replacements.push(this);
        }
      });
    }
    classes = $.trim(src.attr("class"));
    if (classes) {
      classes = '' + classes;
      $(classes.split(/\s+/)).each2(function() {
        if (this.indexOf("select2-") !== 0) {
          adapted = adapter(this);
          if (adapted) {
            replacements.push(adapted);
          }
        }
      });
    }
    dest.attr("class", replacements.join(" "));
  }

  function markMatch(text, term, markup, escapeMarkup) {
    var match = stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
      tl = term.length;
    if (match &lt; 0) {
      markup.push(escapeMarkup(text));
      return;
    }
    markup.push(escapeMarkup(text.substring(0, match)));
    markup.push("&lt;span class='select2-match'&gt;");
    markup.push(escapeMarkup(text.substring(match, match + tl)));
    markup.push("&lt;/span&gt;");
    markup.push(escapeMarkup(text.substring(match + tl, text.length)));
  }

  function defaultEscapeMarkup(markup) {
    var replace_map = {
      '\\': '&amp;#92;',
      '&amp;': '&amp;amp;',
      '&lt;': '&amp;lt;',
      '&gt;': '&amp;gt;',
      '"': '&amp;quot;',
      "'": '&amp;#39;',
      "/": '&amp;#47;'
    };
    return String(markup).replace(/[&amp;&lt;&gt;"'\/\\]/g, function(match) {
      return replace_map[match];
    });
  }

  function ajax(options) {
    var timeout,
      handler = null,
      quietMillis = options.quietMillis || 100,
      ajaxUrl = options.url,
      self = this;
    return function(query) {
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function() {
        var data = options.data,
          url = ajaxUrl,
          transport = options.transport || $.fn.select2.ajaxDefaults.transport,
          deprecated = {
            type: options.type || 'GET',
            cache: options.cache || false,
            jsonpCallback: options.jsonpCallback || undefined,
            dataType: options.dataType || "json"
          },
          params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);
        data = data ? data.call(self, query.term, query.page, query.context) : null;
        url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;
        if (handler &amp;&amp; typeof handler.abort === "function") {
          handler.abort();
        }
        if (options.params) {
          if ($.isFunction(options.params)) {
            $.extend(params, options.params.call(self));
          } else {
            $.extend(params, options.params);
          }
        }
        $.extend(params, {
          url: url,
          dataType: options.dataType,
          data: data,
          success: function(data) {
            var results = options.results(data, query.page, query);
            query.callback(results);
          },
          error: function(jqXHR, textStatus, errorThrown) {
            var results = {
              hasError: true,
              jqXHR: jqXHR,
              textStatus: textStatus,
              errorThrown: errorThrown,
            };
            query.callback(results);
          }
        });
        handler = transport.call(self, params);
      }, quietMillis);
    };
  }

  function local(options) {
    var data = options,
      dataText,
      tmp,
      text = function(item) {
        return "" + item.text;
      };
    if ($.isArray(data)) {
      tmp = data;
      data = {
        results: tmp
      };
    }
    if ($.isFunction(data) === false) {
      tmp = data;
      data = function() {
        return tmp;
      };
    }
    var dataItem = data();
    if (dataItem.text) {
      text = dataItem.text;
      if (!$.isFunction(text)) {
        dataText = dataItem.text;
        text = function(item) {
          return item[dataText];
        };
      }
    }
    return function(query) {
      var t = query.term,
        filtered = {
          results: []
        },
        process;
      if (t === "") {
        query.callback(data());
        return;
      }
      process = function(datum, collection) {
        var group, attr;
        datum = datum[0];
        if (datum.children) {
          group = {};
          for (attr in datum) {
            if (datum.hasOwnProperty(attr)) group[attr] = datum[attr];
          }
          group.children = [];
          $(datum.children).each2(function(i, childDatum) {
            process(childDatum, group.children);
          });
          if (group.children.length || query.matcher(t, text(group), datum)) {
            collection.push(group);
          }
        } else {
          if (query.matcher(t, text(datum), datum)) {
            collection.push(datum);
          }
        }
      };
      $(data().results).each2(function(i, datum) {
        process(datum, filtered.results);
      });
      query.callback(filtered);
    };
  }

  function tags(data) {
    var isFunc = $.isFunction(data);
    return function(query) {
      var t = query.term,
        filtered = {
          results: []
        };
      var result = isFunc ? data(query) : data;
      if ($.isArray(result)) {
        $(result).each(function() {
          var isObject = this.text !== undefined,
            text = isObject ? this.text : this;
          if (t === "" || query.matcher(t, text)) {
            filtered.results.push(isObject ? this : {
              id: this,
              text: this
            });
          }
        });
        query.callback(filtered);
      }
    };
  }

  function checkFormatter(formatter, formatterName) {
    if ($.isFunction(formatter)) return true;
    if (!formatter) return false;
    if (typeof(formatter) === 'string') return true;
    throw new Error(formatterName + " must be a string, function, or falsy value");
  }

  function evaluate(val, context) {
    if ($.isFunction(val)) {
      var args = Array.prototype.slice.call(arguments, 2);
      return val.apply(context, args);
    }
    return val;
  }

  function countResults(results) {
    var count = 0;
    $.each(results, function(i, item) {
      if (item.children) {
        count += countResults(item.children);
      } else {
        count++;
      }
    });
    return count;
  }

  function defaultTokenizer(input, selection, selectCallback, opts) {
    var original = input,
      dupe = false,
      token,
      index,
      i, l,
      separator;
    if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length &lt; 1) return undefined;
    while (true) {
      index = -1;
      for (i = 0, l = opts.tokenSeparators.length; i &lt; l; i++) {
        separator = opts.tokenSeparators[i];
        index = input.indexOf(separator);
        if (index &gt;= 0) break;
      }
      if (index &lt; 0) break;
      token = input.substring(0, index);
      input = input.substring(index + separator.length);
      if (token.length &gt; 0) {
        token = opts.createSearchChoice.call(this, token, selection);
        if (token !== undefined &amp;&amp; token !== null &amp;&amp; opts.id(token) !== undefined &amp;&amp; opts.id(token) !== null) {
          dupe = false;
          for (i = 0, l = selection.length; i &lt; l; i++) {
            if (equal(opts.id(token), opts.id(selection[i]))) {
              dupe = true;
              break;
            }
          }
          if (!dupe) selectCallback(token);
        }
      }
    }
    if (original !== input) return input;
  }

  function cleanupJQueryElements() {
    var self = this;
    $.each(arguments, function(i, element) {
      self[element].remove();
      self[element] = null;
    });
  }

  function clazz(SuperClass, methods) {
    var constructor = function() {};
    constructor.prototype = new SuperClass;
    constructor.prototype.constructor = constructor;
    constructor.prototype.parent = SuperClass.prototype;
    constructor.prototype = $.extend(constructor.prototype, methods);
    return constructor;
  }
  AbstractSelect2 = clazz(Object, {
    bind: function(func) {
      var self = this;
      return function() {
        func.apply(self, arguments);
      };
    },
    init: function(opts) {
      var results, search, resultsSelector = ".select2-results";
      this.opts = opts = this.prepareOpts(opts);
      this.id = opts.id;
      if (opts.element.data("select2") !== undefined &amp;&amp;
        opts.element.data("select2") !== null) {
        opts.element.data("select2").destroy();
      }
      this.container = this.createContainer();
      this.liveRegion = $("&lt;span&gt;", {
          role: "status",
          "aria-live": "polite"
        })
        .addClass("select2-hidden-accessible")
        .appendTo(document.body);
      this.containerId = "s2id_" + (opts.element.attr("id") || "autogen" + nextUid());
      this.containerEventName = this.containerId
        .replace(/([.])/g, '_')
        .replace(/([;&amp;,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=&gt;\|])/g, '\\$1');
      this.container.attr("id", this.containerId);
      this.container.attr("title", opts.element.attr("title"));
      this.body = $("body");
      syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
      this.container.attr("style", opts.element.attr("style"));
      this.container.css(evaluate(opts.containerCss, this.opts.element));
      this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));
      this.elementTabIndex = this.opts.element.attr("tabindex");
      this.opts.element
        .data("select2", this)
        .attr("tabindex", "-1")
        .before(this.container)
        .on("click.select2", killEvent);
      this.container.data("select2", this);
      this.dropdown = this.container.find(".select2-drop");
      syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
      this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
      this.dropdown.data("select2", this);
      this.dropdown.on("click", killEvent);
      this.results = results = this.container.find(resultsSelector);
      this.search = search = this.container.find("input.select2-input");
      this.queryCount = 0;
      this.resultsPage = 0;
      this.context = null;
      this.initContainer();
      this.container.on("click", killEvent);
      installFilteredMouseMove(this.results);
      this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
      this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function(event) {
        this._touchEvent = true;
        this.highlightUnderEvent(event);
      }));
      this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
      this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));
      this.dropdown.on('click', this.bind(function(event) {
        if (this._touchEvent) {
          this._touchEvent = false;
          this.selectHighlighted();
        }
      }));
      installDebouncedScroll(80, this.results);
      this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));
      $(this.container).on("change", ".select2-input", function(e) {
        e.stopPropagation();
      });
      $(this.dropdown).on("change", ".select2-input", function(e) {
        e.stopPropagation();
      });
      if ($.fn.mousewheel) {
        results.mousewheel(function(e, delta, deltaX, deltaY) {
          var top = results.scrollTop();
          if (deltaY &gt; 0 &amp;&amp; top - deltaY &lt;= 0) {
            results.scrollTop(0);
            killEvent(e);
          } else if (deltaY &lt; 0 &amp;&amp; results.get(0).scrollHeight - results.scrollTop() + deltaY &lt;= results.height()) {
            results.scrollTop(results.get(0).scrollHeight - results.height());
            killEvent(e);
          }
        });
      }
      installKeyUpChangeEvent(search);
      search.on("keyup-change input paste", this.bind(this.updateResults));
      search.on("focus", function() {
        search.addClass("select2-focused");
      });
      search.on("blur", function() {
        search.removeClass("select2-focused");
      });
      this.dropdown.on("mouseup", resultsSelector, this.bind(function(e) {
        if ($(e.target).closest(".select2-result-selectable").length &gt; 0) {
          this.highlightUnderEvent(e);
          this.selectHighlighted(e);
        }
      }));
      this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function(e) {
        e.stopPropagation();
      });
      this.nextSearchTerm = undefined;
      if ($.isFunction(this.opts.initSelection)) {
        this.initSelection();
        this.monitorSource();
      }
      if (opts.maximumInputLength !== null) {
        this.search.attr("maxlength", opts.maximumInputLength);
      }
      var disabled = opts.element.prop("disabled");
      if (disabled === undefined) disabled = false;
      this.enable(!disabled);
      var readonly = opts.element.prop("readonly");
      if (readonly === undefined) readonly = false;
      this.readonly(readonly);
      scrollBarDimensions = scrollBarDimensions || measureScrollbar();
      this.autofocus = opts.element.prop("autofocus");
      opts.element.prop("autofocus", false);
      if (this.autofocus) this.focus();
      this.search.attr("placeholder", opts.searchInputPlaceholder);
    },
    destroy: function() {
      var element = this.opts.element,
        select2 = element.data("select2"),
        self = this;
      this.close();
      if (element.length &amp;&amp; element[0].detachEvent) {
        element.each(function() {
          this.detachEvent("onpropertychange", self._sync);
        });
      }
      if (this.propertyObserver) {
        this.propertyObserver.disconnect();
        this.propertyObserver = null;
      }
      this._sync = null;
      if (select2 !== undefined) {
        select2.container.remove();
        select2.liveRegion.remove();
        select2.dropdown.remove();
        element
          .removeClass("select2-offscreen")
          .removeData("select2")
          .off(".select2")
          .prop("autofocus", this.autofocus || false);
        if (this.elementTabIndex) {
          element.attr({
            tabindex: this.elementTabIndex
          });
        } else {
          element.removeAttr("tabindex");
        }
        element.show();
      }
      cleanupJQueryElements.call(this,
        "container",
        "liveRegion",
        "dropdown",
        "results",
        "search"
      );
    },
    optionToData: function(element) {
      if (element.is("option")) {
        return {
          id: element.prop("value"),
          text: element.text(),
          element: element.get(),
          css: element.attr("class"),
          disabled: element.prop("disabled"),
          locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
        };
      } else if (element.is("optgroup")) {
        return {
          text: element.attr("label"),
          children: [],
          element: element.get(),
          css: element.attr("class")
        };
      }
    },
    prepareOpts: function(opts) {
      var element, select, idKey, ajaxUrl, self = this;
      element = opts.element;
      if (element.get(0).tagName.toLowerCase() === "select") {
        this.select = select = opts.element;
      }
      if (select) {
        $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function() {
          if (this in opts) {
            throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a &lt;select&gt; element.");
          }
        });
      }
      opts = $.extend({}, {
        populateResults: function(container, results, query) {
          var populate, id = this.opts.id,
            liveRegion = this.liveRegion;
          populate = function(results, container, depth) {
            var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;
            results = opts.sortResults(results, container, query);
            var nodes = [];
            for (i = 0, l = results.length; i &lt; l; i = i + 1) {
              result = results[i];
              disabled = (result.disabled === true);
              selectable = (!disabled) &amp;&amp; (id(result) !== undefined);
              compound = result.children &amp;&amp; result.children.length &gt; 0;
              node = $("&lt;li&gt;&lt;/li&gt;");
              node.addClass("select2-results-dept-" + depth);
              node.addClass("select2-result");
              node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
              if (disabled) {
                node.addClass("select2-disabled");
              }
              if (compound) {
                node.addClass("select2-result-with-children");
              }
              node.addClass(self.opts.formatResultCssClass(result));
              node.attr("role", "presentation");
              label = $(document.createElement("div"));
              label.addClass("select2-result-label");
              label.attr("id", "select2-result-label-" + nextUid());
              label.attr("role", "option");
              formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
              if (formatted !== undefined) {
                label.html(formatted);
                node.append(label);
              }
              if (compound) {
                innerContainer = $("&lt;ul&gt;&lt;/ul&gt;");
                innerContainer.addClass("select2-result-sub");
                populate(result.children, innerContainer, depth + 1);
                node.append(innerContainer);
              }
              node.data("select2-data", result);
              nodes.push(node[0]);
            }
            container.append(nodes);
            liveRegion.text(opts.formatMatches(results.length));
          };
          populate(results, container, 0);
        }
      }, $.fn.select2.defaults, opts);
      if (typeof(opts.id) !== "function") {
        idKey = opts.id;
        opts.id = function(e) {
          return e[idKey];
        };
      }
      if ($.isArray(opts.element.data("select2Tags"))) {
        if ("tags" in opts) {
          throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
        }
        opts.tags = opts.element.data("select2Tags");
      }
      if (select) {
        opts.query = this.bind(function(query) {
          var data = {
              results: [],
              more: false
            },
            term = query.term,
            children, placeholderOption, process;
          process = function(element, collection) {
            var group;
            if (element.is("option")) {
              if (query.matcher(term, element.text(), element)) {
                collection.push(self.optionToData(element));
              }
            } else if (element.is("optgroup")) {
              group = self.optionToData(element);
              element.children().each2(function(i, elm) {
                process(elm, group.children);
              });
              if (group.children.length &gt; 0) {
                collection.push(group);
              }
            }
          };
          children = element.children();
          if (this.getPlaceholder() !== undefined &amp;&amp; children.length &gt; 0) {
            placeholderOption = this.getPlaceholderOption();
            if (placeholderOption) {
              children = children.not(placeholderOption);
            }
          }
          children.each2(function(i, elm) {
            process(elm, data.results);
          });
          query.callback(data);
        });
        opts.id = function(e) {
          return e.id;
        };
      } else {
        if (!("query" in opts)) {
          if ("ajax" in opts) {
            ajaxUrl = opts.element.data("ajax-url");
            if (ajaxUrl &amp;&amp; ajaxUrl.length &gt; 0) {
              opts.ajax.url = ajaxUrl;
            }
            opts.query = ajax.call(opts.element, opts.ajax);
          } else if ("data" in opts) {
            opts.query = local(opts.data);
          } else if ("tags" in opts) {
            opts.query = tags(opts.tags);
            if (opts.createSearchChoice === undefined) {
              opts.createSearchChoice = function(term) {
                return {
                  id: $.trim(term),
                  text: $.trim(term)
                };
              };
            }
            if (opts.initSelection === undefined) {
              opts.initSelection = function(element, callback) {
                var data = [];
                $(splitVal(element.val(), opts.separator)).each(function() {
                  var obj = {
                      id: this,
                      text: this
                    },
                    tags = opts.tags;
                  if ($.isFunction(tags)) tags = tags();
                  $(tags).each(function() {
                    if (equal(this.id, obj.id)) {
                      obj = this;
                      return false;
                    }
                  });
                  data.push(obj);
                });
                callback(data);
              };
            }
          }
        }
      }
      if (typeof(opts.query) !== "function") {
        throw "query function not defined for Select2 " + opts.element.attr("id");
      }
      if (opts.createSearchChoicePosition === 'top') {
        opts.createSearchChoicePosition = function(list, item) {
          list.unshift(item);
        };
      } else if (opts.createSearchChoicePosition === 'bottom') {
        opts.createSearchChoicePosition = function(list, item) {
          list.push(item);
        };
      } else if (typeof(opts.createSearchChoicePosition) !== "function") {
        throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
      }
      return opts;
    },
    monitorSource: function() {
      var el = this.opts.element,
        observer, self = this;
      el.on("change.select2", this.bind(function(e) {
        if (this.opts.element.data("select2-change-triggered") !== true) {
          this.initSelection();
        }
      }));
      this._sync = this.bind(function() {
        var disabled = el.prop("disabled");
        if (disabled === undefined) disabled = false;
        this.enable(!disabled);
        var readonly = el.prop("readonly");
        if (readonly === undefined) readonly = false;
        this.readonly(readonly);
        syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
        this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
        syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
        this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
      });
      if (el.length &amp;&amp; el[0].attachEvent) {
        el.each(function() {
          this.attachEvent("onpropertychange", self._sync);
        });
      }
      observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
      if (observer !== undefined) {
        if (this.propertyObserver) {
          delete this.propertyObserver;
          this.propertyObserver = null;
        }
        this.propertyObserver = new observer(function(mutations) {
          $.each(mutations, self._sync);
        });
        this.propertyObserver.observe(el.get(0), {
          attributes: true,
          subtree: false
        });
      }
    },
    triggerSelect: function(data) {
      var evt = $.Event("select2-selecting", {
        val: this.id(data),
        object: data,
        choice: data
      });
      this.opts.element.trigger(evt);
      return !evt.isDefaultPrevented();
    },
    triggerChange: function(details) {
      details = details || {};
      details = $.extend({}, details, {
        type: "change",
        val: this.val()
      });
      this.opts.element.data("select2-change-triggered", true);
      this.opts.element.trigger(details);
      this.opts.element.data("select2-change-triggered", false);
      this.opts.element.click();
      if (this.opts.blurOnChange)
        this.opts.element.blur();
    },
    isInterfaceEnabled: function() {
      return this.enabledInterface === true;
    },
    enableInterface: function() {
      var enabled = this._enabled &amp;&amp; !this._readonly,
        disabled = !enabled;
      if (enabled === this.enabledInterface) return false;
      this.container.toggleClass("select2-container-disabled", disabled);
      this.close();
      this.enabledInterface = enabled;
      return true;
    },
    enable: function(enabled) {
      if (enabled === undefined) enabled = true;
      if (this._enabled === enabled) return;
      this._enabled = enabled;
      this.opts.element.prop("disabled", !enabled);
      this.enableInterface();
    },
    disable: function() {
      this.enable(false);
    },
    readonly: function(enabled) {
      if (enabled === undefined) enabled = false;
      if (this._readonly === enabled) return;
      this._readonly = enabled;
      this.opts.element.prop("readonly", enabled);
      this.enableInterface();
    },
    opened: function() {
      return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
    },
    positionDropdown: function() {
      var $dropdown = this.dropdown,
        offset = this.container.offset(),
        height = this.container.outerHeight(false),
        width = this.container.outerWidth(false),
        dropHeight = $dropdown.outerHeight(false),
        $window = $(window),
        windowWidth = $window.width(),
        windowHeight = $window.height(),
        viewPortRight = $window.scrollLeft() + windowWidth,
        viewportBottom = $window.scrollTop() + windowHeight,
        dropTop = offset.top + height,
        dropLeft = offset.left,
        enoughRoomBelow = dropTop + dropHeight &lt;= viewportBottom,
        enoughRoomAbove = (offset.top - dropHeight) &gt;= $window.scrollTop(),
        dropWidth = $dropdown.outerWidth(false),
        enoughRoomOnRight = dropLeft + dropWidth &lt;= viewPortRight,
        aboveNow = $dropdown.hasClass("select2-drop-above"),
        bodyOffset,
        above,
        changeDirection,
        css,
        resultsListNode;
      if (aboveNow) {
        above = true;
        if (!enoughRoomAbove &amp;&amp; enoughRoomBelow) {
          changeDirection = true;
          above = false;
        }
      } else {
        above = false;
        if (!enoughRoomBelow &amp;&amp; enoughRoomAbove) {
          changeDirection = true;
          above = true;
        }
      }
      if (changeDirection) {
        $dropdown.hide();
        offset = this.container.offset();
        height = this.container.outerHeight(false);
        width = this.container.outerWidth(false);
        dropHeight = $dropdown.outerHeight(false);
        viewPortRight = $window.scrollLeft() + windowWidth;
        viewportBottom = $window.scrollTop() + windowHeight;
        dropTop = offset.top + height;
        dropLeft = offset.left;
        dropWidth = $dropdown.outerWidth(false);
        enoughRoomOnRight = dropLeft + dropWidth &lt;= viewPortRight;
        $dropdown.show();
        this.focusSearch();
      }
      if (this.opts.dropdownAutoWidth) {
        resultsListNode = $('.select2-results', $dropdown)[0];
        $dropdown.addClass('select2-drop-auto-width');
        $dropdown.css('width', '');
        dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
        dropWidth &gt; width ? width = dropWidth : dropWidth = width;
        dropHeight = $dropdown.outerHeight(false);
        enoughRoomOnRight = dropLeft + dropWidth &lt;= viewPortRight;
      } else {
        this.container.removeClass('select2-drop-auto-width');
      }
      if (this.body.css('position') !== 'static') {
        bodyOffset = this.body.offset();
        dropTop -= bodyOffset.top;
        dropLeft -= bodyOffset.left;
      }
      if (!enoughRoomOnRight) {
        dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
      }
      css = {
        left: dropLeft,
        width: width
      };
      if (above) {
        css.top = offset.top - dropHeight;
        css.bottom = 'auto';
        this.container.addClass("select2-drop-above");
        $dropdown.addClass("select2-drop-above");
      } else {
        css.top = dropTop;
        css.bottom = 'auto';
        this.container.removeClass("select2-drop-above");
        $dropdown.removeClass("select2-drop-above");
      }
      css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));
      $dropdown.css(css);
    },
    shouldOpen: function() {
      var event;
      if (this.opened()) return false;
      if (this._enabled === false || this._readonly === true) return false;
      event = $.Event("select2-opening");
      this.opts.element.trigger(event);
      return !event.isDefaultPrevented();
    },
    clearDropdownAlignmentPreference: function() {
      this.container.removeClass("select2-drop-above");
      this.dropdown.removeClass("select2-drop-above");
    },
    open: function() {
      if (!this.shouldOpen()) return false;
      this.opening();
      $document.on("mousemove.select2Event", function(e) {
        lastMousePosition.x = e.pageX;
        lastMousePosition.y = e.pageY;
      });
      return true;
    },
    opening: function() {
      var cid = this.containerEventName,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid,
        mask;
      this.container.addClass("select2-dropdown-open").addClass("select2-container-active");
      this.clearDropdownAlignmentPreference();
      if (this.dropdown[0] !== this.body.children().last()[0]) {
        this.dropdown.detach().appendTo(this.body);
      }
      mask = $("#select2-drop-mask");
      if (mask.length == 0) {
        mask = $(document.createElement("div"));
        mask.attr("id", "select2-drop-mask").attr("class", "select2-drop-mask");
        mask.hide();
        mask.appendTo(this.body);
        mask.on("mousedown touchstart click", function(e) {
          reinsertElement(mask);
          var dropdown = $("#select2-drop"),
            self;
          if (dropdown.length &gt; 0) {
            self = dropdown.data("select2");
            if (self.opts.selectOnBlur) {
              self.selectHighlighted({
                noFocus: true
              });
            }
            self.close();
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }
      if (this.dropdown.prev()[0] !== mask[0]) {
        this.dropdown.before(mask);
      }
      $("#select2-drop").removeAttr("id");
      this.dropdown.attr("id", "select2-drop");
      mask.show();
      this.positionDropdown();
      this.dropdown.show();
      this.positionDropdown();
      this.dropdown.addClass("select2-drop-active");
      var that = this;
      this.container.parents().add(window).each(function() {
        $(this).on(resize + " " + scroll + " " + orient, function(e) {
          if (that.opened()) that.positionDropdown();
        });
      });
    },
    close: function() {
      if (!this.opened()) return;
      var cid = this.containerEventName,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid;
      this.container.parents().add(window).each(function() {
        $(this).off(scroll).off(resize).off(orient);
      });
      this.clearDropdownAlignmentPreference();
      $("#select2-drop-mask").hide();
      this.dropdown.removeAttr("id");
      this.dropdown.hide();
      this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
      this.results.empty();
      $document.off("mousemove.select2Event");
      this.clearSearch();
      this.search.removeClass("select2-active");
      this.opts.element.trigger($.Event("select2-close"));
    },
    externalSearch: function(term) {
      this.open();
      this.search.val(term);
      this.updateResults(false);
    },
    clearSearch: function() {},
    getMaximumSelectionSize: function() {
      return evaluate(this.opts.maximumSelectionSize, this.opts.element);
    },
    ensureHighlightVisible: function() {
      var results = this.results,
        children, index, child, hb, rb, y, more, topOffset;
      index = this.highlight();
      if (index &lt; 0) return;
      if (index == 0) {
        results.scrollTop(0);
        return;
      }
      children = this.findHighlightableChoices().find('.select2-result-label');
      child = $(children[index]);
      topOffset = (child.offset() || {}).top || 0;
      hb = topOffset + child.outerHeight(true);
      if (index === children.length - 1) {
        more = results.find("li.select2-more-results");
        if (more.length &gt; 0) {
          hb = more.offset().top + more.outerHeight(true);
        }
      }
      rb = results.offset().top + results.outerHeight(true);
      if (hb &gt; rb) {
        results.scrollTop(results.scrollTop() + (hb - rb));
      }
      y = topOffset - results.offset().top;
      if (y &lt; 0 &amp;&amp; child.css('display') != 'none') {
        results.scrollTop(results.scrollTop() + y);
      }
    },
    findHighlightableChoices: function() {
      return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
    },
    moveHighlight: function(delta) {
      var choices = this.findHighlightableChoices(),
        index = this.highlight();
      while (index &gt; -1 &amp;&amp; index &lt; choices.length) {
        index += delta;
        var choice = $(choices[index]);
        if (choice.hasClass("select2-result-selectable") &amp;&amp; !choice.hasClass("select2-disabled") &amp;&amp; !choice.hasClass("select2-selected")) {
          this.highlight(index);
          break;
        }
      }
    },
    highlight: function(index) {
      var choices = this.findHighlightableChoices(),
        choice,
        data;
      if (arguments.length === 0) {
        return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
      }
      if (index &gt;= choices.length) index = choices.length - 1;
      if (index &lt; 0) index = 0;
      this.removeHighlight();
      choice = $(choices[index]);
      choice.addClass("select2-highlighted");
      this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));
      this.ensureHighlightVisible();
      this.liveRegion.text(choice.text());
      data = choice.data("select2-data");
      if (data) {
        this.opts.element.trigger({
          type: "select2-highlight",
          val: this.id(data),
          choice: data
        });
      }
    },
    removeHighlight: function() {
      this.results.find(".select2-highlighted").removeClass("select2-highlighted");
    },
    touchMoved: function() {
      this._touchMoved = true;
    },
    clearTouchMoved: function() {
      this._touchMoved = false;
    },
    countSelectableResults: function() {
      return this.findHighlightableChoices().length;
    },
    highlightUnderEvent: function(event) {
      var el = $(event.target).closest(".select2-result-selectable");
      if (el.length &gt; 0 &amp;&amp; !el.is(".select2-highlighted")) {
        var choices = this.findHighlightableChoices();
        this.highlight(choices.index(el));
      } else if (el.length == 0) {
        this.removeHighlight();
      }
    },
    loadMoreIfNeeded: function() {
      var results = this.results,
        more = results.find("li.select2-more-results"),
        below,
        page = this.resultsPage + 1,
        self = this,
        term = this.search.val(),
        context = this.context;
      if (more.length === 0) return;
      below = more.offset().top - results.offset().top - results.height();
      if (below &lt;= this.opts.loadMorePadding) {
        more.addClass("select2-active");
        this.opts.query({
          element: this.opts.element,
          term: term,
          page: page,
          context: context,
          matcher: this.opts.matcher,
          callback: this.bind(function(data) {
            if (!self.opened()) return;
            self.opts.populateResults.call(this, results, data.results, {
              term: term,
              page: page,
              context: context
            });
            self.postprocessResults(data, false, false);
            if (data.more === true) {
              more.detach().appendTo(results).text(evaluate(self.opts.formatLoadMore, self.opts.element, page + 1));
              window.setTimeout(function() {
                self.loadMoreIfNeeded();
              }, 10);
            } else {
              more.remove();
            }
            self.positionDropdown();
            self.resultsPage = page;
            self.context = data.context;
            this.opts.element.trigger({
              type: "select2-loaded",
              items: data
            });
          })
        });
      }
    },
    tokenize: function() {},
    updateResults: function(initial) {
      var search = this.search,
        results = this.results,
        opts = this.opts,
        data,
        self = this,
        input,
        term = search.val(),
        lastTerm = $.data(this.container, "select2-last-term"),
        queryNumber;
      if (initial !== true &amp;&amp; lastTerm &amp;&amp; equal(term, lastTerm)) return;
      $.data(this.container, "select2-last-term", term);
      if (initial !== true &amp;&amp; (this.showSearchInput === false || !this.opened())) {
        return;
      }

      function postRender() {
        search.removeClass("select2-active");
        self.positionDropdown();
        if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
          self.liveRegion.text(results.text());
        } else {
          self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable').length));
        }
      }

      function render(html) {
        results.html(html);
        postRender();
      }
      queryNumber = ++this.queryCount;
      var maxSelSize = this.getMaximumSelectionSize();
      if (maxSelSize &gt;= 1) {
        data = this.data();
        if ($.isArray(data) &amp;&amp; data.length &gt;= maxSelSize &amp;&amp; checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
          render("&lt;li class='select2-selection-limit'&gt;" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "&lt;/li&gt;");
          return;
        }
      }
      if (search.val().length &lt; opts.minimumInputLength) {
        if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
          render("&lt;li class='select2-no-results'&gt;" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "&lt;/li&gt;");
        } else {
          render("");
        }
        if (initial &amp;&amp; this.showSearch) this.showSearch(true);
        return;
      }
      if (opts.maximumInputLength &amp;&amp; search.val().length &gt; opts.maximumInputLength) {
        if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
          render("&lt;li class='select2-no-results'&gt;" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "&lt;/li&gt;");
        } else {
          render("");
        }
        return;
      }
      if (opts.formatSearching &amp;&amp; this.findHighlightableChoices().length === 0) {
        render("&lt;li class='select2-searching'&gt;" + evaluate(opts.formatSearching, opts.element) + "&lt;/li&gt;");
      }
      search.addClass("select2-active");
      this.removeHighlight();
      input = this.tokenize();
      if (input != undefined &amp;&amp; input != null) {
        search.val(input);
      }
      this.resultsPage = 1;
      opts.query({
        element: opts.element,
        term: search.val(),
        page: this.resultsPage,
        context: null,
        matcher: opts.matcher,
        callback: this.bind(function(data) {
          var def;
          if (queryNumber != this.queryCount) {
            return;
          }
          if (!this.opened()) {
            this.search.removeClass("select2-active");
            return;
          }
          if (data.hasError !== undefined &amp;&amp; checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
            render("&lt;li class='select2-ajax-error'&gt;" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "&lt;/li&gt;");
            return;
          }
          this.context = (data.context === undefined) ? null : data.context;
          if (this.opts.createSearchChoice &amp;&amp; search.val() !== "") {
            def = this.opts.createSearchChoice.call(self, search.val(), data.results);
            if (def !== undefined &amp;&amp; def !== null &amp;&amp; self.id(def) !== undefined &amp;&amp; self.id(def) !== null) {
              if ($(data.results).filter(
                  function() {
                    return equal(self.id(this), self.id(def));
                  }).length === 0) {
                this.opts.createSearchChoicePosition(data.results, def);
              }
            }
          }
          if (data.results.length === 0 &amp;&amp; checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
            render("&lt;li class='select2-no-results'&gt;" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "&lt;/li&gt;");
            return;
          }
          results.empty();
          self.opts.populateResults.call(this, results, data.results, {
            term: search.val(),
            page: this.resultsPage,
            context: null
          });
          if (data.more === true &amp;&amp; checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
            results.append("&lt;li class='select2-more-results'&gt;" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "&lt;/li&gt;");
            window.setTimeout(function() {
              self.loadMoreIfNeeded();
            }, 10);
          }
          this.postprocessResults(data, initial);
          postRender();
          this.opts.element.trigger({
            type: "select2-loaded",
            items: data
          });
        })
      });
    },
    cancel: function() {
      this.close();
    },
    blur: function() {
      if (this.opts.selectOnBlur)
        this.selectHighlighted({
          noFocus: true
        });
      this.close();
      this.container.removeClass("select2-container-active");
      if (this.search[0] === document.activeElement) {
        this.search.blur();
      }
      this.clearSearch();
      this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
    },
    focusSearch: function() {
      focus(this.search);
    },
    selectHighlighted: function(options) {
      if (this._touchMoved) {
        this.clearTouchMoved();
        return;
      }
      var index = this.highlight(),
        highlighted = this.results.find(".select2-highlighted"),
        data = highlighted.closest('.select2-result').data("select2-data");
      if (data) {
        this.highlight(index);
        this.onSelect(data, options);
      } else if (options &amp;&amp; options.noFocus) {
        this.close();
      }
    },
    getPlaceholder: function() {
      var placeholderOption;
      return this.opts.element.attr("placeholder") ||
        this.opts.element.attr("data-placeholder") ||
        this.opts.element.data("placeholder") ||
        this.opts.placeholder ||
        ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
    },
    getPlaceholderOption: function() {
      if (this.select) {
        var firstOption = this.select.children('option').first();
        if (this.opts.placeholderOption !== undefined) {
          return (this.opts.placeholderOption === "first" &amp;&amp; firstOption) ||
            (typeof this.opts.placeholderOption === "function" &amp;&amp; this.opts.placeholderOption(this.select));
        } else if ($.trim(firstOption.text()) === "" &amp;&amp; firstOption.val() === "") {
          return firstOption;
        }
      }
    },
    initContainerWidth: function() {
      function resolveContainerWidth() {
        var style, attrs, matches, i, l, attr;
        if (this.opts.width === "off") {
          return null;
        } else if (this.opts.width === "element") {
          return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
        } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
          style = this.opts.element.attr('style');
          if (style !== undefined) {
            attrs = style.split(';');
            for (i = 0, l = attrs.length; i &lt; l; i = i + 1) {
              attr = attrs[i].replace(/\s/g, '');
              matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
              if (matches !== null &amp;&amp; matches.length &gt;= 1)
                return matches[1];
            }
          }
          if (this.opts.width === "resolve") {
            style = this.opts.element.css('width');
            if (style.indexOf("%") &gt; 0) return style;
            return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
          }
          return null;
        } else if ($.isFunction(this.opts.width)) {
          return this.opts.width();
        } else {
          return this.opts.width;
        }
      };
      var width = resolveContainerWidth.call(this);
      if (width !== null) {
        this.container.css("width", width);
      }
    }
  });
  SingleSelect2 = clazz(AbstractSelect2, {
    createContainer: function() {
      var container = $(document.createElement("div")).attr({
        "class": "select2-container"
      }).html([
        "&lt;a href='javascript:void(0)' class='select2-choice' tabindex='-1'&gt;",
        "   &lt;span class='select2-chosen'&gt;&amp;#160;&lt;/span&gt;&lt;abbr class='select2-search-choice-close'&gt;&lt;/abbr&gt;",
        "   &lt;span class='select2-arrow' role='presentation'&gt;&lt;b role='presentation'&gt;&lt;/b&gt;&lt;/span&gt;",
        "&lt;/a&gt;",
        "&lt;label for='' class='select2-offscreen'&gt;&lt;/label&gt;",
        "&lt;input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' /&gt;",
        "&lt;div class='select2-drop select2-display-none'&gt;",
        "   &lt;div class='select2-search'&gt;",
        "       &lt;label for='' class='select2-offscreen'&gt;&lt;/label&gt;",
        "       &lt;input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
        "       aria-autocomplete='list' /&gt;",
        "   &lt;/div&gt;",
        "   &lt;ul class='select2-results' role='listbox'&gt;",
        "   &lt;/ul&gt;",
        "&lt;/div&gt;"
      ].join(""));
      return container;
    },
    enableInterface: function() {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.focusser.prop("disabled", !this.isInterfaceEnabled());
      }
    },
    opening: function() {
      var el, range, len;
      if (this.opts.minimumResultsForSearch &gt;= 0) {
        this.showSearch(true);
      }
      this.parent.opening.apply(this, arguments);
      if (this.showSearchInput !== false) {
        this.search.val(this.focusser.val());
      }
      if (this.opts.shouldFocusInput(this)) {
        this.search.focus();
        el = this.search.get(0);
        if (el.createTextRange) {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        } else if (el.setSelectionRange) {
          len = this.search.val().length;
          el.setSelectionRange(len, len);
        }
      }
      if (this.search.val() === "") {
        if (this.nextSearchTerm != undefined) {
          this.search.val(this.nextSearchTerm);
          this.search.select();
        }
      }
      this.focusser.prop("disabled", true).val("");
      this.updateResults(true);
      this.opts.element.trigger($.Event("select2-open"));
    },
    close: function() {
      if (!this.opened()) return;
      this.parent.close.apply(this, arguments);
      this.focusser.prop("disabled", false);
      if (this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
    },
    focus: function() {
      if (this.opened()) {
        this.close();
      } else {
        this.focusser.prop("disabled", false);
        if (this.opts.shouldFocusInput(this)) {
          this.focusser.focus();
        }
      }
    },
    isFocused: function() {
      return this.container.hasClass("select2-container-active");
    },
    cancel: function() {
      this.parent.cancel.apply(this, arguments);
      this.focusser.prop("disabled", false);
      if (this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
    },
    destroy: function() {
      $("label[for='" + this.focusser.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
      this.parent.destroy.apply(this, arguments);
      cleanupJQueryElements.call(this,
        "selection",
        "focusser"
      );
    },
    initContainer: function() {
      var selection,
        container = this.container,
        dropdown = this.dropdown,
        idSuffix = nextUid(),
        elementLabel;
      if (this.opts.minimumResultsForSearch &lt; 0) {
        this.showSearch(false);
      } else {
        this.showSearch(true);
      }
      this.selection = selection = container.find(".select2-choice");
      this.focusser = container.find(".select2-focusser");
      selection.find(".select2-chosen").attr("id", "select2-chosen-" + idSuffix);
      this.focusser.attr("aria-labelledby", "select2-chosen-" + idSuffix);
      this.results.attr("id", "select2-results-" + idSuffix);
      this.search.attr("aria-owns", "select2-results-" + idSuffix);
      this.focusser.attr("id", "s2id_autogen" + idSuffix);
      elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
      this.focusser.prev()
        .text(elementLabel.text())
        .attr('for', this.focusser.attr('id'));
      var originalTitle = this.opts.element.attr("title");
      this.opts.element.attr("title", (originalTitle || elementLabel.text()));
      this.focusser.attr("tabindex", this.elementTabIndex);
      this.search.attr("id", this.focusser.attr('id') + '_search');
      this.search.prev()
        .text($("label[for='" + this.focusser.attr('id') + "']").text())
        .attr('for', this.search.attr('id'));
      this.search.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if (229 == e.keyCode) return;
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
          return;
        }
        switch (e.which) {
          case KEY.UP:
          case KEY.DOWN:
            this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
            killEvent(e);
            return;
          case KEY.ENTER:
            this.selectHighlighted();
            killEvent(e);
            return;
          case KEY.TAB:
            this.selectHighlighted({
              noFocus: true
            });
            return;
          case KEY.ESC:
            this.cancel(e);
            killEvent(e);
            return;
        }
      }));
      this.search.on("blur", this.bind(function(e) {
        if (document.activeElement === this.body.get(0)) {
          window.setTimeout(this.bind(function() {
            if (this.opened()) {
              this.search.focus();
            }
          }), 0);
        }
      }));
      this.focusser.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
          return;
        }
        if (this.opts.openOnEnter === false &amp;&amp; e.which === KEY.ENTER) {
          killEvent(e);
          return;
        }
        if (e.which == KEY.DOWN || e.which == KEY.UP ||
          (e.which == KEY.ENTER &amp;&amp; this.opts.openOnEnter)) {
          if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;
          this.open();
          killEvent(e);
          return;
        }
        if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
          if (this.opts.allowClear) {
            this.clear();
          }
          killEvent(e);
          return;
        }
      }));
      installKeyUpChangeEvent(this.focusser);
      this.focusser.on("keyup-change input", this.bind(function(e) {
        if (this.opts.minimumResultsForSearch &gt;= 0) {
          e.stopPropagation();
          if (this.opened()) return;
          this.open();
        }
      }));
      selection.on("mousedown touchstart", "abbr", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        this.clear();
        killEventImmediately(e);
        this.close();
        this.selection.focus();
      }));
      selection.on("mousedown touchstart", this.bind(function(e) {
        reinsertElement(selection);
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        if (this.opened()) {
          this.close();
        } else if (this.isInterfaceEnabled()) {
          this.open();
        }
        killEvent(e);
      }));
      dropdown.on("mousedown touchstart", this.bind(function() {
        if (this.opts.shouldFocusInput(this)) {
          this.search.focus();
        }
      }));
      selection.on("focus", this.bind(function(e) {
        killEvent(e);
      }));
      this.focusser.on("focus", this.bind(function() {
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
      })).on("blur", this.bind(function() {
        if (!this.opened()) {
          this.container.removeClass("select2-container-active");
          this.opts.element.trigger($.Event("select2-blur"));
        }
      }));
      this.search.on("focus", this.bind(function() {
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
      }));
      this.initContainerWidth();
      this.opts.element.addClass("select2-offscreen");
      this.setPlaceholder();
    },
    clear: function(triggerChange) {
      var data = this.selection.data("select2-data");
      if (data) {
        var evt = $.Event("select2-clearing");
        this.opts.element.trigger(evt);
        if (evt.isDefaultPrevented()) {
          return;
        }
        var placeholderOption = this.getPlaceholderOption();
        this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
        this.selection.find(".select2-chosen").empty();
        this.selection.removeData("select2-data");
        this.setPlaceholder();
        if (triggerChange !== false) {
          this.opts.element.trigger({
            type: "select2-removed",
            val: this.id(data),
            choice: data
          });
          this.triggerChange({
            removed: data
          });
        }
      }
    },
    initSelection: function() {
      var selected;
      if (this.isPlaceholderOptionSelected()) {
        this.updateSelection(null);
        this.close();
        this.setPlaceholder();
      } else {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function(selected) {
          if (selected !== undefined &amp;&amp; selected !== null) {
            self.updateSelection(selected);
            self.close();
            self.setPlaceholder();
            self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
          }
        });
      }
    },
    isPlaceholderOptionSelected: function() {
      var placeholderOption;
      if (this.getPlaceholder() === undefined) return false;
      return ((placeholderOption = this.getPlaceholderOption()) !== undefined &amp;&amp; placeholderOption.prop("selected")) ||
        (this.opts.element.val() === "") ||
        (this.opts.element.val() === undefined) ||
        (this.opts.element.val() === null);
    },
    prepareOpts: function() {
      var opts = this.parent.prepareOpts.apply(this, arguments),
        self = this;
      if (opts.element.get(0).tagName.toLowerCase() === "select") {
        opts.initSelection = function(element, callback) {
          var selected = element.find("option").filter(function() {
            return this.selected &amp;&amp; !this.disabled
          });
          callback(self.optionToData(selected));
        };
      } else if ("data" in opts) {
        opts.initSelection = opts.initSelection || function(element, callback) {
          var id = element.val();
          var match = null;
          opts.query({
            matcher: function(term, text, el) {
              var is_match = equal(id, opts.id(el));
              if (is_match) {
                match = el;
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function() {
              callback(match);
            }
          });
        };
      }
      return opts;
    },
    getPlaceholder: function() {
      if (this.select) {
        if (this.getPlaceholderOption() === undefined) {
          return undefined;
        }
      }
      return this.parent.getPlaceholder.apply(this, arguments);
    },
    setPlaceholder: function() {
      var placeholder = this.getPlaceholder();
      if (this.isPlaceholderOptionSelected() &amp;&amp; placeholder !== undefined) {
        if (this.select &amp;&amp; this.getPlaceholderOption() === undefined) return;
        this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));
        this.selection.addClass("select2-default");
        this.container.removeClass("select2-allowclear");
      }
    },
    postprocessResults: function(data, initial, noHighlightUpdate) {
      var selected = 0,
        self = this,
        showSearchInput = true;
      this.findHighlightableChoices().each2(function(i, elm) {
        if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
          selected = i;
          return false;
        }
      });
      if (noHighlightUpdate !== false) {
        if (initial === true &amp;&amp; selected &gt;= 0) {
          this.highlight(selected);
        } else {
          this.highlight(0);
        }
      }
      if (initial === true) {
        var min = this.opts.minimumResultsForSearch;
        if (min &gt;= 0) {
          this.showSearch(countResults(data.results) &gt;= min);
        }
      }
    },
    showSearch: function(showSearchInput) {
      if (this.showSearchInput === showSearchInput) return;
      this.showSearchInput = showSearchInput;
      this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
      this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
      $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
    },
    onSelect: function(data, options) {
      if (!this.triggerSelect(data)) {
        return;
      }
      var old = this.opts.element.val(),
        oldData = this.data();
      this.opts.element.val(this.id(data));
      this.updateSelection(data);
      this.opts.element.trigger({
        type: "select2-selected",
        val: this.id(data),
        choice: data
      });
      this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
      this.close();
      if ((!options || !options.noFocus) &amp;&amp; this.opts.shouldFocusInput(this)) {
        this.focusser.focus();
      }
      if (!equal(old, this.id(data))) {
        this.triggerChange({
          added: data,
          removed: oldData
        });
      }
    },
    updateSelection: function(data) {
      var container = this.selection.find(".select2-chosen"),
        formatted, cssClass;
      this.selection.data("select2-data", data);
      container.empty();
      if (data !== null) {
        formatted = this.opts.formatSelection(data, container, this.opts.escapeMarkup);
      }
      if (formatted !== undefined) {
        container.append(formatted);
      }
      cssClass = this.opts.formatSelectionCssClass(data, container);
      if (cssClass !== undefined) {
        container.addClass(cssClass);
      }
      this.selection.removeClass("select2-default");
      if (this.opts.allowClear &amp;&amp; this.getPlaceholder() !== undefined) {
        this.container.addClass("select2-allowclear");
      }
    },
    val: function() {
      var val,
        triggerChange = false,
        data = null,
        self = this,
        oldData = this.data();
      if (arguments.length === 0) {
        return this.opts.element.val();
      }
      val = arguments[0];
      if (arguments.length &gt; 1) {
        triggerChange = arguments[1];
      }
      if (this.select) {
        this.select
          .val(val)
          .find("option").filter(function() {
            return this.selected
          }).each2(function(i, elm) {
            data = self.optionToData(elm);
            return false;
          });
        this.updateSelection(data);
        this.setPlaceholder();
        if (triggerChange) {
          this.triggerChange({
            added: data,
            removed: oldData
          });
        }
      } else {
        if (!val &amp;&amp; val !== 0) {
          this.clear(triggerChange);
          return;
        }
        if (this.opts.initSelection === undefined) {
          throw new Error("cannot call val() if initSelection() is not defined");
        }
        this.opts.element.val(val);
        this.opts.initSelection(this.opts.element, function(data) {
          self.opts.element.val(!data ? "" : self.id(data));
          self.updateSelection(data);
          self.setPlaceholder();
          if (triggerChange) {
            self.triggerChange({
              added: data,
              removed: oldData
            });
          }
        });
      }
    },
    clearSearch: function() {
      this.search.val("");
      this.focusser.val("");
    },
    data: function(value) {
      var data,
        triggerChange = false;
      if (arguments.length === 0) {
        data = this.selection.data("select2-data");
        if (data == undefined) data = null;
        return data;
      } else {
        if (arguments.length &gt; 1) {
          triggerChange = arguments[1];
        }
        if (!value) {
          this.clear(triggerChange);
        } else {
          data = this.data();
          this.opts.element.val(!value ? "" : this.id(value));
          this.updateSelection(value);
          if (triggerChange) {
            this.triggerChange({
              added: value,
              removed: data
            });
          }
        }
      }
    }
  });
  MultiSelect2 = clazz(AbstractSelect2, {
    createContainer: function() {
      var container = $(document.createElement("div")).attr({
        "class": "select2-container select2-container-multi"
      }).html([
        "&lt;ul class='select2-choices'&gt;",
        "  &lt;li class='select2-search-field'&gt;",
        "    &lt;label for='' class='select2-offscreen'&gt;&lt;/label&gt;",
        "    &lt;input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'&gt;",
        "  &lt;/li&gt;",
        "&lt;/ul&gt;",
        "&lt;div class='select2-drop select2-drop-multi select2-display-none'&gt;",
        "   &lt;ul class='select2-results'&gt;",
        "   &lt;/ul&gt;",
        "&lt;/div&gt;"
      ].join(""));
      return container;
    },
    prepareOpts: function() {
      var opts = this.parent.prepareOpts.apply(this, arguments),
        self = this;
      if (opts.element.get(0).tagName.toLowerCase() === "select") {
        opts.initSelection = function(element, callback) {
          var data = [];
          element.find("option").filter(function() {
            return this.selected &amp;&amp; !this.disabled
          }).each2(function(i, elm) {
            data.push(self.optionToData(elm));
          });
          callback(data);
        };
      } else if ("data" in opts) {
        opts.initSelection = opts.initSelection || function(element, callback) {
          var ids = splitVal(element.val(), opts.separator);
          var matches = [];
          opts.query({
            matcher: function(term, text, el) {
              var is_match = $.grep(ids, function(id) {
                return equal(id, opts.id(el));
              }).length;
              if (is_match) {
                matches.push(el);
              }
              return is_match;
            },
            callback: !$.isFunction(callback) ? $.noop : function() {
              var ordered = [];
              for (var i = 0; i &lt; ids.length; i++) {
                var id = ids[i];
                for (var j = 0; j &lt; matches.length; j++) {
                  var match = matches[j];
                  if (equal(id, opts.id(match))) {
                    ordered.push(match);
                    matches.splice(j, 1);
                    break;
                  }
                }
              }
              callback(ordered);
            }
          });
        };
      }
      return opts;
    },
    selectChoice: function(choice) {
      var selected = this.container.find(".select2-search-choice-focus");
      if (selected.length &amp;&amp; choice &amp;&amp; choice[0] == selected[0]) {} else {
        if (selected.length) {
          this.opts.element.trigger("choice-deselected", selected);
        }
        selected.removeClass("select2-search-choice-focus");
        if (choice &amp;&amp; choice.length) {
          this.close();
          choice.addClass("select2-search-choice-focus");
          this.opts.element.trigger("choice-selected", choice);
        }
      }
    },
    destroy: function() {
      $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
      this.parent.destroy.apply(this, arguments);
      cleanupJQueryElements.call(this,
        "searchContainer",
        "selection"
      );
    },
    initContainer: function() {
      var selector = ".select2-choices",
        selection;
      this.searchContainer = this.container.find(".select2-search-field");
      this.selection = selection = this.container.find(selector);
      var _this = this;
      this.selection.on("click", ".select2-search-choice:not(.select2-locked)", function(e) {
        _this.search[0].focus();
        _this.selectChoice($(this));
      });
      this.search.attr("id", "s2id_autogen" + nextUid());
      this.search.prev()
        .text($("label[for='" + this.opts.element.attr("id") + "']").text())
        .attr('for', this.search.attr('id'));
      this.search.on("input paste", this.bind(function() {
        if (this.search.attr('placeholder') &amp;&amp; this.search.val().length == 0) return;
        if (!this.isInterfaceEnabled()) return;
        if (!this.opened()) {
          this.open();
        }
      }));
      this.search.attr("tabindex", this.elementTabIndex);
      this.keydowns = 0;
      this.search.on("keydown", this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        ++this.keydowns;
        var selected = selection.find(".select2-search-choice-focus");
        var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
        var next = selected.next(".select2-search-choice:not(.select2-locked)");
        var pos = getCursorInfo(this.search);
        if (selected.length &amp;&amp;
          (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
          var selectedChoice = selected;
          if (e.which == KEY.LEFT &amp;&amp; prev.length) {
            selectedChoice = prev;
          } else if (e.which == KEY.RIGHT) {
            selectedChoice = next.length ? next : null;
          } else if (e.which === KEY.BACKSPACE) {
            if (this.unselect(selected.first())) {
              this.search.width(10);
              selectedChoice = prev.length ? prev : next;
            }
          } else if (e.which == KEY.DELETE) {
            if (this.unselect(selected.first())) {
              this.search.width(10);
              selectedChoice = next.length ? next : null;
            }
          } else if (e.which == KEY.ENTER) {
            selectedChoice = null;
          }
          this.selectChoice(selectedChoice);
          killEvent(e);
          if (!selectedChoice || !selectedChoice.length) {
            this.open();
          }
          return;
        } else if (((e.which === KEY.BACKSPACE &amp;&amp; this.keydowns == 1) ||
            e.which == KEY.LEFT) &amp;&amp; (pos.offset == 0 &amp;&amp; !pos.length)) {
          this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
          killEvent(e);
          return;
        } else {
          this.selectChoice(null);
        }
        if (this.opened()) {
          switch (e.which) {
            case KEY.UP:
            case KEY.DOWN:
              this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
              killEvent(e);
              return;
            case KEY.ENTER:
              this.selectHighlighted();
              killEvent(e);
              return;
            case KEY.TAB:
              this.selectHighlighted({
                noFocus: true
              });
              this.close();
              return;
            case KEY.ESC:
              this.cancel(e);
              killEvent(e);
              return;
          }
        }
        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) ||
          e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
          return;
        }
        if (e.which === KEY.ENTER) {
          if (this.opts.openOnEnter === false) {
            return;
          } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
            return;
          }
        }
        this.open();
        if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
          killEvent(e);
        }
        if (e.which === KEY.ENTER) {
          killEvent(e);
        }
      }));
      this.search.on("keyup", this.bind(function(e) {
        this.keydowns = 0;
        this.resizeSearch();
      }));
      this.search.on("blur", this.bind(function(e) {
        this.container.removeClass("select2-container-active");
        this.search.removeClass("select2-focused");
        this.selectChoice(null);
        if (!this.opened()) this.clearSearch();
        e.stopImmediatePropagation();
        this.opts.element.trigger($.Event("select2-blur"));
      }));
      this.container.on("click", selector, this.bind(function(e) {
        if (!this.isInterfaceEnabled()) return;
        if ($(e.target).closest(".select2-search-choice").length &gt; 0) {
          return;
        }
        this.selectChoice(null);
        this.clearPlaceholder();
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.open();
        this.focusSearch();
        e.preventDefault();
      }));
      this.container.on("focus", selector, this.bind(function() {
        if (!this.isInterfaceEnabled()) return;
        if (!this.container.hasClass("select2-container-active")) {
          this.opts.element.trigger($.Event("select2-focus"));
        }
        this.container.addClass("select2-container-active");
        this.dropdown.addClass("select2-drop-active");
        this.clearPlaceholder();
      }));
      this.initContainerWidth();
      this.opts.element.addClass("select2-offscreen");
      this.clearSearch();
    },
    enableInterface: function() {
      if (this.parent.enableInterface.apply(this, arguments)) {
        this.search.prop("disabled", !this.isInterfaceEnabled());
      }
    },
    initSelection: function() {
      var data;
      if (this.opts.element.val() === "" &amp;&amp; this.opts.element.text() === "") {
        this.updateSelection([]);
        this.close();
        this.clearSearch();
      }
      if (this.select || this.opts.element.val() !== "") {
        var self = this;
        this.opts.initSelection.call(null, this.opts.element, function(data) {
          if (data !== undefined &amp;&amp; data !== null) {
            self.updateSelection(data);
            self.close();
            self.clearSearch();
          }
        });
      }
    },
    clearSearch: function() {
      var placeholder = this.getPlaceholder(),
        maxWidth = this.getMaxSearchWidth();
      if (placeholder !== undefined &amp;&amp; this.getVal().length === 0 &amp;&amp; this.search.hasClass("select2-focused") === false) {
        this.search.val(placeholder).addClass("select2-default");
        this.search.width(maxWidth &gt; 0 ? maxWidth : this.container.css("width"));
      } else {
        this.search.val("").width(10);
      }
    },
    clearPlaceholder: function() {
      if (this.search.hasClass("select2-default")) {
        this.search.val("").removeClass("select2-default");
      }
    },
    opening: function() {
      this.clearPlaceholder();
      this.resizeSearch();
      this.parent.opening.apply(this, arguments);
      this.focusSearch();
      if (this.search.val() === "") {
        if (this.nextSearchTerm != undefined) {
          this.search.val(this.nextSearchTerm);
          this.search.select();
        }
      }
      this.updateResults(true);
      if (this.opts.shouldFocusInput(this)) {
        this.search.focus();
      }
      this.opts.element.trigger($.Event("select2-open"));
    },
    close: function() {
      if (!this.opened()) return;
      this.parent.close.apply(this, arguments);
    },
    focus: function() {
      this.close();
      this.search.focus();
    },
    isFocused: function() {
      return this.search.hasClass("select2-focused");
    },
    updateSelection: function(data) {
      var ids = [],
        filtered = [],
        self = this;
      $(data).each(function() {
        if (indexOf(self.id(this), ids) &lt; 0) {
          ids.push(self.id(this));
          filtered.push(this);
        }
      });
      data = filtered;
      this.selection.find(".select2-search-choice").remove();
      $(data).each(function() {
        self.addSelectedChoice(this);
      });
      self.postprocessResults();
    },
    tokenize: function() {
      var input = this.search.val();
      input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
      if (input != null &amp;&amp; input != undefined) {
        this.search.val(input);
        if (input.length &gt; 0) {
          this.open();
        }
      }
    },
    onSelect: function(data, options) {
      if (!this.triggerSelect(data) || data.text === "") {
        return;
      }
      this.addSelectedChoice(data);
      this.opts.element.trigger({
        type: "selected",
        val: this.id(data),
        choice: data
      });
      this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
      this.clearSearch();
      this.updateResults();
      if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect === true);
      if (this.opts.closeOnSelect) {
        this.close();
        this.search.width(10);
      } else {
        if (this.countSelectableResults() &gt; 0) {
          this.search.width(10);
          this.resizeSearch();
          if (this.getMaximumSelectionSize() &gt; 0 &amp;&amp; this.val().length &gt;= this.getMaximumSelectionSize()) {
            this.updateResults(true);
          } else {
            if (this.nextSearchTerm != undefined) {
              this.search.val(this.nextSearchTerm);
              this.updateResults();
              this.search.select();
            }
          }
          this.positionDropdown();
        } else {
          this.close();
          this.search.width(10);
        }
      }
      this.triggerChange({
        added: data
      });
      if (!options || !options.noFocus)
        this.focusSearch();
    },
    cancel: function() {
      this.close();
      this.focusSearch();
    },
    addSelectedChoice: function(data) {
      var enableChoice = !data.locked,
        enabledItem = $(
          "&lt;li class='select2-search-choice'&gt;" +
          "    &lt;div&gt;&lt;/div&gt;" +
          "    &lt;a href='#' class='select2-search-choice-close' tabindex='-1'&gt;&lt;/a&gt;" +
          "&lt;/li&gt;"),
        disabledItem = $(
          "&lt;li class='select2-search-choice select2-locked'&gt;" +
          "&lt;div&gt;&lt;/div&gt;" +
          "&lt;/li&gt;");
      var choice = enableChoice ? enabledItem : disabledItem,
        id = this.id(data),
        val = this.getVal(),
        formatted,
        cssClass;
      formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
      if (formatted != undefined) {
        choice.find("div").replaceWith("&lt;div&gt;" + formatted + "&lt;/div&gt;");
      }
      cssClass = this.opts.formatSelectionCssClass(data, choice.find("div"));
      if (cssClass != undefined) {
        choice.addClass(cssClass);
      }
      if (enableChoice) {
        choice.find(".select2-search-choice-close")
          .on("mousedown", killEvent)
          .on("click dblclick", this.bind(function(e) {
            if (!this.isInterfaceEnabled()) return;
            this.unselect($(e.target));
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
            killEvent(e);
            this.close();
            this.focusSearch();
          })).on("focus", this.bind(function() {
            if (!this.isInterfaceEnabled()) return;
            this.container.addClass("select2-container-active");
            this.dropdown.addClass("select2-drop-active");
          }));
      }
      choice.data("select2-data", data);
      choice.insertBefore(this.searchContainer);
      val.push(id);
      this.setVal(val);
    },
    unselect: function(selected) {
      var val = this.getVal(),
        data,
        index;
      selected = selected.closest(".select2-search-choice");
      if (selected.length === 0) {
        throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
      }
      data = selected.data("select2-data");
      if (!data) {
        return;
      }
      var evt = $.Event("select2-removing");
      evt.val = this.id(data);
      evt.choice = data;
      this.opts.element.trigger(evt);
      if (evt.isDefaultPrevented()) {
        return false;
      }
      while ((index = indexOf(this.id(data), val)) &gt;= 0) {
        val.splice(index, 1);
        this.setVal(val);
        if (this.select) this.postprocessResults();
      }
      selected.remove();
      this.opts.element.trigger({
        type: "select2-removed",
        val: this.id(data),
        choice: data
      });
      this.triggerChange({
        removed: data
      });
      return true;
    },
    postprocessResults: function(data, initial, noHighlightUpdate) {
      var val = this.getVal(),
        choices = this.results.find(".select2-result"),
        compound = this.results.find(".select2-result-with-children"),
        self = this;
      choices.each2(function(i, choice) {
        var id = self.id(choice.data("select2-data"));
        if (indexOf(id, val) &gt;= 0) {
          choice.addClass("select2-selected");
          choice.find(".select2-result-selectable").addClass("select2-selected");
        }
      });
      compound.each2(function(i, choice) {
        if (!choice.is('.select2-result-selectable') &amp;&amp;
          choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
          choice.addClass("select2-selected");
        }
      });
      if (this.highlight() == -1 &amp;&amp; noHighlightUpdate !== false) {
        self.highlight(0);
      }
      if (!this.opts.createSearchChoice &amp;&amp; !choices.filter('.select2-result:not(.select2-selected)').length &gt; 0) {
        if (!data || data &amp;&amp; !data.more &amp;&amp; this.results.find(".select2-no-results").length === 0) {
          if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
            this.results.append("&lt;li class='select2-no-results'&gt;" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "&lt;/li&gt;");
          }
        }
      }
    },
    getMaxSearchWidth: function() {
      return this.selection.width() - getSideBorderPadding(this.search);
    },
    resizeSearch: function() {
      var minimumWidth, left, maxWidth, containerLeft, searchWidth,
        sideBorderPadding = getSideBorderPadding(this.search);
      minimumWidth = measureTextWidth(this.search) + 10;
      left = this.search.offset().left;
      maxWidth = this.selection.width();
      containerLeft = this.selection.offset().left;
      searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
      if (searchWidth &lt; minimumWidth) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth &lt; 40) {
        searchWidth = maxWidth - sideBorderPadding;
      }
      if (searchWidth &lt;= 0) {
        searchWidth = minimumWidth;
      }
      this.search.width(Math.floor(searchWidth));
    },
    getVal: function() {
      var val;
      if (this.select) {
        val = this.select.val();
        return val === null ? [] : val;
      } else {
        val = this.opts.element.val();
        return splitVal(val, this.opts.separator);
      }
    },
    setVal: function(val) {
      var unique;
      if (this.select) {
        this.select.val(val);
      } else {
        unique = [];
        $(val).each(function() {
          if (indexOf(this, unique) &lt; 0) unique.push(this);
        });
        this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
      }
    },
    buildChangeDetails: function(old, current) {
      var current = current.slice(0),
        old = old.slice(0);
      for (var i = 0; i &lt; current.length; i++) {
        for (var j = 0; j &lt; old.length; j++) {
          if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
            current.splice(i, 1);
            if (i &gt; 0) {
              i--;
            }
            old.splice(j, 1);
            j--;
          }
        }
      }
      return {
        added: current,
        removed: old
      };
    },
    val: function(val, triggerChange) {
      var oldData, self = this;
      if (arguments.length === 0) {
        return this.getVal();
      }
      oldData = this.data();
      if (!oldData.length) oldData = [];
      if (!val &amp;&amp; val !== 0) {
        this.opts.element.val("");
        this.updateSelection([]);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange({
            added: this.data(),
            removed: oldData
          });
        }
        return;
      }
      this.setVal(val);
      if (this.select) {
        this.opts.initSelection(this.select, this.bind(this.updateSelection));
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(oldData, this.data()));
        }
      } else {
        if (this.opts.initSelection === undefined) {
          throw new Error("val() cannot be called if initSelection() is not defined");
        }
        this.opts.initSelection(this.opts.element, function(data) {
          var ids = $.map(data, self.id);
          self.setVal(ids);
          self.updateSelection(data);
          self.clearSearch();
          if (triggerChange) {
            self.triggerChange(self.buildChangeDetails(oldData, self.data()));
          }
        });
      }
      this.clearSearch();
    },
    onSortStart: function() {
      if (this.select) {
        throw new Error("Sorting of elements is not supported when attached to &lt;select&gt;. Attach to &lt;input type='hidden'/&gt; instead.");
      }
      this.search.width(0);
      this.searchContainer.hide();
    },
    onSortEnd: function() {
      var val = [],
        self = this;
      this.searchContainer.show();
      this.searchContainer.appendTo(this.searchContainer.parent());
      this.resizeSearch();
      this.selection.find(".select2-search-choice").each(function() {
        val.push(self.opts.id($(this).data("select2-data")));
      });
      this.setVal(val);
      this.triggerChange();
    },
    data: function(values, triggerChange) {
      var self = this,
        ids, old;
      if (arguments.length === 0) {
        return this.selection
          .children(".select2-search-choice")
          .map(function() {
            return $(this).data("select2-data");
          })
          .get();
      } else {
        old = this.data();
        if (!values) {
          values = [];
        }
        ids = $.map(values, function(e) {
          return self.opts.id(e);
        });
        this.setVal(ids);
        this.updateSelection(values);
        this.clearSearch();
        if (triggerChange) {
          this.triggerChange(this.buildChangeDetails(old, this.data()));
        }
      }
    }
  });
  $.fn.select2 = function() {
    var args = Array.prototype.slice.call(arguments, 0),
      opts,
      select2,
      method, value, multiple,
      allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
      valueMethods = ["opened", "isFocused", "container", "dropdown"],
      propertyMethods = ["val", "data"],
      methodsMap = {
        search: "externalSearch"
      };
    this.each(function() {
      if (args.length === 0 || typeof(args[0]) === "object") {
        opts = args.length === 0 ? {} : $.extend({}, args[0]);
        opts.element = $(this);
        if (opts.element.get(0).tagName.toLowerCase() === "select") {
          multiple = opts.element.prop("multiple");
        } else {
          multiple = opts.multiple || false;
          if ("tags" in opts) {
            opts.multiple = multiple = true;
          }
        }
        select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
        select2.init(opts);
      } else if (typeof(args[0]) === "string") {
        if (indexOf(args[0], allowedMethods) &lt; 0) {
          throw "Unknown method: " + args[0];
        }
        value = undefined;
        select2 = $(this).data("select2");
        if (select2 === undefined) return;
        method = args[0];
        if (method === "container") {
          value = select2.container;
        } else if (method === "dropdown") {
          value = select2.dropdown;
        } else {
          if (methodsMap[method]) method = methodsMap[method];
          value = select2[method].apply(select2, args.slice(1));
        }
        if (indexOf(args[0], valueMethods) &gt;= 0 ||
          (indexOf(args[0], propertyMethods) &gt;= 0 &amp;&amp; args.length == 1)) {
          return false;
        }
      } else {
        throw "Invalid arguments to select2 plugin: " + args;
      }
    });
    return (value === undefined) ? this : value;
  };
  $.fn.select2.defaults = {
    width: "copy",
    loadMorePadding: 0,
    closeOnSelect: true,
    openOnEnter: true,
    containerCss: {},
    dropdownCss: {},
    containerCssClass: "",
    dropdownCssClass: "",
    formatResult: function(result, container, query, escapeMarkup) {
      var markup = [];
      markMatch(result.text, query.term, markup, escapeMarkup);
      return markup.join("");
    },
    formatSelection: function(data, container, escapeMarkup) {
      return data ? escapeMarkup(data.text) : undefined;
    },
    sortResults: function(results, container, query) {
      return results;
    },
    formatResultCssClass: function(data) {
      return data.css;
    },
    formatSelectionCssClass: function(data, container) {
      return undefined;
    },
    minimumResultsForSearch: 0,
    minimumInputLength: 0,
    maximumInputLength: null,
    maximumSelectionSize: 0,
    id: function(e) {
      return e == undefined ? null : e.id;
    },
    matcher: function(term, text) {
      return stripDiacritics('' + text).toUpperCase().indexOf(stripDiacritics('' + term).toUpperCase()) &gt;= 0;
    },
    separator: ",",
    tokenSeparators: [],
    tokenizer: defaultTokenizer,
    escapeMarkup: defaultEscapeMarkup,
    blurOnChange: false,
    selectOnBlur: false,
    adaptContainerCssClass: function(c) {
      return c;
    },
    adaptDropdownCssClass: function(c) {
      return null;
    },
    nextSearchTerm: function(selectedObject, currentSearchTerm) {
      return undefined;
    },
    searchInputPlaceholder: '',
    createSearchChoicePosition: 'top',
    shouldFocusInput: function(instance) {
      var supportsTouchEvents = (('ontouchstart' in window) ||
        (navigator.msMaxTouchPoints &gt; 0));
      if (!supportsTouchEvents) {
        return true;
      }
      if (instance.opts.minimumResultsForSearch &lt; 0) {
        return false;
      }
      return true;
    }
  };
  $.fn.select2.locales = [];
  $.fn.select2.locales['en'] = {
    formatMatches: function(matches) {
      if (matches === 1) {
        return "One result is available, press enter to select it.";
      }
      return matches + " results are available, use up and down arrow keys to navigate.";
    },
    formatNoMatches: function() {
      return "No matches found";
    },
    formatAjaxError: function(jqXHR, textStatus, errorThrown) {
      return "Loading failed";
    },
    formatInputTooShort: function(input, min) {
      var n = min - input.length;
      return "Please enter " + n + " or more character" + (n == 1 ? "" : "s");
    },
    formatInputTooLong: function(input, max) {
      var n = input.length - max;
      return "Please delete " + n + " character" + (n == 1 ? "" : "s");
    },
    formatSelectionTooBig: function(limit) {
      return "You can only select " + limit + " item" + (limit == 1 ? "" : "s");
    },
    formatLoadMore: function(pageNumber) {
      return "Loading more results";
    },
    formatSearching: function() {
      return "Searching";
    },
  };
  $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);
  $.fn.select2.ajaxDefaults = {
    transport: $.ajax,
    params: {
      type: "GET",
      cache: false,
      dataType: "json"
    }
  };
  window.Select2 = {
    query: {
      ajax: ajax,
      local: local,
      tags: tags
    },
    util: {
      debounce: debounce,
      markMatch: markMatch,
      escapeMarkup: defaultEscapeMarkup,
      stripDiacritics: stripDiacritics
    },
    "class": {
      "abstract": AbstractSelect2,
      "single": SingleSelect2,
      "multi": MultiSelect2
    }
  };
}(jQuery));;
/*! RESOURCE: /scripts/sp.geo.js */
function spLoadMaps() {
  if (typeof g_google_maps_api_loaded == "undefined") {
    spLoadScript('https://maps.googleapis.com/maps/api/js?v=3.exp&amp;signed_in=true&amp;callback=initMap');
    g_google_maps_api_loaded = true;
  } else
    CustomEvent.fireAll('map.initialized');
}

function spLoadScript(url) {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = url;
  document.body.appendChild(script);
}

function initMap() {
  CustomEvent.fireAll('map.initialized');
};
/*! RESOURCE: /scripts/js_includes_ng_amb.js */
/*! RESOURCE: /scripts/js_includes_amb.js */
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0.min.js */
/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
! function(a, b) {
  "object" == typeof module &amp;&amp; "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = "".trim,
    l = {},
    m = "1.11.0",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return d.call(this)
    },
    get: function(a) {
      return null != a ? 0 &gt; a ? this[a + this.length] : this[a] : d.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a, b) {
      return n.each(this, a, b)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(d.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 &gt; a ? b : 0);
      return this.pushStack(c &gt;= 0 &amp;&amp; b &gt; c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor(null)
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g &amp;&amp; (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i &amp;&amp; (g = this, h--); i &gt; h; h++)
      if (null != (e = arguments[h]))
        for (d in e) a = g[d], c = e[d], g !== c &amp;&amp; (j &amp;&amp; c &amp;&amp; (n.isPlainObject(c) || (b = n.isArray(c))) ? (b ? (b = !1, f = a &amp;&amp; n.isArray(a) ? a : []) : f = a &amp;&amp; n.isPlainObject(a) ? a : {}, g[d] = n.extend(j, f, c)) : void 0 !== c &amp;&amp; (g[d] = c));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray || function(a) {
      return "array" === n.type(a)
    },
    isWindow: function(a) {
      return null != a &amp;&amp; a == a.window
    },
    isNumeric: function(a) {
      return a - parseFloat(a) &gt;= 0
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    isPlainObject: function(a) {
      var b;
      if (!a || "object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;
      try {
        if (a.constructor &amp;&amp; !j.call(a, "constructor") &amp;&amp; !j.call(a.constructor.prototype, "isPrototypeOf")) return !1
      } catch (c) {
        return !1
      }
      if (l.ownLast)
        for (b in a) return j.call(a, b);
      for (b in a);
      return void 0 === b || j.call(a, b)
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
    },
    globalEval: function(b) {
      b &amp;&amp; n.trim(b) &amp;&amp; (a.execScript || function(b) {
        a.eval.call(a, b)
      })(b)
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b, c) {
      var d, e = 0,
        f = a.length,
        g = s(a);
      if (c) {
        if (g) {
          for (; f &gt; e; e++)
            if (d = b.apply(a[e], c), d === !1) break
        } else
          for (e in a)
            if (d = b.apply(a[e], c), d === !1) break
      } else if (g) {
        for (; f &gt; e; e++)
          if (d = b.call(a[e], e, a[e]), d === !1) break
      } else
        for (e in a)
          if (d = b.call(a[e], e, a[e]), d === !1) break;
      return a
    },
    trim: k &amp;&amp; !k.call("\ufeff\xa0") ? function(a) {
      return null == a ? "" : k.call(a)
    } : function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a &amp;&amp; (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
    },
    inArray: function(a, b, c) {
      var d;
      if (b) {
        if (g) return g.call(b, a, c);
        for (d = b.length, c = c ? 0 &gt; c ? Math.max(0, d + c) : c : 0; d &gt; c; c++)
          if (c in b &amp;&amp; b[c] === a) return c
      }
      return -1
    },
    merge: function(a, b) {
      var c = +b.length,
        d = 0,
        e = a.length;
      while (c &gt; d) a[e++] = b[d++];
      if (c !== c)
        while (void 0 !== b[d]) a[e++] = b[d++];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g &gt; f; f++) d = !b(a[f], f), d !== h &amp;&amp; e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, f = 0,
        g = a.length,
        h = s(a),
        i = [];
      if (h)
        for (; g &gt; f; f++) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      else
        for (f in a) d = b(a[f], f, c), null != d &amp;&amp; i.push(d);
      return e.apply([], i)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, e, f;
      return "string" == typeof b &amp;&amp; (f = a[b], b = a, a = f), n.isFunction(a) ? (c = d.call(arguments, 2), e = function() {
        return a.apply(b || this, c.concat(d.call(arguments)))
      }, e.guid = a.guid = a.guid || n.guid++, e) : void 0
    },
    now: function() {
      return +new Date
    },
    support: l
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
    h["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType &amp;&amp; b ? !0 : "array" === c || 0 === b || "number" == typeof b &amp;&amp; b &gt; 0 &amp;&amp; b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = "sizzle" + -new Date,
      t = a.document,
      u = 0,
      v = 0,
      w = eb(),
      x = eb(),
      y = eb(),
      z = function(a, b) {
        return a === b &amp;&amp; (j = !0), 0
      },
      A = "undefined",
      B = 1 &lt;&lt; 31,
      C = {}.hasOwnProperty,
      D = [],
      E = D.pop,
      F = D.push,
      G = D.push,
      H = D.slice,
      I = D.indexOf || function(a) {
        for (var b = 0, c = this.length; c &gt; b; b++)
          if (this[b] === a) return b;
        return -1
      },
      J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      K = "[\\x20\\t\\r\\n\\f]",
      L = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      M = L.replace("w", "w#"),
      N = "\\[" + K + "*(" + L + ")" + K + "*(?:([*^$|!~]?=)" + K + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + M + ")|)|)" + K + "*\\]",
      O = ":(" + L + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + N.replace(3, 8) + ")*)|.*)\\)|)",
      P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"),
      Q = new RegExp("^" + K + "*," + K + "*"),
      R = new RegExp("^" + K + "*([&gt;+~]|" + K + ")" + K + "*"),
      S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"),
      T = new RegExp(O),
      U = new RegExp("^" + M + "$"),
      V = {
        ID: new RegExp("^#(" + L + ")"),
        CLASS: new RegExp("^\\.(" + L + ")"),
        TAG: new RegExp("^(" + L.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + N),
        PSEUDO: new RegExp("^" + O),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + J + ")$", "i"),
        needsContext: new RegExp("^" + K + "*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
      },
      W = /^(?:input|select|textarea|button)$/i,
      X = /^h\d$/i,
      Y = /^[^{]+\{\s*\[native \w/,
      Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      $ = /[+~]/,
      _ = /'|\\/g,
      ab = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"),
      bb = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 &gt; d ? String.fromCharCode(d + 65536) : String.fromCharCode(d &gt;&gt; 10 | 55296, 1023 &amp; d | 56320)
      };
    try {
      G.apply(D = H.call(t.childNodes), t.childNodes), D[t.childNodes.length].nodeType
    } catch (cb) {
      G = {
        apply: D.length ? function(a, b) {
          F.apply(a, H.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function db(a, b, d, e) {
      var f, g, h, i, j, m, p, q, u, v;
      if ((b ? b.ownerDocument || b : t) !== l &amp;&amp; k(b), b = b || l, d = d || [], !a || "string" != typeof a) return d;
      if (1 !== (i = b.nodeType) &amp;&amp; 9 !== i) return [];
      if (n &amp;&amp; !e) {
        if (f = Z.exec(a))
          if (h = f[1]) {
            if (9 === i) {
              if (g = b.getElementById(h), !g || !g.parentNode) return d;
              if (g.id === h) return d.push(g), d
            } else if (b.ownerDocument &amp;&amp; (g = b.ownerDocument.getElementById(h)) &amp;&amp; r(b, g) &amp;&amp; g.id === h) return d.push(g), d
          } else {
            if (f[2]) return G.apply(d, b.getElementsByTagName(a)), d;
            if ((h = f[3]) &amp;&amp; c.getElementsByClassName &amp;&amp; b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(h)), d
          }
        if (c.qsa &amp;&amp; (!o || !o.test(a))) {
          if (q = p = s, u = b, v = 9 === i &amp;&amp; a, 1 === i &amp;&amp; "object" !== b.nodeName.toLowerCase()) {
            m = ob(a), (p = b.getAttribute("id")) ? q = p.replace(_, "\\$&amp;") : b.setAttribute("id", q), q = "[id='" + q + "'] ", j = m.length;
            while (j--) m[j] = q + pb(m[j]);
            u = $.test(a) &amp;&amp; mb(b.parentNode) || b, v = m.join(",")
          }
          if (v) try {
            return G.apply(d, u.querySelectorAll(v)), d
          } catch (w) {} finally {
            p || b.removeAttribute("id")
          }
        }
      }
      return xb(a.replace(P, "$1"), b, d, e)
    }

    function eb() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") &gt; d.cacheLength &amp;&amp; delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function fb(a) {
      return a[s] = !0, a
    }

    function gb(a) {
      var b = l.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null
      }
    }

    function hb(a, b) {
      var c = a.split("|"),
        e = a.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function ib(a, b) {
      var c = b &amp;&amp; a,
        d = c &amp;&amp; 1 === a.nodeType &amp;&amp; 1 === b.nodeType &amp;&amp; (~b.sourceIndex || B) - (~a.sourceIndex || B);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function jb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c &amp;&amp; b.type === a
      }
    }

    function kb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) &amp;&amp; b.type === a
      }
    }

    function lb(a) {
      return fb(function(b) {
        return b = +b, fb(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] &amp;&amp; (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function mb(a) {
      return a &amp;&amp; typeof a.getElementsByTagName !== A &amp;&amp; a
    }
    c = db.support = {}, f = db.isXML = function(a) {
      var b = a &amp;&amp; (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, k = db.setDocument = function(a) {
      var b, e = a ? a.ownerDocument || a : t,
        g = e.defaultView;
      return e !== l &amp;&amp; 9 === e.nodeType &amp;&amp; e.documentElement ? (l = e, m = e.documentElement, n = !f(e), g &amp;&amp; g !== g.top &amp;&amp; (g.addEventListener ? g.addEventListener("unload", function() {
        k()
      }, !1) : g.attachEvent &amp;&amp; g.attachEvent("onunload", function() {
        k()
      })), c.attributes = gb(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = gb(function(a) {
        return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = Y.test(e.getElementsByClassName) &amp;&amp; gb(function(a) {
        return a.innerHTML = "&lt;div class='a'&gt;&lt;/div&gt;&lt;div class='a i'&gt;&lt;/div&gt;", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length
      }), c.getById = gb(function(a) {
        return m.appendChild(a).id = s, !e.getElementsByName || !e.getElementsByName(s).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if (typeof b.getElementById !== A &amp;&amp; n) {
          var c = b.getElementById(a);
          return c &amp;&amp; c.parentNode ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(ab, bb);
        return function(a) {
          var c = typeof a.getAttributeNode !== A &amp;&amp; a.getAttributeNode("id");
          return c &amp;&amp; c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType &amp;&amp; d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName &amp;&amp; function(a, b) {
        return typeof b.getElementsByClassName !== A &amp;&amp; n ? b.getElementsByClassName(a) : void 0
      }, p = [], o = [], (c.qsa = Y.test(e.querySelectorAll)) &amp;&amp; (gb(function(a) {
        a.innerHTML = "&lt;select t=''&gt;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;", a.querySelectorAll("[t^='']").length &amp;&amp; o.push("[*^$]=" + K + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || o.push("\\[" + K + "*(?:value|" + J + ")"), a.querySelectorAll(":checked").length || o.push(":checked")
      }), gb(function(a) {
        var b = e.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length &amp;&amp; o.push("name" + K + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || o.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), o.push(",.*:")
      })), (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) &amp;&amp; gb(function(a) {
        c.disconnectedMatch = q.call(a, "div"), q.call(a, "[s!='']:x"), p.push("!=", O)
      }), o = o.length &amp;&amp; new RegExp(o.join("|")), p = p.length &amp;&amp; new RegExp(p.join("|")), b = Y.test(m.compareDocumentPosition), r = b || Y.test(m.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b &amp;&amp; b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition &amp;&amp; 16 &amp; a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, z = b ? function(a, b) {
        if (a === b) return j = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 &amp; d || !c.sortDetached &amp;&amp; b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t &amp;&amp; r(t, a) ? -1 : b === e || b.ownerDocument === t &amp;&amp; r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 &amp; d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return j = !0, 0;
        var c, d = 0,
          f = a.parentNode,
          g = b.parentNode,
          h = [a],
          k = [b];
        if (!f || !g) return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;
        if (f === g) return ib(a, b);
        c = a;
        while (c = c.parentNode) h.unshift(c);
        c = b;
        while (c = c.parentNode) k.unshift(c);
        while (h[d] === k[d]) d++;
        return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0
      }, e) : l
    }, db.matches = function(a, b) {
      return db(a, null, null, b)
    }, db.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== l &amp;&amp; k(a), b = b.replace(S, "='$1']"), !(!c.matchesSelector || !n || p &amp;&amp; p.test(b) || o &amp;&amp; o.test(b))) try {
        var d = q.call(a, b);
        if (d || c.disconnectedMatch || a.document &amp;&amp; 11 !== a.document.nodeType) return d
      } catch (e) {}
      return db(b, l, null, [a]).length &gt; 0
    }, db.contains = function(a, b) {
      return (a.ownerDocument || a) !== l &amp;&amp; k(a), r(a, b)
    }, db.attr = function(a, b) {
      (a.ownerDocument || a) !== l &amp;&amp; k(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e &amp;&amp; C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;
      return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) &amp;&amp; f.specified ? f.value : null
    }, db.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, db.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (j = !c.detectDuplicates, i = !c.sortStable &amp;&amp; a.slice(0), a.sort(z), j) {
        while (b = a[f++]) b === a[f] &amp;&amp; (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return i = null, a
    }, e = db.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = db.selectors = {
      cacheLength: 50,
      createPseudo: fb,
      match: V,
      attrHandle: {},
      find: {},
      relative: {
        "&gt;": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(ab, bb), a[3] = (a[4] || a[5] || "").replace(ab, bb), "~=" === a[2] &amp;&amp; (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] &amp;&amp; db.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[5] &amp;&amp; a[2];
          return V.CHILD.test(a[0]) ? null : (a[3] &amp;&amp; void 0 !== a[4] ? a[2] = a[4] : c &amp;&amp; T.test(c) &amp;&amp; (b = ob(c, !0)) &amp;&amp; (b = c.indexOf(")", c.length - b) - c.length) &amp;&amp; (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(ab, bb).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName &amp;&amp; a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = w[a + " "];
          return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) &amp;&amp; w(a, function(a) {
            return b.test("string" == typeof a.className &amp;&amp; a.className || typeof a.getAttribute !== A &amp;&amp; a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = db.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c &amp;&amp; 0 === e.indexOf(c) : "*=" === b ? c &amp;&amp; e.indexOf(c) &gt; -1 : "$=" === b ? c &amp;&amp; e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) &gt; -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d &amp;&amp; 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h &amp;&amp; b.nodeName.toLowerCase(),
              t = !i &amp;&amp; !h;
            if (q) {
              if (f) {
                while (p) {
                  l = b;
                  while (l = l[p])
                    if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                  o = p = "only" === a &amp;&amp; !o &amp;&amp; "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g &amp;&amp; t) {
                k = q[s] || (q[s] = {}), j = k[a] || [], n = j[0] === u &amp;&amp; j[1], m = j[0] === u &amp;&amp; j[2], l = n &amp;&amp; q.childNodes[n];
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if (1 === l.nodeType &amp;&amp; ++m &amp;&amp; l === b) {
                    k[a] = [u, n, m];
                    break
                  }
              } else if (t &amp;&amp; (j = (b[s] || (b[s] = {}))[a]) &amp;&amp; j[0] === u) m = j[1];
              else
                while (l = ++n &amp;&amp; l &amp;&amp; l[p] || (m = n = 0) || o.pop())
                  if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) &amp;&amp; ++m &amp;&amp; (t &amp;&amp; ((l[s] || (l[s] = {}))[a] = [u, m]), l === b)) break;
              return m -= e, m === d || m % d === 0 &amp;&amp; m / d &gt;= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error("unsupported pseudo: " + a);
          return e[s] ? e(b) : e.length &gt; 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = I.call(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: fb(function(a) {
          var b = [],
            c = [],
            d = g(a.replace(P, "$1"));
          return d[s] ? fb(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) &amp;&amp; (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), !c.pop()
          }
        }),
        has: fb(function(a) {
          return function(b) {
            return db(a, b).length &gt; 0
          }
        }),
        contains: fb(function(a) {
          return function(b) {
            return (b.textContent || b.innerText || e(b)).indexOf(a) &gt; -1
          }
        }),
        lang: fb(function(a) {
          return U.test(a || "") || db.error("unsupported lang: " + a), a = a.replace(ab, bb).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = n ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) &amp;&amp; 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location &amp;&amp; a.location.hash;
          return c &amp;&amp; c.slice(1) === b.id
        },
        root: function(a) {
          return a === m
        },
        focus: function(a) {
          return a === l.activeElement &amp;&amp; (!l.hasFocus || l.hasFocus()) &amp;&amp; !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; !!a.checked || "option" === b &amp;&amp; !!a.selected
        },
        selected: function(a) {
          return a.parentNode &amp;&amp; a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType &lt; 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return X.test(a.nodeName)
        },
        input: function(a) {
          return W.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b &amp;&amp; "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() &amp;&amp; "text" === a.type &amp;&amp; (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: lb(function() {
          return [0]
        }),
        last: lb(function(a, b) {
          return [b - 1]
        }),
        eq: lb(function(a, b, c) {
          return [0 &gt; c ? c + b : c]
        }),
        even: lb(function(a, b) {
          for (var c = 0; b &gt; c; c += 2) a.push(c);
          return a
        }),
        odd: lb(function(a, b) {
          for (var c = 1; b &gt; c; c += 2) a.push(c);
          return a
        }),
        lt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; --d &gt;= 0;) a.push(d);
          return a
        }),
        gt: lb(function(a, b, c) {
          for (var d = 0 &gt; c ? c + b : c; ++d &lt; b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = jb(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = kb(b);

    function nb() {}
    nb.prototype = d.filters = d.pseudos, d.setFilters = new nb;

    function ob(a, b) {
      var c, e, f, g, h, i, j, k = x[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        (!c || (e = Q.exec(h))) &amp;&amp; (e &amp;&amp; (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) &amp;&amp; (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(P, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = V[g].exec(h)) || j[g] &amp;&amp; !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? db.error(a) : x(a, i).slice(0)
    }

    function pb(a) {
      for (var b = 0, c = a.length, d = ""; c &gt; b; b++) d += a[b].value;
      return d
    }

    function qb(a, b, c) {
      var d = b.dir,
        e = c &amp;&amp; "parentNode" === d,
        f = v++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j = [u, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) &amp;&amp; a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (i = b[s] || (b[s] = {}), (h = i[d]) &amp;&amp; h[0] === u &amp;&amp; h[1] === f) return j[2] = h[2];
              if (i[d] = j, j[2] = a(b, c, g)) return !0
            }
      }
    }

    function rb(a) {
      return a.length &gt; 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function sb(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i &gt; h; h++)(f = a[h]) &amp;&amp; (!c || c(f, d, e)) &amp;&amp; (g.push(f), j &amp;&amp; b.push(h));
      return g
    }

    function tb(a, b, c, d, e, f) {
      return d &amp;&amp; !d[s] &amp;&amp; (d = tb(d)), e &amp;&amp; !e[s] &amp;&amp; (e = tb(e, f)), fb(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || wb(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f &amp;&amp; b ? p : sb(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c &amp;&amp; c(q, r, h, i), d) {
          j = sb(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) &amp;&amp; (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) &amp;&amp; j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) &amp;&amp; (j = e ? I.call(f, l) : m[k]) &gt; -1 &amp;&amp; (f[j] = !(g[j] = l))
          }
        } else r = sb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r)
      })
    }

    function ub(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[" "], j = g ? 1 : 0, k = qb(function(a) {
          return a === b
        }, i, !0), l = qb(function(a) {
          return I.call(b, a) &gt; -1
        }, i, !0), m = [function(a, c, d) {
          return !g &amp;&amp; (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))
        }]; f &gt; j; j++)
        if (c = d.relative[a[j].type]) m = [qb(rb(m), c)];
        else {
          if (c = d.filter[a[j].type].apply(null, a[j].matches), c[s]) {
            for (e = ++j; f &gt; e; e++)
              if (d.relative[a[e].type]) break;
            return tb(j &gt; 1 &amp;&amp; rb(m), j &gt; 1 &amp;&amp; pb(a.slice(0, j - 1).concat({
              value: " " === a[j - 2].type ? "*" : ""
            })).replace(P, "$1"), c, e &gt; j &amp;&amp; ub(a.slice(j, e)), f &gt; e &amp;&amp; ub(a = a.slice(e)), f &gt; e &amp;&amp; pb(a))
          }
          m.push(c)
        }
      return rb(m)
    }

    function vb(a, b) {
      var c = b.length &gt; 0,
        e = a.length &gt; 0,
        f = function(f, g, i, j, k) {
          var m, n, o, p = 0,
            q = "0",
            r = f &amp;&amp; [],
            s = [],
            t = h,
            v = f || e &amp;&amp; d.find.TAG("*", k),
            w = u += null == t ? 1 : Math.random() || .1,
            x = v.length;
          for (k &amp;&amp; (h = g !== l &amp;&amp; g); q !== x &amp;&amp; null != (m = v[q]); q++) {
            if (e &amp;&amp; m) {
              n = 0;
              while (o = a[n++])
                if (o(m, g, i)) {
                  j.push(m);
                  break
                }
              k &amp;&amp; (u = w)
            }
            c &amp;&amp; ((m = !o &amp;&amp; m) &amp;&amp; p--, f &amp;&amp; r.push(m))
          }
          if (p += q, c &amp;&amp; q !== p) {
            n = 0;
            while (o = b[n++]) o(r, s, g, i);
            if (f) {
              if (p &gt; 0)
                while (q--) r[q] || s[q] || (s[q] = E.call(j));
              s = sb(s)
            }
            G.apply(j, s), k &amp;&amp; !f &amp;&amp; s.length &gt; 0 &amp;&amp; p + b.length &gt; 1 &amp;&amp; db.uniqueSort(j)
          }
          return k &amp;&amp; (u = w, h = t), r
        };
      return c ? fb(f) : f
    }
    g = db.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = y[a + " "];
      if (!f) {
        b || (b = ob(a)), c = b.length;
        while (c--) f = ub(b[c]), f[s] ? d.push(f) : e.push(f);
        f = y(a, vb(e, d))
      }
      return f
    };

    function wb(a, b, c) {
      for (var d = 0, e = b.length; e &gt; d; d++) db(a, b[d], c);
      return c
    }

    function xb(a, b, e, f) {
      var h, i, j, k, l, m = ob(a);
      if (!f &amp;&amp; 1 === m.length) {
        if (i = m[0] = m[0].slice(0), i.length &gt; 2 &amp;&amp; "ID" === (j = i[0]).type &amp;&amp; c.getById &amp;&amp; 9 === b.nodeType &amp;&amp; n &amp;&amp; d.relative[i[1].type]) {
          if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0], !b) return e;
          a = a.slice(i.shift().value.length)
        }
        h = V.needsContext.test(a) ? 0 : i.length;
        while (h--) {
          if (j = i[h], d.relative[k = j.type]) break;
          if ((l = d.find[k]) &amp;&amp; (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) &amp;&amp; mb(b.parentNode) || b))) {
            if (i.splice(h, 1), a = f.length &amp;&amp; pb(i), !a) return G.apply(e, f), e;
            break
          }
        }
      }
      return g(a, m)(f, b, !n, e, $.test(a) &amp;&amp; mb(b.parentNode) || b), e
    }
    return c.sortStable = s.split("").sort(z).join("") === s, c.detectDuplicates = !!j, k(), c.sortDetached = gb(function(a) {
      return 1 &amp; a.compareDocumentPosition(l.createElement("div"))
    }), gb(function(a) {
      return a.innerHTML = "&lt;a href='#'&gt;&lt;/a&gt;", "#" === a.firstChild.getAttribute("href")
    }) || hb("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes &amp;&amp; gb(function(a) {
      return a.innerHTML = "&lt;input/&gt;", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || hb("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), gb(function(a) {
      return null == a.getAttribute("disabled")
    }) || hb(J, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) &amp;&amp; d.specified ? d.value : null
    }), db
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = n.expr.match.needsContext,
    v = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/,
    w = /^.[^:#\[\.,]*$/;

  function x(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return n.inArray(a, b) &gt;= 0 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c &amp;&amp; (a = ":not(" + a + ")"), 1 === b.length &amp;&amp; 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = [],
        d = this,
        e = d.length;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; e &gt; b; b++)
          if (n.contains(d[b], this)) return !0
      }));
      for (b = 0; e &gt; b; b++) n.find(a, d[b], c);
      return c = this.pushStack(e &gt; 1 ? n.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c
    },
    filter: function(a) {
      return this.pushStack(x(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(x(this, a || [], !0))
    },
    is: function(a) {
      return !!x(this, "string" == typeof a &amp;&amp; u.test(a) ? n(a) : a || [], !1).length
    }
  });
  var y, z = a.document,
    A = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/,
    B = n.fn.init = function(a, b) {
      var c, d;
      if (!a) return this;
      if ("string" == typeof a) {
        if (c = "&lt;" === a.charAt(0) &amp;&amp; "&gt;" === a.charAt(a.length - 1) &amp;&amp; a.length &gt;= 3 ? [null, a, null] : A.exec(a), !c || !c[1] &amp;&amp; b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
        if (c[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b &amp;&amp; b.nodeType ? b.ownerDocument || b : z, !0)), v.test(c[1]) &amp;&amp; n.isPlainObject(b))
            for (c in b) n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
          return this
        }
        if (d = z.getElementById(c[2]), d &amp;&amp; d.parentNode) {
          if (d.id !== c[2]) return y.find(a);
          this.length = 1, this[0] = d
        }
        return this.context = z, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector &amp;&amp; (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  B.prototype = n.fn, y = n(z);
  var C = /^(?:parents|prev(?:Until|All))/,
    D = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.extend({
    dir: function(a, b, c) {
      var d = [],
        e = a[b];
      while (e &amp;&amp; 9 !== e.nodeType &amp;&amp; (void 0 === c || 1 !== e.nodeType || !n(e).is(c))) 1 === e.nodeType &amp;&amp; d.push(e), e = e[b];
      return d
    },
    sibling: function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType &amp;&amp; a !== b &amp;&amp; c.push(a);
      return c
    }
  }), n.fn.extend({
    has: function(a) {
      var b, c = n(a, this),
        d = c.length;
      return this.filter(function() {
        for (b = 0; d &gt; b; b++)
          if (n.contains(this, c[b])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e &gt; d; d++)
        for (c = this[d]; c &amp;&amp; c !== b; c = c.parentNode)
          if (c.nodeType &lt; 11 &amp;&amp; (g ? g.index(c) &gt; -1 : 1 === c.nodeType &amp;&amp; n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          }
      return this.pushStack(f.length &gt; 1 ? n.unique(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? n.inArray(this[0], n(a)) : n.inArray(a.jquery ? a[0] : a, this) : this[0] &amp;&amp; this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function E(a, b) {
    do a = a[b]; while (a &amp;&amp; 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return n.dir(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return n.dir(a, "parentNode", c)
    },
    next: function(a) {
      return E(a, "nextSibling")
    },
    prev: function(a) {
      return E(a, "previousSibling")
    },
    nextAll: function(a) {
      return n.dir(a, "nextSibling")
    },
    prevAll: function(a) {
      return n.dir(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return n.dir(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return n.dir(a, "previousSibling", c)
    },
    siblings: function(a) {
      return n.sibling((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return n.sibling(a.firstChild)
    },
    contents: function(a) {
      return n.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) &amp;&amp; (d = c), d &amp;&amp; "string" == typeof d &amp;&amp; (e = n.filter(d, e)), this.length &gt; 1 &amp;&amp; (D[a] || (e = n.unique(e)), C.test(a) &amp;&amp; (e = e.reverse())), this.pushStack(e)
    }
  });
  var F = /\S+/g,
    G = {};

  function H(a) {
    var b = G[a] = {};
    return n.each(a.match(F) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? G[a] || H(a) : n.extend({}, a);
    var b, c, d, e, f, g, h = [],
      i = !a.once &amp;&amp; [],
      j = function(l) {
        for (c = a.memory &amp;&amp; l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h &amp;&amp; e &gt; f; f++)
          if (h[f].apply(l[0], l[1]) === !1 &amp;&amp; a.stopOnFalse) {
            c = !1;
            break
          }
        b = !1, h &amp;&amp; (i ? i.length &amp;&amp; j(i.shift()) : c ? h = [] : k.disable())
      },
      k = {
        add: function() {
          if (h) {
            var d = h.length;
            ! function f(b) {
              n.each(b, function(b, c) {
                var d = n.type(c);
                "function" === d ? a.unique &amp;&amp; k.has(c) || h.push(c) : c &amp;&amp; c.length &amp;&amp; "string" !== d &amp;&amp; f(c)
              })
            }(arguments), b ? e = h.length : c &amp;&amp; (g = d, j(c))
          }
          return this
        },
        remove: function() {
          return h &amp;&amp; n.each(arguments, function(a, c) {
            var d;
            while ((d = n.inArray(c, h, d)) &gt; -1) h.splice(d, 1), b &amp;&amp; (e &gt;= d &amp;&amp; e--, f &gt;= d &amp;&amp; f--)
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, h) &gt; -1 : !(!h || !h.length)
        },
        empty: function() {
          return h = [], e = 0, this
        },
        disable: function() {
          return h = i = c = void 0, this
        },
        disabled: function() {
          return !h
        },
        lock: function() {
          return i = void 0, c || k.disable(), this
        },
        locked: function() {
          return !i
        },
        fireWith: function(a, c) {
          return !h || d &amp;&amp; !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this
        },
        fire: function() {
          return k.fireWith(this, arguments), this
        },
        fired: function() {
          return !!d
        }
      };
    return k
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) &amp;&amp; a[b];
                e[f[1]](function() {
                  var a = g &amp;&amp; g.apply(this, arguments);
                  a &amp;&amp; n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h &amp;&amp; g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a &amp;&amp; a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = d.call(arguments),
        e = c.length,
        f = 1 !== e || a &amp;&amp; n.isFunction(a.promise) ? e : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(e) {
            b[a] = this, c[a] = arguments.length &gt; 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (e &gt; 1)
        for (i = new Array(e), j = new Array(e), k = new Array(e); e &gt; b; b++) c[b] &amp;&amp; n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var I;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      if (a === !0 ? !--n.readyWait : !n.isReady) {
        if (!z.body) return setTimeout(n.ready);
        n.isReady = !0, a !== !0 &amp;&amp; --n.readyWait &gt; 0 || (I.resolveWith(z, [n]), n.fn.trigger &amp;&amp; n(z).trigger("ready").off("ready"))
      }
    }
  });

  function J() {
    z.addEventListener ? (z.removeEventListener("DOMContentLoaded", K, !1), a.removeEventListener("load", K, !1)) : (z.detachEvent("onreadystatechange", K), a.detachEvent("onload", K))
  }

  function K() {
    (z.addEventListener || "load" === event.type || "complete" === z.readyState) &amp;&amp; (J(), n.ready())
  }
  n.ready.promise = function(b) {
    if (!I)
      if (I = n.Deferred(), "complete" === z.readyState) setTimeout(n.ready);
      else if (z.addEventListener) z.addEventListener("DOMContentLoaded", K, !1), a.addEventListener("load", K, !1);
    else {
      z.attachEvent("onreadystatechange", K), a.attachEvent("onload", K);
      var c = !1;
      try {
        c = null == a.frameElement &amp;&amp; z.documentElement
      } catch (d) {}
      c &amp;&amp; c.doScroll &amp;&amp; ! function e() {
        if (!n.isReady) {
          try {
            c.doScroll("left")
          } catch (a) {
            return setTimeout(e, 50)
          }
          J(), n.ready()
        }
      }()
    }
    return I.promise(b)
  };
  var L = "undefined",
    M;
  for (M in n(l)) break;
  l.ownLast = "0" !== M, l.inlineBlockNeedsLayout = !1, n(function() {
      var a, b, c = z.getElementsByTagName("body")[0];
      c &amp;&amp; (a = z.createElement("div"), a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", b = z.createElement("div"), c.appendChild(a).appendChild(b), typeof b.style.zoom !== L &amp;&amp; (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) &amp;&amp; (c.style.zoom = 1)), c.removeChild(a), a = b = null)
    }),
    function() {
      var a = z.createElement("div");
      if (null == l.deleteExpando) {
        l.deleteExpando = !0;
        try {
          delete a.test
        } catch (b) {
          l.deleteExpando = !1
        }
      }
      a = null
    }(), n.acceptData = function(a) {
      var b = n.noData[(a.nodeName + " ").toLowerCase()],
        c = +a.nodeType || 1;
      return 1 !== c &amp;&amp; 9 !== c ? !1 : !b || b !== !0 &amp;&amp; a.getAttribute("classid") === b
    };
  var N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;

  function P(a, b, c) {
    if (void 0 === c &amp;&amp; 1 === a.nodeType) {
      var d = "data-" + b.replace(O, "-$1").toLowerCase();
      if (c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
        } catch (e) {}
        n.data(a, b, c)
      } else c = void 0
    }
    return c
  }

  function Q(a) {
    var b;
    for (b in a)
      if (("data" !== b || !n.isEmptyObject(a[b])) &amp;&amp; "toJSON" !== b) return !1;
    return !0
  }

  function R(a, b, d, e) {
    if (n.acceptData(a)) {
      var f, g, h = n.expando,
        i = a.nodeType,
        j = i ? n.cache : a,
        k = i ? a[h] : a[h] &amp;&amp; h;
      if (k &amp;&amp; j[k] &amp;&amp; (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || n.guid++ : h), j[k] || (j[k] = i ? {} : {
        toJSON: n.noop
      }), ("object" == typeof b || "function" == typeof b) &amp;&amp; (e ? j[k] = n.extend(j[k], b) : j[k].data = n.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d &amp;&amp; (g[n.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f &amp;&amp; (f = g[n.camelCase(b)])) : f = g, f
    }
  }

  function S(a, b, c) {
    if (n.acceptData(a)) {
      var d, e, f = a.nodeType,
        g = f ? n.cache : a,
        h = f ? a[n.expando] : n.expando;
      if (g[h]) {
        if (b &amp;&amp; (d = c ? g[h] : g[h].data)) {
          n.isArray(b) ? b = b.concat(n.map(b, n.camelCase)) : b in d ? b = [b] : (b = n.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;
          while (e--) delete d[b[e]];
          if (c ? !Q(d) : !n.isEmptyObject(d)) return
        }(c || (delete g[h].data, Q(g[h]))) &amp;&amp; (f ? n.cleanData([a], !0) : l.deleteExpando || g != g.window ? delete g[h] : g[h] = null)
      }
    }
  }
  n.extend({
    cache: {},
    noData: {
      "applet ": !0,
      "embed ": !0,
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },
    hasData: function(a) {
      return a = a.nodeType ? n.cache[a[n.expando]] : a[n.expando], !!a &amp;&amp; !Q(a)
    },
    data: function(a, b, c) {
      return R(a, b, c)
    },
    removeData: function(a, b) {
      return S(a, b)
    },
    _data: function(a, b, c) {
      return R(a, b, c, !0)
    },
    _removeData: function(a, b) {
      return S(a, b, !0)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f &amp;&amp; f.attributes;
      if (void 0 === a) {
        if (this.length &amp;&amp; (e = n.data(f), 1 === f.nodeType &amp;&amp; !n._data(f, "parsedAttrs"))) {
          c = g.length;
          while (c--) d = g[c].name, 0 === d.indexOf("data-") &amp;&amp; (d = n.camelCase(d.slice(5)), P(f, d, e[d]));
          n._data(f, "parsedAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        n.data(this, a)
      }) : arguments.length &gt; 1 ? this.each(function() {
        n.data(this, a, b)
      }) : f ? P(f, a, n.data(f, a)) : void 0
    },
    removeData: function(a) {
      return this.each(function() {
        n.removeData(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = n._data(a, b), c &amp;&amp; (!d || n.isArray(c) ? d = n._data(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e &amp;&amp; (e = c.shift(), d--), e &amp;&amp; ("fx" === b &amp;&amp; c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d &amp;&amp; f &amp;&amp; f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return n._data(a, c) || n._data(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          n._removeData(a, b + "queue"), n._removeData(a, c)
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a &amp;&amp; (b = a, a = "fx", c--), arguments.length &lt; c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a &amp;&amp; "inprogress" !== c[0] &amp;&amp; n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a &amp;&amp; (b = a, a = void 0), a = a || "fx";
      while (g--) c = n._data(f[g], a + "queueHooks"), c &amp;&amp; c.empty &amp;&amp; (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    U = ["Top", "Right", "Bottom", "Left"],
    V = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    },
    W = n.access = function(a, b, c, d, e, f, g) {
      var h = 0,
        i = a.length,
        j = null == c;
      if ("object" === n.type(c)) {
        e = !0;
        for (h in c) n.access(a, b, h, c[h], !0, f, g)
      } else if (void 0 !== d &amp;&amp; (e = !0, n.isFunction(d) || (g = !0), j &amp;&amp; (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
          return j.call(n(a), c)
        })), b))
        for (; i &gt; h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
      return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
    },
    X = /^(?:checkbox|radio)$/i;
  ! function() {
    var a = z.createDocumentFragment(),
      b = z.createElement("div"),
      c = z.createElement("input");
    if (b.setAttribute("className", "t"), b.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;", l.leadingWhitespace = 3 === b.firstChild.nodeType, l.tbody = !b.getElementsByTagName("tbody").length, l.htmlSerialize = !!b.getElementsByTagName("link").length, l.html5Clone = "&lt;:nav&gt;&lt;/:nav&gt;" !== z.createElement("nav").cloneNode(!0).outerHTML, c.type = "checkbox", c.checked = !0, a.appendChild(c), l.appendChecked = c.checked, b.innerHTML = "&lt;textarea&gt;x&lt;/textarea&gt;", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, a.appendChild(b), b.innerHTML = "&lt;input type='radio' checked='checked' name='t'/&gt;", l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, l.noCloneEvent = !0, b.attachEvent &amp;&amp; (b.attachEvent("onclick", function() {
        l.noCloneEvent = !1
      }), b.cloneNode(!0).click()), null == l.deleteExpando) {
      l.deleteExpando = !0;
      try {
        delete b.test
      } catch (d) {
        l.deleteExpando = !1
      }
    }
    a = b = c = null
  }(),
  function() {
    var b, c, d = z.createElement("div");
    for (b in {
        submit: !0,
        change: !0,
        focusin: !0
      }) c = "on" + b, (l[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), l[b + "Bubbles"] = d.attributes[c].expando === !1);
    d = null
  }();
  var Y = /^(?:input|select|textarea)$/i,
    Z = /^key/,
    $ = /^(?:mouse|contextmenu)|click/,
    _ = /^(?:focusinfocus|focusoutblur)$/,
    ab = /^([^.]*)(?:\.(.+)|)$/;

  function bb() {
    return !0
  }

  function cb() {
    return !1
  }

  function db() {
    try {
      return z.activeElement
    } catch (a) {}
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n._data(a);
      if (r) {
        c.handler &amp;&amp; (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
          return typeof n === L || a &amp;&amp; n.event.triggered === a.type ? void 0 : n.event.dispatch.apply(k.elem, arguments)
        }, k.elem = a), b = (b || "").match(F) || [""], h = b.length;
        while (h--) f = ab.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o &amp;&amp; (j = n.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = n.event.special[o] || {}, l = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e &amp;&amp; n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, i), (m = g[o]) || (m = g[o] = [], m.delegateCount = 0, j.setup &amp;&amp; j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent &amp;&amp; a.attachEvent("on" + o, k))), j.add &amp;&amp; (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), n.event.global[o] = !0);
        a = null
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData(a) &amp;&amp; n._data(a);
      if (r &amp;&amp; (k = r.events)) {
        b = (b || "").match(F) || [""], j = b.length;
        while (j--)
          if (h = ab.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = k[o] || [], h = h[2] &amp;&amp; new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = m.length;
            while (f--) g = m[f], !e &amp;&amp; q !== g.origType || c &amp;&amp; c.guid !== g.guid || h &amp;&amp; !h.test(g.namespace) || d &amp;&amp; d !== g.selector &amp;&amp; ("**" !== d || !g.selector) || (m.splice(f, 1), g.selector &amp;&amp; m.delegateCount--, l.remove &amp;&amp; l.remove.call(a, g));
            i &amp;&amp; !m.length &amp;&amp; (l.teardown &amp;&amp; l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete k[o])
          } else
            for (o in k) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(k) &amp;&amp; (delete r.handle, n._removeData(a, "events"))
      }
    },
    trigger: function(b, c, d, e) {
      var f, g, h, i, k, l, m, o = [d || z],
        p = j.call(b, "type") ? b.type : b,
        q = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (h = l = d = d || z, 3 !== d.nodeType &amp;&amp; 8 !== d.nodeType &amp;&amp; !_.test(p + n.event.triggered) &amp;&amp; (p.indexOf(".") &gt;= 0 &amp;&amp; (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") &lt; 0 &amp;&amp; "on" + p, b = b[n.expando] ? b : new n.Event(p, "object" == typeof b &amp;&amp; b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), k = n.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
        if (!e &amp;&amp; !k.noBubble &amp;&amp; !n.isWindow(d)) {
          for (i = k.delegateType || p, _.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), l = h;
          l === (d.ownerDocument || z) &amp;&amp; o.push(l.defaultView || l.parentWindow || a)
        }
        m = 0;
        while ((h = o[m++]) &amp;&amp; !b.isPropagationStopped()) b.type = m &gt; 1 ? i : k.bindType || p, f = (n._data(h, "events") || {})[b.type] &amp;&amp; n._data(h, "handle"), f &amp;&amp; f.apply(h, c), f = g &amp;&amp; h[g], f &amp;&amp; f.apply &amp;&amp; n.acceptData(h) &amp;&amp; (b.result = f.apply(h, c), b.result === !1 &amp;&amp; b.preventDefault());
        if (b.type = p, !e &amp;&amp; !b.isDefaultPrevented() &amp;&amp; (!k._default || k._default.apply(o.pop(), c) === !1) &amp;&amp; n.acceptData(d) &amp;&amp; g &amp;&amp; d[p] &amp;&amp; !n.isWindow(d)) {
          l = d[g], l &amp;&amp; (d[g] = null), n.event.triggered = p;
          try {
            d[p]()
          } catch (r) {}
          n.event.triggered = void 0, l &amp;&amp; (d[g] = l)
        }
        return b.result
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, e, f, g, h = [],
        i = d.call(arguments),
        j = (n._data(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) &amp;&amp; !a.isPropagationStopped()) {
          a.currentTarget = f.elem, g = 0;
          while ((e = f.handlers[g++]) &amp;&amp; !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(e.namespace)) &amp;&amp; (a.handleObj = e, a.data = e.data, c = ((n.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c &amp;&amp; (a.result = c) === !1 &amp;&amp; (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch &amp;&amp; k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h &amp;&amp; i.nodeType &amp;&amp; (!a.button || "click" !== a.type))
        for (; i != this; i = i.parentNode || this)
          if (1 === i.nodeType &amp;&amp; (i.disabled !== !0 || "click" !== a.type)) {
            for (e = [], f = 0; h &gt; f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] &amp;&amp; (e[c] = d.needsContext ? n(c, this).index(i) &gt;= 0 : n.find(c, this, null, [i]).length), e[c] &amp;&amp; e.push(d);
            e.length &amp;&amp; g.push({
              elem: i,
              handlers: e
            })
          }
      return h &lt; b.length &amp;&amp; g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, d, e = a.type,
        f = a,
        g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = $.test(e) ? this.mouseHooks : Z.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
      while (b--) c = d[b], a[c] = f[c];
      return a.target || (a.target = f.srcElement || z), 3 === a.target.nodeType &amp;&amp; (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which &amp;&amp; (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, d, e, f = b.button,
          g = b.fromElement;
        return null == a.pageX &amp;&amp; null != b.clientX &amp;&amp; (d = a.target.ownerDocument || z, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e &amp;&amp; e.scrollLeft || c &amp;&amp; c.scrollLeft || 0) - (e &amp;&amp; e.clientLeft || c &amp;&amp; c.clientLeft || 0), a.pageY = b.clientY + (e &amp;&amp; e.scrollTop || c &amp;&amp; c.scrollTop || 0) - (e &amp;&amp; e.clientTop || c &amp;&amp; c.clientTop || 0)), !a.relatedTarget &amp;&amp; g &amp;&amp; (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 &amp; f ? 1 : 2 &amp; f ? 3 : 4 &amp; f ? 2 : 0), a
      }
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          if (this !== db() &amp;&amp; this.focus) try {
            return this.focus(), !1
          } catch (a) {}
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === db() &amp;&amp; this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return n.nodeName(this, "input") &amp;&amp; "checkbox" === this.type &amp;&amp; this.click ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result &amp;&amp; (a.originalEvent.returnValue = a.result)
        }
      }
    },
    simulate: function(a, b, c, d) {
      var e = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() &amp;&amp; c.preventDefault()
    }
  }, n.removeEvent = z.removeEventListener ? function(a, b, c) {
    a.removeEventListener &amp;&amp; a.removeEventListener(b, c, !1)
  } : function(a, b, c) {
    var d = "on" + b;
    a.detachEvent &amp;&amp; (typeof a[d] === L &amp;&amp; (a[d] = null), a.detachEvent(d, c))
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a &amp;&amp; a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented &amp;&amp; (a.returnValue === !1 || a.getPreventDefault &amp;&amp; a.getPreventDefault()) ? bb : cb) : this.type = a, b &amp;&amp; n.extend(this, b), this.timeStamp = a &amp;&amp; a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    isDefaultPrevented: cb,
    isPropagationStopped: cb,
    isImmediatePropagationStopped: cb,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = bb, a &amp;&amp; (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = bb, a &amp;&amp; (a.stopPropagation &amp;&amp; a.stopPropagation(), a.cancelBubble = !0)
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = bb, this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return (!e || e !== d &amp;&amp; !n.contains(d, e)) &amp;&amp; (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), l.submitBubbles || (n.event.special.submit = {
    setup: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.add(this, "click._submit keypress._submit", function(a) {
        var b = a.target,
          c = n.nodeName(b, "input") || n.nodeName(b, "button") ? b.form : void 0;
        c &amp;&amp; !n._data(c, "submitBubbles") &amp;&amp; (n.event.add(c, "submit._submit", function(a) {
          a._submit_bubble = !0
        }), n._data(c, "submitBubbles", !0))
      })
    },
    postDispatch: function(a) {
      a._submit_bubble &amp;&amp; (delete a._submit_bubble, this.parentNode &amp;&amp; !a.isTrigger &amp;&amp; n.event.simulate("submit", this.parentNode, a, !0))
    },
    teardown: function() {
      return n.nodeName(this, "form") ? !1 : void n.event.remove(this, "._submit")
    }
  }), l.changeBubbles || (n.event.special.change = {
    setup: function() {
      return Y.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) &amp;&amp; (n.event.add(this, "propertychange._change", function(a) {
        "checked" === a.originalEvent.propertyName &amp;&amp; (this._just_changed = !0)
      }), n.event.add(this, "click._change", function(a) {
        this._just_changed &amp;&amp; !a.isTrigger &amp;&amp; (this._just_changed = !1), n.event.simulate("change", this, a, !0)
      })), !1) : void n.event.add(this, "beforeactivate._change", function(a) {
        var b = a.target;
        Y.test(b.nodeName) &amp;&amp; !n._data(b, "changeBubbles") &amp;&amp; (n.event.add(b, "change._change", function(a) {
          !this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate("change", this.parentNode, a, !0)
        }), n._data(b, "changeBubbles", !0))
      })
    },
    handle: function(a) {
      var b = a.target;
      return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type &amp;&amp; "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0
    },
    teardown: function() {
      return n.event.remove(this, "._change"), !Y.test(this.nodeName)
    }
  }), l.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0)
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b);
        e || d.addEventListener(a, c, !0), n._data(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = n._data(d, b) - 1;
        e ? n._data(d, b, e) : (d.removeEventListener(a, c, !0), n._removeData(d, b))
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d, e) {
      var f, g;
      if ("object" == typeof a) {
        "string" != typeof b &amp;&amp; (c = c || b, b = void 0);
        for (f in a) this.on(f, b, c, a[f], e);
        return this
      }
      if (null == c &amp;&amp; null == d ? (d = b, c = b = void 0) : null == d &amp;&amp; ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = cb;
      else if (!d) return this;
      return 1 === e &amp;&amp; (g = d, d = function(a) {
        return n().off(a), g.apply(this, arguments)
      }, d.guid = g.guid || (g.guid = n.guid++)), this.each(function() {
        n.event.add(this, a, d, c, b)
      })
    },
    one: function(a, b, c, d) {
      return this.on(a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a &amp;&amp; a.preventDefault &amp;&amp; a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return (b === !1 || "function" == typeof b) &amp;&amp; (c = b, b = void 0), c === !1 &amp;&amp; (c = cb), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    },
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  });

  function eb(a) {
    var b = fb.split("|"),
      c = a.createDocumentFragment();
    if (c.createElement)
      while (b.length) c.createElement(b.pop());
    return c
  }
  var fb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    gb = / jQuery\d+="(?:null|\d+)"/g,
    hb = new RegExp("&lt;(?:" + fb + ")[\\s/&gt;]", "i"),
    ib = /^\s+/,
    jb = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
    kb = /&lt;([\w:]+)/,
    lb = /&lt;tbody/i,
    mb = /&lt;|&amp;#?\w+;/,
    nb = /&lt;(?:script|style|link)/i,
    ob = /checked\s*(?:[^=]|=\s*.checked.)/i,
    pb = /^$|\/(?:java|ecma)script/i,
    qb = /^true\/(.*)/,
    rb = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g,
    sb = {
      option: [1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;"],
      legend: [1, "&lt;fieldset&gt;", "&lt;/fieldset&gt;"],
      area: [1, "&lt;map&gt;", "&lt;/map&gt;"],
      param: [1, "&lt;object&gt;", "&lt;/object&gt;"],
      thead: [1, "&lt;table&gt;", "&lt;/table&gt;"],
      tr: [2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;"],
      col: [2, "&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;"],
      td: [3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;"],
      _default: l.htmlSerialize ? [0, "", ""] : [1, "X&lt;div&gt;", "&lt;/div&gt;"]
    },
    tb = eb(z),
    ub = tb.appendChild(z.createElement("div"));
  sb.optgroup = sb.option, sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb.thead, sb.th = sb.td;

  function vb(a, b) {
    var c, d, e = 0,
      f = typeof a.getElementsByTagName !== L ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== L ? a.querySelectorAll(b || "*") : void 0;
    if (!f)
      for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || n.nodeName(d, b) ? f.push(d) : n.merge(f, vb(d, b));
    return void 0 === b || b &amp;&amp; n.nodeName(a, b) ? n.merge([a], f) : f
  }

  function wb(a) {
    X.test(a.type) &amp;&amp; (a.defaultChecked = a.checked)
  }

  function xb(a, b) {
    return n.nodeName(a, "table") &amp;&amp; n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function yb(a) {
    return a.type = (null !== n.find.attr(a, "type")) + "/" + a.type, a
  }

  function zb(a) {
    var b = qb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function Ab(a, b) {
    for (var c, d = 0; null != (c = a[d]); d++) n._data(c, "globalEval", !b || n._data(b[d], "globalEval"))
  }

  function Bb(a, b) {
    if (1 === b.nodeType &amp;&amp; n.hasData(a)) {
      var c, d, e, f = n._data(a),
        g = n._data(b, f),
        h = f.events;
      if (h) {
        delete g.handle, g.events = {};
        for (c in h)
          for (d = 0, e = h[c].length; e &gt; d; d++) n.event.add(b, c, h[c][d])
      }
      g.data &amp;&amp; (g.data = n.extend({}, g.data))
    }
  }

  function Cb(a, b) {
    var c, d, e;
    if (1 === b.nodeType) {
      if (c = b.nodeName.toLowerCase(), !l.noCloneEvent &amp;&amp; b[n.expando]) {
        e = n._data(b);
        for (d in e.events) n.removeEvent(b, d, e.handle);
        b.removeAttribute(n.expando)
      }
      "script" === c &amp;&amp; b.text !== a.text ? (yb(b).text = a.text, zb(b)) : "object" === c ? (b.parentNode &amp;&amp; (b.outerHTML = a.outerHTML), l.html5Clone &amp;&amp; a.innerHTML &amp;&amp; !n.trim(b.innerHTML) &amp;&amp; (b.innerHTML = a.innerHTML)) : "input" === c &amp;&amp; X.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value &amp;&amp; (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) &amp;&amp; (b.defaultValue = a.defaultValue)
    }
  }
  n.extend({
    clone: function(a, b, c) {
      var d, e, f, g, h, i = n.contains(a.ownerDocument, a);
      if (l.html5Clone || n.isXMLDoc(a) || !hb.test("&lt;" + a.nodeName + "&gt;") ? f = a.cloneNode(!0) : (ub.innerHTML = a.outerHTML, ub.removeChild(f = ub.firstChild)), !(l.noCloneEvent &amp;&amp; l.noCloneChecked || 1 !== a.nodeType &amp;&amp; 11 !== a.nodeType || n.isXMLDoc(a)))
        for (d = vb(f), h = vb(a), g = 0; null != (e = h[g]); ++g) d[g] &amp;&amp; Cb(e, d[g]);
      if (b)
        if (c)
          for (h = h || vb(a), d = d || vb(f), g = 0; null != (e = h[g]); g++) Bb(e, d[g]);
        else Bb(a, f);
      return d = vb(f, "script"), d.length &gt; 0 &amp;&amp; Ab(d, !i &amp;&amp; vb(a, "script")), d = h = e = null, f
    },
    buildFragment: function(a, b, c, d) {
      for (var e, f, g, h, i, j, k, m = a.length, o = eb(b), p = [], q = 0; m &gt; q; q++)
        if (f = a[q], f || 0 === f)
          if ("object" === n.type(f)) n.merge(p, f.nodeType ? [f] : f);
          else if (mb.test(f)) {
        h = h || o.appendChild(b.createElement("div")), i = (kb.exec(f) || ["", ""])[1].toLowerCase(), k = sb[i] || sb._default, h.innerHTML = k[1] + f.replace(jb, "&lt;$1&gt;&lt;/$2&gt;") + k[2], e = k[0];
        while (e--) h = h.lastChild;
        if (!l.leadingWhitespace &amp;&amp; ib.test(f) &amp;&amp; p.push(b.createTextNode(ib.exec(f)[0])), !l.tbody) {
          f = "table" !== i || lb.test(f) ? "&lt;table&gt;" !== k[1] || lb.test(f) ? 0 : h : h.firstChild, e = f &amp;&amp; f.childNodes.length;
          while (e--) n.nodeName(j = f.childNodes[e], "tbody") &amp;&amp; !j.childNodes.length &amp;&amp; f.removeChild(j)
        }
        n.merge(p, h.childNodes), h.textContent = "";
        while (h.firstChild) h.removeChild(h.firstChild);
        h = o.lastChild
      } else p.push(b.createTextNode(f));
      h &amp;&amp; o.removeChild(h), l.appendChecked || n.grep(vb(p, "input"), wb), q = 0;
      while (f = p[q++])
        if ((!d || -1 === n.inArray(f, d)) &amp;&amp; (g = n.contains(f.ownerDocument, f), h = vb(o.appendChild(f), "script"), g &amp;&amp; Ab(h), c)) {
          e = 0;
          while (f = h[e++]) pb.test(f.type || "") &amp;&amp; c.push(f)
        }
      return h = null, o
    },
    cleanData: function(a, b) {
      for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null != (d = a[h]); h++)
        if ((b || n.acceptData(d)) &amp;&amp; (f = d[i], g = f &amp;&amp; j[f])) {
          if (g.events)
            for (e in g.events) m[e] ? n.event.remove(d, e) : n.removeEvent(d, e, g.handle);
          j[f] &amp;&amp; (delete j[f], k ? delete d[i] : typeof d.removeAttribute !== L ? d.removeAttribute(i) : d[i] = null, c.push(f))
        }
    }
  }), n.fn.extend({
    text: function(a) {
      return W(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().append((this[0] &amp;&amp; this[0].ownerDocument || z).createTextNode(a))
      }, null, a, arguments.length)
    },
    append: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = xb(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode &amp;&amp; this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    remove: function(a, b) {
      for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || n.cleanData(vb(c)), c.parentNode &amp;&amp; (b &amp;&amp; n.contains(c.ownerDocument, c) &amp;&amp; Ab(vb(c, "script")), c.parentNode.removeChild(c));
      return this
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) {
        1 === a.nodeType &amp;&amp; n.cleanData(vb(a, !1));
        while (a.firstChild) a.removeChild(a.firstChild);
        a.options &amp;&amp; n.nodeName(a, "select") &amp;&amp; (a.options.length = 0)
      }
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return W(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(gb, "") : void 0;
        if (!("string" != typeof a || nb.test(a) || !l.htmlSerialize &amp;&amp; hb.test(a) || !l.leadingWhitespace &amp;&amp; ib.test(a) || sb[(kb.exec(a) || ["", ""])[1].toLowerCase()])) {
          a = a.replace(jb, "&lt;$1&gt;&lt;/$2&gt;");
          try {
            for (; d &gt; c; c++) b = this[c] || {}, 1 === b.nodeType &amp;&amp; (n.cleanData(vb(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b &amp;&amp; this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = arguments[0];
      return this.domManip(arguments, function(b) {
        a = this.parentNode, n.cleanData(vb(this)), a &amp;&amp; a.replaceChild(b, this)
      }), a &amp;&amp; (a.length || a.nodeType) ? this : this.remove()
    },
    detach: function(a) {
      return this.remove(a, !0)
    },
    domManip: function(a, b) {
      a = e.apply([], a);
      var c, d, f, g, h, i, j = 0,
        k = this.length,
        m = this,
        o = k - 1,
        p = a[0],
        q = n.isFunction(p);
      if (q || k &gt; 1 &amp;&amp; "string" == typeof p &amp;&amp; !l.checkClone &amp;&amp; ob.test(p)) return this.each(function(c) {
        var d = m.eq(c);
        q &amp;&amp; (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
      });
      if (k &amp;&amp; (i = n.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length &amp;&amp; (i = c), c)) {
        for (g = n.map(vb(i, "script"), yb), f = g.length; k &gt; j; j++) d = i, j !== o &amp;&amp; (d = n.clone(d, !0, !0), f &amp;&amp; n.merge(g, vb(d, "script"))), b.call(this[j], d, j);
        if (f)
          for (h = g[g.length - 1].ownerDocument, n.map(g, zb), j = 0; f &gt; j; j++) d = g[j], pb.test(d.type || "") &amp;&amp; !n._data(d, "globalEval") &amp;&amp; n.contains(h, d) &amp;&amp; (d.src ? n._evalUrl &amp;&amp; n._evalUrl(d.src) : n.globalEval((d.text || d.textContent || d.innerHTML || "").replace(rb, "")));
        i = c = null
      }
      return this
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = 0, e = [], g = n(a), h = g.length - 1; h &gt;= d; d++) c = d === h ? this : this.clone(!0), n(g[d])[b](c), f.apply(e, c.get());
      return this.pushStack(e)
    }
  });
  var Db, Eb = {};

  function Fb(b, c) {
    var d = n(c.createElement(b)).appendTo(c.body),
      e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : n.css(d[0], "display");
    return d.detach(), e
  }

  function Gb(a) {
    var b = z,
      c = Eb[a];
    return c || (c = Fb(a, b), "none" !== c &amp;&amp; c || (Db = (Db || n("&lt;iframe frameborder='0' width='0' height='0'/&gt;")).appendTo(b.documentElement), b = (Db[0].contentWindow || Db[0].contentDocument).document, b.write(), b.close(), c = Fb(a, b), Db.detach()), Eb[a] = c), c
  }! function() {
    var a, b, c = z.createElement("div"),
      d = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    c.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = c.getElementsByTagName("a")[0], a.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(a.style.opacity), l.cssFloat = !!a.style.cssFloat, c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, l.shrinkWrapBlocks = function() {
      var a, c, e, f;
      if (null == b) {
        if (a = z.getElementsByTagName("body")[0], !a) return;
        f = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", c = z.createElement("div"), e = z.createElement("div"), a.appendChild(c).appendChild(e), b = !1, typeof e.style.zoom !== L &amp;&amp; (e.style.cssText = d + ";width:1px;padding:1px;zoom:1", e.innerHTML = "&lt;div&gt;&lt;/div&gt;", e.firstChild.style.width = "5px", b = 3 !== e.offsetWidth), a.removeChild(c), a = c = e = null
      }
      return b
    }
  }();
  var Hb = /^margin/,
    Ib = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"),
    Jb, Kb, Lb = /^(top|right|bottom|left)$/;
  a.getComputedStyle ? (Jb = function(a) {
    return a.ownerDocument.defaultView.getComputedStyle(a, null)
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c &amp;&amp; ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), Ib.test(g) &amp;&amp; Hb.test(b) &amp;&amp; (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + ""
  }) : z.documentElement.currentStyle &amp;&amp; (Jb = function(a) {
    return a.currentStyle
  }, Kb = function(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || Jb(a), g = c ? c[b] : void 0, null == g &amp;&amp; h &amp;&amp; h[b] &amp;&amp; (g = h[b]), Ib.test(g) &amp;&amp; !Lb.test(b) &amp;&amp; (d = h.left, e = a.runtimeStyle, f = e &amp;&amp; e.left, f &amp;&amp; (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f &amp;&amp; (e.left = f)), void 0 === g ? g : g + "" || "auto"
  });

  function Mb(a, b) {
    return {
      get: function() {
        var c = a();
        if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }! function() {
    var b, c, d, e, f, g, h = z.createElement("div"),
      i = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
      j = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
    h.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", b = h.getElementsByTagName("a")[0], b.style.cssText = "float:left;opacity:.5", l.opacity = /^0.5/.test(b.style.opacity), l.cssFloat = !!b.style.cssFloat, h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === h.style.backgroundClip, b = h = null, n.extend(l, {
      reliableHiddenOffsets: function() {
        if (null != c) return c;
        var a, b, d, e = z.createElement("div"),
          f = z.getElementsByTagName("body")[0];
        if (f) return e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = z.createElement("div"), a.style.cssText = i, f.appendChild(a).appendChild(e), e.innerHTML = "&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;", b = e.getElementsByTagName("td"), b[0].style.cssText = "padding:0;margin:0;border:0;display:none", d = 0 === b[0].offsetHeight, b[0].style.display = "", b[1].style.display = "none", c = d &amp;&amp; 0 === b[0].offsetHeight, f.removeChild(a), e = f = null, c
      },
      boxSizing: function() {
        return null == d &amp;&amp; k(), d
      },
      boxSizingReliable: function() {
        return null == e &amp;&amp; k(), e
      },
      pixelPosition: function() {
        return null == f &amp;&amp; k(), f
      },
      reliableMarginRight: function() {
        var b, c, d, e;
        if (null == g &amp;&amp; a.getComputedStyle) {
          if (b = z.getElementsByTagName("body")[0], !b) return;
          c = z.createElement("div"), d = z.createElement("div"), c.style.cssText = i, b.appendChild(c).appendChild(d), e = d.appendChild(z.createElement("div")), e.style.cssText = d.style.cssText = j, e.style.marginRight = e.style.width = "0", d.style.width = "1px", g = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight), b.removeChild(c)
        }
        return g
      }
    });

    function k() {
      var b, c, h = z.getElementsByTagName("body")[0];
      h &amp;&amp; (b = z.createElement("div"), c = z.createElement("div"), b.style.cssText = i, h.appendChild(b).appendChild(c), c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", n.swap(h, null != h.style.zoom ? {
        zoom: 1
      } : {}, function() {
        d = 4 === c.offsetWidth
      }), e = !0, f = !1, g = !0, a.getComputedStyle &amp;&amp; (f = "1%" !== (a.getComputedStyle(c, null) || {}).top, e = "4px" === (a.getComputedStyle(c, null) || {
        width: "4px"
      }).width), h.removeChild(b), c = h = null)
    }
  }(), n.swap = function(a, b, c, d) {
    var e, f, g = {};
    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
    e = c.apply(a, d || []);
    for (f in b) a.style[f] = g[f];
    return e
  };
  var Nb = /alpha\([^)]*\)/i,
    Ob = /opacity\s*=\s*([^)]*)/,
    Pb = /^(none|table(?!-c[ea]).+)/,
    Qb = new RegExp("^(" + T + ")(.*)$", "i"),
    Rb = new RegExp("^([+-])=(" + T + ")", "i"),
    Sb = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Tb = {
      letterSpacing: 0,
      fontWeight: 400
    },
    Ub = ["Webkit", "O", "Moz", "ms"];

  function Vb(a, b) {
    if (b in a) return b;
    var c = b.charAt(0).toUpperCase() + b.slice(1),
      d = b,
      e = Ub.length;
    while (e--)
      if (b = Ub[e] + c, b in a) return b;
    return d
  }

  function Wb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h &gt; g; g++) d = a[g], d.style &amp;&amp; (f[g] = n._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display &amp;&amp; V(d) &amp;&amp; (f[g] = n._data(d, "olddisplay", Gb(d.nodeName)))) : f[g] || (e = V(d), (c &amp;&amp; "none" !== c || !e) &amp;&amp; n._data(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h &gt; g; g++) d = a[g], d.style &amp;&amp; (b &amp;&amp; "none" !== d.style.display &amp;&amp; "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }

  function Xb(a, b, c) {
    var d = Qb.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
  }

  function Yb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 &gt; f; f += 2) "margin" === c &amp;&amp; (g += n.css(a, c + U[f], !0, e)), d ? ("content" === c &amp;&amp; (g -= n.css(a, "padding" + U[f], !0, e)), "margin" !== c &amp;&amp; (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e), "padding" !== c &amp;&amp; (g += n.css(a, "border" + U[f] + "Width", !0, e)));
    return g
  }

  function Zb(a, b, c) {
    var d = !0,
      e = "width" === b ? a.offsetWidth : a.offsetHeight,
      f = Jb(a),
      g = l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 &gt;= e || null == e) {
      if (e = Kb(a, b, f), (0 &gt; e || null == e) &amp;&amp; (e = a.style[b]), Ib.test(e)) return e;
      d = g &amp;&amp; (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
    }
    return e + Yb(a, b, c || (g ? "border" : "content"), d, f) + "px"
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = Kb(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": l.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function(a, b, c, d) {
      if (a &amp;&amp; 3 !== a.nodeType &amp;&amp; 8 !== a.nodeType &amp;&amp; a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        if (b = n.cssProps[h] || (n.cssProps[h] = Vb(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c) return g &amp;&amp; "get" in g &amp;&amp; void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
        if (f = typeof c, "string" === f &amp;&amp; (e = Rb.exec(c)) &amp;&amp; (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c &amp;&amp; c === c &amp;&amp; ("number" !== f || n.cssNumber[h] || (c += "px"), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g &amp;&amp; "set" in g &amp;&amp; void 0 === (c = g.set(a, c, d))))) try {
          i[b] = "", i[b] = c
        } catch (j) {}
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Vb(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g &amp;&amp; "get" in g &amp;&amp; (f = g.get(a, !0, c)), void 0 === f &amp;&amp; (f = Kb(a, b, d)), "normal" === f &amp;&amp; b in Tb &amp;&amp; (f = Tb[b]), "" === c || c ? (e = parseFloat(f), c === !0 || n.isNumeric(e) ? e || 0 : f) : f
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? 0 === a.offsetWidth &amp;&amp; Pb.test(n.css(a, "display")) ? n.swap(a, Sb, function() {
          return Zb(a, b, d)
        }) : Zb(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e = d &amp;&amp; Jb(a);
        return Xb(a, c, d ? Yb(a, b, d, l.boxSizing() &amp;&amp; "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
      }
    }
  }), l.opacity || (n.cssHooks.opacity = {
    get: function(a, b) {
      return Ob.test((b &amp;&amp; a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""
    },
    set: function(a, b) {
      var c = a.style,
        d = a.currentStyle,
        e = n.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "",
        f = d &amp;&amp; d.filter || c.filter || "";
      c.zoom = 1, (b &gt;= 1 || "" === b) &amp;&amp; "" === n.trim(f.replace(Nb, "")) &amp;&amp; c.removeAttribute &amp;&amp; (c.removeAttribute("filter"), "" === b || d &amp;&amp; !d.filter) || (c.filter = Nb.test(f) ? f.replace(Nb, e) : f + " " + e)
    }
  }), n.cssHooks.marginRight = Mb(l.reliableMarginRight, function(a, b) {
    return b ? n.swap(a, {
      display: "inline-block"
    }, Kb, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 &gt; d; d++) e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, Hb.test(a) || (n.cssHooks[a + b].set = Xb)
  }), n.fn.extend({
    css: function(a, b) {
      return W(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = Jb(a), e = b.length; e &gt; g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length &gt; 1)
    },
    show: function() {
      return Wb(this, !0)
    },
    hide: function() {
      return Wb(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        V(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function $b(a, b, c, d, e) {
    return new $b.prototype.init(a, b, c, d, e)
  }
  n.Tween = $b, $b.prototype = {
    constructor: $b,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = $b.propHooks[this.prop];
      return a &amp;&amp; a.get ? a.get(this) : $b.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = $b.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step &amp;&amp; this.options.step.call(this.elem, this.now, this), c &amp;&amp; c.set ? c.set(this) : $b.propHooks._default.set(this), this
    }
  }, $b.prototype.init.prototype = $b.prototype, $b.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style &amp;&amp; null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b &amp;&amp; "auto" !== b ? b : 0) : a.elem[a.prop]
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style &amp;&amp; (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
      }
    }
  }, $b.propHooks.scrollTop = $b.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType &amp;&amp; a.elem.parentNode &amp;&amp; (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    }
  }, n.fx = $b.prototype.init, n.fx.step = {};
  var _b, ac, bc = /^(?:toggle|show|hide)$/,
    cc = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"),
    dc = /queueHooks$/,
    ec = [jc],
    fc = {
      "*": [function(a, b) {
        var c = this.createTween(a, b),
          d = c.cur(),
          e = cc.exec(b),
          f = e &amp;&amp; e[3] || (n.cssNumber[a] ? "" : "px"),
          g = (n.cssNumber[a] || "px" !== f &amp;&amp; +d) &amp;&amp; cc.exec(n.css(c.elem, a)),
          h = 1,
          i = 20;
        if (g &amp;&amp; g[3] !== f) {
          f = f || g[3], e = e || [], g = +d || 1;
          do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) &amp;&amp; 1 !== h &amp;&amp; --i)
        }
        return e &amp;&amp; (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
      }]
    };

  function gc() {
    return setTimeout(function() {
      _b = void 0
    }), _b = n.now()
  }

  function hc(a, b) {
    var c, d = {
        height: a
      },
      e = 0;
    for (b = b ? 1 : 0; 4 &gt; e; e += 2 - b) c = U[e], d["margin" + c] = d["padding" + c] = a;
    return b &amp;&amp; (d.opacity = d.width = a), d
  }

  function ic(a, b, c) {
    for (var d, e = (fc[b] || []).concat(fc["*"]), f = 0, g = e.length; g &gt; f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function jc(a, b, c) {
    var d, e, f, g, h, i, j, k, m = this,
      o = {},
      p = a.style,
      q = a.nodeType &amp;&amp; V(a),
      r = n._data(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued &amp;&amp; (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, m.always(function() {
      m.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType &amp;&amp; ("height" in b || "width" in b) &amp;&amp; (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css(a, "display"), k = Gb(a.nodeName), "none" === j &amp;&amp; (j = k), "inline" === j &amp;&amp; "none" === n.css(a, "float") &amp;&amp; (l.inlineBlockNeedsLayout &amp;&amp; "inline" !== k ? p.zoom = 1 : p.display = "inline-block")), c.overflow &amp;&amp; (p.overflow = "hidden", l.shrinkWrapBlocks() || m.always(function() {
      p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], bc.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
          if ("show" !== e || !r || void 0 === r[d]) continue;
          q = !0
        }
        o[d] = r &amp;&amp; r[d] || n.style(a, d)
      }
    if (!n.isEmptyObject(o)) {
      r ? "hidden" in r &amp;&amp; (q = r.hidden) : r = n._data(a, "fxshow", {}), f &amp;&amp; (r.hidden = !q), q ? n(a).show() : m.done(function() {
        n(a).hide()
      }), m.done(function() {
        var b;
        n._removeData(a, "fxshow");
        for (b in o) n.style(a, b, o[b])
      });
      for (d in o) g = ic(q ? r[d] : 0, d, m), d in r || (r[d] = g.start, q &amp;&amp; (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function kc(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) &amp;&amp; (e = f[1], f = a[c] = f[0]), c !== d &amp;&amp; (a[d] = f, delete a[c]), g = n.cssHooks[d], g &amp;&amp; "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function lc(a, b, c) {
    var d, e, f = 0,
      g = ec.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = _b || gc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i &gt; g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 &gt; f &amp;&amp; i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {}
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: _b || gc(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d &gt; c; c++) j.tweens[c].run(1);
          return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for (kc(k, j.opts.specialEasing); g &gt; f; f++)
      if (d = ec[f].call(j, a, k, j.opts)) return d;
    return n.map(k, ic, j), n.isFunction(j.opts.start) &amp;&amp; j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(lc, {
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
        for (var c, d = 0, e = a.length; e &gt; d; d++) c = a[d], fc[c] = fc[c] || [], fc[c].unshift(b)
      },
      prefilter: function(a, b) {
        b ? ec.unshift(a) : ec.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a &amp;&amp; "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c &amp;&amp; b || n.isFunction(a) &amp;&amp; a,
        duration: a,
        easing: c &amp;&amp; b || b &amp;&amp; !n.isFunction(b) &amp;&amp; b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) &amp;&amp; (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) &amp;&amp; d.old.call(this), d.queue &amp;&amp; n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(V).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = lc(this, n.extend({}, a), f);
            (e || n._data(this, "finish")) &amp;&amp; b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a &amp;&amp; (c = b, b = a, a = void 0), b &amp;&amp; a !== !1 &amp;&amp; this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a &amp;&amp; a + "queueHooks",
            f = n.timers,
            g = n._data(this);
          if (e) g[e] &amp;&amp; g[e].stop &amp;&amp; d(g[e]);
          else
            for (e in g) g[e] &amp;&amp; g[e].stop &amp;&amp; dc.test(e) &amp;&amp; d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a &amp;&amp; f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          (b || !c) &amp;&amp; n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 &amp;&amp; (a = a || "fx"), this.each(function() {
          var b, c = n._data(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e &amp;&amp; e.stop &amp;&amp; e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this &amp;&amp; f[b].queue === a &amp;&amp; (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g &gt; b; b++) d[b] &amp;&amp; d[b].finish &amp;&amp; d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(hc(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: hc("show"),
      slideUp: hc("hide"),
      slideToggle: hc("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = n.timers,
        c = 0;
      for (_b = n.now(); c &lt; b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
      b.length || n.fx.stop(), _b = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      ac || (ac = setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      clearInterval(ac), ac = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(a, b) {
      return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
        var d = setTimeout(b, a);
        c.stop = function() {
          clearTimeout(d)
        }
      })
    },
    function() {
      var a, b, c, d, e = z.createElement("div");
      e.setAttribute("className", "t"), e.innerHTML = "  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;", a = e.getElementsByTagName("a")[0], c = z.createElement("select"), d = c.appendChild(z.createElement("option")), b = e.getElementsByTagName("input")[0], a.style.cssText = "top:1px", l.getSetAttribute = "t" !== e.className, l.style = /top/.test(a.getAttribute("style")), l.hrefNormalized = "/a" === a.getAttribute("href"), l.checkOn = !!b.value, l.optSelected = d.selected, l.enctype = !!z.createElement("form").enctype, c.disabled = !0, l.optDisabled = !d.disabled, b = z.createElement("input"), b.setAttribute("value", ""), l.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), l.radioValue = "t" === b.value, a = b = c = d = e = null
    }();
  var mc = /\r/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType &amp;&amp; (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) &amp;&amp; (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b &amp;&amp; "set" in b &amp;&amp; void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b &amp;&amp; "get" in b &amp;&amp; void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(mc, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.text(a)
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 &gt; e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 &gt; e ? h : f ? e : 0; h &gt; i; i++)
            if (c = d[i], !(!c.selected &amp;&amp; i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled &amp;&amp; n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            }
          return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--)
            if (d = e[g], n.inArray(n.valHooks.option.get(d), f) &gt;= 0) try {
              d.selected = c = !0
            } catch (h) {
              d.scrollHeight
            } else d.selected = !1;
          return c || (a.selectedIndex = -1), e
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) &gt;= 0 : void 0
      }
    }, l.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  });
  var nc, oc, pc = n.expr.attrHandle,
    qc = /^(?:checked|selected)$/i,
    rc = l.getSetAttribute,
    sc = l.input;
  n.fn.extend({
    attr: function(a, b) {
      return W(this, n.attr, a, b, arguments.length &gt; 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (a &amp;&amp; 3 !== f &amp;&amp; 8 !== f &amp;&amp; 2 !== f) return typeof a.getAttribute === L ? n.prop(a, b, c) : (1 === f &amp;&amp; n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? oc : nc)), void 0 === c ? d &amp;&amp; "get" in d &amp;&amp; null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d &amp;&amp; "set" in d &amp;&amp; void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b))
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b &amp;&amp; b.match(F);
      if (f &amp;&amp; 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) ? sc &amp;&amp; rc || !qc.test(c) ? a[d] = !1 : a[n.camelCase("default-" + c)] = a[d] = !1 : n.attr(a, c, ""), a.removeAttribute(rc ? c : d)
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!l.radioValue &amp;&amp; "radio" === b &amp;&amp; n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c &amp;&amp; (a.value = c), b
          }
        }
      }
    }
  }), oc = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : sc &amp;&amp; rc || !qc.test(c) ? a.setAttribute(!rc &amp;&amp; n.propFix[c] || c, c) : a[n.camelCase("default-" + c)] = a[c] = !0, c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = pc[b] || n.find.attr;
    pc[b] = sc &amp;&amp; rc || !qc.test(b) ? function(a, b, d) {
      var e, f;
      return d || (f = pc[b], pc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, pc[b] = f), e
    } : function(a, b, c) {
      return c ? void 0 : a[n.camelCase("default-" + b)] ? b.toLowerCase() : null
    }
  }), sc &amp;&amp; rc || (n.attrHooks.value = {
    set: function(a, b, c) {
      return n.nodeName(a, "input") ? void(a.defaultValue = b) : nc &amp;&amp; nc.set(a, b, c)
    }
  }), rc || (nc = {
    set: function(a, b, c) {
      var d = a.getAttributeNode(c);
      return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0
    }
  }, pc.id = pc.name = pc.coords = function(a, b, c) {
    var d;
    return c ? void 0 : (d = a.getAttributeNode(b)) &amp;&amp; "" !== d.value ? d.value : null
  }, n.valHooks.button = {
    get: function(a, b) {
      var c = a.getAttributeNode(b);
      return c &amp;&amp; c.specified ? c.value : void 0
    },
    set: nc.set
  }, n.attrHooks.contenteditable = {
    set: function(a, b, c) {
      nc.set(a, "" === b ? !1 : b, c)
    }
  }, n.each(["width", "height"], function(a, b) {
    n.attrHooks[b] = {
      set: function(a, c) {
        return "" === c ? (a.setAttribute(b, "auto"), c) : void 0
      }
    }
  })), l.style || (n.attrHooks.style = {
    get: function(a) {
      return a.style.cssText || void 0
    },
    set: function(a, b) {
      return a.style.cssText = b + ""
    }
  });
  var tc = /^(?:input|select|textarea|button|object)$/i,
    uc = /^(?:a|area)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return W(this, n.prop, a, b, arguments.length &gt; 1)
    },
    removeProp: function(a) {
      return a = n.propFix[a] || a, this.each(function() {
        try {
          this[a] = void 0, delete this[a]
        } catch (b) {}
      })
    }
  }), n.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(a, b, c) {
      var d, e, f, g = a.nodeType;
      if (a &amp;&amp; 3 !== g &amp;&amp; 8 !== g &amp;&amp; 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f &amp;&amp; (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e &amp;&amp; "set" in e &amp;&amp; void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e &amp;&amp; "get" in e &amp;&amp; null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          var b = n.find.attr(a, "tabindex");
          return b ? parseInt(b, 10) : tc.test(a.nodeName) || uc.test(a.nodeName) &amp;&amp; a.href ? 0 : -1
        }
      }
    }
  }), l.hrefNormalized || n.each(["href", "src"], function(a, b) {
    n.propHooks[b] = {
      get: function(a) {
        return a.getAttribute(b, 4)
      }
    }
  }), l.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b &amp;&amp; (b.selectedIndex, b.parentNode &amp;&amp; b.parentNode.selectedIndex), null
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  }), l.enctype || (n.propFix.enctype = "encoding");
  var vc = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : " ")) {
            f = 0;
            while (e = b[f++]) d.indexOf(" " + e + " ") &lt; 0 &amp;&amp; (d += e + " ");
            g = n.trim(d), c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h = 0,
        i = this.length,
        j = 0 === arguments.length || "string" == typeof a &amp;&amp; a;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, this.className))
      });
      if (j)
        for (b = (a || "").match(F) || []; i &gt; h; h++)
          if (c = this[h], d = 1 === c.nodeType &amp;&amp; (c.className ? (" " + c.className + " ").replace(vc, " ") : "")) {
            f = 0;
            while (e = b[f++])
              while (d.indexOf(" " + e + " ") &gt;= 0) d = d.replace(" " + e + " ", " ");
            g = a ? n.trim(d) : "", c.className !== g &amp;&amp; (c.className = g)
          }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b &amp;&amp; "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function(c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b)
      } : function() {
        if ("string" === c) {
          var b, d = 0,
            e = n(this),
            f = a.match(F) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else(c === L || "boolean" === c) &amp;&amp; (this.className &amp;&amp; n._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : n._data(this, "__className__") || "")
      })
    },
    hasClass: function(a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d &gt; c; c++)
        if (1 === this[c].nodeType &amp;&amp; (" " + this[c].className + " ").replace(vc, " ").indexOf(b) &gt;= 0) return !0;
      return !1
    }
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length &gt; 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    },
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    }
  });
  var wc = n.now(),
    xc = /\?/,
    yc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  n.parseJSON = function(b) {
    if (a.JSON &amp;&amp; a.JSON.parse) return a.JSON.parse(b + "");
    var c, d = null,
      e = n.trim(b + "");
    return e &amp;&amp; !n.trim(e.replace(yc, function(a, b, e, f) {
      return c &amp;&amp; b &amp;&amp; (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "")
    })) ? Function("return " + e)() : n.error("Invalid JSON: " + b)
  }, n.parseXML = function(b) {
    var c, d;
    if (!b || "string" != typeof b) return null;
    try {
      a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b))
    } catch (e) {
      c = void 0
    }
    return c &amp;&amp; c.documentElement &amp;&amp; !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c
  };
  var zc, Ac, Bc = /#.*$/,
    Cc = /([?&amp;])_=[^&amp;]*/,
    Dc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    Ec = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    Fc = /^(?:GET|HEAD)$/,
    Gc = /^\/\//,
    Hc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    Ic = {},
    Jc = {},
    Kc = "*/".concat("*");
  try {
    Ac = location.href
  } catch (Lc) {
    Ac = z.createElement("a"), Ac.href = "", Ac = Ac.href
  }
  zc = Hc.exec(Ac.toLowerCase()) || [];

  function Mc(a) {
    return function(b, c) {
      "string" != typeof b &amp;&amp; (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(F) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function Nc(a, b, c, d) {
    var e = {},
      f = a === Jc;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] &amp;&amp; g("*")
  }

  function Oc(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (d in b) void 0 !== b[d] &amp;&amp; ((e[d] ? a : c || (c = {}))[d] = b[d]);
    return c &amp;&amp; n.extend(!0, a, c), a
  }

  function Pc(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === e &amp;&amp; (e = a.mimeType || b.getResponseHeader("Content-Type"));
    if (e)
      for (g in h)
        if (h[g] &amp;&amp; h[g].test(e)) {
          i.unshift(g);
          break
        }
    if (i[0] in c) f = i[0];
    else {
      for (g in c) {
        if (!i[0] || a.converters[g + " " + i[0]]) {
          f = g;
          break
        }
        d || (d = g)
      }
      f = f || d
    }
    return f ? (f !== i[0] &amp;&amp; i.unshift(f), c[f]) : void 0
  }

  function Qc(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] &amp;&amp; (c[a.responseFields[f]] = b), !i &amp;&amp; d &amp;&amp; a.dataFilter &amp;&amp; (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i &amp;&amp; i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f &amp;&amp; (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 &amp;&amp; (f = h[0], k.unshift(h[1]));
            break
          }
      if (g !== !0)
        if (g &amp;&amp; a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ac,
      type: "GET",
      isLocal: Ec.test(zc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": Kc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? Oc(Oc(a, n.ajaxSettings), b) : Oc(n.ajaxSettings, a)
    },
    ajaxPrefilter: Mc(Ic),
    ajaxTransport: Mc(Jc),
    ajax: function(a, b) {
      "object" == typeof a &amp;&amp; (b = a, a = void 0), b = b || {};
      var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b),
        l = k.context || k,
        m = k.context &amp;&amp; (l.nodeType || l.jquery) ? n(l) : n.event,
        o = n.Deferred(),
        p = n.Callbacks("once memory"),
        q = k.statusCode || {},
        r = {},
        s = {},
        t = 0,
        u = "canceled",
        v = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === t) {
              if (!j) {
                j = {};
                while (b = Dc.exec(f)) j[b[1].toLowerCase()] = b[2]
              }
              b = j[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === t ? f : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return t || (a = s[c] = s[c] || a, r[a] = b), this
          },
          overrideMimeType: function(a) {
            return t || (k.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 &gt; t)
                for (b in a) q[b] = [q[b], a[b]];
              else v.always(a[v.status]);
            return this
          },
          abort: function(a) {
            var b = a || u;
            return i &amp;&amp; i.abort(b), x(0, b), this
          }
        };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || Ac) + "").replace(Bc, "").replace(Gc, zc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(F) || [""], null == k.crossDomain &amp;&amp; (c = Hc.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === zc[1] &amp;&amp; c[2] === zc[2] &amp;&amp; (c[3] || ("http:" === c[1] ? "80" : "443")) === (zc[3] || ("http:" === zc[1] ? "80" : "443")))), k.data &amp;&amp; k.processData &amp;&amp; "string" != typeof k.data &amp;&amp; (k.data = n.param(k.data, k.traditional)), Nc(Ic, k, b, v), 2 === t) return v;
      h = k.global, h &amp;&amp; 0 === n.active++ &amp;&amp; n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Fc.test(k.type), e = k.url, k.hasContent || (k.data &amp;&amp; (e = k.url += (xc.test(e) ? "&amp;" : "?") + k.data, delete k.data), k.cache === !1 &amp;&amp; (k.url = Cc.test(e) ? e.replace(Cc, "$1_=" + wc++) : e + (xc.test(e) ? "&amp;" : "?") + "_=" + wc++)), k.ifModified &amp;&amp; (n.lastModified[e] &amp;&amp; v.setRequestHeader("If-Modified-Since", n.lastModified[e]), n.etag[e] &amp;&amp; v.setRequestHeader("If-None-Match", n.etag[e])), (k.data &amp;&amp; k.hasContent &amp;&amp; k.contentType !== !1 || b.contentType) &amp;&amp; v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] &amp;&amp; k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Kc + "; q=0.01" : "") : k.accepts["*"]);
      for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
      if (k.beforeSend &amp;&amp; (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
      u = "abort";
      for (d in {
          success: 1,
          error: 1,
          complete: 1
        }) v[d](k[d]);
      if (i = Nc(Jc, k, b, v)) {
        v.readyState = 1, h &amp;&amp; m.trigger("ajaxSend", [v, k]), k.async &amp;&amp; k.timeout &gt; 0 &amp;&amp; (g = setTimeout(function() {
          v.abort("timeout")
        }, k.timeout));
        try {
          t = 1, i.send(r, x)
        } catch (w) {
          if (!(2 &gt; t)) throw w;
          x(-1, w)
        }
      } else x(-1, "No Transport");

      function x(a, b, c, d) {
        var j, r, s, u, w, x = b;
        2 !== t &amp;&amp; (t = 2, g &amp;&amp; clearTimeout(g), i = void 0, f = d || "", v.readyState = a &gt; 0 ? 4 : 0, j = a &gt;= 200 &amp;&amp; 300 &gt; a || 304 === a, c &amp;&amp; (u = Pc(k, v, c)), u = Qc(k, u, v, j), j ? (k.ifModified &amp;&amp; (w = v.getResponseHeader("Last-Modified"), w &amp;&amp; (n.lastModified[e] = w), w = v.getResponseHeader("etag"), w &amp;&amp; (n.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) &amp;&amp; (x = "error", 0 &gt; a &amp;&amp; (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h &amp;&amp; m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h &amp;&amp; (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")))
      }
      return v
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) &amp;&amp; (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      })
    }
  }), n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      });
      if (this[0]) {
        var b = n(a, this[0].ownerDocument).eq(0).clone(!0);
        this[0].parentNode &amp;&amp; b.insertBefore(this[0]), b.map(function() {
          var a = this;
          while (a.firstChild &amp;&amp; 1 === a.firstChild.nodeType) a = a.firstChild;
          return a
        }).append(this)
      }
      return this
    },
    wrapInner: function(a) {
      return this.each(n.isFunction(a) ? function(b) {
        n(this).wrapInner(a.call(this, b))
      } : function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return a.offsetWidth &lt;= 0 &amp;&amp; a.offsetHeight &lt;= 0 || !l.reliableHiddenOffsets() &amp;&amp; "none" === (a.style &amp;&amp; a.style.display || n.css(a, "display"))
  }, n.expr.filters.visible = function(a) {
    return !n.expr.filters.hidden(a)
  };
  var Rc = /%20/g,
    Sc = /\[\]$/,
    Tc = /\r?\n/g,
    Uc = /^(?:submit|button|image|reset|file)$/i,
    Vc = /^(?:input|select|textarea|keygen)/i;

  function Wc(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || Sc.test(a) ? d(a, e) : Wc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Wc(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b &amp;&amp; (b = n.ajaxSettings &amp;&amp; n.ajaxSettings.traditional), n.isArray(a) || a.jquery &amp;&amp; !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Wc(c, a[c], b, e);
    return d.join("&amp;").replace(Rc, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name &amp;&amp; !n(this).is(":disabled") &amp;&amp; Vc.test(this.nodeName) &amp;&amp; !Uc.test(a) &amp;&amp; (this.checked || !X.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(Tc, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(Tc, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
    return !this.isLocal &amp;&amp; /^(get|post|head|put|delete|options)$/i.test(this.type) &amp;&amp; $c() || _c()
  } : $c;
  var Xc = 0,
    Yc = {},
    Zc = n.ajaxSettings.xhr();
  a.ActiveXObject &amp;&amp; n(a).on("unload", function() {
    for (var a in Yc) Yc[a](void 0, !0)
  }), l.cors = !!Zc &amp;&amp; "withCredentials" in Zc, Zc = l.ajax = !!Zc, Zc &amp;&amp; n.ajaxTransport(function(a) {
    if (!a.crossDomain || l.cors) {
      var b;
      return {
        send: function(c, d) {
          var e, f = a.xhr(),
            g = ++Xc;
          if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
            for (e in a.xhrFields) f[e] = a.xhrFields[e];
          a.mimeType &amp;&amp; f.overrideMimeType &amp;&amp; f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
          for (e in c) void 0 !== c[e] &amp;&amp; f.setRequestHeader(e, c[e] + "");
          f.send(a.hasContent &amp;&amp; a.data || null), b = function(c, e) {
            var h, i, j;
            if (b &amp;&amp; (e || 4 === f.readyState))
              if (delete Yc[g], b = void 0, f.onreadystatechange = n.noop, e) 4 !== f.readyState &amp;&amp; f.abort();
              else {
                j = {}, h = f.status, "string" == typeof f.responseText &amp;&amp; (j.text = f.responseText);
                try {
                  i = f.statusText
                } catch (k) {
                  i = ""
                }
                h || !a.isLocal || a.crossDomain ? 1223 === h &amp;&amp; (h = 204) : h = j.text ? 200 : 404
              }
            j &amp;&amp; d(h, i, j, f.getAllResponseHeaders())
          }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Yc[g] = b : b()
        },
        abort: function() {
          b &amp;&amp; b(void 0, !0)
        }
      }
    }
  });

  function $c() {
    try {
      return new a.XMLHttpRequest
    } catch (b) {}
  }

  function _c() {
    try {
      return new a.ActiveXObject("Microsoft.XMLHTTP")
    } catch (b) {}
  }
  n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache &amp;&amp; (a.cache = !1), a.crossDomain &amp;&amp; (a.type = "GET", a.global = !1)
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c = z.head || n("head")[0] || z.documentElement;
      return {
        send: function(d, e) {
          b = z.createElement("script"), b.async = !0, a.scriptCharset &amp;&amp; (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
            (c || !b.readyState || /loaded|complete/.test(b.readyState)) &amp;&amp; (b.onload = b.onreadystatechange = null, b.parentNode &amp;&amp; b.parentNode.removeChild(b), b = null, c || e(200, "success"))
          }, c.insertBefore(b, c.firstChild)
        },
        abort: function() {
          b &amp;&amp; b.onload(void 0, !0)
        }
      }
    }
  });
  var ad = [],
    bd = /(=)\?(?=&amp;|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = ad.pop() || n.expando + "_" + wc++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 &amp;&amp; (bd.test(b.url) ? "url" : "string" == typeof b.data &amp;&amp; !(b.contentType || "").indexOf("application/x-www-form-urlencoded") &amp;&amp; bd.test(b.data) &amp;&amp; "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(bd, "$1" + e) : b.jsonp !== !1 &amp;&amp; (b.url += (xc.test(b.url) ? "&amp;" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      a[e] = f, b[e] &amp;&amp; (b.jsonpCallback = c.jsonpCallback, ad.push(e)), g &amp;&amp; n.isFunction(f) &amp;&amp; f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b &amp;&amp; (c = b, b = !1), b = b || z;
    var d = v.exec(a),
      e = !c &amp;&amp; [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e &amp;&amp; e.length &amp;&amp; n(e).remove(), n.merge([], d.childNodes))
  };
  var cd = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a &amp;&amp; cd) return cd.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h &gt;= 0 &amp;&amp; (d = a.slice(h, a.length), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b &amp;&amp; "object" == typeof b &amp;&amp; (f = "POST"), g.length &gt; 0 &amp;&amp; n.ajax({
      url: a,
      type: f,
      dataType: "html",
      data: b
    }).done(function(a) {
      e = arguments, g.html(d ? n("&lt;div&gt;").append(n.parseHTML(a)).find(d) : a)
    }).complete(c &amp;&amp; function(a, b) {
      g.each(c, e || [a.responseText, b, a])
    }), this
  }, n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };
  var dd = a.document.documentElement;

  function ed(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k &amp;&amp; (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) &amp;&amp; n.inArray("auto", [f, i]) &gt; -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) &amp;&amp; (b = b.call(a, c, h)), null != b.top &amp;&amp; (m.top = b.top - h.top + g), null != b.left &amp;&amp; (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = {
          top: 0,
          left: 0
        },
        e = this[0],
        f = e &amp;&amp; e.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, e) ? (typeof e.getBoundingClientRect !== L &amp;&amp; (d = e.getBoundingClientRect()), c = ed(f), {
        top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
        left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
      }) : d
    },
    position: function() {
      if (this[0]) {
        var a, b, c = {
            top: 0,
            left: 0
          },
          d = this[0];
        return "fixed" === n.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (c = a.offset()), c.top += n.css(a[0], "borderTopWidth", !0), c.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - c.top - n.css(d, "marginTop", !0),
          left: b.left - c.left - n.css(d, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent || dd;
        while (a &amp;&amp; !n.nodeName(a, "html") &amp;&amp; "static" === n.css(a, "position")) a = a.offsetParent;
        return a || dd
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(a, b) {
    var c = /Y/.test(b);
    n.fn[a] = function(d) {
      return W(this, function(a, d, e) {
        var f = ed(a);
        return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void(f ? f.scrollTo(c ? n(f).scrollLeft() : e, c ? e : n(f).scrollTop()) : a[d] = e)
      }, a, d, arguments.length, null)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = Mb(l.pixelPosition, function(a, c) {
      return c ? (c = Kb(a, b), Ib.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length &amp;&amp; (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return W(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.size = function() {
    return this.length
  }, n.fn.andSelf = n.fn.addBack, "function" == typeof define &amp;&amp; define.amd &amp;&amp; define("jquery", [], function() {
    return n
  });
  var fd = a.jQuery,
    gd = a.$;
  return n.noConflict = function(b) {
    return a.$ === n &amp;&amp; (a.$ = gd), b &amp;&amp; a.jQuery === n &amp;&amp; (a.jQuery = fd), n
  }, typeof b === L &amp;&amp; (a.jQuery = a.$ = n), n
});
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery-1.11.0_no_conflict.js */
(function() {
  window.jQuery1110 = jQuery.noConflict(true);
})();;
/*! RESOURCE: /scripts/thirdparty/cometd/org/cometd.js */
this.org = this.org || {};
org.cometd = {};
org.cometd.JSON = {};
org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
  throw 'Abstract';
};
org.cometd.Utils = {};
org.cometd.Utils.isString = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'string' || value instanceof String;
};
org.cometd.Utils.isArray = function(value) {
  if (value === undefined || value === null) {
    return false;
  }
  return value instanceof Array;
};
org.cometd.Utils.inArray = function(element, array) {
  for (var i = 0; i &lt; array.length; ++i) {
    if (element === array[i]) {
      return i;
    }
  }
  return -1;
};
org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
  return window.setTimeout(function() {
    try {
      funktion();
    } catch (x) {
      cometd._debug('Exception invoking timed function', funktion, x);
    }
  }, delay);
};
org.cometd.Utils.clearTimeout = function(timeoutHandle) {
  window.clearTimeout(timeoutHandle);
};
org.cometd.TransportRegistry = function() {
  var _types = [];
  var _transports = {};
  this.getTransportTypes = function() {
    return _types.slice(0);
  };
  this.findTransportTypes = function(version, crossDomain, url) {
    var result = [];
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      if (_transports[type].accept(version, crossDomain, url) === true) {
        result.push(type);
      }
    }
    return result;
  };
  this.negotiateTransport = function(types, version, crossDomain, url) {
    for (var i = 0; i &lt; _types.length; ++i) {
      var type = _types[i];
      for (var j = 0; j &lt; types.length; ++j) {
        if (type === types[j]) {
          var transport = _transports[type];
          if (transport.accept(version, crossDomain, url) === true) {
            return transport;
          }
        }
      }
    }
    return null;
  };
  this.add = function(type, transport, index) {
    var existing = false;
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      if (typeof index !== 'number') {
        _types.push(type);
      } else {
        _types.splice(index, 0, type);
      }
      _transports[type] = transport;
    }
    return !existing;
  };
  this.find = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        return _transports[type];
      }
    }
    return null;
  };
  this.remove = function(type) {
    for (var i = 0; i &lt; _types.length; ++i) {
      if (_types[i] === type) {
        _types.splice(i, 1);
        var transport = _transports[type];
        delete _transports[type];
        return transport;
      }
    }
    return null;
  };
  this.clear = function() {
    _types = [];
    _transports = {};
  };
  this.reset = function() {
    for (var i = 0; i &lt; _types.length; ++i) {
      _transports[_types[i]].reset();
    }
  };
};
org.cometd.Transport = function() {
  var _type;
  var _cometd;
  this.registered = function(type, cometd) {
    _type = type;
    _cometd = cometd;
  };
  this.unregistered = function() {
    _type = null;
    _cometd = null;
  };
  this._debug = function() {
    _cometd._debug.apply(_cometd, arguments);
  };
  this._mixin = function() {
    return _cometd._mixin.apply(_cometd, arguments);
  };
  this.getConfiguration = function() {
    return _cometd.getConfiguration();
  };
  this.getAdvice = function() {
    return _cometd.getAdvice();
  };
  this.setTimeout = function(funktion, delay) {
    return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
  };
  this.clearTimeout = function(handle) {
    org.cometd.Utils.clearTimeout(handle);
  };
  this.convertToMessages = function(response) {
    if (org.cometd.Utils.isString(response)) {
      try {
        return org.cometd.JSON.fromJSON(response);
      } catch (x) {
        this._debug('Could not convert to JSON the following string', '"' + response + '"');
        throw x;
      }
    }
    if (org.cometd.Utils.isArray(response)) {
      return response;
    }
    if (response === undefined || response === null) {
      return [];
    }
    if (response instanceof Object) {
      return [response];
    }
    throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
  };
  this.accept = function(version, crossDomain, url) {
    throw 'Abstract';
  };
  this.getType = function() {
    return _type;
  };
  this.send = function(envelope, metaConnect) {
    throw 'Abstract';
  };
  this.reset = function() {
    this._debug('Transport', _type, 'reset');
  };
  this.abort = function() {
    this._debug('Transport', _type, 'aborted');
  };
  this.toString = function() {
    return this.getType();
  };
};
org.cometd.Transport.derive = function(baseObject) {
  function F() {}
  F.prototype = baseObject;
  return new F();
};
org.cometd.RequestTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _requestIds = 0;
  var _metaConnectRequest = null;
  var _requests = [];
  var _envelopes = [];

  function _coalesceEnvelopes(envelope) {
    while (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes[0];
      var newEnvelope = envelopeAndRequest[0];
      var newRequest = envelopeAndRequest[1];
      if (newEnvelope.url === envelope.url &amp;&amp;
        newEnvelope.sync === envelope.sync) {
        _envelopes.shift();
        envelope.messages = envelope.messages.concat(newEnvelope.messages);
        this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
        continue;
      }
      break;
    }
  }

  function _transportSend(envelope, request) {
    this.transportSend(envelope, request);
    request.expired = false;
    if (!envelope.sync) {
      var maxDelay = this.getConfiguration().maxNetworkDelay;
      var delay = maxDelay;
      if (request.metaConnect === true) {
        delay += this.getAdvice().timeout;
      }
      this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
      var self = this;
      request.timeout = this.setTimeout(function() {
        request.expired = true;
        var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
        var failure = {
          reason: errorMessage
        };
        var xhr = request.xhr;
        failure.httpCode = self.xhrStatus(xhr);
        self.abortXHR(xhr);
        self._debug(errorMessage);
        self.complete(request, false, request.metaConnect);
        envelope.onFailure(xhr, envelope.messages, failure);
      }, delay);
    }
  }

  function _queueSend(envelope) {
    var requestId = ++_requestIds;
    var request = {
      id: requestId,
      metaConnect: false
    };
    if (_requests.length &lt; this.getConfiguration().maxConnections - 1) {
      _requests.push(request);
      _transportSend.call(this, envelope, request);
    } else {
      this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
      _envelopes.push([envelope, request]);
    }
  }

  function _metaConnectComplete(request) {
    var requestId = request.id;
    this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
    if (_metaConnectRequest !== null &amp;&amp; _metaConnectRequest.id !== requestId) {
      throw 'Longpoll request mismatch, completing request ' + requestId;
    }
    _metaConnectRequest = null;
  }

  function _complete(request, success) {
    var index = org.cometd.Utils.inArray(request, _requests);
    if (index &gt;= 0) {
      _requests.splice(index, 1);
    }
    if (_envelopes.length &gt; 0) {
      var envelopeAndRequest = _envelopes.shift();
      var nextEnvelope = envelopeAndRequest[0];
      var nextRequest = envelopeAndRequest[1];
      this._debug('Transport dequeued request', nextRequest.id);
      if (success) {
        if (this.getConfiguration().autoBatch) {
          _coalesceEnvelopes.call(this, nextEnvelope);
        }
        _queueSend.call(this, nextEnvelope);
        this._debug('Transport completed request', request.id, nextEnvelope);
      } else {
        var self = this;
        this.setTimeout(function() {
          self.complete(nextRequest, false, nextRequest.metaConnect);
          var failure = {
            reason: 'Previous request failed'
          };
          var xhr = nextRequest.xhr;
          failure.httpCode = self.xhrStatus(xhr);
          nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
        }, 0);
      }
    }
  }
  _self.complete = function(request, success, metaConnect) {
    if (metaConnect) {
      _metaConnectComplete.call(this, request);
    } else {
      _complete.call(this, request, success);
    }
  };
  _self.transportSend = function(envelope, request) {
    throw 'Abstract';
  };
  _self.transportSuccess = function(envelope, request, responses) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, true, request.metaConnect);
      if (responses &amp;&amp; responses.length &gt; 0) {
        envelope.onSuccess(responses);
      } else {
        envelope.onFailure(request.xhr, envelope.messages, {
          httpCode: 204
        });
      }
    }
  };
  _self.transportFailure = function(envelope, request, failure) {
    if (!request.expired) {
      this.clearTimeout(request.timeout);
      this.complete(request, false, request.metaConnect);
      envelope.onFailure(request.xhr, envelope.messages, failure);
    }
  };

  function _metaConnectSend(envelope) {
    if (_metaConnectRequest !== null) {
      throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
    }
    var requestId = ++_requestIds;
    this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
    var request = {
      id: requestId,
      metaConnect: true
    };
    _transportSend.call(this, envelope, request);
    _metaConnectRequest = request;
  }
  _self.send = function(envelope, metaConnect) {
    if (metaConnect) {
      _metaConnectSend.call(this, envelope);
    } else {
      _queueSend.call(this, envelope);
    }
  };
  _self.abort = function() {
    _super.abort();
    for (var i = 0; i &lt; _requests.length; ++i) {
      var request = _requests[i];
      this._debug('Aborting request', request);
      this.abortXHR(request.xhr);
    }
    if (_metaConnectRequest) {
      this._debug('Aborting metaConnect request', _metaConnectRequest);
      this.abortXHR(_metaConnectRequest.xhr);
    }
    this.reset();
  };
  _self.reset = function() {
    _super.reset();
    _metaConnectRequest = null;
    _requests = [];
    _envelopes = [];
  };
  _self.abortXHR = function(xhr) {
    if (xhr) {
      try {
        xhr.abort();
      } catch (x) {
        this._debug(x);
      }
    }
  };
  _self.xhrStatus = function(xhr) {
    if (xhr) {
      try {
        return xhr.status;
      } catch (x) {
        this._debug(x);
      }
    }
    return -1;
  };
  return _self;
};
org.cometd.LongPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _supportsCrossDomain = true;
  _self.accept = function(version, crossDomain, url) {
    return _supportsCrossDomain || !crossDomain;
  };
  _self.xhrSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
    var self = this;
    try {
      var sameStack = true;
      request.xhr = this.xhrSend({
        transport: this,
        url: envelope.url,
        sync: envelope.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelope.messages),
        onSuccess: function(response) {
          self._debug('Transport', self.getType(), 'received response', response);
          var success = false;
          try {
            var received = self.convertToMessages(response);
            if (received.length === 0) {
              _supportsCrossDomain = false;
              self.transportFailure(envelope, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelope, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              _supportsCrossDomain = false;
              var failure = {
                exception: x
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              self.transportFailure(envelope, request, failure);
            }
          }
        },
        onError: function(reason, exception) {
          _supportsCrossDomain = false;
          var failure = {
            reason: reason,
            exception: exception
          };
          failure.httpCode = self.xhrStatus(request.xhr);
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelope, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelope, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (x) {
      _supportsCrossDomain = false;
      this.setTimeout(function() {
        self.transportFailure(envelope, request, {
          exception: x
        });
      }, 0);
    }
  };
  _self.reset = function() {
    _super.reset();
    _supportsCrossDomain = true;
  };
  return _self;
};
org.cometd.CallbackPollingTransport = function() {
  var _super = new org.cometd.RequestTransport();
  var _self = org.cometd.Transport.derive(_super);
  var _maxLength = 2000;
  _self.accept = function(version, crossDomain, url) {
    return true;
  };
  _self.jsonpSend = function(packet) {
    throw 'Abstract';
  };
  _self.transportSend = function(envelope, request) {
    var self = this;
    var start = 0;
    var length = envelope.messages.length;
    var lengths = [];
    while (length &gt; 0) {
      var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length));
      var urlLength = envelope.url.length + encodeURI(json).length;
      if (urlLength &gt; _maxLength) {
        if (length === 1) {
          this.setTimeout(function() {
            self.transportFailure(envelope, request, {
              reason: 'Bayeux message too big, max is ' + _maxLength
            });
          }, 0);
          return;
        }
        --length;
        continue;
      }
      lengths.push(length);
      start += length;
      length = envelope.messages.length - start;
    }
    var envelopeToSend = envelope;
    if (lengths.length &gt; 1) {
      var begin = 0;
      var end = lengths[0];
      this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
      envelopeToSend = this._mixin(false, {}, envelope);
      envelopeToSend.messages = envelope.messages.slice(begin, end);
      envelopeToSend.onSuccess = envelope.onSuccess;
      envelopeToSend.onFailure = envelope.onFailure;
      for (var i = 1; i &lt; lengths.length; ++i) {
        var nextEnvelope = this._mixin(false, {}, envelope);
        begin = end;
        end += lengths[i];
        nextEnvelope.messages = envelope.messages.slice(begin, end);
        nextEnvelope.onSuccess = envelope.onSuccess;
        nextEnvelope.onFailure = envelope.onFailure;
        this.send(nextEnvelope, request.metaConnect);
      }
    }
    this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    try {
      var sameStack = true;
      this.jsonpSend({
        transport: this,
        url: envelopeToSend.url,
        sync: envelopeToSend.sync,
        headers: this.getConfiguration().requestHeaders,
        body: org.cometd.JSON.toJSON(envelopeToSend.messages),
        onSuccess: function(responses) {
          var success = false;
          try {
            var received = self.convertToMessages(responses);
            if (received.length === 0) {
              self.transportFailure(envelopeToSend, request, {
                httpCode: 204
              });
            } else {
              success = true;
              self.transportSuccess(envelopeToSend, request, received);
            }
          } catch (x) {
            self._debug(x);
            if (!success) {
              self.transportFailure(envelopeToSend, request, {
                exception: x
              });
            }
          }
        },
        onError: function(reason, exception) {
          var failure = {
            reason: reason,
            exception: exception
          };
          if (sameStack) {
            self.setTimeout(function() {
              self.transportFailure(envelopeToSend, request, failure);
            }, 0);
          } else {
            self.transportFailure(envelopeToSend, request, failure);
          }
        }
      });
      sameStack = false;
    } catch (xx) {
      this.setTimeout(function() {
        self.transportFailure(envelopeToSend, request, {
          exception: xx
        });
      }, 0);
    }
  };
  return _self;
};
org.cometd.WebSocketTransport = function() {
  var _super = new org.cometd.Transport();
  var _self = org.cometd.Transport.derive(_super);
  var _cometd;
  var _webSocketSupported = true;
  var _webSocketConnected = false;
  var _stickyReconnect = true;
  var _envelopes = {};
  var _timeouts = {};
  var _connecting = false;
  var _webSocket = null;
  var _connected = false;
  var _successCallback = null;
  _self.reset = function() {
    _super.reset();
    _webSocketSupported = true;
    _webSocketConnected = false;
    _stickyReconnect = true;
    _envelopes = {};
    _timeouts = {};
    _connecting = false;
    _webSocket = null;
    _connected = false;
    _successCallback = null;
  };

  function _websocketConnect() {
    if (_connecting) {
      return;
    }
    _connecting = true;
    var url = _cometd.getURL().replace(/^http/, 'ws');
    this._debug('Transport', this.getType(), 'connecting to URL', url);
    try {
      var protocol = _cometd.getConfiguration().protocol;
      var webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
    } catch (x) {
      _webSocketSupported = false;
      this._debug('Exception while creating WebSocket object', x);
      throw x;
    }
    _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
    var self = this;
    var connectTimer = null;
    var connectTimeout = _cometd.getConfiguration().connectTimeout;
    if (connectTimeout &gt; 0) {
      connectTimer = this.setTimeout(function() {
        connectTimer = null;
        self._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
        var event = {
          code: 1000,
          reason: 'Connect Timeout'
        };
        self.webSocketClose(webSocket, event.code, event.reason);
        self.onClose(webSocket, event);
      }, connectTimeout);
    }
    var onopen = function() {
      self._debug('WebSocket opened', webSocket);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket) {
        _cometd._warn('Closing Extra WebSocket Connections', webSocket, _webSocket);
        self.webSocketClose(webSocket, 1000, 'Extra Connection');
      } else {
        self.onOpen(webSocket);
      }
    };
    var onclose = function(event) {
      event = event || {
        code: 1000
      };
      self._debug('WebSocket closing', webSocket, event);
      _connecting = false;
      if (connectTimer) {
        self.clearTimeout(connectTimer);
        connectTimer = null;
      }
      if (_webSocket !== null &amp;&amp; webSocket !== _webSocket) {
        self._debug('Closed Extra WebSocket Connection', webSocket);
      } else {
        self.onClose(webSocket, event);
      }
    };
    var onmessage = function(message) {
      self._debug('WebSocket message', message, webSocket);
      if (webSocket !== _webSocket) {
        _cometd._warn('Extra WebSocket Connections', webSocket, _webSocket);
      }
      self.onMessage(webSocket, message);
    };
    webSocket.onopen = onopen;
    webSocket.onclose = onclose;
    webSocket.onerror = function() {
      onclose({
        code: 1002,
        reason: 'Error'
      });
    };
    webSocket.onmessage = onmessage;
    this._debug('Transport', this.getType(), 'configured callbacks on', webSocket);
  }

  function _webSocketSend(webSocket, envelope, metaConnect) {
    var json = org.cometd.JSON.toJSON(envelope.messages);
    webSocket.send(json);
    this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
    var maxDelay = this.getConfiguration().maxNetworkDelay;
    var delay = maxDelay;
    if (metaConnect) {
      delay += this.getAdvice().timeout;
      _connected = true;
    }
    var self = this;
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      (function() {
        var message = envelope.messages[i];
        if (message.id) {
          messageIds.push(message.id);
          _timeouts[message.id] = this.setTimeout(function() {
            self._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', webSocket);
            var event = {
              code: 1000,
              reason: 'Message Timeout'
            };
            self.webSocketClose(webSocket, event.code, event.reason);
            self.onClose(webSocket, event);
          }, delay);
        }
      })();
    }
    this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', _timeouts);
  }

  function _send(webSocket, envelope, metaConnect) {
    try {
      if (webSocket === null) {
        _websocketConnect.call(this);
      } else {
        _webSocketSend.call(this, webSocket, envelope, metaConnect);
      }
    } catch (x) {
      this.setTimeout(function() {
        envelope.onFailure(webSocket, envelope.messages, {
          exception: x
        });
      }, 0);
    }
  }
  _self.onOpen = function(webSocket) {
    this._debug('Transport', this.getType(), 'opened', webSocket);
    _webSocket = webSocket;
    _webSocketConnected = true;
    this._debug('Sending pending messages', _envelopes);
    for (var key in _envelopes) {
      var element = _envelopes[key];
      var envelope = element[0];
      var metaConnect = element[1];
      _successCallback = envelope.onSuccess;
      _webSocketSend.call(this, webSocket, envelope, metaConnect);
    }
  };
  _self.onMessage = function(webSocket, wsMessage) {
    this._debug('Transport', this.getType(), 'received websocket message', wsMessage, webSocket);
    var close = false;
    var messages = this.convertToMessages(wsMessage.data);
    var messageIds = [];
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      if (/^\/meta\//.test(message.channel) || message.successful !== undefined) {
        if (message.id) {
          messageIds.push(message.id);
          var timeout = _timeouts[message.id];
          if (timeout) {
            this.clearTimeout(timeout);
            delete _timeouts[message.id];
            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', _timeouts);
          }
        }
      }
      if ('/meta/connect' === message.channel) {
        _connected = false;
      }
      if ('/meta/disconnect' === message.channel &amp;&amp; !_connected) {
        close = true;
      }
    }
    var removed = false;
    for (var j = 0; j &lt; messageIds.length; ++j) {
      var id = messageIds[j];
      for (var key in _envelopes) {
        var ids = key.split(',');
        var index = org.cometd.Utils.inArray(id, ids);
        if (index &gt;= 0) {
          removed = true;
          ids.splice(index, 1);
          var envelope = _envelopes[key][0];
          var metaConnect = _envelopes[key][1];
          delete _envelopes[key];
          if (ids.length &gt; 0) {
            _envelopes[ids.join(',')] = [envelope, metaConnect];
          }
          break;
        }
      }
    }
    if (removed) {
      this._debug('Transport', this.getType(), 'removed envelope, envelopes', _envelopes);
    }
    _successCallback.call(this, messages);
    if (close) {
      this.webSocketClose(webSocket, 1000, 'Disconnect');
    }
  };
  _self.onClose = function(webSocket, event) {
    this._debug('Transport', this.getType(), 'closed', webSocket, event);
    _webSocketSupported = _stickyReconnect &amp;&amp; _webSocketConnected;
    for (var id in _timeouts) {
      this.clearTimeout(_timeouts[id]);
    }
    _timeouts = {};
    for (var key in _envelopes) {
      var envelope = _envelopes[key][0];
      var metaConnect = _envelopes[key][1];
      if (metaConnect) {
        _connected = false;
      }
      envelope.onFailure(webSocket, envelope.messages, {
        websocketCode: event.code,
        reason: event.reason
      });
    }
    _envelopes = {};
    _webSocket = null;
  };
  _self.registered = function(type, cometd) {
    _super.registered(type, cometd);
    _cometd = cometd;
  };
  _self.accept = function(version, crossDomain, url) {
    return _webSocketSupported &amp;&amp; !!org.cometd.WebSocket &amp;&amp; _cometd.websocketEnabled !== false;
  };
  _self.send = function(envelope, metaConnect) {
    this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
    var messageIds = [];
    for (var i = 0; i &lt; envelope.messages.length; ++i) {
      var message = envelope.messages[i];
      if (message.id) {
        messageIds.push(message.id);
      }
    }
    _envelopes[messageIds.join(',')] = [envelope, metaConnect];
    this._debug('Transport', this.getType(), 'stored envelope, envelopes', _envelopes);
    _send.call(this, _webSocket, envelope, metaConnect);
  };
  _self.webSocketClose = function(webSocket, code, reason) {
    try {
      webSocket.close(code, reason);
    } catch (x) {
      this._debug(x);
    }
  };
  _self.abort = function() {
    _super.abort();
    if (_webSocket) {
      var event = {
        code: 1001,
        reason: 'Abort'
      };
      this.webSocketClose(_webSocket, event.code, event.reason);
      this.onClose(_webSocket, event);
    }
    this.reset();
  };
  return _self;
};
org.cometd.Cometd = function(name) {
  var _cometd = this;
  var _name = name || 'default';
  var _crossDomain = false;
  var _transports = new org.cometd.TransportRegistry();
  var _transport;
  var _status = 'disconnected';
  var _messageId = 0;
  var _clientId = null;
  var _batch = 0;
  var _messageQueue = [];
  var _internalBatch = false;
  var _listeners = {};
  var _backoff = 0;
  var _scheduledSend = null;
  var _extensions = [];
  var _advice = {};
  var _handshakeProps;
  var _handshakeCallback;
  var _callbacks = {};
  var _reestablish = false;
  var _connected = false;
  var _config = {
    protocol: null,
    stickyReconnect: true,
    connectTimeout: 0,
    maxConnections: 2,
    backoffIncrement: 1000,
    maxBackoff: 60000,
    logLevel: 'info',
    reverseIncomingExtensions: true,
    maxNetworkDelay: 10000,
    requestHeaders: {},
    appendMessageTypeToURL: true,
    autoBatch: false,
    advice: {
      timeout: 60000,
      interval: 0,
      reconnect: 'retry'
    }
  };

  function _fieldValue(object, name) {
    try {
      return object[name];
    } catch (x) {
      return undefined;
    }
  }
  this._mixin = function(deep, target, objects) {
    var result = target || {};
    for (var i = 2; i &lt; arguments.length; ++i) {
      var object = arguments[i];
      if (object === undefined || object === null) {
        continue;
      }
      for (var propName in object) {
        var prop = _fieldValue(object, propName);
        var targ = _fieldValue(result, propName);
        if (prop === target) {
          continue;
        }
        if (prop === undefined) {
          continue;
        }
        if (deep &amp;&amp; typeof prop === 'object' &amp;&amp; prop !== null) {
          if (prop instanceof Array) {
            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
          } else {
            var source = typeof targ === 'object' &amp;&amp; !(targ instanceof Array) ? targ : {};
            result[propName] = this._mixin(deep, source, prop);
          }
        } else {
          result[propName] = prop;
        }
      }
    }
    return result;
  };

  function _isString(value) {
    return org.cometd.Utils.isString(value);
  }

  function _isFunction(value) {
    if (value === undefined || value === null) {
      return false;
    }
    return typeof value === 'function';
  }

  function _log(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (_isFunction(logger)) {
        logger.apply(window.console, args);
      }
    }
  }
  this._warn = function() {
    _log('warn', arguments);
  };
  this._info = function() {
    if (_config.logLevel !== 'warn') {
      _log('info', arguments);
    }
  };
  this._debug = function() {
    if (_config.logLevel === 'debug') {
      _log('debug', arguments);
    }
  };
  this._isCrossDomain = function(hostAndPort) {
    return hostAndPort &amp;&amp; hostAndPort !== window.location.host;
  };

  function _configure(configuration) {
    _cometd._debug('Configuring cometd object with', configuration);
    if (_isString(configuration)) {
      configuration = {
        url: configuration
      };
    }
    if (!configuration) {
      configuration = {};
    }
    _config = _cometd._mixin(false, _config, configuration);
    var url = _cometd.getURL();
    if (!url) {
      throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
    }
    var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
    var hostAndPort = urlParts[2];
    var uri = urlParts[8];
    var afterURI = urlParts[9];
    _crossDomain = _cometd._isCrossDomain(hostAndPort);
    if (_config.appendMessageTypeToURL) {
      if (afterURI !== undefined &amp;&amp; afterURI.length &gt; 0) {
        _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
        _config.appendMessageTypeToURL = false;
      } else {
        var uriSegments = uri.split('/');
        var lastSegmentIndex = uriSegments.length - 1;
        if (uri.match(/\/$/)) {
          lastSegmentIndex -= 1;
        }
        if (uriSegments[lastSegmentIndex].indexOf('.') &gt;= 0) {
          _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
          _config.appendMessageTypeToURL = false;
        }
      }
    }
  }

  function _removeListener(subscription) {
    if (subscription) {
      var subscriptions = _listeners[subscription.channel];
      if (subscriptions &amp;&amp; subscriptions[subscription.id]) {
        delete subscriptions[subscription.id];
        _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
      }
    }
  }

  function _removeSubscription(subscription) {
    if (subscription &amp;&amp; !subscription.listener) {
      _removeListener(subscription);
    }
  }

  function _clearSubscriptions() {
    for (var channel in _listeners) {
      var subscriptions = _listeners[channel];
      if (subscriptions) {
        for (var i = 0; i &lt; subscriptions.length; ++i) {
          _removeSubscription(subscriptions[i]);
        }
      }
    }
  }

  function _setStatus(newStatus) {
    if (_status !== newStatus) {
      _cometd._debug('Status', _status, '-&gt;', newStatus);
      _status = newStatus;
    }
  }

  function _isDisconnected() {
    return _status === 'disconnecting' || _status === 'disconnected';
  }

  function _nextMessageId() {
    return ++_messageId;
  }

  function _applyExtension(scope, callback, name, message, outgoing) {
    try {
      return callback.call(scope, message);
    } catch (x) {
      _cometd._debug('Exception during execution of extension', name, x);
      var exceptionCallback = _cometd.onExtensionException;
      if (_isFunction(exceptionCallback)) {
        _cometd._debug('Invoking extension exception callback', name, x);
        try {
          exceptionCallback.call(_cometd, x, name, outgoing, message);
        } catch (xx) {
          _cometd._info('Exception during execution of exception callback in extension', name, xx);
        }
      }
      return message;
    }
  }

  function _applyIncomingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
      var extension = _extensions[index];
      var callback = extension.extension.incoming;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, false);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _applyOutgoingExtensions(message) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      if (message === undefined || message === null) {
        break;
      }
      var extension = _extensions[i];
      var callback = extension.extension.outgoing;
      if (_isFunction(callback)) {
        var result = _applyExtension(extension.extension, callback, extension.name, message, true);
        message = result === undefined ? message : result;
      }
    }
    return message;
  }

  function _notify(channel, message) {
    var subscriptions = _listeners[channel];
    if (subscriptions &amp;&amp; subscriptions.length &gt; 0) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        var subscription = subscriptions[i];
        if (subscription) {
          try {
            subscription.callback.call(subscription.scope, message);
          } catch (x) {
            _cometd._debug('Exception during notification', subscription, message, x);
            var listenerCallback = _cometd.onListenerException;
            if (_isFunction(listenerCallback)) {
              _cometd._debug('Invoking listener exception callback', subscription, x);
              try {
                listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
              } catch (xx) {
                _cometd._info('Exception during execution of listener callback', subscription, xx);
              }
            }
          }
        }
      }
    }
  }

  function _notifyListeners(channel, message) {
    _notify(channel, message);
    var channelParts = channel.split('/');
    var last = channelParts.length - 1;
    for (var i = last; i &gt; 0; --i) {
      var channelPart = channelParts.slice(0, i).join('/') + '/*';
      if (i === last) {
        _notify(channelPart, message);
      }
      channelPart += '*';
      _notify(channelPart, message);
    }
  }

  function _cancelDelayedSend() {
    if (_scheduledSend !== null) {
      org.cometd.Utils.clearTimeout(_scheduledSend);
    }
    _scheduledSend = null;
  }

  function _delayedSend(operation) {
    _cancelDelayedSend();
    var delay = _advice.interval + _backoff;
    _cometd._debug('Function scheduled in', delay, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
    _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
  }
  var _handleMessages;
  var _handleFailure;

  function _send(sync, messages, longpoll, extraPath) {
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var messageId = '' + _nextMessageId();
      message.id = messageId;
      if (_clientId) {
        message.clientId = _clientId;
      }
      var callback = undefined;
      if (_isFunction(message._callback)) {
        callback = message._callback;
        delete message._callback;
      }
      message = _applyOutgoingExtensions(message);
      if (message !== undefined &amp;&amp; message !== null) {
        message.id = messageId;
        messages[i] = message;
        if (callback) {
          _callbacks[messageId] = callback;
        }
      } else {
        messages.splice(i--, 1);
      }
    }
    if (messages.length === 0) {
      return;
    }
    var url = _cometd.getURL();
    if (_config.appendMessageTypeToURL) {
      if (!url.match(/\/$/)) {
        url = url + '/';
      }
      if (extraPath) {
        url = url + extraPath;
      }
    }
    var envelope = {
      url: url,
      sync: sync,
      messages: messages,
      onSuccess: function(rcvdMessages) {
        try {
          _handleMessages.call(_cometd, rcvdMessages);
        } catch (x) {
          _cometd._debug('Exception during handling of messages', x);
        }
      },
      onFailure: function(conduit, messages, failure) {
        try {
          failure.connectionType = _cometd.getTransport().getType();
          _handleFailure.call(_cometd, conduit, messages, failure);
        } catch (x) {
          _cometd._debug('Exception during handling of failure', x);
        }
      }
    };
    _cometd._debug('Send', envelope);
    _transport.send(envelope, longpoll);
  }

  function _queueSend(message) {
    if (_batch &gt; 0 || _internalBatch === true) {
      _messageQueue.push(message);
    } else {
      _send(false, [message], false);
    }
  }
  this.send = _queueSend;

  function _resetBackoff() {
    _backoff = 0;
  }

  function _increaseBackoff() {
    if (_backoff &lt; _config.maxBackoff) {
      _backoff += _config.backoffIncrement;
    }
  }

  function _startBatch() {
    ++_batch;
  }

  function _flushBatch() {
    var messages = _messageQueue;
    _messageQueue = [];
    if (messages.length &gt; 0) {
      _send(false, messages, false);
    }
  }

  function _endBatch() {
    --_batch;
    if (_batch &lt; 0) {
      throw 'Calls to startBatch() and endBatch() are not paired';
    }
    if (_batch === 0 &amp;&amp; !_isDisconnected() &amp;&amp; !_internalBatch) {
      _flushBatch();
    }
  }

  function _connect() {
    if (!_isDisconnected()) {
      var message = {
        channel: '/meta/connect',
        connectionType: _transport.getType()
      };
      if (!_connected) {
        message.advice = {
          timeout: 0
        };
      }
      _setStatus('connecting');
      _cometd._debug('Connect sent', message);
      _send(false, [message], true, 'connect');
      _setStatus('connected');
    }
  }

  function _delayedConnect() {
    _setStatus('connecting');
    _delayedSend(function() {
      _connect();
    });
  }

  function _updateAdvice(newAdvice) {
    if (newAdvice) {
      _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
      _cometd._debug('New advice', _advice);
    }
  }

  function _disconnect(abort) {
    _cancelDelayedSend();
    if (abort) {
      _transport.abort();
    }
    _clientId = null;
    _setStatus('disconnected');
    _batch = 0;
    _resetBackoff();
    _transport = null;
    if (_messageQueue.length &gt; 0) {
      _handleFailure.call(_cometd, undefined, _messageQueue, {
        reason: 'Disconnected'
      });
      _messageQueue = [];
    }
  }

  function _notifyTransportFailure(oldTransport, newTransport, failure) {
    var callback = _cometd.onTransportFailure;
    if (_isFunction(callback)) {
      _cometd._debug('Invoking transport failure callback', oldTransport, newTransport, failure);
      try {
        callback.call(_cometd, oldTransport, newTransport, failure);
      } catch (x) {
        _cometd._info('Exception during execution of transport failure callback', x);
      }
    }
  }

  function _handshake(handshakeProps, handshakeCallback) {
    if (_isFunction(handshakeProps)) {
      handshakeCallback = handshakeProps;
      handshakeProps = undefined;
    }
    _clientId = null;
    _clearSubscriptions();
    if (_isDisconnected()) {
      _transports.reset();
      _updateAdvice(_config.advice);
    } else {
      _updateAdvice(_cometd._mixin(false, _advice, {
        reconnect: 'retry'
      }));
    }
    _batch = 0;
    _internalBatch = true;
    _handshakeProps = handshakeProps;
    _handshakeCallback = handshakeCallback;
    var version = '1.0';
    var url = _cometd.getURL();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var bayeuxMessage = {
      version: version,
      minimumVersion: version,
      channel: '/meta/handshake',
      supportedConnectionTypes: transportTypes,
      _callback: handshakeCallback,
      advice: {
        timeout: _advice.timeout,
        interval: _advice.interval
      }
    };
    var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
    if (!_transport) {
      _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
      if (!_transport) {
        var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
        _cometd._warn(failure);
        throw failure;
      }
    }
    _cometd._debug('Initial transport is', _transport.getType());
    _setStatus('handshaking');
    _cometd._debug('Handshake sent', message);
    _send(false, [message], false, 'handshake');
  }

  function _delayedHandshake() {
    _setStatus('handshaking');
    _internalBatch = true;
    _delayedSend(function() {
      _handshake(_handshakeProps, _handshakeCallback);
    });
  }

  function _handleCallback(message) {
    var callback = _callbacks[message.id];
    if (_isFunction(callback)) {
      delete _callbacks[message.id];
      callback.call(_cometd, message);
    }
  }

  function _failHandshake(message) {
    _handleCallback(message);
    _notifyListeners('/meta/handshake', message);
    _notifyListeners('/meta/unsuccessful', message);
    var retry = !_isDisconnected() &amp;&amp; _advice.reconnect !== 'none';
    if (retry) {
      _increaseBackoff();
      _delayedHandshake();
    } else {
      _disconnect(false);
    }
  }

  function _handshakeResponse(message) {
    if (message.successful) {
      _clientId = message.clientId;
      var url = _cometd.getURL();
      var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
      if (newTransport === null) {
        var failure = 'Could not negotiate transport with server; client=[' +
          _transports.findTransportTypes(message.version, _crossDomain, url) +
          '], server=[' + message.supportedConnectionTypes + ']';
        var oldTransport = _cometd.getTransport();
        _notifyTransportFailure(oldTransport.getType(), null, {
          reason: failure,
          connectionType: oldTransport.getType(),
          transport: oldTransport
        });
        _cometd._warn(failure);
        _transport.reset();
        _failHandshake(message);
        return;
      } else if (_transport !== newTransport) {
        _cometd._debug('Transport', _transport.getType(), '-&gt;', newTransport.getType());
        _transport = newTransport;
      }
      _internalBatch = false;
      _flushBatch();
      message.reestablish = _reestablish;
      _reestablish = true;
      _handleCallback(message);
      _notifyListeners('/meta/handshake', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failHandshake(message);
    }
  }

  function _handshakeFailure(message) {
    var version = '1.0';
    var url = _cometd.getURL();
    var oldTransport = _cometd.getTransport();
    var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
    var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
    if (!newTransport) {
      _notifyTransportFailure(oldTransport.getType(), null, message.failure);
      _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');
      _transport.reset();
      _failHandshake(message);
    } else {
      _cometd._debug('Transport', oldTransport.getType(), '-&gt;', newTransport.getType());
      _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);
      _failHandshake(message);
      _transport = newTransport;
    }
  }

  function _failConnect(message) {
    _notifyListeners('/meta/connect', message);
    _notifyListeners('/meta/unsuccessful', message);
    var action = _isDisconnected() ? 'none' : _advice.reconnect;
    switch (action) {
      case 'retry':
        _delayedConnect();
        _increaseBackoff();
        break;
      case 'handshake':
        _transports.reset();
        _resetBackoff();
        _delayedHandshake();
        break;
      case 'none':
        _disconnect(false);
        break;
      default:
        throw 'Unrecognized advice action' + action;
    }
  }

  function _connectResponse(message) {
    _connected = message.successful;
    if (_connected) {
      _notifyListeners('/meta/connect', message);
      var action = _isDisconnected() ? 'none' : _advice.reconnect;
      switch (action) {
        case 'retry':
          _resetBackoff();
          _delayedConnect();
          break;
        case 'none':
          _disconnect(false);
          break;
        default:
          throw 'Unrecognized advice action ' + action;
      }
    } else {
      _failConnect(message);
    }
  }

  function _connectFailure(message) {
    _connected = false;
    _failConnect(message);
  }

  function _failDisconnect(message) {
    _disconnect(true);
    _handleCallback(message);
    _notifyListeners('/meta/disconnect', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _disconnectResponse(message) {
    if (message.successful) {
      _disconnect(false);
      _handleCallback(message);
      _notifyListeners('/meta/disconnect', message);
    } else {
      _failDisconnect(message);
    }
  }

  function _disconnectFailure(message) {
    _failDisconnect(message);
  }

  function _failSubscribe(message) {
    var subscriptions = _listeners[message.subscription];
    if (subscriptions) {
      for (var i = subscriptions.length - 1; i &gt;= 0; --i) {
        var subscription = subscriptions[i];
        if (subscription &amp;&amp; !subscription.listener) {
          delete subscriptions[i];
          _cometd._debug('Removed failed subscription', subscription);
          break;
        }
      }
    }
    _handleCallback(message);
    _notifyListeners('/meta/subscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _subscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/subscribe', message);
    } else {
      _failSubscribe(message);
    }
  }

  function _subscribeFailure(message) {
    _failSubscribe(message);
  }

  function _failUnsubscribe(message) {
    _handleCallback(message);
    _notifyListeners('/meta/unsubscribe', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _unsubscribeResponse(message) {
    if (message.successful) {
      _handleCallback(message);
      _notifyListeners('/meta/unsubscribe', message);
    } else {
      _failUnsubscribe(message);
    }
  }

  function _unsubscribeFailure(message) {
    _failUnsubscribe(message);
  }

  function _failMessage(message) {
    _handleCallback(message);
    _notifyListeners('/meta/publish', message);
    _notifyListeners('/meta/unsuccessful', message);
  }

  function _messageResponse(message) {
    if (message.successful === undefined) {
      if (message.data !== undefined) {
        _notifyListeners(message.channel, message);
      } else {
        _cometd._warn('Unknown Bayeux Message', message);
      }
    } else {
      if (message.successful) {
        _handleCallback(message);
        _notifyListeners('/meta/publish', message);
      } else {
        _failMessage(message);
      }
    }
  }

  function _messageFailure(failure) {
    _failMessage(failure);
  }

  function _receive(message) {
    message = _applyIncomingExtensions(message);
    if (message === undefined || message === null) {
      return;
    }
    _updateAdvice(message.advice);
    var channel = message.channel;
    switch (channel) {
      case '/meta/handshake':
        _handshakeResponse(message);
        break;
      case '/meta/connect':
        _connectResponse(message);
        break;
      case '/meta/disconnect':
        _disconnectResponse(message);
        break;
      case '/meta/subscribe':
        _subscribeResponse(message);
        break;
      case '/meta/unsubscribe':
        _unsubscribeResponse(message);
        break;
      default:
        _messageResponse(message);
        break;
    }
  }
  this.receive = _receive;
  _handleMessages = function(rcvdMessages) {
    _cometd._debug('Received', rcvdMessages);
    for (var i = 0; i &lt; rcvdMessages.length; ++i) {
      var message = rcvdMessages[i];
      _receive(message);
    }
  };
  _handleFailure = function(conduit, messages, failure) {
    _cometd._debug('handleFailure', conduit, messages, failure);
    failure.transport = conduit;
    for (var i = 0; i &lt; messages.length; ++i) {
      var message = messages[i];
      var failureMessage = {
        id: message.id,
        successful: false,
        channel: message.channel,
        failure: failure
      };
      failure.message = message;
      switch (message.channel) {
        case '/meta/handshake':
          _handshakeFailure(failureMessage);
          break;
        case '/meta/connect':
          _connectFailure(failureMessage);
          break;
        case '/meta/disconnect':
          _disconnectFailure(failureMessage);
          break;
        case '/meta/subscribe':
          failureMessage.subscription = message.subscription;
          _subscribeFailure(failureMessage);
          break;
        case '/meta/unsubscribe':
          failureMessage.subscription = message.subscription;
          _unsubscribeFailure(failureMessage);
          break;
        default:
          _messageFailure(failureMessage);
          break;
      }
    }
  };

  function _hasSubscriptions(channel) {
    var subscriptions = _listeners[channel];
    if (subscriptions) {
      for (var i = 0; i &lt; subscriptions.length; ++i) {
        if (subscriptions[i]) {
          return true;
        }
      }
    }
    return false;
  }

  function _resolveScopedCallback(scope, callback) {
    var delegate = {
      scope: scope,
      method: callback
    };
    if (_isFunction(scope)) {
      delegate.scope = undefined;
      delegate.method = scope;
    } else {
      if (_isString(callback)) {
        if (!scope) {
          throw 'Invalid scope ' + scope;
        }
        delegate.method = scope[callback];
        if (!_isFunction(delegate.method)) {
          throw 'Invalid callback ' + callback + ' for scope ' + scope;
        }
      } else if (!_isFunction(callback)) {
        throw 'Invalid callback ' + callback;
      }
    }
    return delegate;
  }

  function _addListener(channel, scope, callback, isListener) {
    var delegate = _resolveScopedCallback(scope, callback);
    _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
    var subscription = {
      channel: channel,
      scope: delegate.scope,
      callback: delegate.method,
      listener: isListener
    };
    var subscriptions = _listeners[channel];
    if (!subscriptions) {
      subscriptions = [];
      _listeners[channel] = subscriptions;
    }
    subscription.id = subscriptions.push(subscription) - 1;
    _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
    subscription[0] = channel;
    subscription[1] = subscription.id;
    return subscription;
  }
  this.registerTransport = function(type, transport, index) {
    var result = _transports.add(type, transport, index);
    if (result) {
      this._debug('Registered transport', type);
      if (_isFunction(transport.registered)) {
        transport.registered(type, this);
      }
    }
    return result;
  };
  this.getTransportTypes = function() {
    return _transports.getTransportTypes();
  };
  this.unregisterTransport = function(type) {
    var transport = _transports.remove(type);
    if (transport !== null) {
      this._debug('Unregistered transport', type);
      if (_isFunction(transport.unregistered)) {
        transport.unregistered();
      }
    }
    return transport;
  };
  this.unregisterTransports = function() {
    _transports.clear();
  };
  this.findTransport = function(name) {
    return _transports.find(name);
  };
  this.configure = function(configuration) {
    _configure.call(this, configuration);
  };
  this.init = function(configuration, handshakeProps) {
    this.configure(configuration);
    this.handshake(handshakeProps);
  };
  this.handshake = function(handshakeProps, handshakeCallback) {
    _setStatus('disconnected');
    _reestablish = false;
    _handshake(handshakeProps, handshakeCallback);
  };
  this.disconnect = function(sync, disconnectProps, disconnectCallback) {
    if (_isDisconnected()) {
      return;
    }
    if (typeof sync !== 'boolean') {
      disconnectCallback = disconnectProps;
      disconnectProps = sync;
      sync = false;
    }
    if (_isFunction(disconnectProps)) {
      disconnectCallback = disconnectProps;
      disconnectProps = undefined;
    }
    var bayeuxMessage = {
      channel: '/meta/disconnect',
      _callback: disconnectCallback
    };
    var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
    _setStatus('disconnecting');
    _send(sync === true, [message], false, 'disconnect');
  };
  this.startBatch = function() {
    _startBatch();
  };
  this.endBatch = function() {
    _endBatch();
  };
  this.batch = function(scope, callback) {
    var delegate = _resolveScopedCallback(scope, callback);
    this.startBatch();
    try {
      delegate.method.call(delegate.scope);
      this.endBatch();
    } catch (x) {
      this._info('Exception during execution of batch', x);
      this.endBatch();
      throw x;
    }
  };
  this.addListener = function(channel, scope, callback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    return _addListener(channel, scope, callback, true);
  };
  this.removeListener = function(subscription) {
    if (!subscription || !subscription.channel || !("id" in subscription)) {
      throw 'Invalid argument: expected subscription, not ' + subscription;
    }
    _removeListener(subscription);
  };
  this.clearListeners = function() {
    _listeners = {};
  };
  this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(scope)) {
      subscribeCallback = subscribeProps;
      subscribeProps = callback;
      callback = scope;
      scope = undefined;
    }
    if (_isFunction(subscribeProps)) {
      subscribeCallback = subscribeProps;
      subscribeProps = undefined;
    }
    var send = !_hasSubscriptions(channel);
    var subscription = _addListener(channel, scope, callback, false);
    if (send) {
      var bayeuxMessage = {
        channel: '/meta/subscribe',
        subscription: channel,
        _callback: subscribeCallback
      };
      var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
      _queueSend(message);
    }
    return subscription;
  };
  this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(unsubscribeProps)) {
      unsubscribeCallback = unsubscribeProps;
      unsubscribeProps = undefined;
    }
    this.removeListener(subscription);
    var channel = subscription.channel;
    if (!_hasSubscriptions(channel)) {
      var bayeuxMessage = {
        channel: '/meta/unsubscribe',
        subscription: channel,
        _callback: unsubscribeCallback
      };
      var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
      _queueSend(message);
    }
  };
  this.resubscribe = function(subscription, subscribeProps) {
    _removeSubscription(subscription);
    if (subscription) {
      return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
    }
    return undefined;
  };
  this.clearSubscriptions = function() {
    _clearSubscriptions();
  };
  this.publish = function(channel, content, publishProps, publishCallback) {
    if (arguments.length &lt; 1) {
      throw 'Illegal arguments number: required 1, got ' + arguments.length;
    }
    if (!_isString(channel)) {
      throw 'Illegal argument type: channel must be a string';
    }
    if (/^\/meta\//.test(channel)) {
      throw 'Illegal argument: cannot publish to meta channels';
    }
    if (_isDisconnected()) {
      throw 'Illegal state: already disconnected';
    }
    if (_isFunction(content)) {
      publishCallback = content;
      content = publishProps = {};
    } else if (_isFunction(publishProps)) {
      publishCallback = publishProps;
      publishProps = {};
    }
    var bayeuxMessage = {
      channel: channel,
      data: content,
      _callback: publishCallback
    };
    var message = this._mixin(false, {}, publishProps, bayeuxMessage);
    _queueSend(message);
  };
  this.getStatus = function() {
    return _status;
  };
  this.isDisconnected = _isDisconnected;
  this.setBackoffIncrement = function(period) {
    _config.backoffIncrement = period;
  };
  this.getBackoffIncrement = function() {
    return _config.backoffIncrement;
  };
  this.getBackoffPeriod = function() {
    return _backoff;
  };
  this.setLogLevel = function(level) {
    _config.logLevel = level;
  };
  this.registerExtension = function(name, extension) {
    if (arguments.length &lt; 2) {
      throw 'Illegal arguments number: required 2, got ' + arguments.length;
    }
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var existing = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var existingExtension = _extensions[i];
      if (existingExtension.name === name) {
        existing = true;
        break;
      }
    }
    if (!existing) {
      _extensions.push({
        name: name,
        extension: extension
      });
      this._debug('Registered extension', name);
      if (_isFunction(extension.registered)) {
        extension.registered(name, this);
      }
      return true;
    } else {
      this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
      return false;
    }
  };
  this.unregisterExtension = function(name) {
    if (!_isString(name)) {
      throw 'Illegal argument type: extension name must be a string';
    }
    var unregistered = false;
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        _extensions.splice(i, 1);
        unregistered = true;
        this._debug('Unregistered extension', name);
        var ext = extension.extension;
        if (_isFunction(ext.unregistered)) {
          ext.unregistered();
        }
        break;
      }
    }
    return unregistered;
  };
  this.getExtension = function(name) {
    for (var i = 0; i &lt; _extensions.length; ++i) {
      var extension = _extensions[i];
      if (extension.name === name) {
        return extension.extension;
      }
    }
    return null;
  };
  this.getName = function() {
    return _name;
  };
  this.getClientId = function() {
    return _clientId;
  };
  this.getURL = function() {
    if (_transport &amp;&amp; typeof _config.urls === 'object') {
      var url = _config.urls[_transport.getType()];
      if (url) {
        return url;
      }
    }
    return _config.url;
  };
  this.getTransport = function() {
    return _transport;
  };
  this.getConfiguration = function() {
    return this._mixin(true, {}, _config);
  };
  this.getAdvice = function() {
    return this._mixin(true, {}, _advice);
  };
  org.cometd.WebSocket = window.WebSocket;
  if (!org.cometd.WebSocket) {
    org.cometd.WebSocket = window.MozWebSocket;
  }
};
if (typeof define === 'function' &amp;&amp; define.amd) {
  define(function() {
    return org.cometd;
  });
};
/*! RESOURCE: /scripts/thirdparty/cometd/jquery/jquery.cometd.js */
(function() {
  function bind($, org_cometd) {
    org_cometd.JSON.toJSON = (window.JSON &amp;&amp; JSON.stringify) || (window.jaredJSON &amp;&amp; window.jaredJSON.stringify);
    org_cometd.JSON.fromJSON = (window.JSON &amp;&amp; JSON.parse) || (window.jaredJSON &amp;&amp; window.jaredJSON.parse);

    function _setHeaders(xhr, headers) {
      if (headers) {
        for (var headerName in headers) {
          if (headerName.toLowerCase() === 'content-type') {
            continue;
          }
          xhr.setRequestHeader(headerName, headers[headerName]);
        }
      }
    }

    function LongPollingTransport() {
      var _super = new org_cometd.LongPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.xhrSend = function(packet) {
        return $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'POST',
          contentType: 'application/json;charset=UTF-8',
          data: packet.body,
          xhrFields: {
            withCredentials: true
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }

    function CallbackPollingTransport() {
      var _super = new org_cometd.CallbackPollingTransport();
      var that = org_cometd.Transport.derive(_super);
      that.jsonpSend = function(packet) {
        $.ajax({
          url: packet.url,
          async: packet.sync !== true,
          type: 'GET',
          dataType: 'jsonp',
          jsonp: 'jsonp',
          data: {
            message: packet.body
          },
          beforeSend: function(xhr) {
            _setHeaders(xhr, packet.headers);
            return true;
          },
          success: packet.onSuccess,
          error: function(xhr, reason, exception) {
            packet.onError(reason, exception);
          }
        });
      };
      return that;
    }
    $.Cometd = function(name) {
      var cometd = new org_cometd.Cometd(name);
      if (org_cometd.WebSocket) {
        cometd.registerTransport('websocket', new org_cometd.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      cometd.registerTransport('callback-polling', new CallbackPollingTransport());
      return cometd;
    };
    $.cometd = new $.Cometd();
    return $.cometd;
  }
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define(['jquery', 'org/cometd'], bind);
  } else {
    bind(window.jQuery1110 || window.Zepto, org.cometd);
  }
})();;
/*! RESOURCE: /scripts/amb_properties.js */
var amb = amb || {
  properties: {
    servletURI: 'amb/',
    logLevel: 'info',
    loginWindow: 'true'
  }
};;
/*! RESOURCE: /scripts/amb.Logger.js */
amb['Logger'] = function(callerType) {
  var _debugEnabled = amb['properties']['logLevel'] == 'debug';

  function print(message) {
    console.log(callerType + ' ' + message);
  }
  return {
    debug: function(message) {
      if (_debugEnabled)
        print('[DEBUG] ' + message);
    },
    addInfoMessage: function(message) {
      print('[INFO] ' + message);
    },
    addErrorMessage: function(message) {
      print('[ERROR] ' + message);
    }
  }
};;
/*! RESOURCE: /scripts/amb.EventManager.js */
amb.EventManager = function EventManager(events) {
  var _subscriptions = [];
  var _idCounter = 0;

  function _getSubscriptions(event) {
    var subscriptions = [];
    for (var i = 0; i &lt; _subscriptions.length; i++) {
      if (_subscriptions[i].event == event)
        subscriptions.push(_subscriptions[i]);
    }
    return subscriptions;
  }
  return {
    subscribe: function(event, callback) {
      var id = _idCounter++;
      _subscriptions.push({
        event: event,
        callback: callback,
        id: id
      });
      return id;
    },
    unsubscribe: function(id) {
      for (var i = 0; i &lt; _subscriptions.length; i++)
        if (id == _subscriptions[i].id)
          _subscriptions.splice(i, 1);
    },
    publish: function(event, args) {
      var subscriptions = _getSubscriptions(event);
      for (var i = 0; i &lt; subscriptions.length; i++)
        subscriptions[i].callback.apply(null, args);
    },
    getEvents: function() {
      return events;
    }
  }
};;
/*! RESOURCE: /scripts/amb.ServerConnection.js */
amb.ServerConnection = function ServerConnection(cometd) {
  var connected = false;
  var disconnecting = false;
  var eventManager = new amb.EventManager({
    CONNECTION_INITIALIZED: 'connection.initialized',
    CONNECTION_OPENED: 'connection.opened',
    CONNECTION_CLOSED: 'connection.closed',
    CONNECTION_BROKEN: 'connection.broken',
    SESSION_LOGGED_IN: 'session.logged.in',
    SESSION_LOGGED_OUT: 'session.logged.out'
  });
  var state = "closed";
  var LOGGER = new amb.Logger('amb.ServerConnection');
  _initializeMetaChannelListeners();
  var loggedIn = true;
  var loginWindow = null;
  var loginWindowEnabled = amb.properties['loginWindow'] === 'true';
  var lastError = null;
  var errorMessages = {
    'UNKNOWN_CLIENT': '402::Unknown client'
  };
  var loginWindowOverride = false;
  var ambServerConnection = {};
  ambServerConnection.connect = function() {
    if (connected) {
      console.log("&gt;&gt;&gt; connection exists, request satisfied");
      return;
    }
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    LOGGER.debug('Connecting to glide amb server -&gt; ' + amb['properties']['servletURI']);
    cometd.configure({
      url: _getRelativePath(amb['properties']['servletURI']),
      logLevel: amb['properties']['logLevel']
    });
    cometd.handshake();
  };
  ambServerConnection.reload = function() {
    cometd.reload();
  };
  ambServerConnection.abort = function() {
    cometd.getTransport().abort();
  };
  ambServerConnection.disconnect = function() {
    LOGGER.debug('Disconnecting from glide amb server..');
    disconnecting = true;
    cometd.disconnect();
  };

  function _initializeMetaChannelListeners() {
    cometd.addListener('/meta/handshake', this, _metaHandshake);
    cometd.addListener('/meta/connect', this, _metaConnect);
  }

  function _metaHandshake(message) {
    setTimeout(function() {
      if (message['successful'])
        _connectionInitialized();
    }, 0);
  }

  function _metaConnect(message) {
    if (disconnecting) {
      setTimeout(function() {
        connected = false;
        _connectionClosed();
      }, 0);
      return;
    }
    var error = message['error'];
    if (error)
      lastError = error;
    _sessionStatus(message);
    var wasConnected = connected;
    connected = (message['successful'] === true);
    if (!wasConnected &amp;&amp; connected)
      _connectionOpened();
    else if (wasConnected &amp;&amp; !connected)
      _connectionBroken();
  }

  function _connectionInitialized() {
    LOGGER.debug('Connection initialized');
    state = "initialized";
    eventManager.publish(eventManager.getEvents().CONNECTION_INITIALIZED);
  }

  function _connectionOpened() {
    LOGGER.debug('Connection opened');
    state = "opened";
    eventManager.publish(eventManager.getEvents().CONNECTION_OPENED);
  }

  function _connectionClosed() {
    LOGGER.debug('Connection closed');
    state = "closed";
    eventManager.publish(eventManager.getEvents().CONNECTION_CLOSED);
  }

  function _connectionBroken() {
    LOGGER.addErrorMessage('Connection broken');
    state = "broken";
    eventManager.publish(eventManager.getEvents().CONNECTION_BROKEN);
  }

  function _sessionStatus(message) {
    var ext = message['ext'];
    if (ext) {
      var sessionStatus = ext['glide.session.status'];
      loginWindowOverride = ext['glide.amb.login.window.override'] === true;
      LOGGER.debug('session.status - ' + sessionStatus);
      switch (sessionStatus) {
        case 'session.logged.out':
          if (loggedIn)
            _logout();
          break;
        case 'session.logged.in':
          if (!loggedIn)
            _login();
          break;
        default:
          LOGGER.debug("unknown session status - " + sessionStatus);
          break;
      }
    }
  }

  function _login() {
    loggedIn = true;
    LOGGER.debug("LOGGED_IN event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_IN);
    ambServerConnection.loginHide();
  }

  function _logout() {
    loggedIn = false;
    LOGGER.debug("LOGGED_OUT event fire!");
    eventManager.publish(eventManager.getEvents().SESSION_LOGGED_OUT);
    ambServerConnection.loginShow();
  }
  var modalContent = '&lt;iframe src="/amb_login.do" frameborder="0" height="400px" width="405px" scrolling="no"&gt;&lt;/iframe&gt;';
  var modalTemplate = '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '  &lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '     &lt;div class="modal-content"&gt;' +
    '        &lt;header class="modal-header"&gt;' +
    '           &lt;h4 id="small_modal1_title" class="modal-title"&gt;Login&lt;/h4&gt;' +
    '        &lt;/header&gt;' +
    '        &lt;div class="modal-body"&gt;' +
    '        &lt;/div&gt;' +
    '     &lt;/div&gt;' +
    '  &lt;/div&gt;' +
    '&lt;/div&gt;';

  function _loginShow() {
    if (!loginWindowEnabled || loginWindowOverride)
      return;
    var dialog = new GlideModal('amb_disconnect_modal');
    if (dialog['renderWithContent']) {
      dialog.template = modalTemplate;
      dialog.renderWithContent(modalContent);
    } else {
      dialog.setBody(modalContent);
      dialog.render();
    }
    loginWindow = dialog;
  }

  function _loginHide() {
    if (!loginWindow)
      return;
    loginWindow.destroy();
    loginWindow = null;
  }

  function loginComplete() {
    _login();
  }

  function _getRelativePath(uri) {
    var relativePath = "";
    for (var i = 0; i &lt; window.location.pathname.match(/\//g).length - 1; i++) {
      relativePath = "../" + relativePath;
    }
    return relativePath + uri;
  }
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.getLastError = function() {
    return lastError;
  };
  ambServerConnection.setLastError = function(error) {
    lastError = error;
  };
  ambServerConnection.getErrorMessages = function() {
    return errorMessages;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.getEvents = function() {
    return eventManager.getEvents();
  };
  ambServerConnection.subscribeToEvent = function(event, callback) {
    if (eventManager.getEvents().CONNECTION_OPENED == event &amp;&amp; connected)
      callback();
    return eventManager.subscribe(event, callback);
  };
  ambServerConnection.unsubscribeFromEvent = function(id) {
    eventManager.unsubscribe(id);
  };
  ambServerConnection.getConnectionState = function() {
    return state;
  };
  ambServerConnection.isLoggedIn = function() {
    return loggedIn;
  };
  ambServerConnection.loginShow = function() {
    _loginShow();
  };
  ambServerConnection.loginHide = function() {
    _loginHide();
  };
  ambServerConnection.loginComplete = function() {
    _login();
  };
  ambServerConnection.isLoginWindowEnabled = function() {
    return loginWindowEnabled;
  };
  ambServerConnection.isLoginWindowOverride = function() {
    return loginWindowOverride;
  }
  return ambServerConnection;
};;
/*! RESOURCE: /scripts/amb.ChannelRedirect.js */
amb.ChannelRedirect = function ChannelRedirect(cometd, serverConnection,
  channelProvider) {
  var initialized = false;
  var _cometd = cometd;
  var eventManager = new amb.EventManager({
    CHANNEL_REDIRECT: 'channel.redirect'
  });
  var LOGGER = new amb.Logger('amb.ChannelRedirect');

  function _onAdvice(advice) {
    LOGGER.debug('_onAdvice:' + advice.data.clientId);
    var fromChannel = channelProvider(advice.data.fromChannel);
    var toChannel = channelProvider(advice.data.toChannel);
    eventManager.publish(eventManager.getEvents().CHANNEL_REDIRECT, [fromChannel, toChannel]);
    LOGGER.debug(
      'published channel switch event, fromChannel:' + fromChannel.getName() +
      ', toChannel:' + toChannel.getName());
  }
  return {
    subscribeToEvent: function(event, callback) {
      return eventManager.subscribe(event, callback);
    },
    unsubscribeToEvent: function(id) {
      eventManager.unsubscribe(id);
    },
    getEvents: function() {
      return eventManager.getEvents();
    },
    initialize: function() {
      if (!initialized) {
        var channelName = '/sn/meta/channel_redirect/' + _cometd.getClientId();
        var metaChannel = channelProvider(channelName);
        metaChannel.newListener(serverConnection, null).subscribe(_onAdvice);
        LOGGER.debug("ChannelRedirect initialized: " + channelName);
        initialized = true;
      }
    }
  }
};;
/*! RESOURCE: /scripts/amb.ChannelListener.js */
amb.ChannelListener = function ChannelListener(channel, serverConnection,
  channelRedirect) {
  var id;
  var subscriberCallback;
  var LOGGER = new amb.Logger('amb.ChannelListener');
  var channelRedirectId = null;
  var connectOpenedEventId;
  var currentChannel = channel;
  return {
    getCallback: function() {
      return subscriberCallback;
    },
    getID: function() {
      return id;
    },
    subscribe: function(callback) {
      subscriberCallback = callback;
      if (channelRedirect)
        channelRedirectId = channelRedirect.subscribeToEvent(
          channelRedirect.getEvents().CHANNEL_REDIRECT, this._switchToChannel.bind(this));
      connectOpenedEventId = serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED,
        this._subscribeWhenReady.bind(this));
      LOGGER.debug("Subscribed from channel: " + currentChannel.getName());
      return this;
    },
    resubscribe: function() {
      return this.subscribe(subscriberCallback);
    },
    _switchToChannel: function(fromChannel, toChannel) {
      if (!fromChannel || !toChannel)
        return;
      if (fromChannel.getName() != currentChannel.getName())
        return;
      this.unsubscribe();
      currentChannel = toChannel;
      this.subscribe(subscriberCallback);
    },
    _subscribeWhenReady: function() {
      LOGGER.debug("Subscribing to '" + currentChannel.getName() + "'...");
      id = currentChannel.subscribe(this);
    },
    unsubscribe: function() {
      channelRedirect.unsubscribeToEvent(channelRedirectId);
      currentChannel.unsubscribe(this);
      serverConnection.unsubscribeFromEvent(connectOpenedEventId);
      LOGGER.debug("Unsubscribed from channel: " + currentChannel.getName());
      return this;
    },
    publish: function(message) {
      currentChannel.publish(message);
    },
    getName: function() {
      return currentChannel.getName();
    }
  }
};;
/*! RESOURCE: /scripts/amb.Channel.js */
amb.Channel = function Channel(cometd, channelName, initialized) {
  var subscription = null;
  var listeners = [];
  var LOGGER = new amb.Logger('amb.Channel');
  var idCounter = 0;
  var _initialized = initialized;

  function _disconnected() {
    var status = cometd.getStatus();
    return status === 'disconnecting' || status === 'disconnected';
  }
  return {
    newListener: function(serverConnection,
      channelRedirect) {
      return new amb.ChannelListener(this, serverConnection, channelRedirect);
    },
    subscribe: function(listener) {
      if (!listener.getCallback()) {
        LOGGER.addErrorMessage('Cannot subscribe to channel: ' + channelName +
          ', callback not provided');
        return;
      }
      if (!subscription &amp;&amp; _initialized) {
        subscription = cometd.subscribe(channelName, this._handleResponse.bind(this));
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i] === listener) {
          LOGGER.debug('Channel listener already in the list');
          return listener.getID();
        }
      }
      var id = idCounter++;
      listeners.push(listener);
      return id;
    },
    subscribeOnInitCompletion: function(redirect) {
      _initialized = true;
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++) {
        listeners[i].subscribe();
        LOGGER.debug('Successfully subscribed to channel: ' + channelName);
      }
    },
    resubscribe: function() {
      subscription = null;
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].resubscribe();
    },
    _handleResponse: function(message) {
      for (var i = 0; i &lt; listeners.length; i++)
        listeners[i].getCallback()(message);
    },
    unsubscribe: function(listener) {
      if (!listener) {
        LOGGER.addErrorMessage('Cannot unsubscribe from channel: ' + channelName +
          ', listener argument does not exist');
        return;
      }
      for (var i = 0; i &lt; listeners.length; i++) {
        if (listeners[i].getID() == listener.getID())
          listeners.splice(i, 1);
      }
      if (listeners.length &lt; 1 &amp;&amp; subscription &amp;&amp; !_disconnected()) {
        cometd.unsubscribe(subscription);
        subscription = null;
      }
      LOGGER.debug('Successfully unsubscribed from channel: ' + channelName);
    },
    publish: function(message) {
      cometd.publish(channelName, message);
    },
    getName: function() {
      return channelName;
    }
  }
};;
/*! RESOURCE: /scripts/amb.MessageClient.js */
(function($) {
  amb.MessageClient = function MessageClient() {
    var cometd = new $.Cometd();
    cometd.unregisterTransport('websocket');
    cometd.unregisterTransport('callback-polling');
    var serverConnection = new amb.ServerConnection(cometd);
    var channels = {};
    var LOGGER = new amb.Logger('amb.MessageClient');
    var channelRedirect = null;
    var connected = false;
    var initialized = false;
    var uninitializedChannels = [];
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_BROKEN, _connectionBroken);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_OPENED, _connectionOpened);
    serverConnection.subscribeToEvent(serverConnection.getEvents().CONNECTION_INITIALIZED, _connectionInitialized);
    var _connectionBrokenEvent = false;

    function _connectionBroken() {
      LOGGER.debug("connection broken!");
      _connectionBrokenEvent = true;
    }

    function _connectionInitialized() {
      initialized = true;
      _initChannelRedirect();
      channelRedirect.initialize();
      LOGGER.debug("Connection initialized. Initializing " + uninitializedChannels.length + " channels.");
      for (var i = 0; i &lt; uninitializedChannels.length; i++) {
        uninitializedChannels[i].subscribeOnInitCompletion();
      }
      uninitializedChannels = [];
    }

    function _connectionOpened() {
      if (_connectionBrokenEvent) {
        LOGGER.debug("connection opened!");
        _connectionBrokenEvent = false;
        var sc = serverConnection;
        if (sc.getLastError() !== sc.getErrorMessages().UNKNOWN_CLIENT)
          return;
        sc.setLastError(null);
        LOGGER.debug("channel resubscribe!");
        $.ajax({
          url: "/amb_session_setup.do",
          method: "GET",
          contentType: "application/json;charset=UTF-8",
          data: "",
          dataType: "HTML",
          headers: {
            'X-UserToken': window.g_ck
          }
        }).done(function() {
          for (var name in channels) {
            var channel = channels[name];
            channel.resubscribe();
          }
        });
      }
    }

    function _initChannelRedirect() {
      if (channelRedirect)
        return;
      channelRedirect = new amb.ChannelRedirect(cometd, serverConnection, _getChannel);
    }

    function _getChannel(channelName) {
      if (channelName in channels)
        return channels[channelName];
      var channel = new amb.Channel(cometd, channelName, initialized);
      channels[channelName] = channel;
      if (!initialized)
        uninitializedChannels.push(channel);
      return channel;
    }
    return {
      getServerConnection: function() {
        return serverConnection;
      },
      isLoggedIn: function() {
        return serverConnection.isLoggedIn();
      },
      loginComplete: function() {
        serverConnection.loginComplete();
      },
      connect: function() {
        if (connected) {
          LOGGER.addInfoMessage("&gt;&gt;&gt; connection exists, request satisfied");
          return;
        }
        connected = true;
        serverConnection.connect();
      },
      reload: function() {
        connected = false;
        serverConnection.reload();
      },
      abort: function() {
        connected = false;
        serverConnection.abort();
      },
      disconnect: function() {
        connected = false;
        serverConnection.disconnect();
      },
      getConnectionEvents: function() {
        return serverConnection.getEvents();
      },
      subscribeToEvent: function(event, callback) {
        return serverConnection.subscribeToEvent(event, callback);
      },
      unsubscribeFromEvent: function(id) {
        serverConnection.unsubscribeFromEvent(id);
      },
      getConnectionState: function() {
        return serverConnection.getConnectionState();
      },
      getClientId: function() {
        return cometd.getClientId();
      },
      getChannel: function(channelName) {
        _initChannelRedirect();
        var channel = _getChannel(channelName);
        return channel.newListener(serverConnection, channelRedirect);
      },
      registerExtension: function(extensionName, extension) {
        cometd.registerExtension(extensionName, extension);
      },
      unregisterExtension: function(extensionName) {
        cometd.unregisterExtension(extensionName);
      },
      batch: function(block) {
        cometd.batch(block);
      }
    }
  };
})(jQuery1110);;
/*! RESOURCE: /scripts/amb.MessageClientBuilder.js */
(function($) {
  amb.getClient = function() {
    return getClient();
  }

  function getClient() {
    var _window = window.self;
    try {
      if (!(window.MSInputMethodContext &amp;&amp; document.documentMode)) {
        while (_window != _window.parent) {
          if (_window.g_ambClient)
            break;
          _window = _window.parent;
        }
      }
      if (_window.g_ambClient)
        return _window.g_ambClient;
    } catch (e) {
      console.log("AMB getClient() tried to access parent from an iFrame. Caught error: " + e);
    }
    var client = buildClient();
    setClient(client);
    return client;
  }

  function setClient(client) {
    var _window = window.self;
    _window.g_ambClient = client;
    $(_window).unload(function() {
      _window.g_ambClient.disconnect();
    });
    _window.g_ambClient.connect();
  }

  function buildClient() {
    return (function() {
      var ambClient = new amb.MessageClient();
      return {
        getServerConnection: function() {
          return ambClient.getServerConnection();
        },
        connect: function() {
          ambClient.connect();
        },
        abort: function() {
          ambClient.abort();
        },
        disconnect: function() {
          ambClient.disconnect();
        },
        getConnectionState: function() {
          return ambClient.getConnectionState();
        },
        getState: function() {
          return ambClient.getConnectionState();
        },
        getClientId: function() {
          return ambClient.getClientId();
        },
        getChannel: function(channelName) {
          var channel = ambClient.getChannel(channelName);
          var originalSubscribe = channel.subscribe;
          var originalUnsubscribe = channel.unsubscribe;
          channel.subscribe = function(listener) {
            originalSubscribe.call(channel, listener);
            $(window).unload(function(event) {
              originalUnsubscribe.call(channel);
            });
            return channel;
          };
          return channel;
        },
        getChannel0: function(channelName) {
          return ambClient.getChannel(channelName);
        },
        registerExtension: function(extensionName, extension) {
          ambClient.registerExtension(extensionName, extension);
        },
        unregisterExtension: function(extensionName) {
          ambClient.unregisterExtension(extensionName);
        },
        batch: function(block) {
          ambClient.batch(block);
        },
        subscribeToEvent: function(event, callback) {
          return ambClient.subscribeToEvent(event, callback);
        },
        unsubscribeFromEvent: function(id) {
          ambClient.unsubscribeFromEvent(id);
        },
        isLoggedIn: function() {
          return ambClient.isLoggedIn();
        },
        getConnectionEvents: function() {
          return ambClient.getConnectionEvents();
        },
        getEvents: function() {
          return ambClient.getConnectionEvents();
        },
        loginComplete: function() {
          ambClient.loginComplete();
        }
      };
    })();
  }
})(jQuery1110);;
/*! RESOURCE: /scripts/amb_initialize.js */
if (typeof g_amb_on_login === 'undefined') {
  amb.getClient();
};;
/*! RESOURCE: /scripts/app.ng.amb/app.ng.amb.js */
angular.module("ng.amb", ['sn.common.presence', 'sn.common.util'])
  .value("ambLogLevel", 'info')
  .value("ambServletURI", '/amb')
  .value("cometd", angular.element.cometd)
  .value("ambLoginWindow", 'true');;
/*! RESOURCE: /scripts/app.ng.amb/service.AMB.js */
angular.module("ng.amb").service("amb", function(AMBOverlay, $window, $q, $log, $rootScope, $timeout) {
  "use strict";
  var ambClient = null;
  var _window = $window.self;
  var loginWindow = null;
  var sameScope = false;
  if (_window.g_ambClient) {
    ambClient = _window.g_ambClient;
    sameScope = true;
  }
  if (!ambClient)
    ambClient = amb.getClient();
  if (sameScope) {
    var serverConnection = ambClient.getServerConnection();
    serverConnection.loginShow = function() {
      if (!serverConnection.isLoginWindowEnabled())
        return;
      if (loginWindow &amp;&amp; loginWindow.isVisible())
        return;
      if (serverConnection.isLoginWindowOverride())
        return;
      loginWindow = new AMBOverlay();
      loginWindow.render();
      loginWindow.show();
    };
    serverConnection.loginHide = function() {
      if (!loginWindow)
        return;
      loginWindow.hide();
      loginWindow.destroy();
      loginWindow = null;
    }
  }
  var connected = $q.defer();
  var connectionInterrupted = false;
  var monitorAMB = false;
  $timeout(function() {
    monitorAMB = true;
  }, 5 * 1000);

  function ambInterrupted() {
    var state = ambClient.getState();
    return monitorAMB &amp;&amp; state !== "opened" &amp;&amp; state !== "initialized"
  }
  var interruptionTimeout;
  var extendedInterruption = false;

  function setInterrupted(eventName) {
    connectionInterrupted = true;
    $rootScope.$broadcast(eventName);
    if (!interruptionTimeout) {
      interruptionTimeout = $timeout(function() {
        extendedInterruption = true;
      }, 30 * 1000)
    }
    connected = $q.defer();
  }
  var connectOpenedEventId = ambClient.subscribeToEvent("connection.opened", function() {
    $rootScope.$broadcast("amb.connection.opened");
    if (interruptionTimeout) {
      $timeout.cancel(interruptionTimeout);
      interruptionTimeout = null;
    }
    extendedInterruption = false;
    if (connectionInterrupted) {
      connectionInterrupted = false;
      $rootScope.$broadcast("amb.connection.recovered");
    }
    connected.resolve();
  });
  var connectClosedEventId = ambClient.subscribeToEvent("connection.closed", function() {
    setInterrupted("amb.connection.closed");
  });
  var connectBrokenEventId = ambClient.subscribeToEvent("connection.broken", function() {
    setInterrupted("amb.connection.broken");
  });
  jQuery(window).unload(function fixMemoryLeakInGlobalAMBEventManager(event) {
    ambClient.unsubscribeFromEvent(connectOpenedEventId);
    ambClient.unsubscribeFromEvent(connectClosedEventId);
    ambClient.unsubscribeFromEvent(connectBrokenEventId);
    jQuery(this).unbind(event);
  });
  ambClient.connect();
  return {
    getServerConnection: function() {
      return ambClient.getServerConnection();
    },
    connect: function() {
      ambClient.connect();
      return connected.promise;
    },
    get interrupted() {
      return ambInterrupted();
    },
    get extendedInterruption() {
      return extendedInterruption;
    },
    get connected() {
      return connected.promise;
    },
    abort: function() {
      ambClient.abort();
    },
    disconnect: function() {
      ambClient.disconnect();
    },
    getConnectionState: function() {
      return ambClient.getConnectionState();
    },
    getClientId: function() {
      return ambClient.getClientId();
    },
    getChannel: function(channelName) {
      var channel = ambClient.getChannel0(channelName);
      var originalSubscribe = channel.subscribe;
      var originalUnsubscribe = channel.unsubscribe;
      channel.subscribe = function(listener) {
        originalSubscribe.call(channel, listener);
        jQuery(window).unload(function() {
          originalUnsubscribe.call(channel);
        });
        return channel;
      };
      return channel;
    },
    registerExtension: function(extensionName, extension) {
      ambClient.registerExtension(extensionName, extension);
    },
    unregisterExtension: function(extensionName) {
      ambClient.unregisterExtension(extensionName);
    },
    batch: function(batch) {
      ambClient.batch(batch);
    },
    getState: function() {
      return ambClient.getState();
    },
    getFilterString: function(filter) {
      filter = filter.
      replace(/\^EQ/g, '').
      replace(/\^ORDERBY(?:DESC)?[^^]*/g, '').
      replace(/^GOTO/, '');
      return btoa(filter).replace(/=/g, '-');
    },
    getChannelRW: function(table, filter) {
      var t = '/rw/default/' + table + '/' + this.getFilterString(filter);
      return this.getChannel(t);
    },
    isLoggedIn: function() {
      return ambClient.isLoggedIn();
    },
    subscribeToEvent: function(event, callback) {
      ambClient.subscribeToEvent(event, callback);
    },
    getConnectionEvents: function() {
      return ambClient.getConnectionEvents();
    },
    getEvents: function() {
      return ambClient.getConnectionEvents();
    },
    loginComplete: function() {
      ambClient.loginComplete();
    }
  };
});;
/*! RESOURCE: /scripts/app.ng.amb/controller.AMBRecordWatcher.js */
angular.module("ng.amb").controller("AMBRecordWatcher", function($scope, $timeout, $window) {
  "use strict";
  var amb = $window.top.g_ambClient;
  $scope.messages = [];
  var lastFilter;
  var watcherChannel;
  var watcher;

  function onMessage(message) {
    $scope.messages.push(message.data);
  }
  $scope.getState = function() {
    return amb.getState();
  };
  $scope.initWatcher = function() {
    angular.element(":focus").blur();
    if (!$scope.filter || $scope.filter === lastFilter)
      return;
    lastFilter = $scope.filter;
    console.log("initiating watcher on " + $scope.filter);
    $scope.messages = [];
    if (watcher) {
      watcher.unsubscribe();
    }
    var base64EncodeQuery = btoa($scope.filter).replace(/=/g, '-');
    var channelId = '/rw/' + base64EncodeQuery;
    watcherChannel = amb.getChannel(channelId)
    watcher = watcherChannel.subscribe(onMessage);
  };
  amb.connect();
});
/*! RESOURCE: /scripts/app.ng.amb/factory.snRecordWatcher.js */
angular.module("ng.amb").factory('snRecordWatcher', function($rootScope, amb, $timeout, snPresence, $log, urlTools) {
  "use strict";
  var watcherChannel;
  var connected = false;
  var diagnosticLog = true;

  function initWatcher(table, sys_id, query) {
    if (!table)
      return;
    if (sys_id)
      var filter = "sys_id=" + sys_id;
    else
      filter = query;
    if (!filter)
      return;
    return initChannel(table, filter);
  }

  function initList(table, query) {
    if (!table)
      return;
    query = query || "sys_idISNOTEMPTY";
    return initChannel(table, query);
  }

  function initTaskList(list, prevChannel) {
    if (prevChannel)
      prevChannel.unsubscribe();
    var sys_ids = list.toString();
    var filter = "sys_idIN" + sys_ids;
    return initChannel("task", filter);
  }

  function initChannel(table, filter) {
    if (isBlockedTable(table)) {
      $log.log("Blocked from watching", table);
      return null;
    }
    if (diagnosticLog)
      log("&gt;&gt;&gt; init " + table + "?" + filter);
    watcherChannel = amb.getChannelRW(table, filter);
    watcherChannel.subscribe(onMessage);
    amb.connect();
    return watcherChannel;
  }

  function onMessage(message) {
    var r = message.data;
    var c = message.channel;
    if (diagnosticLog)
      log("&gt;&gt;&gt; record " + r.operation + ": " + r.table_name + "." + r.sys_id + " " + r.display_value);
    $rootScope.$broadcast('record.updated', r);
    $rootScope.$broadcast("sn.stream.tap");
    $rootScope.$broadcast('list.updated', r, c);
  }

  function log(message) {
    $log.log(message);
  }

  function isBlockedTable(table) {
    return table == 'sys_amb_message' || table.startsWith('sys_rw');
  }
  return {
    initTaskList: initTaskList,
    initChannel: initChannel,
    init: function() {
      var location = urlTools.parseQueryString(window.location.search);
      var table = location['table'] || location['sysparm_table'];
      var sys_id = location['sys_id'] || location['sysparm_sys_id'];
      var query = location['sysparm_query'];
      initWatcher(table, sys_id, query);
      snPresence.init(table, sys_id, query);
    },
    initList: initList,
    initRecord: function(table, sysId) {
      initWatcher(table, sysId, null);
      snPresence.initWithDocument(table, sysId);
    }
  }
});;
/*! RESOURCE: /scripts/app.ng.amb/factory.AMBOverlay.js */
angular.module("ng.amb").factory("AMBOverlay", function($templateCache, $compile, $rootScope) {
  "use strict";
  var showCallbacks = [],
    hideCallbacks = [],
    isRendered = false,
    modal,
    modalScope,
    modalOptions;
  var defaults = {
    backdrop: 'static',
    keyboard: false,
    show: true
  };

  function AMBOverlay(config) {
    config = config || {};
    if (angular.isFunction(config.onShow))
      showCallbacks.push(config.onShow);
    if (angular.isFunction(config.onHide))
      hideCallbacks.push(config.onHide);

    function lazyRender() {
      if (!angular.element('html')['modal']) {
        var bootstrapInclude = "/scripts/bootstrap3/bootstrap.js";
        ScriptLoader.getScripts([bootstrapInclude], renderModal);
      } else
        renderModal();
    }

    function renderModal() {
      if (isRendered)
        return;
      modalScope = angular.extend($rootScope.$new(), config);
      modal = $compile($templateCache.get("amb_disconnect_modal.xml"))(modalScope);
      angular.element("body").append(modal);
      modal.on("shown.bs.modal", function(e) {
        for (var i = 0, len = showCallbacks.length; i &lt; len; i++)
          showCallbacks[i](e);
      });
      modal.on("hidden.bs.modal", function(e) {
        for (var i = 0, len = hideCallbacks.length; i &lt; len; i++)
          hideCallbacks[i](e);
      });
      modalOptions = angular.extend({}, defaults, config);
      modal.modal(modalOptions);
      isRendered = true;
    }

    function showModal() {
      if (isRendered)
        modal.modal('show');
    }

    function hideModal() {
      if (isRendered)
        modal.modal('hide');
    }

    function destroyModal() {
      if (!isRendered)
        return;
      modal.modal('hide');
      modal.remove();
      modalScope.$destroy();
      modalScope = void(0);
      isRendered = false;
      var pos = showCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        showCallbacks.splice(pos, 1);
      pos = hideCallbacks.indexOf(config.onShow);
      if (pos &gt;= 0)
        hideCallbacks.splice(pos, 1);
    }
    return {
      render: lazyRender,
      destroy: destroyModal,
      show: showModal,
      hide: hideModal,
      isVisible: function() {
        if (!isRendered)
          false;
        return modal.visible();
      }
    }
  }
  $templateCache.put('amb_disconnect_modal.xml',
    '&lt;div id="amb_disconnect_modal" tabindex="-1" aria-hidden="true" class="modal" role="dialog"&gt;' +
    '	&lt;div class="modal-dialog small-modal" style="width:450px"&gt;' +
    '		&lt;div class="modal-content"&gt;' +
    '			&lt;header class="modal-header"&gt;' +
    '				&lt;h4 id="small_modal1_title" class="modal-title"&gt;{{title || "Login"}}&lt;/h4&gt;' +
    '			&lt;/header&gt;' +
    '			&lt;div class="modal-body"&gt;' +
    '			&lt;iframe class="concourse_modal" ng-src=\'{{iframe || "/amb_login.do"}}\' frameborder="0" scrolling="no" height="400px" width="405px"&gt;&lt;/iframe&gt;' +
    '			&lt;/div&gt;' +
    '		&lt;/div&gt;' +
    '	&lt;/div&gt;' +
    '&lt;/div&gt;'
  );
  return AMBOverlay;
});;;
/*! RESOURCE: /scripts/bootstrap-datetimepicker.js */
;
(function(root, factory) {
  'use strict';
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define(['jquery', 'moment'], factory);
  } else if (typeof exports === 'object') {
    factory(require('jquery'), require('moment'));
  } else {
    if (!jQuery) {
      throw new Error('bootstrap-datetimepicker requires jQuery to be loaded first');
    }
    if (!moment) {
      throw new Error('bootstrap-datetimepicker requires moment.js to be loaded first');
    }
    factory(root.jQuery, moment);
  }
}(this, function($, moment) {
  'use strict';
  if (typeof moment === 'undefined') {
    throw new Error('momentjs is required');
  }
  var dpgId = 0,
    DateTimePicker = function(element, options) {
      var defaults = $.fn.datetimepicker.defaults,
        icons = {
          time: 'glyphicon glyphicon-time',
          date: 'glyphicon glyphicon-calendar',
          up: 'glyphicon glyphicon-chevron-up',
          down: 'glyphicon glyphicon-chevron-down'
        },
        picker = this,
        errored = false,
        dDate,
        init = function() {
          var icon = false,
            localeData, rInterval;
          picker.options = $.extend({}, defaults, options);
          picker.options.icons = $.extend({}, icons, picker.options.icons);
          picker.element = $(element);
          dataToOptions();
          if (!(picker.options.pickTime || picker.options.pickDate)) {
            throw new Error('Must choose at least one picker');
          }
          picker.id = dpgId++;
          moment.locale(picker.options.language);
          picker.date = moment();
          picker.unset = false;
          picker.isInput = picker.element.is('input');
          picker.component = false;
          if (picker.element.hasClass('input-group')) {
            if (picker.element.find('.datepickerbutton').size() === 0) {
              picker.component = picker.element.find('[class^="input-group-"]');
            } else {
              picker.component = picker.element.find('.datepickerbutton');
            }
          }
          picker.format = picker.options.format;
          localeData = moment().localeData();
          if (!picker.format) {
            picker.format = (picker.options.pickDate ? localeData.longDateFormat('L') : '');
            if (picker.options.pickDate &amp;&amp; picker.options.pickTime) {
              picker.format += ' ';
            }
            picker.format += (picker.options.pickTime ? localeData.longDateFormat('LT') : '');
            if (picker.options.useSeconds) {
              if (localeData.longDateFormat('LT').indexOf(' A') !== -1) {
                picker.format = picker.format.split(' A')[0] + ':ss A';
              } else {
                picker.format += ':ss';
              }
            }
          }
          picker.use24hours = (picker.format.toLowerCase().indexOf('a') &lt; 0 &amp;&amp; picker.format.indexOf('h') &lt; 0);
          if (picker.component) {
            icon = picker.component.find('span');
          }
          if (picker.options.pickTime) {
            if (icon) {
              icon.addClass(picker.options.icons.time);
            }
          }
          if (picker.options.pickDate) {
            if (icon) {
              icon.removeClass(picker.options.icons.time);
              icon.addClass(picker.options.icons.date);
            }
          }
          picker.options.widgetParent =
            typeof picker.options.widgetParent === 'string' &amp;&amp; picker.options.widgetParent ||
            picker.element.parents().filter(function() {
              return 'scroll' === $(this).css('overflow-y');
            }).get(0) ||
            'body';
          picker.widget = $(getTemplate()).appendTo(picker.options.widgetParent);
          picker.minViewMode = picker.options.minViewMode || 0;
          if (typeof picker.minViewMode === 'string') {
            switch (picker.minViewMode) {
              case 'months':
                picker.minViewMode = 1;
                break;
              case 'years':
                picker.minViewMode = 2;
                break;
              default:
                picker.minViewMode = 0;
                break;
            }
          }
          picker.viewMode = picker.options.viewMode || 0;
          if (typeof picker.viewMode === 'string') {
            switch (picker.viewMode) {
              case 'months':
                picker.viewMode = 1;
                break;
              case 'years':
                picker.viewMode = 2;
                break;
              default:
                picker.viewMode = 0;
                break;
            }
          }
          picker.viewMode = Math.max(picker.viewMode, picker.minViewMode);
          picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
          picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);
          picker.startViewMode = picker.viewMode;
          picker.setMinDate(picker.options.minDate);
          picker.setMaxDate(picker.options.maxDate);
          fillDow();
          fillMonths();
          fillHours();
          fillMinutes();
          fillSeconds();
          update();
          showMode();
          if (!getPickerInput().prop('disabled')) {
            attachDatePickerEvents();
          }
          if (picker.options.defaultDate !== '' &amp;&amp; getPickerInput().val() === '') {
            picker.setValue(picker.options.defaultDate);
          }
          if (picker.options.minuteStepping !== 1) {
            rInterval = picker.options.minuteStepping;
            picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
          }
        },
        getPickerInput = function() {
          var input;
          if (picker.isInput) {
            return picker.element;
          }
          input = picker.element.find('.datepickerinput');
          if (input.size() === 0) {
            input = picker.element.find('input');
          } else if (!input.is('input')) {
            throw new Error('CSS class "datepickerinput" cannot be applied to non input element');
          }
          return input;
        },
        dataToOptions = function() {
          var eData;
          if (picker.element.is('input')) {
            eData = picker.element.data();
          } else {
            eData = picker.element.find('input').data();
          }
          if (eData.dateFormat !== undefined) {
            picker.options.format = eData.dateFormat;
          }
          if (eData.datePickdate !== undefined) {
            picker.options.pickDate = eData.datePickdate;
          }
          if (eData.datePicktime !== undefined) {
            picker.options.pickTime = eData.datePicktime;
          }
          if (eData.dateUseminutes !== undefined) {
            picker.options.useMinutes = eData.dateUseminutes;
          }
          if (eData.dateUseseconds !== undefined) {
            picker.options.useSeconds = eData.dateUseseconds;
          }
          if (eData.dateUsecurrent !== undefined) {
            picker.options.useCurrent = eData.dateUsecurrent;
          }
          if (eData.calendarWeeks !== undefined) {
            picker.options.calendarWeeks = eData.calendarWeeks;
          }
          if (eData.dateMinutestepping !== undefined) {
            picker.options.minuteStepping = eData.dateMinutestepping;
          }
          if (eData.dateMindate !== undefined) {
            picker.options.minDate = eData.dateMindate;
          }
          if (eData.dateMaxdate !== undefined) {
            picker.options.maxDate = eData.dateMaxdate;
          }
          if (eData.dateShowtoday !== undefined) {
            picker.options.showToday = eData.dateShowtoday;
          }
          if (eData.dateCollapse !== undefined) {
            picker.options.collapse = eData.dateCollapse;
          }
          if (eData.dateLanguage !== undefined) {
            picker.options.language = eData.dateLanguage;
          }
          if (eData.dateDefaultdate !== undefined) {
            picker.options.defaultDate = eData.dateDefaultdate;
          }
          if (eData.dateDisableddates !== undefined) {
            picker.options.disabledDates = eData.dateDisableddates;
          }
          if (eData.dateEnableddates !== undefined) {
            picker.options.enabledDates = eData.dateEnableddates;
          }
          if (eData.dateIcons !== undefined) {
            picker.options.icons = eData.dateIcons;
          }
          if (eData.dateUsestrict !== undefined) {
            picker.options.useStrict = eData.dateUsestrict;
          }
          if (eData.dateDirection !== undefined) {
            picker.options.direction = eData.dateDirection;
          }
          if (eData.dateSidebyside !== undefined) {
            picker.options.sideBySide = eData.dateSidebyside;
          }
          if (eData.dateDaysofweekdisabled !== undefined) {
            picker.options.daysOfWeekDisabled = eData.dateDaysofweekdisabled;
          }
        },
        place = function() {
          var position = 'absolute',
            offset = picker.component ? picker.component.offset() : picker.element.offset(),
            $window = $(window),
            placePosition;
          picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
          offset.top = offset.top + picker.element.outerHeight();
          if (picker.options.direction === 'up') {
            placePosition = 'top';
          } else if (picker.options.direction === 'bottom') {
            placePosition = 'bottom';
          } else if (picker.options.direction === 'auto') {
            if (offset.top + picker.widget.height() &gt; $window.height() + $window.scrollTop() &amp;&amp; picker.widget.height() + picker.element.outerHeight() &lt; offset.top) {
              placePosition = 'top';
            } else {
              placePosition = 'bottom';
            }
          }
          if (placePosition === 'top') {
            offset.top = offset.top - picker.element.outerHeight() - picker.widget.height() - 13;
            picker.widget.addClass('top').removeClass('bottom');
          } else {
            offset.top += 1;
            picker.widget.addClass('bottom').removeClass('top');
          }
          if (picker.options.width !== undefined) {
            picker.widget.width(picker.options.width);
          }
          if (picker.options.orientation === 'left') {
            picker.widget.addClass('left-oriented');
            offset.left = offset.left - picker.widget.width() + 20;
          }
          if (isInFixed()) {
            position = 'fixed';
            offset.top -= $window.scrollTop();
            offset.left -= $window.scrollLeft();
          }
          if ($window.width() &lt; offset.left + picker.widget.outerWidth()) {
            offset.right = $window.width() - offset.left - picker.width;
            offset.left = 'auto';
            picker.widget.addClass('pull-right');
          } else {
            offset.right = 'auto';
            picker.widget.removeClass('pull-right');
          }
          if (placePosition === 'top') {
            picker.widget.css({
              position: position,
              bottom: 'auto',
              top: offset.top,
              left: offset.left,
              right: offset.right
            });
          } else {
            picker.widget.css({
              position: position,
              top: offset.top,
              bottom: 'auto',
              left: offset.left,
              right: offset.right
            });
          }
        },
        notifyChange = function(oldDate, eventType) {
          if (moment(picker.date).isSame(moment(oldDate)) &amp;&amp; !errored) {
            return;
          }
          errored = false;
          picker.element.trigger({
            type: 'dp.change',
            date: moment(picker.date),
            oldDate: moment(oldDate)
          });
          if (eventType !== 'change') {
            picker.element.change();
          }
        },
        notifyError = function(date) {
          errored = true;
          picker.element.trigger({
            type: 'dp.error',
            date: moment(date, picker.format, picker.options.useStrict)
          });
        },
        update = function(newDate) {
          moment.locale(picker.options.language);
          var dateStr = newDate;
          if (!dateStr) {
            dateStr = getPickerInput().val();
            if (dateStr) {
              picker.date = moment(dateStr, picker.format, picker.options.useStrict);
            }
            if (!picker.date) {
              picker.date = moment();
            }
          }
          picker.viewDate = moment(picker.date).startOf('month');
          fillDate();
          fillTime();
        },
        fillDow = function() {
          moment.locale(picker.options.language);
          var html = $('&lt;tr&gt;'),
            weekdaysMin = moment.weekdaysMin(),
            i;
          if (picker.options.calendarWeeks === true) {
            html.append('&lt;th class="cw"&gt;#&lt;/th&gt;');
          }
          if (moment().localeData()._week.dow === 0) {
            for (i = 0; i &lt; 7; i++) {
              html.append('&lt;th class="dow"&gt;' + weekdaysMin[i] + '&lt;/th&gt;');
            }
          } else {
            for (i = 1; i &lt; 8; i++) {
              if (i === 7) {
                html.append('&lt;th class="dow"&gt;' + weekdaysMin[0] + '&lt;/th&gt;');
              } else {
                html.append('&lt;th class="dow"&gt;' + weekdaysMin[i] + '&lt;/th&gt;');
              }
            }
          }
          picker.widget.find('.datepicker-days thead').append(html);
        },
        fillMonths = function() {
          moment.locale(picker.options.language);
          var html = '',
            i, monthsShort = moment.monthsShort();
          for (i = 0; i &lt; 12; i++) {
            html += '&lt;span class="month"&gt;' + monthsShort[i] + '&lt;/span&gt;';
          }
          picker.widget.find('.datepicker-months td').append(html);
        },
        fillDate = function() {
          if (!picker.options.pickDate) {
            return;
          }
          moment.locale(picker.options.language);
          var year = picker.viewDate.year(),
            month = picker.viewDate.month(),
            startYear = picker.options.minDate.year(),
            startMonth = picker.options.minDate.month(),
            endYear = picker.options.maxDate.year(),
            endMonth = picker.options.maxDate.month(),
            currentDate,
            prevMonth, nextMonth, html = [],
            row, clsName, i, days, yearCont, currentYear, months = moment.months();
          picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');
          picker.widget.find('.datepicker-days th:eq(1)').text(
            months[month] + ' ' + year);
          prevMonth = moment(picker.viewDate, picker.format, picker.options.useStrict).subtract(1, 'months');
          days = prevMonth.daysInMonth();
          prevMonth.date(days).startOf('week');
          if ((year === startYear &amp;&amp; month &lt;= startMonth) || year &lt; startYear) {
            picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
          }
          if ((year === endYear &amp;&amp; month &gt;= endMonth) || year &gt; endYear) {
            picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
          }
          nextMonth = moment(prevMonth).add(42, 'd');
          while (prevMonth.isBefore(nextMonth)) {
            if (prevMonth.weekday() === moment().startOf('week').weekday()) {
              row = $('&lt;tr&gt;');
              html.push(row);
              if (picker.options.calendarWeeks === true) {
                row.append('&lt;td class="cw"&gt;' + prevMonth.week() + '&lt;/td&gt;');
              }
            }
            clsName = '';
            if (prevMonth.year() &lt; year || (prevMonth.year() === year &amp;&amp; prevMonth.month() &lt; month)) {
              clsName += ' old';
            } else if (prevMonth.year() &gt; year || (prevMonth.year() === year &amp;&amp; prevMonth.month() &gt; month)) {
              clsName += ' new';
            }
            if (prevMonth.isSame(moment({
                y: picker.date.year(),
                M: picker.date.month(),
                d: picker.date.date()
              }))) {
              clsName += ' active';
            }
            if (isInDisableDates(prevMonth, 'day') || !isInEnableDates(prevMonth)) {
              clsName += ' disabled';
            }
            if (picker.options.showToday === true) {
              if (prevMonth.isSame(moment(), 'day')) {
                clsName += ' today';
              }
            }
            if (picker.options.daysOfWeekDisabled) {
              for (i = 0; i &lt; picker.options.daysOfWeekDisabled.length; i++) {
                if (prevMonth.day() === picker.options.daysOfWeekDisabled[i]) {
                  clsName += ' disabled';
                  break;
                }
              }
            }
            row.append('&lt;td class="day' + clsName + '"&gt;' + prevMonth.date() + '&lt;/td&gt;');
            currentDate = prevMonth.date();
            prevMonth.add(1, 'd');
            if (currentDate === prevMonth.date()) {
              prevMonth.add(1, 'd');
            }
          }
          picker.widget.find('.datepicker-days tbody').empty().append(html);
          currentYear = picker.date.year();
          months = picker.widget.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');
          if (currentYear === year) {
            months.eq(picker.date.month()).addClass('active');
          }
          if (year - 1 &lt; startYear) {
            picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
          }
          if (year + 1 &gt; endYear) {
            picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
          }
          for (i = 0; i &lt; 12; i++) {
            if ((year === startYear &amp;&amp; startMonth &gt; i) || (year &lt; startYear)) {
              $(months[i]).addClass('disabled');
            } else if ((year === endYear &amp;&amp; endMonth &lt; i) || (year &gt; endYear)) {
              $(months[i]).addClass('disabled');
            }
          }
          html = '';
          year = parseInt(year / 10, 10) * 10;
          yearCont = picker.widget.find('.datepicker-years').find(
            'th:eq(1)').text(year + '-' + (year + 9)).parents('table').find('td');
          picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
          if (startYear &gt; year) {
            picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
          }
          if (endYear &lt; year + 9) {
            picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
          }
          year -= 1;
          for (i = -1; i &lt; 11; i++) {
            html += '&lt;span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year &lt; startYear || year &gt; endYear) ? ' disabled' : '') + '"&gt;' + year + '&lt;/span&gt;';
            year += 1;
          }
          yearCont.html(html);
        },
        fillHours = function() {
          moment.locale(picker.options.language);
          var table = picker.widget.find('.timepicker .timepicker-hours table'),
            html = '',
            current, i, j;
          table.parent().hide();
          if (picker.use24hours) {
            current = 0;
            for (i = 0; i &lt; 6; i += 1) {
              html += '&lt;tr&gt;';
              for (j = 0; j &lt; 4; j += 1) {
                html += '&lt;td class="hour"&gt;' + padLeft(current.toString()) + '&lt;/td&gt;';
                current++;
              }
              html += '&lt;/tr&gt;';
            }
          } else {
            current = 1;
            for (i = 0; i &lt; 3; i += 1) {
              html += '&lt;tr&gt;';
              for (j = 0; j &lt; 4; j += 1) {
                html += '&lt;td class="hour"&gt;' + padLeft(current.toString()) + '&lt;/td&gt;';
                current++;
              }
              html += '&lt;/tr&gt;';
            }
          }
          table.html(html);
        },
        fillMinutes = function() {
          var table = picker.widget.find('.timepicker .timepicker-minutes table'),
            html = '',
            current = 0,
            i, j, step = picker.options.minuteStepping;
          table.parent().hide();
          if (step === 1) {
            step = 5;
          }
          for (i = 0; i &lt; Math.ceil(60 / step / 4); i++) {
            html += '&lt;tr&gt;';
            for (j = 0; j &lt; 4; j += 1) {
              if (current &lt; 60) {
                html += '&lt;td class="minute"&gt;' + padLeft(current.toString()) + '&lt;/td&gt;';
                current += step;
              } else {
                html += '&lt;td&gt;&lt;/td&gt;';
              }
            }
            html += '&lt;/tr&gt;';
          }
          table.html(html);
        },
        fillSeconds = function() {
          var table = picker.widget.find('.timepicker .timepicker-seconds table'),
            html = '',
            current = 0,
            i, j;
          table.parent().hide();
          for (i = 0; i &lt; 3; i++) {
            html += '&lt;tr&gt;';
            for (j = 0; j &lt; 4; j += 1) {
              html += '&lt;td class="second"&gt;' + padLeft(current.toString()) + '&lt;/td&gt;';
              current += 5;
            }
            html += '&lt;/tr&gt;';
          }
          table.html(html);
        },
        fillTime = function() {
          if (!picker.date) {
            return;
          }
          var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
            hour = picker.date.hours(),
            period = picker.date.format('A');
          if (!picker.use24hours) {
            if (hour === 0) {
              hour = 12;
            } else if (hour !== 12) {
              hour = hour % 12;
            }
            picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
          }
          timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
          timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
          timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
        },
        click = function(e) {
          e.stopPropagation();
          e.preventDefault();
          picker.unset = false;
          var target = $(e.target).closest('span, td, th'),
            month, year, step, day, oldDate = moment(picker.date);
          if (target.length === 1) {
            if (!target.is('.disabled')) {
              switch (target[0].nodeName.toLowerCase()) {
                case 'th':
                  switch (target[0].className) {
                    case 'picker-switch':
                      showMode(1);
                      break;
                    case 'prev':
                    case 'next':
                      step = dpGlobal.modes[picker.viewMode].navStep;
                      if (target[0].className === 'prev') {
                        step = step * -1;
                      }
                      picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
                      fillDate();
                      break;
                  }
                  break;
                case 'span':
                  if (target.is('.month')) {
                    month = target.parent().find('span').index(target);
                    picker.viewDate.month(month);
                  } else {
                    year = parseInt(target.text(), 10) || 0;
                    picker.viewDate.year(year);
                  }
                  if (picker.viewMode === picker.minViewMode) {
                    picker.date = moment({
                      y: picker.viewDate.year(),
                      M: picker.viewDate.month(),
                      d: picker.viewDate.date(),
                      h: picker.date.hours(),
                      m: picker.date.minutes(),
                      s: picker.date.seconds()
                    });
                    set();
                    notifyChange(oldDate, e.type);
                  }
                  showMode(-1);
                  fillDate();
                  break;
                case 'td':
                  if (target.is('.day')) {
                    day = parseInt(target.text(), 10) || 1;
                    month = picker.viewDate.month();
                    year = picker.viewDate.year();
                    if (target.is('.old')) {
                      if (month === 0) {
                        month = 11;
                        year -= 1;
                      } else {
                        month -= 1;
                      }
                    } else if (target.is('.new')) {
                      if (month === 11) {
                        month = 0;
                        year += 1;
                      } else {
                        month += 1;
                      }
                    }
                    picker.date = moment({
                      y: year,
                      M: month,
                      d: day,
                      h: picker.date.hours(),
                      m: picker.date.minutes(),
                      s: picker.date.seconds()
                    });
                    picker.viewDate = moment({
                      y: year,
                      M: month,
                      d: Math.min(28, day)
                    });
                    fillDate();
                    set();
                    notifyChange(oldDate, e.type);
                  }
                  break;
              }
            }
          }
        },
        actions = {
          incrementHours: function() {
            checkDate('add', 'hours', 1);
          },
          incrementMinutes: function() {
            checkDate('add', 'minutes', picker.options.minuteStepping);
          },
          incrementSeconds: function() {
            checkDate('add', 'seconds', 1);
          },
          decrementHours: function() {
            checkDate('subtract', 'hours', 1);
          },
          decrementMinutes: function() {
            checkDate('subtract', 'minutes', picker.options.minuteStepping);
          },
          decrementSeconds: function() {
            checkDate('subtract', 'seconds', 1);
          },
          togglePeriod: function() {
            var hour = picker.date.hours();
            if (hour &gt;= 12) {
              hour -= 12;
            } else {
              hour += 12;
            }
            picker.date.hours(hour);
          },
          showPicker: function() {
            picker.widget.find('.timepicker &gt; div:not(.timepicker-picker)').hide();
            picker.widget.find('.timepicker .timepicker-picker').show();
          },
          showHours: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-hours').show();
          },
          showMinutes: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-minutes').show();
          },
          showSeconds: function() {
            picker.widget.find('.timepicker .timepicker-picker').hide();
            picker.widget.find('.timepicker .timepicker-seconds').show();
          },
          selectHour: function(e) {
            var hour = parseInt($(e.target).text(), 10);
            if (!picker.use24hours) {
              if (picker.date.hours() &gt;= 12) {
                if (hour !== 12) {
                  hour += 12;
                }
              } else {
                if (hour === 12) {
                  hour = 0;
                }
              }
            }
            picker.date.hours(hour);
            actions.showPicker.call(picker);
          },
          selectMinute: function(e) {
            picker.date.minutes(parseInt($(e.target).text(), 10));
            actions.showPicker.call(picker);
          },
          selectSecond: function(e) {
            picker.date.seconds(parseInt($(e.target).text(), 10));
            actions.showPicker.call(picker);
          }
        },
        doAction = function(e) {
          var oldDate = moment(picker.date),
            action = $(e.currentTarget).data('action'),
            rv = actions[action].apply(picker, arguments);
          stopEvent(e);
          if (!picker.date) {
            picker.date = moment({
              y: 1970
            });
          }
          set();
          fillTime();
          notifyChange(oldDate, e.type);
          return rv;
        },
        stopEvent = function(e) {
          e.stopPropagation();
          e.preventDefault();
        },
        keydown = function(e) {
          if (e.keyCode === 27) {
            picker.hide();
          }
        },
        change = function(e) {
          moment.locale(picker.options.language);
          var input = $(e.target),
            oldDate = moment(picker.date),
            newDate = moment(input.val(), picker.format, picker.options.useStrict);
          if (newDate.isValid() &amp;&amp; !isInDisableDates(newDate) &amp;&amp; isInEnableDates(newDate)) {
            update();
            picker.setValue(newDate);
            notifyChange(oldDate, e.type);
            set();
          } else {
            picker.viewDate = oldDate;
            picker.unset = true;
            notifyChange(oldDate, e.type);
            notifyError(newDate);
          }
        },
        showMode = function(dir) {
          if (dir) {
            picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
          }
          picker.widget.find('.datepicker &gt; div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
        },
        attachDatePickerEvents = function() {
          var $this, $parent, expanded, closed, collapseData;
          picker.widget.on('click', '.datepicker *', $.proxy(click, this));
          picker.widget.on('click', '[data-action]', $.proxy(doAction, this));
          picker.widget.on('mousedown', $.proxy(stopEvent, this));
          picker.element.on('keydown', $.proxy(keydown, this));
          if (picker.options.pickDate &amp;&amp; picker.options.pickTime) {
            picker.widget.on('click.togglePicker', '.accordion-toggle', function(e) {
              e.stopPropagation();
              $this = $(this);
              $parent = $this.closest('ul');
              expanded = $parent.find('.in');
              closed = $parent.find('.collapse:not(.in)');
              if (expanded &amp;&amp; expanded.length) {
                collapseData = expanded.data('collapse');
                if (collapseData &amp;&amp; collapseData.transitioning) {
                  return;
                }
                expanded.collapse('hide');
                closed.collapse('show');
                $this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                if (picker.component) {
                  picker.component.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
                }
              }
            });
          }
          if (picker.isInput) {
            picker.element.on({
              'click': $.proxy(picker.show, this),
              'focus': $.proxy(picker.show, this),
              'change': $.proxy(change, this),
              'blur': $.proxy(picker.hide, this)
            });
          } else {
            picker.element.on({
              'change': $.proxy(change, this)
            }, 'input');
            if (picker.component) {
              picker.component.on('click', $.proxy(picker.show, this));
              picker.component.on('mousedown', $.proxy(stopEvent, this));
            } else {
              picker.element.on('click', $.proxy(picker.show, this));
            }
          }
        },
        attachDatePickerGlobalEvents = function() {
          $(window).on(
            'resize.datetimepicker' + picker.id, $.proxy(place, this));
          if (!picker.isInput) {
            $(document).on(
              'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
          }
        },
        detachDatePickerEvents = function() {
          picker.widget.off('click', '.datepicker *', picker.click);
          picker.widget.off('click', '[data-action]');
          picker.widget.off('mousedown', picker.stopEvent);
          if (picker.options.pickDate &amp;&amp; picker.options.pickTime) {
            picker.widget.off('click.togglePicker');
          }
          if (picker.isInput) {
            picker.element.off({
              'focus': picker.show,
              'change': change,
              'click': picker.show,
              'blur': picker.hide
            });
          } else {
            picker.element.off({
              'change': change
            }, 'input');
            if (picker.component) {
              picker.component.off('click', picker.show);
              picker.component.off('mousedown', picker.stopEvent);
            } else {
              picker.element.off('click', picker.show);
            }
          }
        },
        detachDatePickerGlobalEvents = function() {
          $(window).off('resize.datetimepicker' + picker.id);
          if (!picker.isInput) {
            $(document).off('mousedown.datetimepicker' + picker.id);
          }
        },
        isInFixed = function() {
          if (picker.element) {
            var parents = picker.element.parents(),
              inFixed = false,
              i;
            for (i = 0; i &lt; parents.length; i++) {
              if ($(parents[i]).css('position') === 'fixed') {
                inFixed = true;
                break;
              }
            }
            return inFixed;
          } else {
            return false;
          }
        },
        set = function() {
          moment.locale(picker.options.language);
          var formatted = '';
          if (!picker.unset) {
            formatted = moment(picker.date).format(picker.format);
          }
          getPickerInput().val(formatted);
          picker.element.data('date', formatted);
          if (!picker.options.pickTime) {
            picker.hide();
          }
        },
        checkDate = function(direction, unit, amount) {
          moment.locale(picker.options.language);
          var newDate;
          if (direction === 'add') {
            newDate = moment(picker.date);
            if (newDate.hours() === 23) {
              newDate.add(amount, unit);
            }
            newDate.add(amount, unit);
          } else {
            newDate = moment(picker.date).subtract(amount, unit);
          }
          if (isInDisableDates(moment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
            notifyError(newDate.format(picker.format));
            return;
          }
          if (direction === 'add') {
            picker.date.add(amount, unit);
          } else {
            picker.date.subtract(amount, unit);
          }
          picker.unset = false;
        },
        isInDisableDates = function(date, timeUnit) {
          moment.locale(picker.options.language);
          var maxDate = moment(picker.options.maxDate, picker.format, picker.options.useStrict),
            minDate = moment(picker.options.minDate, picker.format, picker.options.useStrict);
          if (timeUnit) {
            maxDate = maxDate.endOf(timeUnit);
            minDate = minDate.startOf(timeUnit);
          }
          if (date.isAfter(maxDate) || date.isBefore(minDate)) {
            return true;
          }
          if (picker.options.disabledDates === false) {
            return false;
          }
          return picker.options.disabledDates[date.format('YYYY-MM-DD')] === true;
        },
        isInEnableDates = function(date) {
          moment.locale(picker.options.language);
          if (picker.options.enabledDates === false) {
            return true;
          }
          return picker.options.enabledDates[date.format('YYYY-MM-DD')] === true;
        },
        indexGivenDates = function(givenDatesArray) {
          var givenDatesIndexed = {},
            givenDatesCount = 0,
            i;
          for (i = 0; i &lt; givenDatesArray.length; i++) {
            if (moment.isMoment(givenDatesArray[i]) || givenDatesArray[i] instanceof Date) {
              dDate = moment(givenDatesArray[i]);
            } else {
              dDate = moment(givenDatesArray[i], picker.format, picker.options.useStrict);
            }
            if (dDate.isValid()) {
              givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
              givenDatesCount++;
            }
          }
          if (givenDatesCount &gt; 0) {
            return givenDatesIndexed;
          }
          return false;
        },
        padLeft = function(string) {
          string = string.toString();
          if (string.length &gt;= 2) {
            return string;
          }
          return '0' + string;
        },
        getTemplate = function() {
          var
            headTemplate =
            '&lt;thead&gt;' +
            '&lt;tr&gt;' +
            '&lt;th class="prev"&gt;&amp;lsaquo;&lt;/th&gt;&lt;th colspan="' + (picker.options.calendarWeeks ? '6' : '5') + '" class="picker-switch"&gt;&lt;/th&gt;&lt;th class="next"&gt;&amp;rsaquo;&lt;/th&gt;' +
            '&lt;/tr&gt;' +
            '&lt;/thead&gt;',
            contTemplate =
            '&lt;tbody&gt;&lt;tr&gt;&lt;td colspan="' + (picker.options.calendarWeeks ? '8' : '7') + '"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;',
            template = '&lt;div class="datepicker-days"&gt;' +
            '&lt;table class="table-condensed"&gt;' + headTemplate + '&lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt;' +
            '&lt;/div&gt;' +
            '&lt;div class="datepicker-months"&gt;' +
            '&lt;table class="table-condensed"&gt;' + headTemplate + contTemplate + '&lt;/table&gt;' +
            '&lt;/div&gt;' +
            '&lt;div class="datepicker-years"&gt;' +
            '&lt;table class="table-condensed"&gt;' + headTemplate + contTemplate + '&lt;/table&gt;' +
            '&lt;/div&gt;',
            ret = '';
          if (picker.options.pickDate &amp;&amp; picker.options.pickTime) {
            ret = '&lt;div class="bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + (picker.use24hours ? ' usetwentyfour' : '') + ' dropdown-menu" style="z-index:9999 !important;"&gt;';
            if (picker.options.sideBySide) {
              ret += '&lt;div class="row"&gt;' +
                '&lt;div class="col-sm-6 datepicker"&gt;' + template + '&lt;/div&gt;' +
                '&lt;div class="col-sm-6 timepicker"&gt;' + tpGlobal.getTemplate() + '&lt;/div&gt;' +
                '&lt;/div&gt;';
            } else {
              ret += '&lt;ul class="list-unstyled"&gt;' +
                '&lt;li' + (picker.options.collapse ? ' class="collapse in"' : '') + '&gt;' +
                '&lt;div class="datepicker"&gt;' + template + '&lt;/div&gt;' +
                '&lt;/li&gt;' +
                '&lt;li class="picker-switch accordion-toggle"&gt;&lt;a class="btn" style="width:100%"&gt;&lt;span class="' + picker.options.icons.time + '"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;' +
                '&lt;li' + (picker.options.collapse ? ' class="collapse"' : '') + '&gt;' +
                '&lt;div class="timepicker"&gt;' + tpGlobal.getTemplate() + '&lt;/div&gt;' +
                '&lt;/li&gt;' +
                '&lt;/ul&gt;';
            }
            ret += '&lt;/div&gt;';
            return ret;
          }
          if (picker.options.pickTime) {
            return (
              '&lt;div class="bootstrap-datetimepicker-widget dropdown-menu"&gt;' +
              '&lt;div class="timepicker"&gt;' + tpGlobal.getTemplate() + '&lt;/div&gt;' +
              '&lt;/div&gt;'
            );
          }
          return (
            '&lt;div class="bootstrap-datetimepicker-widget dropdown-menu"&gt;' +
            '&lt;div class="datepicker"&gt;' + template + '&lt;/div&gt;' +
            '&lt;/div&gt;'
          );
        },
        dpGlobal = {
          modes: [{
              clsName: 'days',
              navFnc: 'month',
              navStep: 1
            },
            {
              clsName: 'months',
              navFnc: 'year',
              navStep: 1
            },
            {
              clsName: 'years',
              navFnc: 'year',
              navStep: 10
            }
          ]
        },
        tpGlobal = {
          hourTemplate: '&lt;span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"&gt;&lt;/span&gt;',
          minuteTemplate: '&lt;span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"&gt;&lt;/span&gt;',
          secondTemplate: '&lt;span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"&gt;&lt;/span&gt;'
        };
      tpGlobal.getTemplate = function() {
        return (
          '&lt;div class="timepicker-picker"&gt;' +
          '&lt;table class="table-condensed"&gt;' +
          '&lt;tr&gt;' +
          '&lt;td&gt;&lt;a href="#" class="btn" data-action="incrementHours"&gt;&lt;span class="' + picker.options.icons.up + '"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;' +
          '&lt;td class="separator"&gt;&lt;/td&gt;' +
          '&lt;td&gt;' + (picker.options.useMinutes ? '&lt;a href="#" class="btn" data-action="incrementMinutes"&gt;&lt;span class="' + picker.options.icons.up + '"&gt;&lt;/span&gt;&lt;/a&gt;' : '') + '&lt;/td&gt;' +
          (picker.options.useSeconds ?
            '&lt;td class="separator"&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="#" class="btn" data-action="incrementSeconds"&gt;&lt;span class="' + picker.options.icons.up + '"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;' : '') +
          (picker.use24hours ? '' : '&lt;td class="separator"&gt;&lt;/td&gt;') +
          '&lt;/tr&gt;' +
          '&lt;tr&gt;' +
          '&lt;td&gt;' + tpGlobal.hourTemplate + '&lt;/td&gt; ' +
          '&lt;td class="separator"&gt;:&lt;/td&gt;' +
          '&lt;td&gt;' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '&lt;span class="timepicker-minute"&gt;00&lt;/span&gt;') + '&lt;/td&gt; ' +
          (picker.options.useSeconds ?
            '&lt;td class="separator"&gt;:&lt;/td&gt;&lt;td&gt;' + tpGlobal.secondTemplate + '&lt;/td&gt;' : '') +
          (picker.use24hours ? '' : '&lt;td class="separator"&gt;&lt;/td&gt;' +
            '&lt;td&gt;&lt;button type="button" class="btn btn-primary" data-action="togglePeriod"&gt;&lt;/button&gt;&lt;/td&gt;') +
          '&lt;/tr&gt;' +
          '&lt;tr&gt;' +
          '&lt;td&gt;&lt;a href="#" class="btn" data-action="decrementHours"&gt;&lt;span class="' + picker.options.icons.down + '"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;' +
          '&lt;td class="separator"&gt;&lt;/td&gt;' +
          '&lt;td&gt;' + (picker.options.useMinutes ? '&lt;a href="#" class="btn" data-action="decrementMinutes"&gt;&lt;span class="' + picker.options.icons.down + '"&gt;&lt;/span&gt;&lt;/a&gt;' : '') + '&lt;/td&gt;' +
          (picker.options.useSeconds ?
            '&lt;td class="separator"&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="#" class="btn" data-action="decrementSeconds"&gt;&lt;span class="' + picker.options.icons.down + '"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;' : '') +
          (picker.use24hours ? '' : '&lt;td class="separator"&gt;&lt;/td&gt;') +
          '&lt;/tr&gt;' +
          '&lt;/table&gt;' +
          '&lt;/div&gt;' +
          '&lt;div class="timepicker-hours" data-action="selectHour"&gt;' +
          '&lt;table class="table-condensed"&gt;&lt;/table&gt;' +
          '&lt;/div&gt;' +
          '&lt;div class="timepicker-minutes" data-action="selectMinute"&gt;' +
          '&lt;table class="table-condensed"&gt;&lt;/table&gt;' +
          '&lt;/div&gt;' +
          (picker.options.useSeconds ?
            '&lt;div class="timepicker-seconds" data-action="selectSecond"&gt;&lt;table class="table-condensed"&gt;&lt;/table&gt;&lt;/div&gt;' : '')
        );
      };
      picker.destroy = function() {
        detachDatePickerEvents();
        detachDatePickerGlobalEvents();
        picker.widget.remove();
        picker.element.removeData('DateTimePicker');
        if (picker.component) {
          picker.component.removeData('DateTimePicker');
        }
      };
      picker.show = function(e) {
        if (getPickerInput().prop('disabled')) {
          return;
        }
        if (picker.options.useCurrent) {
          if (getPickerInput().val() === '') {
            if (picker.options.minuteStepping !== 1) {
              var mDate = moment(),
                rInterval = picker.options.minuteStepping;
              mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
              picker.setValue(mDate.format(picker.format));
            } else {
              picker.setValue(moment().format(picker.format));
            }
            notifyChange('', e.type);
          }
        }
        if (e &amp;&amp; e.type === 'click' &amp;&amp; picker.isInput &amp;&amp; picker.widget.hasClass('picker-open')) {
          return;
        }
        if (picker.widget.hasClass('picker-open')) {
          picker.widget.hide();
          picker.widget.removeClass('picker-open');
        } else {
          picker.widget.show();
          picker.widget.addClass('picker-open');
        }
        picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
        place();
        picker.element.trigger({
          type: 'dp.show',
          date: moment(picker.date)
        });
        attachDatePickerGlobalEvents();
        if (e) {
          stopEvent(e);
        }
      };
      picker.disable = function() {
        var input = getPickerInput();
        if (input.prop('disabled')) {
          return;
        }
        input.prop('disabled', true);
        detachDatePickerEvents();
      };
      picker.enable = function() {
        var input = getPickerInput();
        if (!input.prop('disabled')) {
          return;
        }
        input.prop('disabled', false);
        attachDatePickerEvents();
      };
      picker.hide = function() {
        var collapse = picker.widget.find('.collapse'),
          i, collapseData;
        for (i = 0; i &lt; collapse.length; i++) {
          collapseData = collapse.eq(i).data('collapse');
          if (collapseData &amp;&amp; collapseData.transitioning) {
            return;
          }
        }
        picker.widget.hide();
        picker.widget.removeClass('picker-open');
        picker.viewMode = picker.startViewMode;
        showMode();
        picker.element.trigger({
          type: 'dp.hide',
          date: moment(picker.date)
        });
        detachDatePickerGlobalEvents();
      };
      picker.setValue = function(newDate) {
        moment.locale(picker.options.language);
        if (!newDate) {
          picker.unset = true;
          set();
        } else {
          picker.unset = false;
        }
        if (!moment.isMoment(newDate)) {
          newDate = (newDate instanceof Date) ? moment(newDate) : moment(newDate, picker.format, picker.options.useStrict);
        } else {
          newDate = newDate.locale(picker.options.language);
        }
        if (newDate.isValid()) {
          picker.date = newDate;
          set();
          picker.viewDate = moment({
            y: picker.date.year(),
            M: picker.date.month()
          });
          fillDate();
          fillTime();
        } else {
          notifyError(newDate);
        }
      };
      picker.getDate = function() {
        if (picker.unset) {
          return null;
        }
        return moment(picker.date);
      };
      picker.setDate = function(date) {
        var oldDate = moment(picker.date);
        if (!date) {
          picker.setValue(null);
        } else {
          picker.setValue(date);
        }
        notifyChange(oldDate, 'function');
      };
      picker.setDisabledDates = function(dates) {
        picker.options.disabledDates = indexGivenDates(dates);
        if (picker.viewDate) {
          update();
        }
      };
      picker.setEnabledDates = function(dates) {
        picker.options.enabledDates = indexGivenDates(dates);
        if (picker.viewDate) {
          update();
        }
      };
      picker.setMaxDate = function(date) {
        if (date === undefined) {
          return;
        }
        if (moment.isMoment(date) || date instanceof Date) {
          picker.options.maxDate = moment(date);
        } else {
          picker.options.maxDate = moment(date, picker.format, picker.options.useStrict);
        }
        if (picker.viewDate) {
          update();
        }
      };
      picker.setMinDate = function(date) {
        if (date === undefined) {
          return;
        }
        if (moment.isMoment(date) || date instanceof Date) {
          picker.options.minDate = moment(date);
        } else {
          picker.options.minDate = moment(date, picker.format, picker.options.useStrict);
        }
        if (picker.viewDate) {
          update();
        }
      };
      init();
    };
  $.fn.datetimepicker = function(options) {
    return this.each(function() {
      var $this = $(this),
        data = $this.data('DateTimePicker');
      if (!data) {
        $this.data('DateTimePicker', new DateTimePicker(this, options));
      }
    });
  };
  $.fn.datetimepicker.defaults = {
    format: false,
    pickDate: true,
    pickTime: true,
    useMinutes: true,
    useSeconds: false,
    useCurrent: true,
    calendarWeeks: false,
    minuteStepping: 1,
    minDate: moment({
      y: 1900
    }),
    maxDate: moment().add(100, 'y'),
    showToday: true,
    collapse: true,
    language: moment.locale(),
    defaultDate: '',
    disabledDates: false,
    enabledDates: false,
    icons: {},
    useStrict: false,
    direction: 'auto',
    sideBySide: false,
    daysOfWeekDisabled: [],
    widgetParent: false
  };
}));;
/*! RESOURCE: /scripts/libs/sortable.min.js */
/*! Sortable 1.4.2 - MIT | git://github.com/rubaxa/Sortable.git */
! function(a) {
  "use strict";
  "function" == typeof define &amp;&amp; define.amd ? define(a) : "undefined" != typeof module &amp;&amp; "undefined" != typeof module.exports ? module.exports = a() : "undefined" != typeof Package ? Sortable = a() : window.Sortable = a()
}(function() {
  "use strict";

  function a(a, b) {
    if (!a || !a.nodeType || 1 !== a.nodeType) throw "Sortable: `el` must be HTMLElement, and not " + {}.toString.call(a);
    this.el = a, this.options = b = r({}, b), a[L] = this;
    var c = {
      group: Math.random(),
      sort: !0,
      disabled: !1,
      store: null,
      handle: null,
      scroll: !0,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      draggable: /[uo]l/i.test(a.nodeName) ? "li" : "&gt;*",
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      ignore: "a, img",
      filter: null,
      animation: 0,
      setData: function(a, b) {
        a.setData("Text", b.textContent)
      },
      dropBubble: !1,
      dragoverBubble: !1,
      dataIdAttr: "data-id",
      delay: 0,
      forceFallback: !1,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: !1
    };
    for (var d in c) !(d in b) &amp;&amp; (b[d] = c[d]);
    V(b);
    for (var f in this) "_" === f.charAt(0) &amp;&amp; (this[f] = this[f].bind(this));
    this.nativeDraggable = b.forceFallback ? !1 : P, e(a, "mousedown", this._onTapStart), e(a, "touchstart", this._onTapStart), this.nativeDraggable &amp;&amp; (e(a, "dragover", this), e(a, "dragenter", this)), T.push(this._onDragOver), b.store &amp;&amp; this.sort(b.store.get(this))
  }

  function b(a) {
    v &amp;&amp; v.state !== a &amp;&amp; (h(v, "display", a ? "none" : ""), !a &amp;&amp; v.state &amp;&amp; w.insertBefore(v, s), v.state = a)
  }

  function c(a, b, c) {
    if (a) {
      c = c || N, b = b.split(".");
      var d = b.shift().toUpperCase(),
        e = new RegExp("\\s(" + b.join("|") + ")(?=\\s)", "g");
      do
        if ("&gt;*" === d &amp;&amp; a.parentNode === c || ("" === d || a.nodeName.toUpperCase() == d) &amp;&amp; (!b.length || ((" " + a.className + " ").match(e) || []).length == b.length)) return a; while (a !== c &amp;&amp; (a = a.parentNode))
    }
    return null
  }

  function d(a) {
    a.dataTransfer &amp;&amp; (a.dataTransfer.dropEffect = "move"), a.preventDefault()
  }

  function e(a, b, c) {
    a.addEventListener(b, c, !1)
  }

  function f(a, b, c) {
    a.removeEventListener(b, c, !1)
  }

  function g(a, b, c) {
    if (a)
      if (a.classList) a.classList[c ? "add" : "remove"](b);
      else {
        var d = (" " + a.className + " ").replace(K, " ").replace(" " + b + " ", " ");
        a.className = (d + (c ? " " + b : "")).replace(K, " ")
      }
  }

  function h(a, b, c) {
    var d = a &amp;&amp; a.style;
    if (d) {
      if (void 0 === c) return N.defaultView &amp;&amp; N.defaultView.getComputedStyle ? c = N.defaultView.getComputedStyle(a, "") : a.currentStyle &amp;&amp; (c = a.currentStyle), void 0 === b ? c : c[b];
      b in d || (b = "-webkit-" + b), d[b] = c + ("string" == typeof c ? "" : "px")
    }
  }

  function i(a, b, c) {
    if (a) {
      var d = a.getElementsByTagName(b),
        e = 0,
        f = d.length;
      if (c)
        for (; f &gt; e; e++) c(d[e], e);
      return d
    }
    return []
  }

  function j(a, b, c, d, e, f, g) {
    var h = N.createEvent("Event"),
      i = (a || b[L]).options,
      j = "on" + c.charAt(0).toUpperCase() + c.substr(1);
    h.initEvent(c, !0, !0), h.to = b, h.from = e || b, h.item = d || b, h.clone = v, h.oldIndex = f, h.newIndex = g, b.dispatchEvent(h), i[j] &amp;&amp; i[j].call(a, h)
  }

  function k(a, b, c, d, e, f) {
    var g, h, i = a[L],
      j = i.options.onMove;
    return g = N.createEvent("Event"), g.initEvent("move", !0, !0), g.to = b, g.from = a, g.dragged = c, g.draggedRect = d, g.related = e || b, g.relatedRect = f || b.getBoundingClientRect(), a.dispatchEvent(g), j &amp;&amp; (h = j.call(i, g)), h
  }

  function l(a) {
    a.draggable = !1
  }

  function m() {
    R = !1
  }

  function n(a, b) {
    var c = a.lastElementChild,
      d = c.getBoundingClientRect();
    return (b.clientY - (d.top + d.height) &gt; 5 || b.clientX - (d.right + d.width) &gt; 5) &amp;&amp; c
  }

  function o(a) {
    for (var b = a.tagName + a.className + a.src + a.href + a.textContent, c = b.length, d = 0; c--;) d += b.charCodeAt(c);
    return d.toString(36)
  }

  function p(a) {
    var b = 0;
    if (!a || !a.parentNode) return -1;
    for (; a &amp;&amp; (a = a.previousElementSibling);) "TEMPLATE" !== a.nodeName.toUpperCase() &amp;&amp; b++;
    return b
  }

  function q(a, b) {
    var c, d;
    return function() {
      void 0 === c &amp;&amp; (c = arguments, d = this, setTimeout(function() {
        1 === c.length ? a.call(d, c[0]) : a.apply(d, c), c = void 0
      }, b))
    }
  }

  function r(a, b) {
    if (a &amp;&amp; b)
      for (var c in b) b.hasOwnProperty(c) &amp;&amp; (a[c] = b[c]);
    return a
  }
  var s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J = {},
    K = /\s+/g,
    L = "Sortable" + (new Date).getTime(),
    M = window,
    N = M.document,
    O = M.parseInt,
    P = !!("draggable" in N.createElement("div")),
    Q = function(a) {
      return a = N.createElement("x"), a.style.cssText = "pointer-events:auto", "auto" === a.style.pointerEvents
    }(),
    R = !1,
    S = Math.abs,
    T = ([].slice, []),
    U = q(function(a, b, c) {
      if (c &amp;&amp; b.scroll) {
        var d, e, f, g, h = b.scrollSensitivity,
          i = b.scrollSpeed,
          j = a.clientX,
          k = a.clientY,
          l = window.innerWidth,
          m = window.innerHeight;
        if (z !== c &amp;&amp; (y = b.scroll, z = c, y === !0)) {
          y = c;
          do
            if (y.offsetWidth &lt; y.scrollWidth || y.offsetHeight &lt; y.scrollHeight) break; while (y = y.parentNode)
        }
        y &amp;&amp; (d = y, e = y.getBoundingClientRect(), f = (S(e.right - j) &lt;= h) - (S(e.left - j) &lt;= h), g = (S(e.bottom - k) &lt;= h) - (S(e.top - k) &lt;= h)), f || g || (f = (h &gt;= l - j) - (h &gt;= j), g = (h &gt;= m - k) - (h &gt;= k), (f || g) &amp;&amp; (d = M)), (J.vx !== f || J.vy !== g || J.el !== d) &amp;&amp; (J.el = d, J.vx = f, J.vy = g, clearInterval(J.pid), d &amp;&amp; (J.pid = setInterval(function() {
          d === M ? M.scrollTo(M.pageXOffset + f * i, M.pageYOffset + g * i) : (g &amp;&amp; (d.scrollTop += g * i), f &amp;&amp; (d.scrollLeft += f * i))
        }, 24)))
      }
    }, 30),
    V = function(a) {
      var b = a.group;
      b &amp;&amp; "object" == typeof b || (b = a.group = {
        name: b
      }), ["pull", "put"].forEach(function(a) {
        a in b || (b[a] = !0)
      }), a.groups = " " + b.name + (b.put.join ? " " + b.put.join(" ") : "") + " "
    };
  return a.prototype = {
    constructor: a,
    _onTapStart: function(a) {
      var b = this,
        d = this.el,
        e = this.options,
        f = a.type,
        g = a.touches &amp;&amp; a.touches[0],
        h = (g || a).target,
        i = h,
        k = e.filter;
      if (!("mousedown" === f &amp;&amp; 0 !== a.button || e.disabled) &amp;&amp; (h = c(h, e.draggable, d))) {
        if (D = p(h), "function" == typeof k) {
          if (k.call(this, a, h, this)) return j(b, i, "filter", h, d, D), void a.preventDefault()
        } else if (k &amp;&amp; (k = k.split(",").some(function(a) {
            return a = c(i, a.trim(), d), a ? (j(b, a, "filter", h, d, D), !0) : void 0
          }))) return void a.preventDefault();
        (!e.handle || c(i, e.handle, d)) &amp;&amp; this._prepareDragStart(a, g, h)
      }
    },
    _prepareDragStart: function(a, b, c) {
      var d, f = this,
        h = f.el,
        j = f.options,
        k = h.ownerDocument;
      c &amp;&amp; !s &amp;&amp; c.parentNode === h &amp;&amp; (G = a, w = h, s = c, t = s.parentNode, x = s.nextSibling, F = j.group, d = function() {
        f._disableDelayedDrag(), s.draggable = !0, g(s, f.options.chosenClass, !0), f._triggerDragStart(b)
      }, j.ignore.split(",").forEach(function(a) {
        i(s, a.trim(), l)
      }), e(k, "mouseup", f._onDrop), e(k, "touchend", f._onDrop), e(k, "touchcancel", f._onDrop), j.delay ? (e(k, "mouseup", f._disableDelayedDrag), e(k, "touchend", f._disableDelayedDrag), e(k, "touchcancel", f._disableDelayedDrag), e(k, "mousemove", f._disableDelayedDrag), e(k, "touchmove", f._disableDelayedDrag), f._dragStartTimer = setTimeout(d, j.delay)) : d())
    },
    _disableDelayedDrag: function() {
      var a = this.el.ownerDocument;
      clearTimeout(this._dragStartTimer), f(a, "mouseup", this._disableDelayedDrag), f(a, "touchend", this._disableDelayedDrag), f(a, "touchcancel", this._disableDelayedDrag), f(a, "mousemove", this._disableDelayedDrag), f(a, "touchmove", this._disableDelayedDrag)
    },
    _triggerDragStart: function(a) {
      a ? (G = {
        target: s,
        clientX: a.clientX,
        clientY: a.clientY
      }, this._onDragStart(G, "touch")) : this.nativeDraggable ? (e(s, "dragend", this), e(w, "dragstart", this._onDragStart)) : this._onDragStart(G, !0);
      try {
        N.selection ? N.selection.empty() : window.getSelection().removeAllRanges()
      } catch (b) {}
    },
    _dragStarted: function() {
      w &amp;&amp; s &amp;&amp; (g(s, this.options.ghostClass, !0), a.active = this, j(this, w, "start", s, w, D))
    },
    _emulateDragOver: function() {
      if (H) {
        if (this._lastX === H.clientX &amp;&amp; this._lastY === H.clientY) return;
        this._lastX = H.clientX, this._lastY = H.clientY, Q || h(u, "display", "none");
        var a = N.elementFromPoint(H.clientX, H.clientY),
          b = a,
          c = " " + this.options.group.name,
          d = T.length;
        if (b)
          do {
            if (b[L] &amp;&amp; b[L].options.groups.indexOf(c) &gt; -1) {
              for (; d--;) T[d]({
                clientX: H.clientX,
                clientY: H.clientY,
                target: a,
                rootEl: b
              });
              break
            }
            a = b
          } while (b = b.parentNode);
        Q || h(u, "display", "")
      }
    },
    _onTouchMove: function(b) {
      if (G) {
        a.active || this._dragStarted(), this._appendGhost();
        var c = b.touches ? b.touches[0] : b,
          d = c.clientX - G.clientX,
          e = c.clientY - G.clientY,
          f = b.touches ? "translate3d(" + d + "px," + e + "px,0)" : "translate(" + d + "px," + e + "px)";
        I = !0, H = c, h(u, "webkitTransform", f), h(u, "mozTransform", f), h(u, "msTransform", f), h(u, "transform", f), b.preventDefault()
      }
    },
    _appendGhost: function() {
      if (!u) {
        var a, b = s.getBoundingClientRect(),
          c = h(s),
          d = this.options;
        u = s.cloneNode(!0), g(u, d.ghostClass, !1), g(u, d.fallbackClass, !0), h(u, "top", b.top - O(c.marginTop, 10)), h(u, "left", b.left - O(c.marginLeft, 10)), h(u, "width", b.width), h(u, "height", b.height), h(u, "opacity", "0.8"), h(u, "position", "fixed"), h(u, "zIndex", "100000"), h(u, "pointerEvents", "none"), d.fallbackOnBody &amp;&amp; N.body.appendChild(u) || w.appendChild(u), a = u.getBoundingClientRect(), h(u, "width", 2 * b.width - a.width), h(u, "height", 2 * b.height - a.height)
      }
    },
    _onDragStart: function(a, b) {
      var c = a.dataTransfer,
        d = this.options;
      this._offUpEvents(), "clone" == F.pull &amp;&amp; (v = s.cloneNode(!0), h(v, "display", "none"), w.insertBefore(v, s)), b ? ("touch" === b ? (e(N, "touchmove", this._onTouchMove), e(N, "touchend", this._onDrop), e(N, "touchcancel", this._onDrop)) : (e(N, "mousemove", this._onTouchMove), e(N, "mouseup", this._onDrop)), this._loopId = setInterval(this._emulateDragOver, 50)) : (c &amp;&amp; (c.effectAllowed = "move", d.setData &amp;&amp; d.setData.call(this, c, s)), e(N, "drop", this), setTimeout(this._dragStarted, 0))
    },
    _onDragOver: function(a) {
      var d, e, f, g = this.el,
        i = this.options,
        j = i.group,
        l = j.put,
        o = F === j,
        p = i.sort;
      if (void 0 !== a.preventDefault &amp;&amp; (a.preventDefault(), !i.dragoverBubble &amp;&amp; a.stopPropagation()), I = !0, F &amp;&amp; !i.disabled &amp;&amp; (o ? p || (f = !w.contains(s)) : F.pull &amp;&amp; l &amp;&amp; (F.name === j.name || l.indexOf &amp;&amp; ~l.indexOf(F.name))) &amp;&amp; (void 0 === a.rootEl || a.rootEl === this.el)) {
        if (U(a, i, this.el), R) return;
        if (d = c(a.target, i.draggable, g), e = s.getBoundingClientRect(), f) return b(!0), void(v || x ? w.insertBefore(s, v || x) : p || w.appendChild(s));
        if (0 === g.children.length || g.children[0] === u || g === a.target &amp;&amp; (d = n(g, a))) {
          if (d) {
            if (d.animated) return;
            r = d.getBoundingClientRect()
          }
          b(o), k(w, g, s, e, d, r) !== !1 &amp;&amp; (s.contains(g) || (g.appendChild(s), t = g), this._animate(e, s), d &amp;&amp; this._animate(r, d))
        } else if (d &amp;&amp; !d.animated &amp;&amp; d !== s &amp;&amp; void 0 !== d.parentNode[L]) {
          A !== d &amp;&amp; (A = d, B = h(d), C = h(d.parentNode));
          var q, r = d.getBoundingClientRect(),
            y = r.right - r.left,
            z = r.bottom - r.top,
            D = /left|right|inline/.test(B.cssFloat + B.display) || "flex" == C.display &amp;&amp; 0 === C["flex-direction"].indexOf("row"),
            E = d.offsetWidth &gt; s.offsetWidth,
            G = d.offsetHeight &gt; s.offsetHeight,
            H = (D ? (a.clientX - r.left) / y : (a.clientY - r.top) / z) &gt; .5,
            J = d.nextElementSibling,
            K = k(w, g, s, e, d, r);
          if (K !== !1) {
            if (R = !0, setTimeout(m, 30), b(o), 1 === K || -1 === K) q = 1 === K;
            else if (D) {
              var M = s.offsetTop,
                N = d.offsetTop;
              q = M === N ? d.previousElementSibling === s &amp;&amp; !E || H &amp;&amp; E : N &gt; M
            } else q = J !== s &amp;&amp; !G || H &amp;&amp; G;
            s.contains(g) || (q &amp;&amp; !J ? g.appendChild(s) : d.parentNode.insertBefore(s, q ? J : d)), t = s.parentNode, this._animate(e, s), this._animate(r, d)
          }
        }
      }
    },
    _animate: function(a, b) {
      var c = this.options.animation;
      if (c) {
        var d = b.getBoundingClientRect();
        h(b, "transition", "none"), h(b, "transform", "translate3d(" + (a.left - d.left) + "px," + (a.top - d.top) + "px,0)"), b.offsetWidth, h(b, "transition", "all " + c + "ms"), h(b, "transform", "translate3d(0,0,0)"), clearTimeout(b.animated), b.animated = setTimeout(function() {
          h(b, "transition", ""), h(b, "transform", ""), b.animated = !1
        }, c)
      }
    },
    _offUpEvents: function() {
      var a = this.el.ownerDocument;
      f(N, "touchmove", this._onTouchMove), f(a, "mouseup", this._onDrop), f(a, "touchend", this._onDrop), f(a, "touchcancel", this._onDrop)
    },
    _onDrop: function(b) {
      var c = this.el,
        d = this.options;
      clearInterval(this._loopId), clearInterval(J.pid), clearTimeout(this._dragStartTimer), f(N, "mousemove", this._onTouchMove), this.nativeDraggable &amp;&amp; (f(N, "drop", this), f(c, "dragstart", this._onDragStart)), this._offUpEvents(), b &amp;&amp; (I &amp;&amp; (b.preventDefault(), !d.dropBubble &amp;&amp; b.stopPropagation()), u &amp;&amp; u.parentNode.removeChild(u), s &amp;&amp; (this.nativeDraggable &amp;&amp; f(s, "dragend", this), l(s), g(s, this.options.ghostClass, !1), g(s, this.options.chosenClass, !1), w !== t ? (E = p(s), E &gt;= 0 &amp;&amp; (j(null, t, "sort", s, w, D, E), j(this, w, "sort", s, w, D, E), j(null, t, "add", s, w, D, E), j(this, w, "remove", s, w, D, E))) : (v &amp;&amp; v.parentNode.removeChild(v), s.nextSibling !== x &amp;&amp; (E = p(s), E &gt;= 0 &amp;&amp; (j(this, w, "update", s, w, D, E), j(this, w, "sort", s, w, D, E)))), a.active &amp;&amp; ((null === E || -1 === E) &amp;&amp; (E = D), j(this, w, "end", s, w, D, E), this.save())), w = s = t = u = x = v = y = z = G = H = I = E = A = B = F = a.active = null)
    },
    handleEvent: function(a) {
      var b = a.type;
      "dragover" === b || "dragenter" === b ? s &amp;&amp; (this._onDragOver(a), d(a)) : ("drop" === b || "dragend" === b) &amp;&amp; this._onDrop(a)
    },
    toArray: function() {
      for (var a, b = [], d = this.el.children, e = 0, f = d.length, g = this.options; f &gt; e; e++) a = d[e], c(a, g.draggable, this.el) &amp;&amp; b.push(a.getAttribute(g.dataIdAttr) || o(a));
      return b
    },
    sort: function(a) {
      var b = {},
        d = this.el;
      this.toArray().forEach(function(a, e) {
        var f = d.children[e];
        c(f, this.options.draggable, d) &amp;&amp; (b[a] = f)
      }, this), a.forEach(function(a) {
        b[a] &amp;&amp; (d.removeChild(b[a]), d.appendChild(b[a]))
      })
    },
    save: function() {
      var a = this.options.store;
      a &amp;&amp; a.set(this)
    },
    closest: function(a, b) {
      return c(a, b || this.options.draggable, this.el)
    },
    option: function(a, b) {
      var c = this.options;
      return void 0 === b ? c[a] : (c[a] = b, void("group" === a &amp;&amp; V(c)))
    },
    destroy: function() {
      var a = this.el;
      a[L] = null, f(a, "mousedown", this._onTapStart), f(a, "touchstart", this._onTapStart), this.nativeDraggable &amp;&amp; (f(a, "dragover", this), f(a, "dragenter", this)), Array.prototype.forEach.call(a.querySelectorAll("[draggable]"), function(a) {
        a.removeAttribute("draggable")
      }), T.splice(T.indexOf(this._onDragOver), 1), this._onDrop(), this.el = a = null
    }
  }, a.utils = {
    on: e,
    off: f,
    css: h,
    find: i,
    is: function(a, b) {
      return !!c(a, b, a)
    },
    extend: r,
    throttle: q,
    closest: c,
    toggleClass: g,
    index: p
  }, a.create = function(b, c) {
    return new a(b, c)
  }, a.version = "1.4.2", a
});
/*! RESOURCE: /scripts/libs/lodash.min.js */
/**
 * @license
 * lodash 4.11.0 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash -o ./dist/lodash.js`
 */
;
(function() {
  function t(t, n) {
    return t.set(n[0], n[1]), t
  }

  function n(t, n) {
    return t.add(n), t
  }

  function r(t, n, r) {
    switch (r.length) {
      case 0:
        return t.call(n);
      case 1:
        return t.call(n, r[0]);
      case 2:
        return t.call(n, r[0], r[1]);
      case 3:
        return t.call(n, r[0], r[1], r[2])
    }
    return t.apply(n, r)
  }

  function e(t, n, r, e) {
    for (var u = -1, o = t.length; ++u &lt; o;) {
      var i = t[u];
      n(e, i, r(i), t)
    }
    return e
  }

  function u(t, n) {
    for (var r = -1, e = t.length; ++r &lt; e &amp;&amp; false !== n(t[r], r, t););
    return t
  }

  function o(t, n) {
    for (var r = -1, e = t.length; ++r &lt; e;)
      if (!n(t[r], r, t)) return false;
    return true
  }

  function i(t, n) {
    for (var r = -1, e = t.length, u = 0, o = []; ++r &lt; e;) {
      var i = t[r];
      n(i, r, t) &amp;&amp; (o[u++] = i)
    }
    return o
  }

  function f(t, n) {
    return !!t.length &amp;&amp; -1 &lt; d(t, n, 0)
  }

  function c(t, n, r) {
    for (var e = -1, u = t.length; ++e &lt; u;)
      if (r(n, t[e])) return true;
    return false
  }

  function a(t, n) {
    for (var r = -1, e = t.length, u = Array(e); ++r &lt; e;) u[r] = n(t[r], r, t);
    return u
  }

  function l(t, n) {
    for (var r = -1, e = n.length, u = t.length; ++r &lt; e;) t[u + r] = n[r];
    return t
  }

  function s(t, n, r, e) {
    var u = -1,
      o = t.length;
    for (e &amp;&amp; o &amp;&amp; (r = t[++u]); ++u &lt; o;) r = n(r, t[u], u, t);
    return r
  }

  function h(t, n, r, e) {
    var u = t.length;
    for (e &amp;&amp; u &amp;&amp; (r = t[--u]); u--;) r = n(r, t[u], u, t);
    return r
  }

  function p(t, n) {
    for (var r = -1, e = t.length; ++r &lt; e;)
      if (n(t[r], r, t)) return true;
    return false
  }

  function _(t, n, r) {
    for (var e = -1, u = t.length; ++e &lt; u;) {
      var o = t[e],
        i = n(o);
      if (null != i &amp;&amp; (f === q ? i === i : r(i, f))) var f = i,
        c = o
    }
    return c
  }

  function v(t, n, r, e) {
    var u;
    return r(t, function(t, r, o) {
      return n(t, r, o) ? (u = e ? r : t, false) : void 0
    }), u
  }

  function g(t, n, r) {
    for (var e = t.length, u = r ? e : -1; r ? u-- : ++u &lt; e;)
      if (n(t[u], u, t)) return u;
    return -1
  }

  function d(t, n, r) {
    if (n !== n) return M(t, r);
    --r;
    for (var e = t.length; ++r &lt; e;)
      if (t[r] === n) return r;
    return -1
  }

  function y(t, n, r, e) {
    --r;
    for (var u = t.length; ++r &lt; u;)
      if (e(t[r], n)) return r;
    return -1
  }

  function b(t, n) {
    var r = t ? t.length : 0;
    return r ? m(t, n) / r : K
  }

  function x(t, n, r, e, u) {
    return u(t, function(t, u, o) {
      r = e ? (e = false, t) : n(r, t, u, o)
    }), r
  }

  function j(t, n) {
    var r = t.length;
    for (t.sort(n); r--;) t[r] = t[r].c;
    return t
  }

  function m(t, n) {
    for (var r, e = -1, u = t.length; ++e &lt; u;) {
      var o = n(t[e]);
      o !== q &amp;&amp; (r = r === q ? o : r + o)
    }
    return r
  }

  function w(t, n) {
    for (var r = -1, e = Array(t); ++r &lt; t;) e[r] = n(r);
    return e
  }

  function A(t, n) {
    return a(n, function(n) {
      return [n, t[n]];
    })
  }

  function O(t) {
    return function(n) {
      return t(n)
    }
  }

  function k(t, n) {
    return a(n, function(n) {
      return t[n]
    })
  }

  function E(t, n) {
    for (var r = -1, e = t.length; ++r &lt; e &amp;&amp; -1 &lt; d(n, t[r], 0););
    return r
  }

  function I(t, n) {
    for (var r = t.length; r-- &amp;&amp; -1 &lt; d(n, t[r], 0););
    return r
  }

  function S(t) {
    return t &amp;&amp; t.Object === Object ? t : null
  }

  function R(t, n) {
    if (t !== n) {
      var r = null === t,
        e = t === q,
        u = t === t,
        o = null === n,
        i = n === q,
        f = n === n;
      if (t &gt; n &amp;&amp; !o || !u || r &amp;&amp; !i &amp;&amp; f || e &amp;&amp; f) return 1;
      if (n &gt; t &amp;&amp; !r || !f || o &amp;&amp; !e &amp;&amp; u || i &amp;&amp; u) return -1
    }
    return 0
  }

  function W(t) {
    return function(n, r) {
      var e;
      return n === q &amp;&amp; r === q ? 0 : (n !== q &amp;&amp; (e = n), r !== q &amp;&amp; (e = e === q ? r : t(e, r)), e)
    }
  }

  function B(t) {
    return Ut[t]
  }

  function L(t) {
    return Dt[t]
  }

  function C(t) {
    return "\\" + Nt[t]
  }

  function M(t, n, r) {
    var e = t.length;
    for (n += r ? 0 : -1; r ? n-- : ++n &lt; e;) {
      var u = t[n];
      if (u !== u) return n
    }
    return -1
  }

  function z(t) {
    var n = false;
    if (null != t &amp;&amp; typeof t.toString != "function") try {
      n = !!(t + "")
    } catch (r) {}
    return n
  }

  function U(t, n) {
    return t = typeof t == "number" || jt.test(t) ? +t : -1, t &gt; -1 &amp;&amp; 0 == t % 1 &amp;&amp; (null == n ? 9007199254740991 : n) &gt; t
  }

  function D(t) {
    for (var n, r = []; !(n = t.next()).done;) r.push(n.value);
    return r
  }

  function $(t) {
    var n = -1,
      r = Array(t.size);
    return t.forEach(function(t, e) {
      r[++n] = [e, t]
    }), r
  }

  function F(t, n) {
    for (var r = -1, e = t.length, u = 0, o = []; ++r &lt; e;) {
      var i = t[r];
      i !== n &amp;&amp; "__lodash_placeholder__" !== i || (t[r] = "__lodash_placeholder__", o[u++] = r)
    }
    return o
  }

  function N(t) {
    var n = -1,
      r = Array(t.size);
    return t.forEach(function(t) {
      r[++n] = t
    }), r
  }

  function P(t) {
    if (!t || !Bt.test(t)) return t.length;
    for (var n = Rt.lastIndex = 0; Rt.test(t);) n++;
    return n
  }

  function Z(t) {
    return $t[t]
  }

  function T(S) {
    function jt(t) {
      if (Le(t) &amp;&amp; !oi(t) &amp;&amp; !(t instanceof Et)) {
        if (t instanceof kt) return t;
        if (xu.call(t, "__wrapped__")) return Xr(t)
      }
      return new kt(t)
    }

    function Ot() {}

    function kt(t, n) {
      this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!n, this.__index__ = 0, this.__values__ = q
    }

    function Et(t) {
      this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = []
    }

    function Ut() {}

    function Dt(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.clear(); ++n &lt; r;) {
        var e = t[n];
        this.set(e[0], e[1])
      }
    }

    function $t(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.__data__ = new Dt; ++n &lt; r;) this.push(t[n])
    }

    function Ft(t, n) {
      var r = t.__data__;
      return qr(n) ? (r = r.__data__, "__lodash_hash_undefined__" === (typeof n == "string" ? r.string : r.hash)[n]) : r.has(n)
    }

    function Nt(t) {
      var n = -1,
        r = t ? t.length : 0;
      for (this.clear(); ++n &lt; r;) {
        var e = t[n];
        this.set(e[0], e[1])
      }
    }

    function Tt(t, n) {
      var r = Kt(t, n);
      return 0 &gt; r ? false : (r == t.length - 1 ? t.pop() : Uu.call(t, r, 1), true)
    }

    function qt(t, n) {
      var r = Kt(t, n);
      return 0 &gt; r ? q : t[r][1]
    }

    function Kt(t, n) {
      for (var r = t.length; r--;)
        if (we(t[r][0], n)) return r;
      return -1
    }

    function Gt(t, n, r) {
      var e = Kt(t, n);
      0 &gt; e ? t.push([n, r]) : t[e][1] = r
    }

    function Jt(t, n, r, e) {
      return t === q || we(t, du[r]) &amp;&amp; !xu.call(e, r) ? n : t
    }

    function Qt(t, n, r) {
      (r === q || we(t[n], r)) &amp;&amp; (typeof n != "number" || r !== q || n in t) || (t[n] = r)
    }

    function Xt(t, n, r) {
      var e = t[n];
      xu.call(t, n) &amp;&amp; we(e, r) &amp;&amp; (r !== q || n in t) || (t[n] = r)
    }

    function tn(t, n, r, e) {
      return _o(t, function(t, u, o) {
        n(e, t, r(t), o)
      }), e
    }

    function nn(t, n) {
      return t &amp;&amp; ir(n, He(n), t)
    }

    function rn(t, n) {
      for (var r = -1, e = null == t, u = n.length, o = Array(u); ++r &lt; u;) o[r] = e ? q : Ge(t, n[r]);
      return o
    }

    function en(t, n, r) {
      return t === t &amp;&amp; (r !== q &amp;&amp; (t = t &gt; r ? r : t),
        n !== q &amp;&amp; (t = n &gt; t ? n : t)), t
    }

    function un(t, n, r, e, o, i, f) {
      var c;
      if (e &amp;&amp; (c = i ? e(t, o, i, f) : e(t)), c !== q) return c;
      if (!Be(t)) return t;
      if (o = oi(t)) {
        if (c = Ur(t), !n) return or(t, c)
      } else {
        var a = Mr(t),
          l = "[object Function]" == a || "[object GeneratorFunction]" == a;
        if (ii(t)) return nr(t, n);
        if ("[object Object]" == a || "[object Arguments]" == a || l &amp;&amp; !i) {
          if (z(t)) return i ? t : {};
          if (c = Dr(l ? {} : t), !n) return fr(t, nn(c, t))
        } else {
          if (!zt[a]) return i ? t : {};
          c = $r(t, a, un, n)
        }
      }
      if (f || (f = new Nt), i = f.get(t)) return i;
      if (f.set(t, c), !o) var s = r ? dn(t, He, Cr) : He(t);
      return u(s || t, function(u, o) {
        s &amp;&amp; (o = u, u = t[o]), Xt(c, o, un(u, n, r, e, o, t, f))
      }), c
    }

    function on(t) {
      var n = He(t),
        r = n.length;
      return function(e) {
        if (null == e) return !r;
        for (var u = r; u--;) {
          var o = n[u],
            i = t[o],
            f = e[o];
          if (f === q &amp;&amp; !(o in Object(e)) || !i(f)) return false
        }
        return true
      }
    }

    function fn(t) {
      return Be(t) ? Cu(t) : {}
    }

    function cn(t, n, r) {
      if (typeof t != "function") throw new vu("Expected a function");
      return zu(function() {
        t.apply(q, r)
      }, n)
    }

    function an(t, n, r, e) {
      var u = -1,
        o = f,
        i = true,
        l = t.length,
        s = [],
        h = n.length;
      if (!l) return s;
      r &amp;&amp; (n = a(n, O(r))), e ? (o = c, i = false) : n.length &gt;= 200 &amp;&amp; (o = Ft,
        i = false, n = new $t(n));
      t: for (; ++u &lt; l;) {
        var p = t[u],
          _ = r ? r(p) : p;
        if (i &amp;&amp; _ === _) {
          for (var v = h; v--;)
            if (n[v] === _) continue t;
          s.push(p)
        } else o(n, _, e) || s.push(p)
      }
      return s
    }

    function ln(t, n) {
      var r = true;
      return _o(t, function(t, e, u) {
        return r = !!n(t, e, u)
      }), r
    }

    function sn(t, n) {
      var r = [];
      return _o(t, function(t, e, u) {
        n(t, e, u) &amp;&amp; r.push(t)
      }), r
    }

    function hn(t, n, r, e, u) {
      var o = -1,
        i = t.length;
      for (r || (r = Nr), u || (u = []); ++o &lt; i;) {
        var f = t[o];
        n &gt; 0 &amp;&amp; r(f) ? n &gt; 1 ? hn(f, n - 1, r, e, u) : l(u, f) : e || (u[u.length] = f)
      }
      return u
    }

    function pn(t, n) {
      return t &amp;&amp; go(t, n, He)
    }

    function _n(t, n) {
      return t &amp;&amp; yo(t, n, He)
    }

    function vn(t, n) {
      return i(n, function(n) {
        return Se(t[n])
      })
    }

    function gn(t, n) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var r = 0, e = n.length; null != t &amp;&amp; e &gt; r;) t = t[n[r++]];
      return r &amp;&amp; r == e ? t : q
    }

    function dn(t, n, r) {
      return n = n(t), oi(t) ? n : l(n, r(t))
    }

    function yn(t, n) {
      return xu.call(t, n) || typeof t == "object" &amp;&amp; n in t &amp;&amp; null === Fu(Object(t))
    }

    function bn(t, n) {
      return n in Object(t)
    }

    function xn(t, n, r) {
      for (var e = r ? c : f, u = t[0].length, o = t.length, i = o, l = Array(o), s = 1 / 0, h = []; i--;) {
        var p = t[i];
        i &amp;&amp; n &amp;&amp; (p = a(p, O(n))), s = qu(p.length, s),
          l[i] = r || !n &amp;&amp; (120 &gt; u || 120 &gt; p.length) ? q : new $t(i &amp;&amp; p)
      }
      var p = t[0],
        _ = -1,
        v = l[0];
      t: for (; ++_ &lt; u &amp;&amp; s &gt; h.length;) {
        var g = p[_],
          d = n ? n(g) : g;
        if (v ? !Ft(v, d) : !e(h, d, r)) {
          for (i = o; --i;) {
            var y = l[i];
            if (y ? !Ft(y, d) : !e(t[i], d, r)) continue t
          }
          v &amp;&amp; v.push(d), h.push(g)
        }
      }
      return h
    }

    function jn(t, n, r) {
      var e = {};
      return pn(t, function(t, u, o) {
        n(e, r(t), u, o)
      }), e
    }

    function mn(t, n, e) {
      return Tr(n, t) || (n = Xn(n), t = Yr(t, n), n = ee(n)), n = null == t ? t : t[n], null == n ? q : r(n, t, e)
    }

    function wn(t, n, r, e, u) {
      if (t === n) n = true;
      else if (null == t || null == n || !Be(t) &amp;&amp; !Le(n)) n = t !== t &amp;&amp; n !== n;
      else t: {
        var o = oi(t),
          i = oi(n),
          f = "[object Array]",
          c = "[object Array]";o || (f = Mr(t), f = "[object Arguments]" == f ? "[object Object]" : f),
        i || (c = Mr(n), c = "[object Arguments]" == c ? "[object Object]" : c);
        var a = "[object Object]" == f &amp;&amp; !z(t),
          i = "[object Object]" == c &amp;&amp; !z(n);
        if ((c = f == c) &amp;&amp; !a) u || (u = new Nt),
        n = o || Fe(t) ? Er(t, n, wn, r, e, u) : Ir(t, n, f, wn, r, e, u);
        else {
          if (!(2 &amp; e) &amp;&amp; (o = a &amp;&amp; xu.call(t, "__wrapped__"), f = i &amp;&amp; xu.call(n, "__wrapped__"), o || f)) {
            t = o ? t.value() : t, n = f ? n.value() : n, u || (u = new Nt), n = wn(t, n, r, e, u);
            break t
          }
          if (c) n: if (u || (u = new Nt), o = 2 &amp; e,
            f = He(t), i = f.length, c = He(n).length, i == c || o) {
            for (a = i; a--;) {
              var l = f[a];
              if (!(o ? l in n : yn(n, l))) {
                n = false;
                break n
              }
            }
            if (c = u.get(t)) n = c == n;
            else {
              c = true, u.set(t, n);
              for (var s = o; ++a &lt; i;) {
                var l = f[a],
                  h = t[l],
                  p = n[l];
                if (r) var _ = o ? r(p, h, l, n, t, u) : r(h, p, l, t, n, u);
                if (_ === q ? h !== p &amp;&amp; !wn(h, p, r, e, u) : !_) {
                  c = false;
                  break
                }
                s || (s = "constructor" == l)
              }
              c &amp;&amp; !s &amp;&amp; (r = t.constructor, e = n.constructor, r != e &amp;&amp; "constructor" in t &amp;&amp; "constructor" in n &amp;&amp; !(typeof r == "function" &amp;&amp; r instanceof r &amp;&amp; typeof e == "function" &amp;&amp; e instanceof e) &amp;&amp; (c = false)), u["delete"](t), n = c
            }
          } else n = false;
          else n = false;
        }
      }
      return n
    }

    function An(t, n, r, e) {
      var u = r.length,
        o = u,
        i = !e;
      if (null == t) return !o;
      for (t = Object(t); u--;) {
        var f = r[u];
        if (i &amp;&amp; f[2] ? f[1] !== t[f[0]] : !(f[0] in t)) return false
      }
      for (; ++u &lt; o;) {
        var f = r[u],
          c = f[0],
          a = t[c],
          l = f[1];
        if (i &amp;&amp; f[2]) {
          if (a === q &amp;&amp; !(c in t)) return false
        } else {
          if (f = new Nt, e) var s = e(a, l, c, t, n, f);
          if (s === q ? !wn(l, a, e, 3, f) : !s) return false
        }
      }
      return true
    }

    function On(t) {
      return typeof t == "function" ? t : null == t ? iu : typeof t == "object" ? oi(t) ? Sn(t[0], t[1]) : In(t) : lu(t)
    }

    function kn(t) {
      t = null == t ? t : Object(t);
      var n, r = [];
      for (n in t) r.push(n);
      return r
    }

    function En(t, n) {
      var r = -1,
        e = ke(t) ? Array(t.length) : [];
      return _o(t, function(t, u, o) {
        e[++r] = n(t, u, o)
      }), e
    }

    function In(t) {
      var n = Wr(t);
      return 1 == n.length &amp;&amp; n[0][2] ? Gr(n[0][0], n[0][1]) : function(r) {
        return r === t || An(r, t, n)
      }
    }

    function Sn(t, n) {
      return Tr(t) &amp;&amp; n === n &amp;&amp; !Be(n) ? Gr(t, n) : function(r) {
        var e = Ge(r, t);
        return e === q &amp;&amp; e === n ? Ye(r, t) : wn(n, e, q, 3)
      }
    }

    function Rn(t, n, r, e, o) {
      if (t !== n) {
        if (!oi(n) &amp;&amp; !Fe(n)) var i = Qe(n);
        u(i || n, function(u, f) {
          if (i &amp;&amp; (f = u, u = n[f]), Be(u)) {
            o || (o = new Nt);
            var c = f,
              a = o,
              l = t[c],
              s = n[c],
              h = a.get(s);
            if (h) Qt(t, c, h);
            else {
              var h = e ? e(l, s, c + "", t, n, a) : q,
                p = h === q;
              p &amp;&amp; (h = s, oi(s) || Fe(s) ? oi(l) ? h = l : Ee(l) ? h = or(l) : (p = false, h = un(s, true)) : ze(s) || Oe(s) ? Oe(l) ? h = Ve(l) : !Be(l) || r &amp;&amp; Se(l) ? (p = false, h = un(s, true)) : h = l : p = false), a.set(s, h), p &amp;&amp; Rn(h, s, r, e, a), a["delete"](s), Qt(t, c, h)
            }
          } else c = e ? e(t[f], u, f + "", t, n, o) : q, c === q &amp;&amp; (c = u), Qt(t, f, c)
        })
      }
    }

    function Wn(t, n) {
      var r = t.length;
      return r ? (n += 0 &gt; n ? r : 0, U(n, r) ? t[n] : q) : void 0
    }

    function Bn(t, n, r) {
      var e = -1;
      return n = a(n.length ? n : [iu], O(Rr())), t = En(t, function(t) {
        return {
          a: a(n, function(n) {
            return n(t)
          }),
          b: ++e,
          c: t
        }
      }), j(t, function(t, n) {
        var e;
        t: {
          e = -1;
          for (var u = t.a, o = n.a, i = u.length, f = r.length; ++e &lt; i;) {
            var c = R(u[e], o[e]);
            if (c) {
              e = f &gt; e ? c * ("desc" == r[e] ? -1 : 1) : c;
              break t
            }
          }
          e = t.b - n.b
        }
        return e
      })
    }

    function Ln(t, n) {
      return t = Object(t), s(n, function(n, r) {
        return r in t &amp;&amp; (n[r] = t[r]), n
      }, {})
    }

    function Cn(t, n) {
      for (var r = -1, e = dn(t, Qe, wo), u = e.length, o = {}; ++r &lt; u;) {
        var i = e[r],
          f = t[i];
        n(f, i) &amp;&amp; (o[i] = f)
      }
      return o
    }

    function Mn(t) {
      return function(n) {
        return null == n ? q : n[t]
      }
    }

    function zn(t) {
      return function(n) {
        return gn(n, t)
      }
    }

    function Un(t, n, r, e) {
      var u = e ? y : d,
        o = -1,
        i = n.length,
        f = t;
      for (r &amp;&amp; (f = a(t, O(r))); ++o &lt; i;)
        for (var c = 0, l = n[o], l = r ? r(l) : l; - 1 &lt; (c = u(f, l, c, e));) f !== t &amp;&amp; Uu.call(f, c, 1), Uu.call(t, c, 1);
      return t
    }

    function Dn(t, n) {
      for (var r = t ? n.length : 0, e = r - 1; r--;) {
        var u = n[r];
        if (e == r || u != o) {
          var o = u;
          if (U(u)) Uu.call(t, u, 1);
          else if (Tr(u, t)) delete t[u];
          else {
            var u = Xn(u),
              i = Yr(t, u);
            null != i &amp;&amp; delete i[ee(u)]
          }
        }
      }
    }

    function $n(t, n) {
      return t + $u(Ku() * (n - t + 1))
    }

    function Fn(t, n) {
      var r = "";
      if (!t || 1 &gt; n || n &gt; 9007199254740991) return r;
      do n % 2 &amp;&amp; (r += t), (n = $u(n / 2)) &amp;&amp; (t += t); while (n);
      return r;
    }

    function Nn(t, n, r, e) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var u = -1, o = n.length, i = o - 1, f = t; null != f &amp;&amp; ++u &lt; o;) {
        var c = n[u];
        if (Be(f)) {
          var a = r;
          if (u != i) {
            var l = f[c],
              a = e ? e(l, c, f) : q;
            a === q &amp;&amp; (a = null == l ? U(n[u + 1]) ? [] : {} : l)
          }
          Xt(f, c, a)
        }
        f = f[c]
      }
      return t
    }

    function Pn(t, n, r) {
      var e = -1,
        u = t.length;
      for (0 &gt; n &amp;&amp; (n = -n &gt; u ? 0 : u + n), r = r &gt; u ? u : r, 0 &gt; r &amp;&amp; (r += u), u = n &gt; r ? 0 : r - n &gt;&gt;&gt; 0, n &gt;&gt;&gt;= 0, r = Array(u); ++e &lt; u;) r[e] = t[e + n];
      return r
    }

    function Zn(t, n) {
      var r;
      return _o(t, function(t, e, u) {
        return r = n(t, e, u), !r
      }), !!r
    }

    function Tn(t, n, r) {
      var e = 0,
        u = t ? t.length : e;
      if (typeof n == "number" &amp;&amp; n === n &amp;&amp; 2147483647 &gt;= u) {
        for (; u &gt; e;) {
          var o = e + u &gt;&gt;&gt; 1,
            i = t[o];
          (r ? n &gt;= i : n &gt; i) &amp;&amp; null !== i ? e = o + 1 : u = o
        }
        return u
      }
      return qn(t, n, iu, r)
    }

    function qn(t, n, r, e) {
      n = r(n);
      for (var u = 0, o = t ? t.length : 0, i = n !== n, f = null === n, c = n === q; o &gt; u;) {
        var a = $u((u + o) / 2),
          l = r(t[a]),
          s = l !== q,
          h = l === l;
        (i ? h || e : f ? h &amp;&amp; s &amp;&amp; (e || null != l) : c ? h &amp;&amp; (e || s) : null == l ? 0 : e ? n &gt;= l : n &gt; l) ? u = a + 1: o = a
      }
      return qu(o, 4294967294)
    }

    function Vn(t, n) {
      for (var r = 0, e = t.length, u = t[0], o = n ? n(u) : u, i = o, f = 1, c = [u]; ++r &lt; e;) u = t[r], o = n ? n(u) : u, we(o, i) || (i = o, c[f++] = u);
      return c
    }

    function Kn(t, n, r) {
      var e = -1,
        u = f,
        o = t.length,
        i = true,
        a = [],
        l = a;
      if (r) i = false, u = c;
      else if (o &lt; 200) l = n ? [] : a;
      else {
        if (u = n ? null : xo(t)) return N(u);
        i = false, u = Ft, l = new $t
      }
      t: for (; ++e &lt; o;) {
        var s = t[e],
          h = n ? n(s) : s;
        if (i &amp;&amp; h === h) {
          for (var p = l.length; p--;)
            if (l[p] === h) continue t;
          n &amp;&amp; l.push(h), a.push(s)
        } else u(l, h, r) || (l !== a &amp;&amp; l.push(h), a.push(s))
      }
      return a
    }

    function Gn(t, n, r, e) {
      for (var u = t.length, o = e ? u : -1;
        (e ? o-- : ++o &lt; u) &amp;&amp; n(t[o], o, t););
      return r ? Pn(t, e ? 0 : o, e ? o + 1 : u) : Pn(t, e ? o + 1 : 0, e ? u : o)
    }

    function Jn(t, n) {
      var r = t;
      return r instanceof Et &amp;&amp; (r = r.value()), s(n, function(t, n) {
        return n.func.apply(n.thisArg, l([t], n.args));
      }, r)
    }

    function Yn(t, n, r) {
      for (var e = -1, u = t.length; ++e &lt; u;) var o = o ? l(an(o, t[e], n, r), an(t[e], o, n, r)) : t[e];
      return o &amp;&amp; o.length ? Kn(o, n, r) : []
    }

    function Hn(t, n, r) {
      for (var e = -1, u = t.length, o = n.length, i = {}; ++e &lt; u;) r(i, t[e], o &gt; e ? n[e] : q);
      return i
    }

    function Qn(t) {
      return Ee(t) ? t : []
    }

    function Xn(t) {
      return oi(t) ? t : Oo(t)
    }

    function tr(t, n, r) {
      var e = t.length;
      return r = r === q ? e : r, n || e &gt; r ? Pn(t, n, r) : t
    }

    function nr(t, n) {
      if (n) return t.slice();
      var r = new t.constructor(t.length);
      return t.copy(r), r
    }

    function rr(t) {
      var n = new t.constructor(t.byteLength);
      return new Su(n).set(new Su(t)), n
    }

    function er(t, n, r, e) {
      var u = -1,
        o = t.length,
        i = r.length,
        f = -1,
        c = n.length,
        a = Tu(o - i, 0),
        l = Array(c + a);
      for (e = !e; ++f &lt; c;) l[f] = n[f];
      for (; ++u &lt; i;)(e || o &gt; u) &amp;&amp; (l[r[u]] = t[u]);
      for (; a--;) l[f++] = t[u++];
      return l
    }

    function ur(t, n, r, e) {
      var u = -1,
        o = t.length,
        i = -1,
        f = r.length,
        c = -1,
        a = n.length,
        l = Tu(o - f, 0),
        s = Array(l + a);
      for (e = !e; ++u &lt; l;) s[u] = t[u];
      for (l = u; ++c &lt; a;) s[l + c] = n[c];
      for (; ++i &lt; f;)(e || o &gt; u) &amp;&amp; (s[l + r[i]] = t[u++]);
      return s
    }

    function or(t, n) {
      var r = -1,
        e = t.length;
      for (n || (n = Array(e)); ++r &lt; e;) n[r] = t[r];
      return n;
    }

    function ir(t, n, r, e) {
      r || (r = {});
      for (var u = -1, o = n.length; ++u &lt; o;) {
        var i = n[u],
          f = e ? e(r[i], t[i], i, r, t) : t[i];
        Xt(r, i, f)
      }
      return r
    }

    function fr(t, n) {
      return ir(t, Cr(t), n)
    }

    function cr(t, n) {
      return function(r, u) {
        var o = oi(r) ? e : tn,
          i = n ? n() : {};
        return o(r, t, Rr(u), i)
      }
    }

    function ar(t) {
      return je(function(n, r) {
        var e = -1,
          u = r.length,
          o = u &gt; 1 ? r[u - 1] : q,
          i = u &gt; 2 ? r[2] : q,
          o = typeof o == "function" ? (u--, o) : q;
        for (i &amp;&amp; Zr(r[0], r[1], i) &amp;&amp; (o = 3 &gt; u ? q : o, u = 1), n = Object(n); ++e &lt; u;)(i = r[e]) &amp;&amp; t(n, i, e, o);
        return n
      })
    }

    function lr(t, n) {
      return function(r, e) {
        if (null == r) return r;
        if (!ke(r)) return t(r, e);
        for (var u = r.length, o = n ? u : -1, i = Object(r);
          (n ? o-- : ++o &lt; u) &amp;&amp; false !== e(i[o], o, i););
        return r
      }
    }

    function sr(t) {
      return function(n, r, e) {
        var u = -1,
          o = Object(n);
        e = e(n);
        for (var i = e.length; i--;) {
          var f = e[t ? i : ++u];
          if (false === r(o[f], f, o)) break
        }
        return n
      }
    }

    function hr(t, n, r) {
      function e() {
        return (this &amp;&amp; this !== Yt &amp;&amp; this instanceof e ? o : t).apply(u ? r : this, arguments)
      }
      var u = 1 &amp; n,
        o = vr(t);
      return e
    }

    function pr(t) {
      return function(n) {
        n = Ke(n);
        var r = Bt.test(n) ? n.match(Rt) : q,
          e = r ? r[0] : n.charAt(0);
        return n = r ? tr(r, 1).join("") : n.slice(1),
          e[t]() + n
      }
    }

    function _r(t) {
      return function(n) {
        return s(uu(eu(n).replace(It, "")), t, "")
      }
    }

    function vr(t) {
      return function() {
        var n = arguments;
        switch (n.length) {
          case 0:
            return new t;
          case 1:
            return new t(n[0]);
          case 2:
            return new t(n[0], n[1]);
          case 3:
            return new t(n[0], n[1], n[2]);
          case 4:
            return new t(n[0], n[1], n[2], n[3]);
          case 5:
            return new t(n[0], n[1], n[2], n[3], n[4]);
          case 6:
            return new t(n[0], n[1], n[2], n[3], n[4], n[5]);
          case 7:
            return new t(n[0], n[1], n[2], n[3], n[4], n[5], n[6])
        }
        var r = fn(t.prototype),
          n = t.apply(r, n);
        return Be(n) ? n : r;
      }
    }

    function gr(t, n, e) {
      function u() {
        for (var i = arguments.length, f = Array(i), c = i, a = Lr(u); c--;) f[c] = arguments[c];
        return c = 3 &gt; i &amp;&amp; f[0] !== a &amp;&amp; f[i - 1] !== a ? [] : F(f, a), i -= c.length, e &gt; i ? Ar(t, n, yr, u.placeholder, q, f, c, q, q, e - i) : r(this &amp;&amp; this !== Yt &amp;&amp; this instanceof u ? o : t, this, f)
      }
      var o = vr(t);
      return u
    }

    function dr(t) {
      return je(function(n) {
        n = hn(n, 1);
        var r = n.length,
          e = r,
          u = kt.prototype.thru;
        for (t &amp;&amp; n.reverse(); e--;) {
          var o = n[e];
          if (typeof o != "function") throw new vu("Expected a function");
          if (u &amp;&amp; !i &amp;&amp; "wrapper" == Sr(o)) var i = new kt([], true);
        }
        for (e = i ? e : r; ++e &lt; r;) var o = n[e],
          u = Sr(o),
          f = "wrapper" == u ? jo(o) : q,
          i = f &amp;&amp; Vr(f[0]) &amp;&amp; 424 == f[1] &amp;&amp; !f[4].length &amp;&amp; 1 == f[9] ? i[Sr(f[0])].apply(i, f[3]) : 1 == o.length &amp;&amp; Vr(o) ? i[u]() : i.thru(o);
        return function() {
          var t = arguments,
            e = t[0];
          if (i &amp;&amp; 1 == t.length &amp;&amp; oi(e) &amp;&amp; e.length &gt;= 200) return i.plant(e).value();
          for (var u = 0, t = r ? n[u].apply(this, t) : e; ++u &lt; r;) t = n[u].call(this, t);
          return t
        }
      })
    }

    function yr(t, n, r, e, u, o, i, f, c, a) {
      function l() {
        for (var d = arguments.length, y = d, b = Array(d); y--;) b[y] = arguments[y];
        if (_) {
          var x, j = Lr(l),
            y = b.length;
          for (x = 0; y--;) b[y] === j &amp;&amp; x++;
        }
        if (e &amp;&amp; (b = er(b, e, u, _)), o &amp;&amp; (b = ur(b, o, i, _)), d -= x, _ &amp;&amp; a &gt; d) return j = F(b, j), Ar(t, n, yr, l.placeholder, r, b, j, f, c, a - d);
        if (j = h ? r : this, y = p ? j[t] : t, d = b.length, f) {
          x = b.length;
          for (var m = qu(f.length, x), w = or(b); m--;) {
            var A = f[m];
            b[m] = U(A, x) ? w[A] : q
          }
        } else v &amp;&amp; d &gt; 1 &amp;&amp; b.reverse();
        return s &amp;&amp; d &gt; c &amp;&amp; (b.length = c), this &amp;&amp; this !== Yt &amp;&amp; this instanceof l &amp;&amp; (y = g || vr(y)), y.apply(j, b)
      }
      var s = 128 &amp; n,
        h = 1 &amp; n,
        p = 2 &amp; n,
        _ = 24 &amp; n,
        v = 512 &amp; n,
        g = p ? q : vr(t);
      return l
    }

    function br(t, n) {
      return function(r, e) {
        return jn(r, t, n(e))
      }
    }

    function xr(t) {
      return je(function(n) {
        return n = 1 == n.length &amp;&amp; oi(n[0]) ? a(n[0], O(Rr())) : a(hn(n, 1, Pr), O(Rr())),
          je(function(e) {
            var u = this;
            return t(n, function(t) {
              return r(t, u, e)
            })
          })
      })
    }

    function jr(t, n) {
      n = n === q ? " " : n + "";
      var r = n.length;
      return 2 &gt; r ? r ? Fn(n, t) : n : (r = Fn(n, Du(t / P(n))), Bt.test(n) ? tr(r.match(Rt), 0, t).join("") : r.slice(0, t))
    }

    function mr(t, n, e, u) {
      function o() {
        for (var n = -1, c = arguments.length, a = -1, l = u.length, s = Array(l + c), h = this &amp;&amp; this !== Yt &amp;&amp; this instanceof o ? f : t; ++a &lt; l;) s[a] = u[a];
        for (; c--;) s[a++] = arguments[++n];
        return r(h, i ? e : this, s)
      }
      var i = 1 &amp; n,
        f = vr(t);
      return o
    }

    function wr(t) {
      return function(n, r, e) {
        e &amp;&amp; typeof e != "number" &amp;&amp; Zr(n, r, e) &amp;&amp; (r = e = q),
          n = qe(n), n = n === n ? n : 0, r === q ? (r = n, n = 0) : r = qe(r) || 0, e = e === q ? r &gt; n ? 1 : -1 : qe(e) || 0;
        var u = -1;
        r = Tu(Du((r - n) / (e || 1)), 0);
        for (var o = Array(r); r--;) o[t ? r : ++u] = n, n += e;
        return o
      }
    }

    function Ar(t, n, r, e, u, o, i, f, c, a) {
      var l = 8 &amp; n,
        s = l ? i : q;
      i = l ? q : i;
      var h = l ? o : q;
      return o = l ? q : o, n = (n | (l ? 32 : 64)) &amp; ~(l ? 64 : 32), 4 &amp; n || (n &amp;= -4), n = [t, n, u, h, s, o, i, f, c, a], r = r.apply(q, n), Vr(t) &amp;&amp; Ao(r, n), r.placeholder = e, r
    }

    function Or(t) {
      var n = pu[t];
      return function(t, r) {
        if (t = qe(t), r = Ze(r)) {
          var e = (Ke(t) + "e").split("e"),
            e = n(e[0] + "e" + (+e[1] + r)),
            e = (Ke(e) + "e").split("e");
          return +(e[0] + "e" + (+e[1] - r))
        }
        return n(t)
      }
    }

    function kr(t, n, r, e, u, o, i, f) {
      var c = 2 &amp; n;
      if (!c &amp;&amp; typeof t != "function") throw new vu("Expected a function");
      var a = e ? e.length : 0;
      if (a || (n &amp;= -97, e = u = q), i = i === q ? i : Tu(Ze(i), 0), f = f === q ? f : Ze(f), a -= u ? u.length : 0, 64 &amp; n) {
        var l = e,
          s = u;
        e = u = q
      }
      var h = c ? q : jo(t);
      return o = [t, n, r, e, u, l, s, o, i, f], h &amp;&amp; (r = o[1], t = h[1], n = r | t, e = 128 == t &amp;&amp; 8 == r || 128 == t &amp;&amp; 256 == r &amp;&amp; h[8] &gt;= o[7].length || 384 == t &amp;&amp; h[8] &gt;= h[7].length &amp;&amp; 8 == r, 131 &gt; n || e) &amp;&amp; (1 &amp; t &amp;&amp; (o[2] = h[2], n |= 1 &amp; r ? 0 : 4), (r = h[3]) &amp;&amp; (e = o[3], o[3] = e ? er(e, r, h[4]) : r, o[4] = e ? F(o[3], "__lodash_placeholder__") : h[4]),
        (r = h[5]) &amp;&amp; (e = o[5], o[5] = e ? ur(e, r, h[6]) : r, o[6] = e ? F(o[5], "__lodash_placeholder__") : h[6]), (r = h[7]) &amp;&amp; (o[7] = r), 128 &amp; t &amp;&amp; (o[8] = null == o[8] ? h[8] : qu(o[8], h[8])), null == o[9] &amp;&amp; (o[9] = h[9]), o[0] = h[0], o[1] = n), t = o[0], n = o[1], r = o[2], e = o[3], u = o[4], f = o[9] = null == o[9] ? c ? 0 : t.length : Tu(o[9] - a, 0), !f &amp;&amp; 24 &amp; n &amp;&amp; (n &amp;= -25), (h ? bo : Ao)(n &amp;&amp; 1 != n ? 8 == n || 16 == n ? gr(t, n, f) : 32 != n &amp;&amp; 33 != n || u.length ? yr.apply(q, o) : mr(t, n, r, e) : hr(t, n, r), o)
    }

    function Er(t, n, r, e, u, o) {
      var i = -1,
        f = 2 &amp; u,
        c = 1 &amp; u,
        a = t.length,
        l = n.length;
      if (!(a == l || f &amp;&amp; l &gt; a)) return false;
      if (l = o.get(t)) return l == n;
      for (l = true, o.set(t, n); ++i &lt; a;) {
        var s = t[i],
          h = n[i];
        if (e) var _ = f ? e(h, s, i, n, t, o) : e(s, h, i, t, n, o);
        if (_ !== q) {
          if (_) continue;
          l = false;
          break
        }
        if (c) {
          if (!p(n, function(t) {
              return s === t || r(s, t, e, u, o)
            })) {
            l = false;
            break
          }
        } else if (s !== h &amp;&amp; !r(s, h, e, u, o)) {
          l = false;
          break
        }
      }
      return o["delete"](t), l
    }

    function Ir(t, n, r, e, u, o, i) {
      switch (r) {
        case "[object DataView]":
          if (t.byteLength != n.byteLength || t.byteOffset != n.byteOffset) break;
          t = t.buffer, n = n.buffer;
        case "[object ArrayBuffer]":
          if (t.byteLength != n.byteLength || !e(new Su(t), new Su(n))) break;
          return true;
        case "[object Boolean]":
        case "[object Date]":
          return +t == +n;
        case "[object Error]":
          return t.name == n.name &amp;&amp; t.message == n.message;
        case "[object Number]":
          return t != +t ? n != +n : t == +n;
        case "[object RegExp]":
        case "[object String]":
          return t == n + "";
        case "[object Map]":
          var f = $;
        case "[object Set]":
          if (f || (f = N), t.size != n.size &amp;&amp; !(2 &amp; o)) break;
          return (r = i.get(t)) ? r == n : (o |= 1, i.set(t, n), Er(f(t), f(n), e, u, o, i));
        case "[object Symbol]":
          if (ho) return ho.call(t) == ho.call(n)
      }
      return false
    }

    function Sr(t) {
      for (var n = t.name + "", r = oo[n], e = xu.call(oo, n) ? r.length : 0; e--;) {
        var u = r[e],
          o = u.func;
        if (null == o || o == t) return u.name
      }
      return n
    }

    function Rr() {
      var t = jt.iteratee || fu,
        t = t === fu ? On : t;
      return arguments.length ? t(arguments[0], arguments[1]) : t
    }

    function Wr(t) {
      t = Xe(t);
      for (var n = t.length; n--;) {
        var r = t[n][1];
        t[n][2] = r === r &amp;&amp; !Be(r)
      }
      return t
    }

    function Br(t, n) {
      var r = t[n];
      return Ce(r) ? r : q
    }

    function Lr(t) {
      return (xu.call(jt, "placeholder") ? jt : t).placeholder
    }

    function Cr(t) {
      return Bu(Object(t))
    }

    function Mr(t) {
      return wu.call(t)
    }

    function zr(t, n, r) {
      n = Tr(n, t) ? [n] : Xn(n);
      for (var e, u = -1, o = n.length; ++u &lt; o;) {
        var i = n[u];
        if (!(e = null != t &amp;&amp; r(t, i))) break;
        t = t[i]
      }
      return e ? e : (o = t ? t.length : 0, !!o &amp;&amp; We(o) &amp;&amp; U(i, o) &amp;&amp; (oi(t) || De(t) || Oe(t)))
    }

    function Ur(t) {
      var n = t.length,
        r = t.constructor(n);
      return n &amp;&amp; "string" == typeof t[0] &amp;&amp; xu.call(t, "index") &amp;&amp; (r.index = t.index, r.input = t.input), r
    }

    function Dr(t) {
      return typeof t.constructor != "function" || Kr(t) ? {} : fn(Fu(Object(t)))
    }

    function $r(r, e, u, o) {
      var i = r.constructor;
      switch (e) {
        case "[object ArrayBuffer]":
          return rr(r);
        case "[object Boolean]":
        case "[object Date]":
          return new i(+r);
        case "[object DataView]":
          return e = o ? rr(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.byteLength);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return e = o ? rr(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.length);
        case "[object Map]":
          return e = o ? u($(r), true) : $(r), s(e, t, new r.constructor);
        case "[object Number]":
        case "[object String]":
          return new i(r);
        case "[object RegExp]":
          return e = new r.constructor(r.source, vt.exec(r)), e.lastIndex = r.lastIndex, e;
        case "[object Set]":
          return e = o ? u(N(r), true) : N(r), s(e, n, new r.constructor);
        case "[object Symbol]":
          return ho ? Object(ho.call(r)) : {}
      }
    }

    function Fr(t) {
      var n = t ? t.length : q;
      return We(n) &amp;&amp; (oi(t) || De(t) || Oe(t)) ? w(n, String) : null
    }

    function Nr(t) {
      return Ee(t) &amp;&amp; (oi(t) || Oe(t))
    }

    function Pr(t) {
      return oi(t) &amp;&amp; !(2 == t.length &amp;&amp; !Se(t[0]))
    }

    function Zr(t, n, r) {
      if (!Be(r)) return false;
      var e = typeof n;
      return ("number" == e ? ke(r) &amp;&amp; U(n, r.length) : "string" == e &amp;&amp; n in r) ? we(r[n], t) : false;
    }

    function Tr(t, n) {
      var r = typeof t;
      return "number" == r || "symbol" == r ? true : !oi(t) &amp;&amp; ($e(t) || ot.test(t) || !ut.test(t) || null != n &amp;&amp; t in Object(n))
    }

    function qr(t) {
      var n = typeof t;
      return "number" == n || "boolean" == n || "string" == n &amp;&amp; "__proto__" != t || null == t
    }

    function Vr(t) {
      var n = Sr(t),
        r = jt[n];
      return typeof r == "function" &amp;&amp; n in Et.prototype ? t === r ? true : (n = jo(r), !!n &amp;&amp; t === n[0]) : false
    }

    function Kr(t) {
      var n = t &amp;&amp; t.constructor;
      return t === (typeof n == "function" &amp;&amp; n.prototype || du)
    }

    function Gr(t, n) {
      return function(r) {
        return null == r ? false : r[t] === n &amp;&amp; (n !== q || t in Object(r));
      }
    }

    function Jr(t, n, r, e, u, o) {
      return Be(t) &amp;&amp; Be(n) &amp;&amp; Rn(t, n, q, Jr, o.set(n, t)), t
    }

    function Yr(t, n) {
      return 1 == n.length ? t : gn(t, Pn(n, 0, -1))
    }

    function Hr(t) {
      return typeof t == "string" || $e(t) ? t : t + ""
    }

    function Qr(t) {
      if (null != t) {
        try {
          return bu.call(t)
        } catch (n) {}
        return t + ""
      }
      return ""
    }

    function Xr(t) {
      if (t instanceof Et) return t.clone();
      var n = new kt(t.__wrapped__, t.__chain__);
      return n.__actions__ = or(t.__actions__), n.__index__ = t.__index__, n.__values__ = t.__values__, n
    }

    function te(t, n, r) {
      var e = t ? t.length : 0;
      return e ? (n = r || n === q ? 1 : Ze(n),
        Pn(t, 0 &gt; n ? 0 : n, e)) : []
    }

    function ne(t, n, r) {
      var e = t ? t.length : 0;
      return e ? (n = r || n === q ? 1 : Ze(n), n = e - n, Pn(t, 0, 0 &gt; n ? 0 : n)) : []
    }

    function re(t) {
      return t &amp;&amp; t.length ? t[0] : q
    }

    function ee(t) {
      var n = t ? t.length : 0;
      return n ? t[n - 1] : q
    }

    function ue(t, n) {
      return t &amp;&amp; t.length &amp;&amp; n &amp;&amp; n.length ? Un(t, n) : t
    }

    function oe(t) {
      return t ? Ju.call(t) : t
    }

    function ie(t) {
      if (!t || !t.length) return [];
      var n = 0;
      return t = i(t, function(t) {
        return Ee(t) ? (n = Tu(t.length, n), true) : void 0
      }), w(n, function(n) {
        return a(t, Mn(n))
      })
    }

    function fe(t, n) {
      if (!t || !t.length) return [];
      var e = ie(t);
      return null == n ? e : a(e, function(t) {
        return r(n, q, t)
      })
    }

    function ce(t) {
      return t = jt(t), t.__chain__ = true, t
    }

    function ae(t, n) {
      return n(t)
    }

    function le() {
      return this
    }

    function se(t, n) {
      return typeof n == "function" &amp;&amp; oi(t) ? u(t, n) : _o(t, Rr(n))
    }

    function he(t, n) {
      var r;
      if (typeof n == "function" &amp;&amp; oi(t)) {
        for (r = t.length; r-- &amp;&amp; false !== n(t[r], r, t););
        r = t
      } else r = vo(t, Rr(n));
      return r
    }

    function pe(t, n) {
      return (oi(t) ? a : En)(t, Rr(n, 3))
    }

    function _e(t, n, r) {
      var e = -1,
        u = Pe(t),
        o = u.length,
        i = o - 1;
      for (n = (r ? Zr(t, n, r) : n === q) ? 1 : en(Ze(n), 0, o); ++e &lt; n;) t = $n(e, i),
        r = u[t], u[t] = u[e], u[e] = r;
      return u.length = n, u
    }

    function ve(t, n, r) {
      return n = r ? q : n, n = t &amp;&amp; null == n ? t.length : n, kr(t, 128, q, q, q, q, n)
    }

    function ge(t, n) {
      var r;
      if (typeof n != "function") throw new vu("Expected a function");
      return t = Ze(t),
        function() {
          return 0 &lt; --t &amp;&amp; (r = n.apply(this, arguments)), 1 &gt;= t &amp;&amp; (n = q), r
        }
    }

    function de(t, n, r) {
      return n = r ? q : n, t = kr(t, 8, q, q, q, q, q, n), t.placeholder = de.placeholder, t
    }

    function ye(t, n, r) {
      return n = r ? q : n, t = kr(t, 16, q, q, q, q, q, n), t.placeholder = ye.placeholder, t
    }

    function be(t, n, r) {
      function e(n) {
        var r = c,
          e = a;
        return c = a = q, p = n, l = t.apply(e, r)
      }

      function u(t) {
        var r = t - h;
        return t -= p, !h || r &gt;= n || 0 &gt; r || false !== v &amp;&amp; t &gt;= v
      }

      function o() {
        var t = Yo();
        if (u(t)) return i(t);
        var r;
        r = t - p, t = n - (t - h), r = false === v ? t : qu(t, v - r), s = zu(o, r)
      }

      function i(t) {
        return Ru(s), s = q, g &amp;&amp; c ? e(t) : (c = a = q, l)
      }

      function f() {
        var t = Yo(),
          r = u(t);
        return c = arguments, a = this, h = t, r ? s === q ? (p = t = h, s = zu(o, n), _ ? e(t) : l) : (Ru(s), s = zu(o, n), e(h)) : (s === q &amp;&amp; (s = zu(o, n)), l)
      }
      var c, a, l, s, h = 0,
        p = 0,
        _ = false,
        v = false,
        g = true;
      if (typeof t != "function") throw new vu("Expected a function");
      return n = qe(n) || 0, Be(r) &amp;&amp; (_ = !!r.leading,
        v = "maxWait" in r &amp;&amp; Tu(qe(r.maxWait) || 0, n), g = "trailing" in r ? !!r.trailing : g), f.cancel = function() {
        s !== q &amp;&amp; Ru(s), h = p = 0, c = a = s = q
      }, f.flush = function() {
        return s === q ? l : i(Yo())
      }, f
    }

    function xe(t, n) {
      function r() {
        var e = arguments,
          u = n ? n.apply(this, e) : e[0],
          o = r.cache;
        return o.has(u) ? o.get(u) : (e = t.apply(this, e), r.cache = o.set(u, e), e)
      }
      if (typeof t != "function" || n &amp;&amp; typeof n != "function") throw new vu("Expected a function");
      return r.cache = new(xe.Cache || Dt), r
    }

    function je(t, n) {
      if (typeof t != "function") throw new vu("Expected a function");
      return n = Tu(n === q ? t.length - 1 : Ze(n), 0),
        function() {
          for (var e = arguments, u = -1, o = Tu(e.length - n, 0), i = Array(o); ++u &lt; o;) i[u] = e[n + u];
          switch (n) {
            case 0:
              return t.call(this, i);
            case 1:
              return t.call(this, e[0], i);
            case 2:
              return t.call(this, e[0], e[1], i)
          }
          for (o = Array(n + 1), u = -1; ++u &lt; n;) o[u] = e[u];
          return o[n] = i, r(t, this, o)
        }
    }

    function me() {
      if (!arguments.length) return [];
      var t = arguments[0];
      return oi(t) ? t : [t]
    }

    function we(t, n) {
      return t === n || t !== t &amp;&amp; n !== n
    }

    function Ae(t, n) {
      return t &gt; n
    }

    function Oe(t) {
      return Ee(t) &amp;&amp; xu.call(t, "callee") &amp;&amp; (!Mu.call(t, "callee") || "[object Arguments]" == wu.call(t));
    }

    function ke(t) {
      return null != t &amp;&amp; We(mo(t)) &amp;&amp; !Se(t)
    }

    function Ee(t) {
      return Le(t) &amp;&amp; ke(t)
    }

    function Ie(t) {
      return Le(t) ? "[object Error]" == wu.call(t) || typeof t.message == "string" &amp;&amp; typeof t.name == "string" : false
    }

    function Se(t) {
      return t = Be(t) ? wu.call(t) : "", "[object Function]" == t || "[object GeneratorFunction]" == t
    }

    function Re(t) {
      return typeof t == "number" &amp;&amp; t == Ze(t)
    }

    function We(t) {
      return typeof t == "number" &amp;&amp; t &gt; -1 &amp;&amp; 0 == t % 1 &amp;&amp; 9007199254740991 &gt;= t
    }

    function Be(t) {
      var n = typeof t;
      return !!t &amp;&amp; ("object" == n || "function" == n)
    }

    function Le(t) {
      return !!t &amp;&amp; typeof t == "object"
    }

    function Ce(t) {
      return Be(t) ? (Se(t) || z(t) ? Ou : bt).test(Qr(t)) : false
    }

    function Me(t) {
      return typeof t == "number" || Le(t) &amp;&amp; "[object Number]" == wu.call(t)
    }

    function ze(t) {
      return !Le(t) || "[object Object]" != wu.call(t) || z(t) ? false : (t = Fu(Object(t)), null === t ? true : (t = xu.call(t, "constructor") &amp;&amp; t.constructor, typeof t == "function" &amp;&amp; t instanceof t &amp;&amp; bu.call(t) == mu))
    }

    function Ue(t) {
      return Be(t) &amp;&amp; "[object RegExp]" == wu.call(t)
    }

    function De(t) {
      return typeof t == "string" || !oi(t) &amp;&amp; Le(t) &amp;&amp; "[object String]" == wu.call(t);
    }

    function $e(t) {
      return typeof t == "symbol" || Le(t) &amp;&amp; "[object Symbol]" == wu.call(t)
    }

    function Fe(t) {
      return Le(t) &amp;&amp; We(t.length) &amp;&amp; !!Mt[wu.call(t)]
    }

    function Ne(t, n) {
      return n &gt; t
    }

    function Pe(t) {
      if (!t) return [];
      if (ke(t)) return De(t) ? t.match(Rt) : or(t);
      if (Lu &amp;&amp; t[Lu]) return D(t[Lu]());
      var n = Mr(t);
      return ("[object Map]" == n ? $ : "[object Set]" == n ? N : nu)(t)
    }

    function Ze(t) {
      if (!t) return 0 === t ? t : 0;
      if (t = qe(t), t === V || t === -V) return 1.7976931348623157e308 * (0 &gt; t ? -1 : 1);
      var n = t % 1;
      return t === t ? n ? t - n : t : 0
    }

    function Te(t) {
      return t ? en(Ze(t), 0, 4294967295) : 0;
    }

    function qe(t) {
      if (typeof t == "number") return t;
      if ($e(t)) return K;
      if (Be(t) &amp;&amp; (t = Se(t.valueOf) ? t.valueOf() : t, t = Be(t) ? t + "" : t), typeof t != "string") return 0 === t ? t : +t;
      t = t.replace(at, "");
      var n = yt.test(t);
      return n || xt.test(t) ? Zt(t.slice(2), n ? 2 : 8) : dt.test(t) ? K : +t
    }

    function Ve(t) {
      return ir(t, Qe(t))
    }

    function Ke(t) {
      if (typeof t == "string") return t;
      if (null == t) return "";
      if ($e(t)) return po ? po.call(t) : "";
      var n = t + "";
      return "0" == n &amp;&amp; 1 / t == -V ? "-0" : n
    }

    function Ge(t, n, r) {
      return t = null == t ? q : gn(t, n), t === q ? r : t
    }

    function Je(t, n) {
      return null != t &amp;&amp; zr(t, n, yn);
    }

    function Ye(t, n) {
      return null != t &amp;&amp; zr(t, n, bn)
    }

    function He(t) {
      var n = Kr(t);
      if (!n &amp;&amp; !ke(t)) return Zu(Object(t));
      var r, e = Fr(t),
        u = !!e,
        e = e || [],
        o = e.length;
      for (r in t) !yn(t, r) || u &amp;&amp; ("length" == r || U(r, o)) || n &amp;&amp; "constructor" == r || e.push(r);
      return e
    }

    function Qe(t) {
      for (var n = -1, r = Kr(t), e = kn(t), u = e.length, o = Fr(t), i = !!o, o = o || [], f = o.length; ++n &lt; u;) {
        var c = e[n];
        i &amp;&amp; ("length" == c || U(c, f)) || "constructor" == c &amp;&amp; (r || !xu.call(t, c)) || o.push(c)
      }
      return o
    }

    function Xe(t) {
      return A(t, He(t))
    }

    function tu(t) {
      return A(t, Qe(t))
    }

    function nu(t) {
      return t ? k(t, He(t)) : []
    }

    function ru(t) {
      return Ii(Ke(t).toLowerCase())
    }

    function eu(t) {
      return (t = Ke(t)) &amp;&amp; t.replace(mt, B).replace(St, "")
    }

    function uu(t, n, r) {
      return t = Ke(t), n = r ? q : n, n === q &amp;&amp; (n = Lt.test(t) ? Wt : ht), t.match(n) || []
    }

    function ou(t) {
      return function() {
        return t
      }
    }

    function iu(t) {
      return t
    }

    function fu(t) {
      return On(typeof t == "function" ? t : un(t, true))
    }

    function cu(t, n, r) {
      var e = He(n),
        o = vn(n, e);
      null != r || Be(n) &amp;&amp; (o.length || !e.length) || (r = n, n = t, t = this, o = vn(n, He(n)));
      var i = Be(r) &amp;&amp; "chain" in r ? r.chain : true,
        f = Se(t);
      return u(o, function(r) {
        var e = n[r];
        t[r] = e, f &amp;&amp; (t.prototype[r] = function() {
          var n = this.__chain__;
          if (i || n) {
            var r = t(this.__wrapped__);
            return (r.__actions__ = or(this.__actions__)).push({
              func: e,
              args: arguments,
              thisArg: t
            }), r.__chain__ = n, r
          }
          return e.apply(t, l([this.value()], arguments))
        })
      }), t
    }

    function au() {}

    function lu(t) {
      return Tr(t) ? Mn(t) : zn(t)
    }
    S = S ? Ht.defaults({}, S, Ht.pick(Yt, Ct)) : Yt;
    var su = S.Date,
      hu = S.Error,
      pu = S.Math,
      _u = S.RegExp,
      vu = S.TypeError,
      gu = S.Array.prototype,
      du = S.Object.prototype,
      yu = S.String.prototype,
      bu = S.Function.prototype.toString,
      xu = du.hasOwnProperty,
      ju = 0,
      mu = bu.call(Object),
      wu = du.toString,
      Au = Yt._,
      Ou = _u("^" + bu.call(xu).replace(ft, "\\$&amp;").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      ku = Vt ? S.Buffer : q,
      Eu = S.Reflect,
      Iu = S.Symbol,
      Su = S.Uint8Array,
      Ru = S.clearTimeout,
      Wu = Eu ? Eu.f : q,
      Bu = Object.getOwnPropertySymbols,
      Lu = typeof(Lu = Iu &amp;&amp; Iu.iterator) == "symbol" ? Lu : q,
      Cu = Object.create,
      Mu = du.propertyIsEnumerable,
      zu = S.setTimeout,
      Uu = gu.splice,
      Du = pu.ceil,
      $u = pu.floor,
      Fu = Object.getPrototypeOf,
      Nu = S.isFinite,
      Pu = gu.join,
      Zu = Object.keys,
      Tu = pu.max,
      qu = pu.min,
      Vu = S.parseInt,
      Ku = pu.random,
      Gu = yu.replace,
      Ju = gu.reverse,
      Yu = yu.split,
      Hu = Br(S, "DataView"),
      Qu = Br(S, "Map"),
      Xu = Br(S, "Promise"),
      to = Br(S, "Set"),
      no = Br(S, "WeakMap"),
      ro = Br(Object, "create"),
      eo = no &amp;&amp; new no,
      uo = !Mu.call({
        valueOf: 1
      }, "valueOf"),
      oo = {},
      io = Qr(Hu),
      fo = Qr(Qu),
      co = Qr(Xu),
      ao = Qr(to),
      lo = Qr(no),
      so = Iu ? Iu.prototype : q,
      ho = so ? so.valueOf : q,
      po = so ? so.toString : q;
    jt.templateSettings = {
      escape: nt,
      evaluate: rt,
      interpolate: et,
      variable: "",
      imports: {
        _: jt
      }
    }, jt.prototype = Ot.prototype, jt.prototype.constructor = jt, kt.prototype = fn(Ot.prototype), kt.prototype.constructor = kt, Et.prototype = fn(Ot.prototype), Et.prototype.constructor = Et, Ut.prototype = ro ? ro(null) : du, Dt.prototype.clear = function() {
      this.__data__ = {
        hash: new Ut,
        map: Qu ? new Qu : [],
        string: new Ut
      }
    }, Dt.prototype["delete"] = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, t = (ro ? n[t] !== q : xu.call(n, t)) &amp;&amp; delete n[t]) : t = Qu ? n.map["delete"](t) : Tt(n.map, t), t
    }, Dt.prototype.get = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, ro ? (t = n[t], t = "__lodash_hash_undefined__" === t ? q : t) : t = xu.call(n, t) ? n[t] : q) : t = Qu ? n.map.get(t) : qt(n.map, t), t
    }, Dt.prototype.has = function(t) {
      var n = this.__data__;
      return qr(t) ? (n = typeof t == "string" ? n.string : n.hash, t = ro ? n[t] !== q : xu.call(n, t)) : t = Qu ? n.map.has(t) : -1 &lt; Kt(n.map, t),
        t
    }, Dt.prototype.set = function(t, n) {
      var r = this.__data__;
      return qr(t) ? (typeof t == "string" ? r.string : r.hash)[t] = ro &amp;&amp; n === q ? "__lodash_hash_undefined__" : n : Qu ? r.map.set(t, n) : Gt(r.map, t, n), this
    }, $t.prototype.push = function(t) {
      var n = this.__data__;
      qr(t) ? (n = n.__data__, (typeof t == "string" ? n.string : n.hash)[t] = "__lodash_hash_undefined__") : n.set(t, "__lodash_hash_undefined__")
    }, Nt.prototype.clear = function() {
      this.__data__ = {
        array: [],
        map: null
      }
    }, Nt.prototype["delete"] = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? Tt(r, t) : n.map["delete"](t);
    }, Nt.prototype.get = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? qt(r, t) : n.map.get(t)
    }, Nt.prototype.has = function(t) {
      var n = this.__data__,
        r = n.array;
      return r ? -1 &lt; Kt(r, t) : n.map.has(t)
    }, Nt.prototype.set = function(t, n) {
      var r = this.__data__,
        e = r.array;
      return e &amp;&amp; (199 &gt; e.length ? Gt(e, t, n) : (r.array = null, r.map = new Dt(e))), (r = r.map) &amp;&amp; r.set(t, n), this
    };
    var _o = lr(pn),
      vo = lr(_n, true),
      go = sr(),
      yo = sr(true);
    Wu &amp;&amp; !Mu.call({
      valueOf: 1
    }, "valueOf") &amp;&amp; (kn = function(t) {
      return D(Wu(t))
    });
    var bo = eo ? function(t, n) {
        return eo.set(t, n), t
      } : iu,
      xo = to &amp;&amp; 2 === new to([1, 2]).size ? function(t) {
        return new to(t)
      } : au,
      jo = eo ? function(t) {
        return eo.get(t)
      } : au,
      mo = Mn("length");
    Bu || (Cr = function() {
      return []
    });
    var wo = Bu ? function(t) {
      for (var n = []; t;) l(n, Cr(t)), t = Fu(Object(t));
      return n
    } : Cr;
    (Hu &amp;&amp; "[object DataView]" != Mr(new Hu(new ArrayBuffer(1))) || Qu &amp;&amp; "[object Map]" != Mr(new Qu) || Xu &amp;&amp; "[object Promise]" != Mr(Xu.resolve()) || to &amp;&amp; "[object Set]" != Mr(new to) || no &amp;&amp; "[object WeakMap]" != Mr(new no)) &amp;&amp; (Mr = function(t) {
      var n = wu.call(t);
      if (t = (t = "[object Object]" == n ? t.constructor : q) ? Qr(t) : q) switch (t) {
        case io:
          return "[object DataView]";
        case fo:
          return "[object Map]";
        case co:
          return "[object Promise]";
        case ao:
          return "[object Set]";
        case lo:
          return "[object WeakMap]"
      }
      return n
    });
    var Ao = function() {
        var t = 0,
          n = 0;
        return function(r, e) {
          var u = Yo(),
            o = 16 - (u - n);
          if (n = u, o &gt; 0) {
            if (150 &lt;= ++t) return r
          } else t = 0;
          return bo(r, e)
        }
      }(),
      Oo = xe(function(t) {
        var n = [];
        return Ke(t).replace(it, function(t, r, e, u) {
          n.push(e ? u.replace(pt, "$1") : r || t)
        }), n
      }),
      ko = je(function(t, n) {
        return Ee(t) ? an(t, hn(n, 1, Ee, true)) : []
      }),
      Eo = je(function(t, n) {
        var r = ee(n);
        return Ee(r) &amp;&amp; (r = q), Ee(t) ? an(t, hn(n, 1, Ee, true), Rr(r)) : [];
      }),
      Io = je(function(t, n) {
        var r = ee(n);
        return Ee(r) &amp;&amp; (r = q), Ee(t) ? an(t, hn(n, 1, Ee, true), q, r) : []
      }),
      So = je(function(t) {
        var n = a(t, Qn);
        return n.length &amp;&amp; n[0] === t[0] ? xn(n) : []
      }),
      Ro = je(function(t) {
        var n = ee(t),
          r = a(t, Qn);
        return n === ee(r) ? n = q : r.pop(), r.length &amp;&amp; r[0] === t[0] ? xn(r, Rr(n)) : []
      }),
      Wo = je(function(t) {
        var n = ee(t),
          r = a(t, Qn);
        return n === ee(r) ? n = q : r.pop(), r.length &amp;&amp; r[0] === t[0] ? xn(r, q, n) : []
      }),
      Bo = je(ue),
      Lo = je(function(t, n) {
        n = a(hn(n, 1), String);
        var r = rn(t, n);
        return Dn(t, n.sort(R)), r
      }),
      Co = je(function(t) {
        return Kn(hn(t, 1, Ee, true));
      }),
      Mo = je(function(t) {
        var n = ee(t);
        return Ee(n) &amp;&amp; (n = q), Kn(hn(t, 1, Ee, true), Rr(n))
      }),
      zo = je(function(t) {
        var n = ee(t);
        return Ee(n) &amp;&amp; (n = q), Kn(hn(t, 1, Ee, true), q, n)
      }),
      Uo = je(function(t, n) {
        return Ee(t) ? an(t, n) : []
      }),
      Do = je(function(t) {
        return Yn(i(t, Ee))
      }),
      $o = je(function(t) {
        var n = ee(t);
        return Ee(n) &amp;&amp; (n = q), Yn(i(t, Ee), Rr(n))
      }),
      Fo = je(function(t) {
        var n = ee(t);
        return Ee(n) &amp;&amp; (n = q), Yn(i(t, Ee), q, n)
      }),
      No = je(ie),
      Po = je(function(t) {
        var n = t.length,
          n = n &gt; 1 ? t[n - 1] : q,
          n = typeof n == "function" ? (t.pop(), n) : q;
        return fe(t, n)
      }),
      Zo = je(function(t) {
        function n(n) {
          return rn(n, t)
        }
        t = hn(t, 1);
        var r = t.length,
          e = r ? t[0] : 0,
          u = this.__wrapped__;
        return 1 &gt;= r &amp;&amp; !this.__actions__.length &amp;&amp; u instanceof Et &amp;&amp; U(e) ? (u = u.slice(e, +e + (r ? 1 : 0)), u.__actions__.push({
          func: ae,
          args: [n],
          thisArg: q
        }), new kt(u, this.__chain__).thru(function(t) {
          return r &amp;&amp; !t.length &amp;&amp; t.push(q), t
        })) : this.thru(n)
      }),
      To = cr(function(t, n, r) {
        xu.call(t, r) ? ++t[r] : t[r] = 1
      }),
      qo = cr(function(t, n, r) {
        xu.call(t, r) ? t[r].push(n) : t[r] = [n]
      }),
      Vo = je(function(t, n, e) {
        var u = -1,
          o = typeof n == "function",
          i = Tr(n),
          f = ke(t) ? Array(t.length) : [];
        return _o(t, function(t) {
          var c = o ? n : i &amp;&amp; null != t ? t[n] : q;
          f[++u] = c ? r(c, t, e) : mn(t, n, e)
        }), f
      }),
      Ko = cr(function(t, n, r) {
        t[r] = n
      }),
      Go = cr(function(t, n, r) {
        t[r ? 0 : 1].push(n)
      }, function() {
        return [
          [],
          []
        ]
      }),
      Jo = je(function(t, n) {
        if (null == t) return [];
        var r = n.length;
        return r &gt; 1 &amp;&amp; Zr(t, n[0], n[1]) ? n = [] : r &gt; 2 &amp;&amp; Zr(n[0], n[1], n[2]) &amp;&amp; (n = [n[0]]), n = 1 == n.length &amp;&amp; oi(n[0]) ? n[0] : hn(n, 1, Pr), Bn(t, n, [])
      }),
      Yo = su.now,
      Ho = je(function(t, n, r) {
        var e = 1;
        if (r.length) var u = F(r, Lr(Ho)),
          e = 32 | e;
        return kr(t, e, n, r, u)
      }),
      Qo = je(function(t, n, r) {
        var e = 3;
        if (r.length) var u = F(r, Lr(Qo)),
          e = 32 | e;
        return kr(n, e, t, r, u)
      }),
      Xo = je(function(t, n) {
        return cn(t, 1, n)
      }),
      ti = je(function(t, n, r) {
        return cn(t, qe(n) || 0, r)
      });
    xe.Cache = Dt;
    var ni = je(function(t, n) {
        n = 1 == n.length &amp;&amp; oi(n[0]) ? a(n[0], O(Rr())) : a(hn(n, 1, Pr), O(Rr()));
        var e = n.length;
        return je(function(u) {
          for (var o = -1, i = qu(u.length, e); ++o &lt; i;) u[o] = n[o].call(this, u[o]);
          return r(t, this, u)
        })
      }),
      ri = je(function(t, n) {
        var r = F(n, Lr(ri));
        return kr(t, 32, q, n, r)
      }),
      ei = je(function(t, n) {
        var r = F(n, Lr(ei));
        return kr(t, 64, q, n, r)
      }),
      ui = je(function(t, n) {
        return kr(t, 256, q, q, q, hn(n, 1));
      }),
      oi = Array.isArray,
      ii = ku ? function(t) {
        return t instanceof ku
      } : ou(false),
      fi = ar(function(t, n) {
        if (uo || Kr(n) || ke(n)) ir(n, He(n), t);
        else
          for (var r in n) xu.call(n, r) &amp;&amp; Xt(t, r, n[r])
      }),
      ci = ar(function(t, n) {
        if (uo || Kr(n) || ke(n)) ir(n, Qe(n), t);
        else
          for (var r in n) Xt(t, r, n[r])
      }),
      ai = ar(function(t, n, r, e) {
        ir(n, Qe(n), t, e)
      }),
      li = ar(function(t, n, r, e) {
        ir(n, He(n), t, e)
      }),
      si = je(function(t, n) {
        return rn(t, hn(n, 1))
      }),
      hi = je(function(t) {
        return t.push(q, Jt), r(ai, q, t)
      }),
      pi = je(function(t) {
        return t.push(q, Jr), r(yi, q, t)
      }),
      _i = br(function(t, n, r) {
        t[n] = r
      }, ou(iu)),
      vi = br(function(t, n, r) {
        xu.call(t, n) ? t[n].push(r) : t[n] = [r]
      }, Rr),
      gi = je(mn),
      di = ar(function(t, n, r) {
        Rn(t, n, r)
      }),
      yi = ar(function(t, n, r, e) {
        Rn(t, n, r, e)
      }),
      bi = je(function(t, n) {
        return null == t ? {} : (n = a(hn(n, 1), Hr), Ln(t, an(dn(t, Qe, wo), n)))
      }),
      xi = je(function(t, n) {
        return null == t ? {} : Ln(t, hn(n, 1))
      }),
      ji = _r(function(t, n, r) {
        return n = n.toLowerCase(), t + (r ? ru(n) : n)
      }),
      mi = _r(function(t, n, r) {
        return t + (r ? "-" : "") + n.toLowerCase()
      }),
      wi = _r(function(t, n, r) {
        return t + (r ? " " : "") + n.toLowerCase()
      }),
      Ai = pr("toLowerCase"),
      Oi = _r(function(t, n, r) {
        return t + (r ? "_" : "") + n.toLowerCase()
      }),
      ki = _r(function(t, n, r) {
        return t + (r ? " " : "") + Ii(n)
      }),
      Ei = _r(function(t, n, r) {
        return t + (r ? " " : "") + n.toUpperCase()
      }),
      Ii = pr("toUpperCase"),
      Si = je(function(t, n) {
        try {
          return r(t, q, n)
        } catch (e) {
          return Ie(e) ? e : new hu(e)
        }
      }),
      Ri = je(function(t, n) {
        return u(hn(n, 1), function(n) {
          t[n] = Ho(t[n], t)
        }), t
      }),
      Wi = dr(),
      Bi = dr(true),
      Li = je(function(t, n) {
        return function(r) {
          return mn(r, t, n)
        }
      }),
      Ci = je(function(t, n) {
        return function(r) {
          return mn(t, r, n)
        }
      }),
      Mi = xr(a),
      zi = xr(o),
      Ui = xr(p),
      Di = wr(),
      $i = wr(true),
      Fi = W(function(t, n) {
        return t + n
      }),
      Ni = Or("ceil"),
      Pi = W(function(t, n) {
        return t / n
      }),
      Zi = Or("floor"),
      Ti = W(function(t, n) {
        return t * n
      }),
      qi = Or("round"),
      Vi = W(function(t, n) {
        return t - n
      });
    return jt.after = function(t, n) {
        if (typeof n != "function") throw new vu("Expected a function");
        return t = Ze(t),
          function() {
            return 1 &gt; --t ? n.apply(this, arguments) : void 0
          }
      }, jt.ary = ve, jt.assign = fi, jt.assignIn = ci, jt.assignInWith = ai, jt.assignWith = li, jt.at = si, jt.before = ge, jt.bind = Ho, jt.bindAll = Ri, jt.bindKey = Qo, jt.castArray = me, jt.chain = ce, jt.chunk = function(t, n, r) {
        if (n = (r ? Zr(t, n, r) : n === q) ? 1 : Tu(Ze(n), 0), r = t ? t.length : 0, !r || 1 &gt; n) return [];
        for (var e = 0, u = 0, o = Array(Du(r / n)); r &gt; e;) o[u++] = Pn(t, e, e += n);
        return o
      }, jt.compact = function(t) {
        for (var n = -1, r = t ? t.length : 0, e = 0, u = []; ++n &lt; r;) {
          var o = t[n];
          o &amp;&amp; (u[e++] = o)
        }
        return u
      }, jt.concat = function() {
        var t = arguments.length,
          n = me(arguments[0]);
        if (2 &gt; t) return t ? or(n) : [];
        for (var r = Array(t - 1); t--;) r[t - 1] = arguments[t];
        for (var t = hn(r, 1), r = -1, e = n.length, u = -1, o = t.length, i = Array(e + o); ++r &lt; e;) i[r] = n[r];
        for (; ++u &lt; o;) i[r++] = t[u];
        return i
      }, jt.cond = function(t) {
        var n = t ? t.length : 0,
          e = Rr();
        return t = n ? a(t, function(t) {
          if ("function" != typeof t[1]) throw new vu("Expected a function");
          return [e(t[0]), t[1]]
        }) : [], je(function(e) {
          for (var u = -1; ++u &lt; n;) {
            var o = t[u];
            if (r(o[0], this, e)) return r(o[1], this, e)
          }
        })
      }, jt.conforms = function(t) {
        return on(un(t, true))
      }, jt.constant = ou, jt.countBy = To, jt.create = function(t, n) {
        var r = fn(t);
        return n ? nn(r, n) : r
      }, jt.curry = de, jt.curryRight = ye, jt.debounce = be, jt.defaults = hi, jt.defaultsDeep = pi, jt.defer = Xo, jt.delay = ti, jt.difference = ko, jt.differenceBy = Eo,
      jt.differenceWith = Io, jt.drop = te, jt.dropRight = ne, jt.dropRightWhile = function(t, n) {
        return t &amp;&amp; t.length ? Gn(t, Rr(n, 3), true, true) : []
      }, jt.dropWhile = function(t, n) {
        return t &amp;&amp; t.length ? Gn(t, Rr(n, 3), true) : []
      }, jt.fill = function(t, n, r, e) {
        var u = t ? t.length : 0;
        if (!u) return [];
        for (r &amp;&amp; typeof r != "number" &amp;&amp; Zr(t, n, r) &amp;&amp; (r = 0, e = u), u = t.length, r = Ze(r), 0 &gt; r &amp;&amp; (r = -r &gt; u ? 0 : u + r), e = e === q || e &gt; u ? u : Ze(e), 0 &gt; e &amp;&amp; (e += u), e = r &gt; e ? 0 : Te(e); e &gt; r;) t[r++] = n;
        return t
      }, jt.filter = function(t, n) {
        return (oi(t) ? i : sn)(t, Rr(n, 3))
      }, jt.flatMap = function(t, n) {
        return hn(pe(t, n), 1);
      }, jt.flatMapDeep = function(t, n) {
        return hn(pe(t, n), V)
      }, jt.flatMapDepth = function(t, n, r) {
        return r = r === q ? 1 : Ze(r), hn(pe(t, n), r)
      }, jt.flatten = function(t) {
        return t &amp;&amp; t.length ? hn(t, 1) : []
      }, jt.flattenDeep = function(t) {
        return t &amp;&amp; t.length ? hn(t, V) : []
      }, jt.flattenDepth = function(t, n) {
        return t &amp;&amp; t.length ? (n = n === q ? 1 : Ze(n), hn(t, n)) : []
      }, jt.flip = function(t) {
        return kr(t, 512)
      }, jt.flow = Wi, jt.flowRight = Bi, jt.fromPairs = function(t) {
        for (var n = -1, r = t ? t.length : 0, e = {}; ++n &lt; r;) {
          var u = t[n];
          e[u[0]] = u[1]
        }
        return e
      }, jt.functions = function(t) {
        return null == t ? [] : vn(t, He(t))
      }, jt.functionsIn = function(t) {
        return null == t ? [] : vn(t, Qe(t))
      }, jt.groupBy = qo, jt.initial = function(t) {
        return ne(t, 1)
      }, jt.intersection = So, jt.intersectionBy = Ro, jt.intersectionWith = Wo, jt.invert = _i, jt.invertBy = vi, jt.invokeMap = Vo, jt.iteratee = fu, jt.keyBy = Ko, jt.keys = He, jt.keysIn = Qe, jt.map = pe, jt.mapKeys = function(t, n) {
        var r = {};
        return n = Rr(n, 3), pn(t, function(t, e, u) {
          r[n(t, e, u)] = t
        }), r
      }, jt.mapValues = function(t, n) {
        var r = {};
        return n = Rr(n, 3), pn(t, function(t, e, u) {
          r[e] = n(t, e, u)
        }), r
      }, jt.matches = function(t) {
        return In(un(t, true))
      }, jt.matchesProperty = function(t, n) {
        return Sn(t, un(n, true))
      }, jt.memoize = xe, jt.merge = di, jt.mergeWith = yi, jt.method = Li, jt.methodOf = Ci, jt.mixin = cu, jt.negate = function(t) {
        if (typeof t != "function") throw new vu("Expected a function");
        return function() {
          return !t.apply(this, arguments)
        }
      }, jt.nthArg = function(t) {
        return t = Ze(t), je(function(n) {
          return Wn(n, t)
        })
      }, jt.omit = bi, jt.omitBy = function(t, n) {
        return n = Rr(n), Cn(t, function(t, r) {
          return !n(t, r)
        })
      }, jt.once = function(t) {
        return ge(2, t)
      }, jt.orderBy = function(t, n, r, e) {
        return null == t ? [] : (oi(n) || (n = null == n ? [] : [n]), r = e ? q : r, oi(r) || (r = null == r ? [] : [r]), Bn(t, n, r))
      }, jt.over = Mi, jt.overArgs = ni, jt.overEvery = zi, jt.overSome = Ui, jt.partial = ri, jt.partialRight = ei, jt.partition = Go, jt.pick = xi, jt.pickBy = function(t, n) {
        return null == t ? {} : Cn(t, Rr(n))
      }, jt.property = lu, jt.propertyOf = function(t) {
        return function(n) {
          return null == t ? q : gn(t, n)
        }
      }, jt.pull = Bo, jt.pullAll = ue, jt.pullAllBy = function(t, n, r) {
        return t &amp;&amp; t.length &amp;&amp; n &amp;&amp; n.length ? Un(t, n, Rr(r)) : t
      }, jt.pullAllWith = function(t, n, r) {
        return t &amp;&amp; t.length &amp;&amp; n &amp;&amp; n.length ? Un(t, n, q, r) : t;
      }, jt.pullAt = Lo, jt.range = Di, jt.rangeRight = $i, jt.rearg = ui, jt.reject = function(t, n) {
        var r = oi(t) ? i : sn;
        return n = Rr(n, 3), r(t, function(t, r, e) {
          return !n(t, r, e)
        })
      }, jt.remove = function(t, n) {
        var r = [];
        if (!t || !t.length) return r;
        var e = -1,
          u = [],
          o = t.length;
        for (n = Rr(n, 3); ++e &lt; o;) {
          var i = t[e];
          n(i, e, t) &amp;&amp; (r.push(i), u.push(e))
        }
        return Dn(t, u), r
      }, jt.rest = je, jt.reverse = oe, jt.sampleSize = _e, jt.set = function(t, n, r) {
        return null == t ? t : Nn(t, n, r)
      }, jt.setWith = function(t, n, r, e) {
        return e = typeof e == "function" ? e : q, null == t ? t : Nn(t, n, r, e)
      }, jt.shuffle = function(t) {
        return _e(t, 4294967295)
      }, jt.slice = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (r &amp;&amp; typeof r != "number" &amp;&amp; Zr(t, n, r) ? (n = 0, r = e) : (n = null == n ? 0 : Ze(n), r = r === q ? e : Ze(r)), Pn(t, n, r)) : []
      }, jt.sortBy = Jo, jt.sortedUniq = function(t) {
        return t &amp;&amp; t.length ? Vn(t) : []
      }, jt.sortedUniqBy = function(t, n) {
        return t &amp;&amp; t.length ? Vn(t, Rr(n)) : []
      }, jt.split = function(t, n, r) {
        return r &amp;&amp; typeof r != "number" &amp;&amp; Zr(t, n, r) &amp;&amp; (n = r = q), r = r === q ? 4294967295 : r &gt;&gt;&gt; 0, r ? (t = Ke(t)) &amp;&amp; (typeof n == "string" || null != n &amp;&amp; !Ue(n)) &amp;&amp; (n += "", "" == n &amp;&amp; Bt.test(t)) ? tr(t.match(Rt), 0, r) : Yu.call(t, n, r) : [];
      }, jt.spread = function(t, n) {
        if (typeof t != "function") throw new vu("Expected a function");
        return n = n === q ? 0 : Tu(Ze(n), 0), je(function(e) {
          var u = e[n];
          return e = tr(e, 0, n), u &amp;&amp; l(e, u), r(t, this, e)
        })
      }, jt.tail = function(t) {
        return te(t, 1)
      }, jt.take = function(t, n, r) {
        return t &amp;&amp; t.length ? (n = r || n === q ? 1 : Ze(n), Pn(t, 0, 0 &gt; n ? 0 : n)) : []
      }, jt.takeRight = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (n = r || n === q ? 1 : Ze(n), n = e - n, Pn(t, 0 &gt; n ? 0 : n, e)) : []
      }, jt.takeRightWhile = function(t, n) {
        return t &amp;&amp; t.length ? Gn(t, Rr(n, 3), false, true) : []
      }, jt.takeWhile = function(t, n) {
        return t &amp;&amp; t.length ? Gn(t, Rr(n, 3)) : []
      }, jt.tap = function(t, n) {
        return n(t), t
      }, jt.throttle = function(t, n, r) {
        var e = true,
          u = true;
        if (typeof t != "function") throw new vu("Expected a function");
        return Be(r) &amp;&amp; (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), be(t, n, {
          leading: e,
          maxWait: n,
          trailing: u
        })
      }, jt.thru = ae, jt.toArray = Pe, jt.toPairs = Xe, jt.toPairsIn = tu, jt.toPath = function(t) {
        return oi(t) ? a(t, Hr) : $e(t) ? [t] : or(Oo(t))
      }, jt.toPlainObject = Ve, jt.transform = function(t, n, r) {
        var e = oi(t) || Fe(t);
        if (n = Rr(n, 4), null == r)
          if (e || Be(t)) {
            var o = t.constructor;
            r = e ? oi(t) ? new o : [] : Se(o) ? fn(Fu(Object(t))) : {}
          } else r = {};
        return (e ? u : pn)(t, function(t, e, u) {
          return n(r, t, e, u)
        }), r
      }, jt.unary = function(t) {
        return ve(t, 1)
      }, jt.union = Co, jt.unionBy = Mo, jt.unionWith = zo, jt.uniq = function(t) {
        return t &amp;&amp; t.length ? Kn(t) : []
      }, jt.uniqBy = function(t, n) {
        return t &amp;&amp; t.length ? Kn(t, Rr(n)) : []
      }, jt.uniqWith = function(t, n) {
        return t &amp;&amp; t.length ? Kn(t, q, n) : []
      }, jt.unset = function(t, n) {
        var r;
        if (null == t) r = true;
        else {
          r = t;
          var e = n,
            e = Tr(e, r) ? [e] : Xn(e);
          r = Yr(r, e), e = ee(e), r = null != r &amp;&amp; Je(r, e) ? delete r[e] : true;
        }
        return r
      }, jt.unzip = ie, jt.unzipWith = fe, jt.update = function(t, n, r) {
        return null == t ? t : Nn(t, n, (typeof r == "function" ? r : iu)(gn(t, n)), void 0)
      }, jt.updateWith = function(t, n, r, e) {
        return e = typeof e == "function" ? e : q, null != t &amp;&amp; (t = Nn(t, n, (typeof r == "function" ? r : iu)(gn(t, n)), e)), t
      }, jt.values = nu, jt.valuesIn = function(t) {
        return null == t ? [] : k(t, Qe(t))
      }, jt.without = Uo, jt.words = uu, jt.wrap = function(t, n) {
        return n = null == n ? iu : n, ri(n, t)
      }, jt.xor = Do, jt.xorBy = $o, jt.xorWith = Fo, jt.zip = No, jt.zipObject = function(t, n) {
        return Hn(t || [], n || [], Xt);
      }, jt.zipObjectDeep = function(t, n) {
        return Hn(t || [], n || [], Nn)
      }, jt.zipWith = Po, jt.entries = Xe, jt.entriesIn = tu, jt.extend = ci, jt.extendWith = ai, cu(jt, jt), jt.add = Fi, jt.attempt = Si, jt.camelCase = ji, jt.capitalize = ru, jt.ceil = Ni, jt.clamp = function(t, n, r) {
        return r === q &amp;&amp; (r = n, n = q), r !== q &amp;&amp; (r = qe(r), r = r === r ? r : 0), n !== q &amp;&amp; (n = qe(n), n = n === n ? n : 0), en(qe(t), n, r)
      }, jt.clone = function(t) {
        return un(t, false, true)
      }, jt.cloneDeep = function(t) {
        return un(t, true, true)
      }, jt.cloneDeepWith = function(t, n) {
        return un(t, true, true, n)
      }, jt.cloneWith = function(t, n) {
        return un(t, false, true, n);
      }, jt.deburr = eu, jt.divide = Pi, jt.endsWith = function(t, n, r) {
        t = Ke(t), n = typeof n == "string" ? n : n + "";
        var e = t.length;
        return r = r === q ? e : en(Ze(r), 0, e), r -= n.length, r &gt;= 0 &amp;&amp; t.indexOf(n, r) == r
      }, jt.eq = we, jt.escape = function(t) {
        return (t = Ke(t)) &amp;&amp; tt.test(t) ? t.replace(Q, L) : t
      }, jt.escapeRegExp = function(t) {
        return (t = Ke(t)) &amp;&amp; ct.test(t) ? t.replace(ft, "\\$&amp;") : t
      }, jt.every = function(t, n, r) {
        var e = oi(t) ? o : ln;
        return r &amp;&amp; Zr(t, n, r) &amp;&amp; (n = q), e(t, Rr(n, 3))
      }, jt.find = function(t, n) {
        if (n = Rr(n, 3), oi(t)) {
          var r = g(t, n);
          return r &gt; -1 ? t[r] : q
        }
        return v(t, n, _o);
      }, jt.findIndex = function(t, n) {
        return t &amp;&amp; t.length ? g(t, Rr(n, 3)) : -1
      }, jt.findKey = function(t, n) {
        return v(t, Rr(n, 3), pn, true)
      }, jt.findLast = function(t, n) {
        if (n = Rr(n, 3), oi(t)) {
          var r = g(t, n, true);
          return r &gt; -1 ? t[r] : q
        }
        return v(t, n, vo)
      }, jt.findLastIndex = function(t, n) {
        return t &amp;&amp; t.length ? g(t, Rr(n, 3), true) : -1
      }, jt.findLastKey = function(t, n) {
        return v(t, Rr(n, 3), _n, true)
      }, jt.floor = Zi, jt.forEach = se, jt.forEachRight = he, jt.forIn = function(t, n) {
        return null == t ? t : go(t, Rr(n), Qe)
      }, jt.forInRight = function(t, n) {
        return null == t ? t : yo(t, Rr(n), Qe);
      }, jt.forOwn = function(t, n) {
        return t &amp;&amp; pn(t, Rr(n))
      }, jt.forOwnRight = function(t, n) {
        return t &amp;&amp; _n(t, Rr(n))
      }, jt.get = Ge, jt.gt = Ae, jt.gte = function(t, n) {
        return t &gt;= n
      }, jt.has = Je, jt.hasIn = Ye, jt.head = re, jt.identity = iu, jt.includes = function(t, n, r, e) {
        return t = ke(t) ? t : nu(t), r = r &amp;&amp; !e ? Ze(r) : 0, e = t.length, 0 &gt; r &amp;&amp; (r = Tu(e + r, 0)), De(t) ? e &gt;= r &amp;&amp; -1 &lt; t.indexOf(n, r) : !!e &amp;&amp; -1 &lt; d(t, n, r)
      }, jt.indexOf = function(t, n, r) {
        var e = t ? t.length : 0;
        return e ? (r = Ze(r), 0 &gt; r &amp;&amp; (r = Tu(e + r, 0)), d(t, n, r)) : -1
      }, jt.inRange = function(t, n, r) {
        return n = qe(n) || 0, r === q ? (r = n,
          n = 0) : r = qe(r) || 0, t = qe(t), t &gt;= qu(n, r) &amp;&amp; t &lt; Tu(n, r)
      }, jt.invoke = gi, jt.isArguments = Oe, jt.isArray = oi, jt.isArrayBuffer = function(t) {
        return Le(t) &amp;&amp; "[object ArrayBuffer]" == wu.call(t)
      }, jt.isArrayLike = ke, jt.isArrayLikeObject = Ee, jt.isBoolean = function(t) {
        return true === t || false === t || Le(t) &amp;&amp; "[object Boolean]" == wu.call(t)
      }, jt.isBuffer = ii, jt.isDate = function(t) {
        return Le(t) &amp;&amp; "[object Date]" == wu.call(t)
      }, jt.isElement = function(t) {
        return !!t &amp;&amp; 1 === t.nodeType &amp;&amp; Le(t) &amp;&amp; !ze(t)
      }, jt.isEmpty = function(t) {
        if (ke(t) &amp;&amp; (oi(t) || De(t) || Se(t.splice) || Oe(t) || ii(t))) return !t.length;
        if (Le(t)) {
          var n = Mr(t);
          if ("[object Map]" == n || "[object Set]" == n) return !t.size
        }
        for (var r in t)
          if (xu.call(t, r)) return false;
        return !(uo &amp;&amp; He(t).length)
      }, jt.isEqual = function(t, n) {
        return wn(t, n)
      }, jt.isEqualWith = function(t, n, r) {
        var e = (r = typeof r == "function" ? r : q) ? r(t, n) : q;
        return e === q ? wn(t, n, r) : !!e
      }, jt.isError = Ie, jt.isFinite = function(t) {
        return typeof t == "number" &amp;&amp; Nu(t)
      }, jt.isFunction = Se, jt.isInteger = Re, jt.isLength = We, jt.isMap = function(t) {
        return Le(t) &amp;&amp; "[object Map]" == Mr(t)
      }, jt.isMatch = function(t, n) {
        return t === n || An(t, n, Wr(n));
      }, jt.isMatchWith = function(t, n, r) {
        return r = typeof r == "function" ? r : q, An(t, n, Wr(n), r)
      }, jt.isNaN = function(t) {
        return Me(t) &amp;&amp; t != +t
      }, jt.isNative = Ce, jt.isNil = function(t) {
        return null == t
      }, jt.isNull = function(t) {
        return null === t
      }, jt.isNumber = Me, jt.isObject = Be, jt.isObjectLike = Le, jt.isPlainObject = ze, jt.isRegExp = Ue, jt.isSafeInteger = function(t) {
        return Re(t) &amp;&amp; t &gt;= -9007199254740991 &amp;&amp; 9007199254740991 &gt;= t
      }, jt.isSet = function(t) {
        return Le(t) &amp;&amp; "[object Set]" == Mr(t)
      }, jt.isString = De, jt.isSymbol = $e, jt.isTypedArray = Fe, jt.isUndefined = function(t) {
        return t === q
      }, jt.isWeakMap = function(t) {
        return Le(t) &amp;&amp; "[object WeakMap]" == Mr(t)
      }, jt.isWeakSet = function(t) {
        return Le(t) &amp;&amp; "[object WeakSet]" == wu.call(t)
      }, jt.join = function(t, n) {
        return t ? Pu.call(t, n) : ""
      }, jt.kebabCase = mi, jt.last = ee, jt.lastIndexOf = function(t, n, r) {
        var e = t ? t.length : 0;
        if (!e) return -1;
        var u = e;
        if (r !== q &amp;&amp; (u = Ze(r), u = (0 &gt; u ? Tu(e + u, 0) : qu(u, e - 1)) + 1), n !== n) return M(t, u, true);
        for (; u--;)
          if (t[u] === n) return u;
        return -1
      }, jt.lowerCase = wi, jt.lowerFirst = Ai, jt.lt = Ne, jt.lte = function(t, n) {
        return n &gt;= t
      }, jt.max = function(t) {
        return t &amp;&amp; t.length ? _(t, iu, Ae) : q
      }, jt.maxBy = function(t, n) {
        return t &amp;&amp; t.length ? _(t, Rr(n), Ae) : q
      }, jt.mean = function(t) {
        return b(t, iu)
      }, jt.meanBy = function(t, n) {
        return b(t, Rr(n))
      }, jt.min = function(t) {
        return t &amp;&amp; t.length ? _(t, iu, Ne) : q
      }, jt.minBy = function(t, n) {
        return t &amp;&amp; t.length ? _(t, Rr(n), Ne) : q
      }, jt.multiply = Ti, jt.nth = function(t, n) {
        return t &amp;&amp; t.length ? Wn(t, Ze(n)) : q
      }, jt.noConflict = function() {
        return Yt._ === this &amp;&amp; (Yt._ = Au), this
      }, jt.noop = au, jt.now = Yo, jt.pad = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n &amp;&amp; n &gt; e ? (n = (n - e) / 2,
          jr($u(n), r) + t + jr(Du(n), r)) : t
      }, jt.padEnd = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n &amp;&amp; n &gt; e ? t + jr(n - e, r) : t
      }, jt.padStart = function(t, n, r) {
        t = Ke(t);
        var e = (n = Ze(n)) ? P(t) : 0;
        return n &amp;&amp; n &gt; e ? jr(n - e, r) + t : t
      }, jt.parseInt = function(t, n, r) {
        return r || null == n ? n = 0 : n &amp;&amp; (n = +n), t = Ke(t).replace(at, ""), Vu(t, n || (gt.test(t) ? 16 : 10))
      }, jt.random = function(t, n, r) {
        if (r &amp;&amp; typeof r != "boolean" &amp;&amp; Zr(t, n, r) &amp;&amp; (n = r = q), r === q &amp;&amp; (typeof n == "boolean" ? (r = n, n = q) : typeof t == "boolean" &amp;&amp; (r = t, t = q)), t === q &amp;&amp; n === q ? (t = 0, n = 1) : (t = qe(t) || 0, n === q ? (n = t,
            t = 0) : n = qe(n) || 0), t &gt; n) {
          var e = t;
          t = n, n = e
        }
        return r || t % 1 || n % 1 ? (r = Ku(), qu(t + r * (n - t + Pt("1e-" + ((r + "").length - 1))), n)) : $n(t, n)
      }, jt.reduce = function(t, n, r) {
        var e = oi(t) ? s : x,
          u = 3 &gt; arguments.length;
        return e(t, Rr(n, 4), r, u, _o)
      }, jt.reduceRight = function(t, n, r) {
        var e = oi(t) ? h : x,
          u = 3 &gt; arguments.length;
        return e(t, Rr(n, 4), r, u, vo)
      }, jt.repeat = function(t, n, r) {
        return n = (r ? Zr(t, n, r) : n === q) ? 1 : Ze(n), Fn(Ke(t), n)
      }, jt.replace = function() {
        var t = arguments,
          n = Ke(t[0]);
        return 3 &gt; t.length ? n : Gu.call(n, t[1], t[2])
      }, jt.result = function(t, n, r) {
        n = Tr(n, t) ? [n] : Xn(n);
        var e = -1,
          u = n.length;
        for (u || (t = q, u = 1); ++e &lt; u;) {
          var o = null == t ? q : t[n[e]];
          o === q &amp;&amp; (e = u, o = r), t = Se(o) ? o.call(t) : o
        }
        return t
      }, jt.round = qi, jt.runInContext = T, jt.sample = function(t) {
        t = ke(t) ? t : nu(t);
        var n = t.length;
        return n &gt; 0 ? t[$n(0, n - 1)] : q
      }, jt.size = function(t) {
        if (null == t) return 0;
        if (ke(t)) {
          var n = t.length;
          return n &amp;&amp; De(t) ? P(t) : n
        }
        return Le(t) &amp;&amp; (n = Mr(t), "[object Map]" == n || "[object Set]" == n) ? t.size : He(t).length
      }, jt.snakeCase = Oi, jt.some = function(t, n, r) {
        var e = oi(t) ? p : Zn;
        return r &amp;&amp; Zr(t, n, r) &amp;&amp; (n = q), e(t, Rr(n, 3))
      }, jt.sortedIndex = function(t, n) {
        return Tn(t, n)
      }, jt.sortedIndexBy = function(t, n, r) {
        return qn(t, n, Rr(r))
      }, jt.sortedIndexOf = function(t, n) {
        var r = t ? t.length : 0;
        if (r) {
          var e = Tn(t, n);
          if (r &gt; e &amp;&amp; we(t[e], n)) return e
        }
        return -1
      }, jt.sortedLastIndex = function(t, n) {
        return Tn(t, n, true)
      }, jt.sortedLastIndexBy = function(t, n, r) {
        return qn(t, n, Rr(r), true)
      }, jt.sortedLastIndexOf = function(t, n) {
        if (t &amp;&amp; t.length) {
          var r = Tn(t, n, true) - 1;
          if (we(t[r], n)) return r
        }
        return -1
      }, jt.startCase = ki, jt.startsWith = function(t, n, r) {
        return t = Ke(t), r = en(Ze(r), 0, t.length), t.lastIndexOf(n, r) == r;
      }, jt.subtract = Vi, jt.sum = function(t) {
        return t &amp;&amp; t.length ? m(t, iu) : 0
      }, jt.sumBy = function(t, n) {
        return t &amp;&amp; t.length ? m(t, Rr(n)) : 0
      }, jt.template = function(t, n, r) {
        var e = jt.templateSettings;
        r &amp;&amp; Zr(t, n, r) &amp;&amp; (n = q), t = Ke(t), n = ai({}, n, e, Jt), r = ai({}, n.imports, e.imports, Jt);
        var u, o, i = He(r),
          f = k(r, i),
          c = 0;
        r = n.interpolate || wt;
        var a = "__p+='";
        r = _u((n.escape || wt).source + "|" + r.source + "|" + (r === et ? _t : wt).source + "|" + (n.evaluate || wt).source + "|$", "g");
        var l = "sourceURL" in n ? "//# sourceURL=" + n.sourceURL + "\n" : "";
        if (t.replace(r, function(n, r, e, i, f, l) {
            return e || (e = i), a += t.slice(c, l).replace(At, C), r &amp;&amp; (u = true, a += "'+__e(" + r + ")+'"), f &amp;&amp; (o = true, a += "';" + f + ";\n__p+='"), e &amp;&amp; (a += "'+((__t=(" + e + "))==null?'':__t)+'"), c = l + n.length, n
          }), a += "';", (n = n.variable) || (a = "with(obj){" + a + "}"), a = (o ? a.replace(G, "") : a).replace(J, "$1").replace(Y, "$1;"), a = "function(" + (n || "obj") + "){" + (n ? "" : "obj||(obj={});") + "var __t,__p=''" + (u ? ",__e=_.escape" : "") + (o ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" : ";") + a + "return __p}", n = Si(function() {
            return Function(i, l + "return " + a).apply(q, f);
          }), n.source = a, Ie(n)) throw n;
        return n
      }, jt.times = function(t, n) {
        if (t = Ze(t), 1 &gt; t || t &gt; 9007199254740991) return [];
        var r = 4294967295,
          e = qu(t, 4294967295);
        for (n = Rr(n), t -= 4294967295, e = w(e, n); ++r &lt; t;) n(r);
        return e
      }, jt.toInteger = Ze, jt.toLength = Te, jt.toLower = function(t) {
        return Ke(t).toLowerCase()
      }, jt.toNumber = qe, jt.toSafeInteger = function(t) {
        return en(Ze(t), -9007199254740991, 9007199254740991)
      }, jt.toString = Ke, jt.toUpper = function(t) {
        return Ke(t).toUpperCase()
      }, jt.trim = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(at, "") : (n += "") ? (t = t.match(Rt),
          n = n.match(Rt), tr(t, E(t, n), I(t, n) + 1).join("")) : t : t
      }, jt.trimEnd = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(st, "") : (n += "") ? (t = t.match(Rt), n = I(t, n.match(Rt)) + 1, tr(t, 0, n).join("")) : t : t
      }, jt.trimStart = function(t, n, r) {
        return (t = Ke(t)) ? r || n === q ? t.replace(lt, "") : (n += "") ? (t = t.match(Rt), n = E(t, n.match(Rt)), tr(t, n).join("")) : t : t
      }, jt.truncate = function(t, n) {
        var r = 30,
          e = "...";
        if (Be(n)) var u = "separator" in n ? n.separator : u,
          r = "length" in n ? Ze(n.length) : r,
          e = "omission" in n ? Ke(n.omission) : e;
        t = Ke(t);
        var o = t.length;
        if (Bt.test(t)) var i = t.match(Rt),
          o = i.length;
        if (r &gt;= o) return t;
        if (o = r - P(e), 1 &gt; o) return e;
        if (r = i ? tr(i, 0, o).join("") : t.slice(0, o), u === q) return r + e;
        if (i &amp;&amp; (o += r.length - o), Ue(u)) {
          if (t.slice(o).search(u)) {
            var f = r;
            for (u.global || (u = _u(u.source, Ke(vt.exec(u)) + "g")), u.lastIndex = 0; i = u.exec(f);) var c = i.index;
            r = r.slice(0, c === q ? o : c)
          }
        } else t.indexOf(u, o) != o &amp;&amp; (u = r.lastIndexOf(u), u &gt; -1 &amp;&amp; (r = r.slice(0, u)));
        return r + e
      }, jt.unescape = function(t) {
        return (t = Ke(t)) &amp;&amp; X.test(t) ? t.replace(H, Z) : t
      }, jt.uniqueId = function(t) {
        var n = ++ju;
        return Ke(t) + n
      }, jt.upperCase = Ei, jt.upperFirst = Ii,
      jt.each = se, jt.eachRight = he, jt.first = re, cu(jt, function() {
        var t = {};
        return pn(jt, function(n, r) {
          xu.call(jt.prototype, r) || (t[r] = n)
        }), t
      }(), {
        chain: false
      }), jt.VERSION = "4.11.0", u("bind bindKey curry curryRight partial partialRight".split(" "), function(t) {
        jt[t].placeholder = jt
      }), u(["drop", "take"], function(t, n) {
        Et.prototype[t] = function(r) {
          var e = this.__filtered__;
          if (e &amp;&amp; !n) return new Et(this);
          r = r === q ? 1 : Tu(Ze(r), 0);
          var u = this.clone();
          return e ? u.__takeCount__ = qu(r, u.__takeCount__) : u.__views__.push({
            size: qu(r, 4294967295),
            type: t + (0 &gt; u.__dir__ ? "Right" : "")
          }), u
        }, Et.prototype[t + "Right"] = function(n) {
          return this.reverse()[t](n).reverse()
        }
      }), u(["filter", "map", "takeWhile"], function(t, n) {
        var r = n + 1,
          e = 1 == r || 3 == r;
        Et.prototype[t] = function(t) {
          var n = this.clone();
          return n.__iteratees__.push({
            iteratee: Rr(t, 3),
            type: r
          }), n.__filtered__ = n.__filtered__ || e, n
        }
      }), u(["head", "last"], function(t, n) {
        var r = "take" + (n ? "Right" : "");
        Et.prototype[t] = function() {
          return this[r](1).value()[0]
        }
      }), u(["initial", "tail"], function(t, n) {
        var r = "drop" + (n ? "" : "Right");
        Et.prototype[t] = function() {
          return this.__filtered__ ? new Et(this) : this[r](1)
        }
      }), Et.prototype.compact = function() {
        return this.filter(iu)
      }, Et.prototype.find = function(t) {
        return this.filter(t).head()
      }, Et.prototype.findLast = function(t) {
        return this.reverse().find(t)
      }, Et.prototype.invokeMap = je(function(t, n) {
        return typeof t == "function" ? new Et(this) : this.map(function(r) {
          return mn(r, t, n)
        })
      }), Et.prototype.reject = function(t) {
        return t = Rr(t, 3), this.filter(function(n) {
          return !t(n)
        })
      }, Et.prototype.slice = function(t, n) {
        t = Ze(t);
        var r = this;
        return r.__filtered__ &amp;&amp; (t &gt; 0 || 0 &gt; n) ? new Et(r) : (0 &gt; t ? r = r.takeRight(-t) : t &amp;&amp; (r = r.drop(t)), n !== q &amp;&amp; (n = Ze(n), r = 0 &gt; n ? r.dropRight(-n) : r.take(n - t)), r)
      }, Et.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse()
      }, Et.prototype.toArray = function() {
        return this.take(4294967295)
      }, pn(Et.prototype, function(t, n) {
        var r = /^(?:filter|find|map|reject)|While$/.test(n),
          e = /^(?:head|last)$/.test(n),
          u = jt[e ? "take" + ("last" == n ? "Right" : "") : n],
          o = e || /^find/.test(n);
        u &amp;&amp; (jt.prototype[n] = function() {
          function n(t) {
            return t = u.apply(jt, l([t], f)), e &amp;&amp; h ? t[0] : t
          }
          var i = this.__wrapped__,
            f = e ? [1] : arguments,
            c = i instanceof Et,
            a = f[0],
            s = c || oi(i);
          s &amp;&amp; r &amp;&amp; typeof a == "function" &amp;&amp; 1 != a.length &amp;&amp; (c = s = false);
          var h = this.__chain__,
            p = !!this.__actions__.length,
            a = o &amp;&amp; !h,
            c = c &amp;&amp; !p;
          return !o &amp;&amp; s ? (i = c ? i : new Et(this), i = t.apply(i, f), i.__actions__.push({
            func: ae,
            args: [n],
            thisArg: q
          }), new kt(i, h)) : a &amp;&amp; c ? t.apply(this, f) : (i = this.thru(n), a ? e ? i.value()[0] : i.value() : i)
        })
      }), u("pop push shift sort splice unshift".split(" "), function(t) {
        var n = gu[t],
          r = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
          e = /^(?:pop|shift)$/.test(t);
        jt.prototype[t] = function() {
          var t = arguments;
          if (e &amp;&amp; !this.__chain__) {
            var u = this.value();
            return n.apply(oi(u) ? u : [], t)
          }
          return this[r](function(r) {
            return n.apply(oi(r) ? r : [], t)
          })
        }
      }), pn(Et.prototype, function(t, n) {
        var r = jt[n];
        if (r) {
          var e = r.name + "";
          (oo[e] || (oo[e] = [])).push({
            name: n,
            func: r
          })
        }
      }), oo[yr(q, 2).name] = [{
        name: "wrapper",
        func: q
      }], Et.prototype.clone = function() {
        var t = new Et(this.__wrapped__);
        return t.__actions__ = or(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = or(this.__iteratees__),
          t.__takeCount__ = this.__takeCount__, t.__views__ = or(this.__views__), t
      }, Et.prototype.reverse = function() {
        if (this.__filtered__) {
          var t = new Et(this);
          t.__dir__ = -1, t.__filtered__ = true
        } else t = this.clone(), t.__dir__ *= -1;
        return t
      }, Et.prototype.value = function() {
        var t, n = this.__wrapped__.value(),
          r = this.__dir__,
          e = oi(n),
          u = 0 &gt; r,
          o = e ? n.length : 0;
        t = o;
        for (var i = this.__views__, f = 0, c = -1, a = i.length; ++c &lt; a;) {
          var l = i[c],
            s = l.size;
          switch (l.type) {
            case "drop":
              f += s;
              break;
            case "dropRight":
              t -= s;
              break;
            case "take":
              t = qu(t, f + s);
              break;
            case "takeRight":
              f = Tu(f, t - s)
          }
        }
        if (t = {
            start: f,
            end: t
          }, i = t.start, f = t.end, t = f - i, u = u ? f : i - 1, i = this.__iteratees__, f = i.length, c = 0, a = qu(t, this.__takeCount__), !e || 200 &gt; o || o == t &amp;&amp; a == t) return Jn(n, this.__actions__);
        e = [];
        t: for (; t-- &amp;&amp; a &gt; c;) {
          for (u += r, o = -1, l = n[u]; ++o &lt; f;) {
            var h = i[o],
              s = h.type,
              h = (0, h.iteratee)(l);
            if (2 == s) l = h;
            else if (!h) {
              if (1 == s) continue t;
              break t
            }
          }
          e[c++] = l
        }
        return e
      }, jt.prototype.at = Zo, jt.prototype.chain = function() {
        return ce(this)
      }, jt.prototype.commit = function() {
        return new kt(this.value(), this.__chain__)
      }, jt.prototype.next = function() {
        this.__values__ === q &amp;&amp; (this.__values__ = Pe(this.value()));
        var t = this.__index__ &gt;= this.__values__.length,
          n = t ? q : this.__values__[this.__index__++];
        return {
          done: t,
          value: n
        }
      }, jt.prototype.plant = function(t) {
        for (var n, r = this; r instanceof Ot;) {
          var e = Xr(r);
          e.__index__ = 0, e.__values__ = q, n ? u.__wrapped__ = e : n = e;
          var u = e,
            r = r.__wrapped__
        }
        return u.__wrapped__ = t, n
      }, jt.prototype.reverse = function() {
        var t = this.__wrapped__;
        return t instanceof Et ? (this.__actions__.length &amp;&amp; (t = new Et(this)), t = t.reverse(), t.__actions__.push({
          func: ae,
          args: [oe],
          thisArg: q
        }), new kt(t, this.__chain__)) : this.thru(oe)
      }, jt.prototype.toJSON = jt.prototype.valueOf = jt.prototype.value = function() {
        return Jn(this.__wrapped__, this.__actions__)
      }, Lu &amp;&amp; (jt.prototype[Lu] = le), jt
  }
  var q, V = 1 / 0,
    K = NaN,
    G = /\b__p\+='';/g,
    J = /\b(__p\+=)''\+/g,
    Y = /(__e\(.*?\)|\b__t\))\+'';/g,
    H = /&amp;(?:amp|lt|gt|quot|#39|#96);/g,
    Q = /[&amp;&lt;&gt;"'`]/g,
    X = RegExp(H.source),
    tt = RegExp(Q.source),
    nt = /&lt;%-([\s\S]+?)%&gt;/g,
    rt = /&lt;%([\s\S]+?)%&gt;/g,
    et = /&lt;%=([\s\S]+?)%&gt;/g,
    ut = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    ot = /^\w*$/,
    it = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g,
    ft = /[\\^$.*+?()[\]{}|]/g,
    ct = RegExp(ft.source),
    at = /^\s+|\s+$/g,
    lt = /^\s+/,
    st = /\s+$/,
    ht = /[a-zA-Z0-9]+/g,
    pt = /\\(\\)?/g,
    _t = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
    vt = /\w*$/,
    gt = /^0x/i,
    dt = /^[-+]0x[0-9a-f]+$/i,
    yt = /^0b[01]+$/i,
    bt = /^\[object .+?Constructor\]$/,
    xt = /^0o[0-7]+$/i,
    jt = /^(?:0|[1-9]\d*)$/,
    mt = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,
    wt = /($^)/,
    At = /['\n\r\u2028\u2029\\]/g,
    Ot = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?)*",
    kt = "(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])" + Ot,
    Et = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]?|[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",
    It = RegExp("['\u2019]", "g"),
    St = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", "g"),
    Rt = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Et + Ot, "g"),
    Wt = RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2018\\u2019\\u201c\\u201d \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d+", kt].join("|"), "g"),
    Bt = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),
    Lt = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
    Ct = "Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise Reflect RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),
    Mt = {};
  Mt["[object Float32Array]"] = Mt["[object Float64Array]"] = Mt["[object Int8Array]"] = Mt["[object Int16Array]"] = Mt["[object Int32Array]"] = Mt["[object Uint8Array]"] = Mt["[object Uint8ClampedArray]"] = Mt["[object Uint16Array]"] = Mt["[object Uint32Array]"] = true, Mt["[object Arguments]"] = Mt["[object Array]"] = Mt["[object ArrayBuffer]"] = Mt["[object Boolean]"] = Mt["[object DataView]"] = Mt["[object Date]"] = Mt["[object Error]"] = Mt["[object Function]"] = Mt["[object Map]"] = Mt["[object Number]"] = Mt["[object Object]"] = Mt["[object RegExp]"] = Mt["[object Set]"] = Mt["[object String]"] = Mt["[object WeakMap]"] = false;
  var zt = {};
  zt["[object Arguments]"] = zt["[object Array]"] = zt["[object ArrayBuffer]"] = zt["[object DataView]"] = zt["[object Boolean]"] = zt["[object Date]"] = zt["[object Float32Array]"] = zt["[object Float64Array]"] = zt["[object Int8Array]"] = zt["[object Int16Array]"] = zt["[object Int32Array]"] = zt["[object Map]"] = zt["[object Number]"] = zt["[object Object]"] = zt["[object RegExp]"] = zt["[object Set]"] = zt["[object String]"] = zt["[object Symbol]"] = zt["[object Uint8Array]"] = zt["[object Uint8ClampedArray]"] = zt["[object Uint16Array]"] = zt["[object Uint32Array]"] = true,
    zt["[object Error]"] = zt["[object Function]"] = zt["[object WeakMap]"] = false;
  var Ut = {
      "\xc0": "A",
      "\xc1": "A",
      "\xc2": "A",
      "\xc3": "A",
      "\xc4": "A",
      "\xc5": "A",
      "\xe0": "a",
      "\xe1": "a",
      "\xe2": "a",
      "\xe3": "a",
      "\xe4": "a",
      "\xe5": "a",
      "\xc7": "C",
      "\xe7": "c",
      "\xd0": "D",
      "\xf0": "d",
      "\xc8": "E",
      "\xc9": "E",
      "\xca": "E",
      "\xcb": "E",
      "\xe8": "e",
      "\xe9": "e",
      "\xea": "e",
      "\xeb": "e",
      "\xcc": "I",
      "\xcd": "I",
      "\xce": "I",
      "\xcf": "I",
      "\xec": "i",
      "\xed": "i",
      "\xee": "i",
      "\xef": "i",
      "\xd1": "N",
      "\xf1": "n",
      "\xd2": "O",
      "\xd3": "O",
      "\xd4": "O",
      "\xd5": "O",
      "\xd6": "O",
      "\xd8": "O",
      "\xf2": "o",
      "\xf3": "o",
      "\xf4": "o",
      "\xf5": "o",
      "\xf6": "o",
      "\xf8": "o",
      "\xd9": "U",
      "\xda": "U",
      "\xdb": "U",
      "\xdc": "U",
      "\xf9": "u",
      "\xfa": "u",
      "\xfb": "u",
      "\xfc": "u",
      "\xdd": "Y",
      "\xfd": "y",
      "\xff": "y",
      "\xc6": "Ae",
      "\xe6": "ae",
      "\xde": "Th",
      "\xfe": "th",
      "\xdf": "ss"
    },
    Dt = {
      "&amp;": "&amp;amp;",
      "&lt;": "&amp;lt;",
      "&gt;": "&amp;gt;",
      '"': "&amp;quot;",
      "'": "&amp;#39;",
      "`": "&amp;#96;"
    },
    $t = {
      "&amp;amp;": "&amp;",
      "&amp;lt;": "&lt;",
      "&amp;gt;": "&gt;",
      "&amp;quot;": '"',
      "&amp;#39;": "'",
      "&amp;#96;": "`"
    },
    Ft = {
      "function": true,
      object: true
    },
    Nt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    },
    Pt = parseFloat,
    Zt = parseInt,
    Tt = Ft[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType ? exports : q,
    qt = Ft[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType ? module : q,
    Vt = qt &amp;&amp; qt.exports === Tt ? Tt : q,
    Kt = S(Ft[typeof self] &amp;&amp; self),
    Gt = S(Ft[typeof window] &amp;&amp; window),
    Jt = S(Ft[typeof this] &amp;&amp; this),
    Yt = S(Tt &amp;&amp; qt &amp;&amp; typeof global == "object" &amp;&amp; global) || Gt !== (Jt &amp;&amp; Jt.window) &amp;&amp; Gt || Kt || Jt || Function("return this")(),
    Ht = T();
  (Gt || Kt || {})._ = Ht, typeof define == "function" &amp;&amp; typeof define.amd == "object" &amp;&amp; define.amd ? define(function() {
    return Ht
  }) : Tt &amp;&amp; qt ? (Vt &amp;&amp; ((qt.exports = Ht)._ = Ht),
    Tt._ = Ht) : Yt._ = Ht
}).call(this);
/*! RESOURCE: /scripts/libs/ocLazyLoad.min.js */
/**
 * oclazyload - Load modules on demand (lazy load) with angularJS
 * @version v1.0.9
 * @link https://github.com/ocombe/ocLazyLoad
 * @license MIT
 * @author Olivier Combe &lt;olivier.combe@gmail.com&gt;
 */
! function(e, n) {
  "use strict";
  var r = ["ng", "oc.lazyLoad"],
    o = {},
    t = [],
    i = [],
    a = [],
    s = [],
    u = e.noop,
    c = {},
    l = [],
    d = e.module("oc.lazyLoad", ["ng"]);
  d.provider("$ocLazyLoad", ["$controllerProvider", "$provide", "$compileProvider", "$filterProvider", "$injector", "$animateProvider", function(d, f, p, m, v, y) {
    function L(n, o, t) {
      if (o) {
        var i, s, d, f = [];
        for (i = o.length - 1; i &gt;= 0; i--)
          if (s = o[i], e.isString(s) || (s = E(s)), s &amp;&amp; -1 === l.indexOf(s) &amp;&amp; (!w[s] || -1 !== a.indexOf(s))) {
            var h = -1 === r.indexOf(s);
            if (d = g(s), h &amp;&amp; (r.push(s), L(n, d.requires, t)), d._runBlocks.length &gt; 0)
              for (c[s] = []; d._runBlocks.length &gt; 0;) c[s].push(d._runBlocks.shift());
            e.isDefined(c[s]) &amp;&amp; (h || t.rerun) &amp;&amp; (f = f.concat(c[s])), j(n, d._invokeQueue, s, t.reconfig), j(n, d._configBlocks, s, t.reconfig), u(h ? "ocLazyLoad.moduleLoaded" : "ocLazyLoad.moduleReloaded", s), o.pop(), l.push(s)
          }
        var p = n.getInstanceInjector();
        e.forEach(f, function(e) {
          p.invoke(e)
        })
      }
    }

    function $(n, r) {
      function t(n, r) {
        var o, t = !0;
        return r.length &amp;&amp; (o = i(n), e.forEach(r, function(e) {
          t = t &amp;&amp; i(e) !== o
        })), t
      }

      function i(n) {
        return e.isArray(n) ? M(n.toString()) : e.isObject(n) ? M(S(n)) : e.isDefined(n) &amp;&amp; null !== n ? M(n.toString()) : n
      }
      var a = n[2][0],
        s = n[1],
        c = !1;
      e.isUndefined(o[r]) &amp;&amp; (o[r] = {}), e.isUndefined(o[r][s]) &amp;&amp; (o[r][s] = {});
      var l = function(e, n) {
        o[r][s].hasOwnProperty(e) || (o[r][s][e] = []), t(n, o[r][s][e]) &amp;&amp; (c = !0, o[r][s][e].push(n), u("ocLazyLoad.componentLoaded", [r, s, e]))
      };
      if (e.isString(a)) l(a, n[2][1]);
      else {
        if (!e.isObject(a)) return !1;
        e.forEach(a, function(n, r) {
          e.isString(n) ? l(n, a[1]) : l(r, n)
        })
      }
      return c
    }

    function j(n, r, o, i) {
      if (r) {
        var a, s, u, c;
        for (a = 0, s = r.length; s &gt; a; a++)
          if (u = r[a], e.isArray(u)) {
            if (null !== n) {
              if (!n.hasOwnProperty(u[0])) throw new Error("unsupported provider " + u[0]);
              c = n[u[0]]
            }
            var l = $(u, o);
            if ("invoke" !== u[1]) l &amp;&amp; e.isDefined(c) &amp;&amp; c[u[1]].apply(c, u[2]);
            else {
              var d = function(n) {
                var r = t.indexOf(o + "-" + n);
                (-1 === r || i) &amp;&amp; (-1 === r &amp;&amp; t.push(o + "-" + n), e.isDefined(c) &amp;&amp; c[u[1]].apply(c, u[2]))
              };
              if (e.isFunction(u[2][0])) d(u[2][0]);
              else if (e.isArray(u[2][0]))
                for (var f = 0, h = u[2][0].length; h &gt; f; f++) e.isFunction(u[2][0][f]) &amp;&amp; d(u[2][0][f])
            }
          }
      }
    }

    function E(n) {
      var r = null;
      return e.isString(n) ? r = n : e.isObject(n) &amp;&amp; n.hasOwnProperty("name") &amp;&amp; e.isString(n.name) &amp;&amp; (r = n.name), r
    }

    function _(n) {
      if (!e.isString(n)) return !1;
      try {
        return g(n)
      } catch (r) {
        if (/No module/.test(r) || r.message.indexOf("$injector:nomod") &gt; -1) return !1
      }
    }
    var w = {},
      O = {
        $controllerProvider: d,
        $compileProvider: p,
        $filterProvider: m,
        $provide: f,
        $injector: v,
        $animateProvider: y
      },
      x = !1,
      b = !1,
      z = [],
      D = {};
    z.push = function(e) {
      -1 === this.indexOf(e) &amp;&amp; Array.prototype.push.apply(this, arguments)
    }, this.config = function(n) {
      e.isDefined(n.modules) &amp;&amp; (e.isArray(n.modules) ? e.forEach(n.modules, function(e) {
        w[e.name] = e
      }) : w[n.modules.name] = n.modules), e.isDefined(n.debug) &amp;&amp; (x = n.debug), e.isDefined(n.events) &amp;&amp; (b = n.events)
    }, this._init = function(o) {
      if (0 === i.length) {
        var t = [o],
          a = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"],
          u = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/,
          c = function(e) {
            return e &amp;&amp; t.push(e)
          };
        e.forEach(a, function(n) {
          a[n] = !0, c(document.getElementById(n)), n = n.replace(":", "\\:"), "undefined" != typeof o[0] &amp;&amp; o[0].querySelectorAll &amp;&amp; (e.forEach(o[0].querySelectorAll("." + n), c), e.forEach(o[0].querySelectorAll("." + n + "\\:"), c), e.forEach(o[0].querySelectorAll("[" + n + "]"), c))
        }), e.forEach(t, function(n) {
          if (0 === i.length) {
            var r = " " + o.className + " ",
              t = u.exec(r);
            t ? i.push((t[2] || "").replace(/\s+/g, ",")) : e.forEach(n.attributes, function(e) {
              0 === i.length &amp;&amp; a[e.name] &amp;&amp; i.push(e.value)
            })
          }
        })
      }
      0 !== i.length || (n.jasmine || n.mocha) &amp;&amp; e.isDefined(e.mock) || console.error("No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.");
      var l = function d(n) {
        if (-1 === r.indexOf(n)) {
          r.push(n);
          var o = e.module(n);
          j(null, o._invokeQueue, n), j(null, o._configBlocks, n), e.forEach(o.requires, d)
        }
      };
      e.forEach(i, function(e) {
        l(e)
      }), i = [], s.pop()
    };
    var S = function(n) {
        try {
          return JSON.stringify(n)
        } catch (r) {
          var o = [];
          return JSON.stringify(n, function(n, r) {
            if (e.isObject(r) &amp;&amp; null !== r) {
              if (-1 !== o.indexOf(r)) return;
              o.push(r)
            }
            return r
          })
        }
      },
      M = function(e) {
        var n, r, o, t = 0;
        if (0 == e.length) return t;
        for (n = 0, o = e.length; o &gt; n; n++) r = e.charCodeAt(n), t = (t &lt;&lt; 5) - t + r, t |= 0;
        return t
      };
    this.$get = ["$log", "$rootElement", "$rootScope", "$cacheFactory", "$q", function(n, t, a, c, d) {
      function f(e) {
        var r = d.defer();
        return n.error(e.message), r.reject(e), r.promise
      }
      var p, m = c("ocLazyLoad");
      return x || (n = {}, n.error = e.noop, n.warn = e.noop, n.info = e.noop), O.getInstanceInjector = function() {
        return p ? p : p = t.data("$injector") || e.injector()
      }, u = function(e, r) {
        b &amp;&amp; a.$broadcast(e, r), x &amp;&amp; n.info(e, r)
      }, {
        _broadcast: u,
        _$log: n,
        _getFilesCache: function() {
          return m
        },
        toggleWatch: function(e) {
          e ? s.push(!0) : s.pop()
        },
        getModuleConfig: function(n) {
          if (!e.isString(n)) throw new Error("You need to give the name of the module to get");
          return w[n] ? e.copy(w[n]) : null
        },
        setModuleConfig: function(n) {
          if (!e.isObject(n)) throw new Error("You need to give the module config object to set");
          return w[n.name] = n, n
        },
        getModules: function() {
          return r
        },
        isLoaded: function(n) {
          var o = function(e) {
            var n = r.indexOf(e) &gt; -1;
            return n || (n = !!_(e)), n
          };
          if (e.isString(n) &amp;&amp; (n = [n]), e.isArray(n)) {
            var t, i;
            for (t = 0, i = n.length; i &gt; t; t++)
              if (!o(n[t])) return !1;
            return !0
          }
          throw new Error("You need to define the module(s) name(s)")
        },
        _getModuleName: E,
        _getModule: function(e) {
          try {
            return g(e)
          } catch (n) {
            throw (/No module/.test(n) || n.message.indexOf("$injector:nomod") &gt; -1) &amp;&amp; (n.message = 'The module "' + S(e) + '" that you are trying to load does not exist. ' + n.message), n
          }
        },
        moduleExists: _,
        _loadDependencies: function(n, r) {
          var o, t, i, a = [],
            s = this;
          if (n = s._getModuleName(n), null === n) return d.when();
          try {
            o = s._getModule(n)
          } catch (u) {
            return f(u)
          }
          return t = s.getRequires(o), e.forEach(t, function(o) {
            if (e.isString(o)) {
              var t = s.getModuleConfig(o);
              if (null === t) return void z.push(o);
              o = t, t.name = void 0
            }
            if (s.moduleExists(o.name)) return i = o.files.filter(function(e) {
              return s.getModuleConfig(o.name).files.indexOf(e) &lt; 0
            }), 0 !== i.length &amp;&amp; s._$log.warn('Module "', n, '" attempted to redefine configuration for dependency. "', o.name, '"\n Additional Files Loaded:', i), e.isDefined(s.filesLoader) ? void a.push(s.filesLoader(o, r).then(function() {
              return s._loadDependencies(o)
            })) : f(new Error("Error: New dependencies need to be loaded from external files (" + o.files + "), but no loader has been defined."));
            if (e.isArray(o)) {
              var u = [];
              e.forEach(o, function(e) {
                var n = s.getModuleConfig(e);
                null === n ? u.push(e) : n.files &amp;&amp; (u = u.concat(n.files))
              }), u.length &gt; 0 &amp;&amp; (o = {
                files: u
              })
            } else e.isObject(o) &amp;&amp; o.hasOwnProperty("name") &amp;&amp; o.name &amp;&amp; (s.setModuleConfig(o), z.push(o.name));
            if (e.isDefined(o.files) &amp;&amp; 0 !== o.files.length) {
              if (!e.isDefined(s.filesLoader)) return f(new Error('Error: the module "' + o.name + '" is defined in external files (' + o.files + "), but no loader has been defined."));
              a.push(s.filesLoader(o, r).then(function() {
                return s._loadDependencies(o)
              }))
            }
          }), d.all(a)
        },
        inject: function(n) {
          var r = arguments.length &lt;= 1 || void 0 === arguments[1] ? {} : arguments[1],
            o = arguments.length &lt;= 2 || void 0 === arguments[2] ? !1 : arguments[2],
            t = this,
            a = d.defer();
          if (e.isDefined(n) &amp;&amp; null !== n) {
            if (e.isArray(n)) {
              var s = [];
              return e.forEach(n, function(e) {
                s.push(t.inject(e, r, o))
              }), d.all(s)
            }
            t._addToLoadList(t._getModuleName(n), !0, o)
          }
          if (i.length &gt; 0) {
            var u = i.slice(),
              c = function f(e) {
                z.push(e), D[e] = a.promise, t._loadDependencies(e, r).then(function() {
                  try {
                    l = [], L(O, z, r)
                  } catch (e) {
                    return t._$log.error(e.message), void a.reject(e)
                  }
                  i.length &gt; 0 ? f(i.shift()) : a.resolve(u)
                }, function(e) {
                  a.reject(e)
                })
              };
            c(i.shift())
          } else {
            if (r &amp;&amp; r.name &amp;&amp; D[r.name]) return D[r.name];
            a.resolve()
          }
          return a.promise
        },
        getRequires: function(n) {
          var o = [];
          return e.forEach(n.requires, function(e) {
            -1 === r.indexOf(e) &amp;&amp; o.push(e)
          }), o
        },
        _invokeQueue: j,
        _registerInvokeList: $,
        _register: L,
        _addToLoadList: h,
        _unregister: function(n) {
          e.isDefined(n) &amp;&amp; e.isArray(n) &amp;&amp; e.forEach(n, function(e) {
            o[e] = void 0
          })
        }
      }
    }], this._init(e.element(n.document))
  }]);
  var f = e.bootstrap;
  e.bootstrap = function(n, r, o) {
    return e.forEach(r.slice(), function(e) {
      h(e, !0, !0)
    }), f(n, r, o)
  };
  var h = function(n, r, o) {
      (s.length &gt; 0 || r) &amp;&amp; e.isString(n) &amp;&amp; -1 === i.indexOf(n) &amp;&amp; (i.push(n), o &amp;&amp; a.push(n))
    },
    g = e.module;
  e.module = function(e, n, r) {
    return h(e, !1, !0), g(e, n, r)
  }, "undefined" != typeof module &amp;&amp; "undefined" != typeof exports &amp;&amp; module.exports === exports &amp;&amp; (module.exports = "oc.lazyLoad")
}(angular, window),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").directive("ocLazyLoad", ["$ocLazyLoad", "$compile", "$animate", "$parse", "$timeout", function(n, r, o, t, i) {
    return {
      restrict: "A",
      terminal: !0,
      priority: 1e3,
      compile: function(i, a) {
        var s = i[0].innerHTML;
        return i.html(""),
          function(i, a, u) {
            var c = t(u.ocLazyLoad);
            i.$watch(function() {
              return c(i) || u.ocLazyLoad
            }, function(t) {
              e.isDefined(t) &amp;&amp; n.load(t).then(function() {
                o.enter(s, a), r(a.contents())(i)
              })
            }, !0)
          }
      }
    }
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", "$window", "$interval", function(n, r, o, t) {
      var i = !1,
        a = !1,
        s = o.document.getElementsByTagName("head")[0] || o.document.getElementsByTagName("body")[0];
      return n.buildElement = function(u, c, l) {
        var d, f, h = r.defer(),
          g = n._getFilesCache(),
          p = function(e) {
            var n = (new Date).getTime();
            return e.indexOf("?") &gt;= 0 ? "&amp;" === e.substring(0, e.length - 1) ? e + "_dc=" + n : e + "&amp;_dc=" + n : e + "?_dc=" + n
          };
        switch (e.isUndefined(g.get(c)) &amp;&amp; g.put(c, h.promise), u) {
          case "css":
            d = o.document.createElement("link"), d.type = "text/css", d.rel = "stylesheet", d.href = l.cache === !1 ? p(c) : c;
            break;
          case "js":
            d = o.document.createElement("script"), d.src = l.cache === !1 ? p(c) : c;
            break;
          default:
            g.remove(c), h.reject(new Error('Requested type "' + u + '" is not known. Could not inject "' + c + '"'))
        }
        d.onload = d.onreadystatechange = function(e) {
          d.readyState &amp;&amp; !/^c|loade/.test(d.readyState) || f || (d.onload = d.onreadystatechange = null, f = 1, n._broadcast("ocLazyLoad.fileLoaded", c), h.resolve())
        }, d.onerror = function() {
          g.remove(c), h.reject(new Error("Unable to load " + c))
        }, d.async = l.serie ? 0 : 1;
        var m = s.lastChild;
        if (l.insertBefore) {
          var v = e.element(e.isDefined(window.jQuery) ? l.insertBefore : document.querySelector(l.insertBefore));
          v &amp;&amp; v.length &gt; 0 &amp;&amp; (m = v[0])
        }
        if (m.parentNode.insertBefore(d, m), "css" == u) {
          if (!i) {
            var y = o.navigator.userAgent.toLowerCase();
            if (/iP(hone|od|ad)/.test(o.navigator.platform)) {
              var L = o.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                $ = parseFloat([parseInt(L[1], 10), parseInt(L[2], 10), parseInt(L[3] || 0, 10)].join("."));
              a = 6 &gt; $
            } else if (y.indexOf("android") &gt; -1) {
              var j = parseFloat(y.slice(y.indexOf("android") + 8));
              a = 4.4 &gt; j
            } else if (y.indexOf("safari") &gt; -1) {
              var E = y.match(/version\/([\.\d]+)/i);
              a = E &amp;&amp; E[1] &amp;&amp; parseFloat(E[1]) &lt; 6
            }
          }
          if (a) var _ = 1e3,
            w = t(function() {
              try {
                d.sheet.cssRules, t.cancel(w), d.onload()
              } catch (e) {
                --_ &lt;= 0 &amp;&amp; d.onerror()
              }
            }, 20)
        }
        return h.promise
      }, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.filesLoader = function(o) {
        var t = arguments.length &lt;= 1 || void 0 === arguments[1] ? {} : arguments[1],
          i = [],
          a = [],
          s = [],
          u = [],
          c = null,
          l = n._getFilesCache();
        n.toggleWatch(!0), e.extend(t, o);
        var d = function(r) {
          var o, d = null;
          if (e.isObject(r) &amp;&amp; (d = r.type, r = r.path), c = l.get(r), e.isUndefined(c) || t.cache === !1) {
            if (null !== (o = /^(css|less|html|htm|js)?(?=!)/.exec(r)) &amp;&amp; (d = o[1], r = r.substr(o[1].length + 1, r.length)), !d)
              if (null !== (o = /[.](css|less|html|htm|js)?((\?|#).*)?$/.exec(r))) d = o[1];
              else {
                if (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || !n.jsLoader.hasOwnProperty("requirejs")) return void n._$log.error("File type could not be determined. " + r);
                d = "js"
              }
            "css" !== d &amp;&amp; "less" !== d || -1 !== i.indexOf(r) ? "html" !== d &amp;&amp; "htm" !== d || -1 !== a.indexOf(r) ? "js" === d || -1 === s.indexOf(r) ? s.push(r) : n._$log.error("File type is not valid. " + r) : a.push(r) : i.push(r)
          } else c &amp;&amp; u.push(c)
        };
        if (t.serie ? d(t.files.shift()) : e.forEach(t.files, function(e) {
            d(e)
          }), i.length &gt; 0) {
          var f = r.defer();
          n.cssLoader(i, function(r) {
            e.isDefined(r) &amp;&amp; n.cssLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), f.reject(r)) : f.resolve()
          }, t), u.push(f.promise)
        }
        if (a.length &gt; 0) {
          var h = r.defer();
          n.templatesLoader(a, function(r) {
            e.isDefined(r) &amp;&amp; n.templatesLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), h.reject(r)) : h.resolve()
          }, t), u.push(h.promise)
        }
        if (s.length &gt; 0) {
          var g = r.defer();
          n.jsLoader(s, function(r) {
            e.isDefined(r) &amp;&amp; (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || n.jsLoader.hasOwnProperty("requirejs")) ? (n._$log.error(r), g.reject(r)) : g.resolve()
          }, t), u.push(g.promise)
        }
        if (0 === u.length) {
          var p = r.defer(),
            m = "Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.";
          return n._$log.error(m), p.reject(m), p.promise
        }
        return t.serie &amp;&amp; t.files.length &gt; 0 ? r.all(u).then(function() {
          return n.filesLoader(o, t)
        }) : r.all(u)["finally"](function(e) {
          return n.toggleWatch(!1), e
        })
      }, n.load = function(o) {
        var t, i = arguments.length &lt;= 1 || void 0 === arguments[1] ? {} : arguments[1],
          a = this,
          s = null,
          u = [],
          c = r.defer(),
          l = e.copy(o),
          d = e.copy(i);
        if (e.isArray(l)) return e.forEach(l, function(e) {
          u.push(a.load(e, d))
        }), r.all(u).then(function(e) {
          c.resolve(e)
        }, function(e) {
          c.reject(e)
        }), c.promise;
        if (e.isString(l) ? (s = a.getModuleConfig(l), s || (s = {
            files: [l]
          })) : e.isObject(l) &amp;&amp; (s = e.isDefined(l.path) &amp;&amp; e.isDefined(l.type) ? {
            files: [l]
          } : a.setModuleConfig(l)), null === s) {
          var f = a._getModuleName(l);
          return t = 'Module "' + (f || "unknown") + '" is not configured, cannot load.', n._$log.error(t), c.reject(new Error(t)), c.promise
        }
        e.isDefined(s.template) &amp;&amp; (e.isUndefined(s.files) &amp;&amp; (s.files = []), e.isString(s.template) ? s.files.push(s.template) : e.isArray(s.template) &amp;&amp; s.files.concat(s.template));
        var h = e.extend({}, d, s);
        return e.isUndefined(s.files) &amp;&amp; e.isDefined(s.name) &amp;&amp; n.moduleExists(s.name) ? n.inject(s.name, h, !0) : (n.filesLoader(s, h).then(function() {
          n.inject(null, h).then(function(e) {
            c.resolve(e)
          }, function(e) {
            c.reject(e)
          })
        }, function(e) {
          c.reject(e)
        }), c.promise)
      }, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.cssLoader = function(o, t, i) {
        var a = [];
        e.forEach(o, function(e) {
          a.push(n.buildElement("css", e, i))
        }), r.all(a).then(function() {
          t()
        }, function(e) {
          t(e)
        })
      }, n.cssLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$q", function(n, r) {
      return n.jsLoader = function(o, t, i) {
        var a = [];
        e.forEach(o, function(e) {
          a.push(n.buildElement("js", e, i))
        }), r.all(a).then(function() {
          t()
        }, function(e) {
          t(e)
        })
      }, n.jsLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular),
function(e) {
  "use strict";
  e.module("oc.lazyLoad").config(["$provide", function(n) {
    n.decorator("$ocLazyLoad", ["$delegate", "$templateCache", "$q", "$http", function(n, r, o, t) {
      return n.templatesLoader = function(i, a, s) {
        var u = [],
          c = n._getFilesCache();
        return e.forEach(i, function(n) {
          var i = o.defer();
          u.push(i.promise), t.get(n, s).success(function(o) {
            e.isString(o) &amp;&amp; o.length &gt; 0 &amp;&amp; e.forEach(e.element(o), function(e) {
              "SCRIPT" === e.nodeName &amp;&amp; "text/ng-template" === e.type &amp;&amp; r.put(e.id, e.innerHTML)
            }), e.isUndefined(c.get(n)) &amp;&amp; c.put(n, !0), i.resolve()
          }).error(function(e) {
            i.reject(new Error('Unable to load template file "' + n + '": ' + e))
          })
        }), o.all(u).then(function() {
          a()
        }, function(e) {
          a(e)
        })
      }, n.templatesLoader.ocLazyLoadLoader = !0, n
    }])
  }])
}(angular), Array.prototype.indexOf || (Array.prototype.indexOf = function(e, n) {
  var r;
  if (null == this) throw new TypeError('"this" is null or not defined');
  var o = Object(this),
    t = o.length &gt;&gt;&gt; 0;
  if (0 === t) return -1;
  var i = +n || 0;
  if (Math.abs(i) === 1 / 0 &amp;&amp; (i = 0), i &gt;= t) return -1;
  for (r = Math.max(i &gt;= 0 ? i : t - Math.abs(i), 0); t &gt; r;) {
    if (r in o &amp;&amp; o[r] === e) return r;
    r++
  }
  return -1
});
/*! RESOURCE: /scripts/snm/cabrillo/js_includes_cabrillo.js */
/*! RESOURCE: /scripts/snm/cabrillo/core.js */
(function(window, undefined) {
  'use strict';
  var cabrillo = {
    isNative: isNative,
    postMethod: postMethod,
    callMethod: callMethod,
    receiveMethod: receiveMethod,
    EXPORT_NAME: 'snmCabrillo',
    CLIENT_EXPORT_NAME: 'CabrilloClient',
    PACKAGE: 'com.servicenow.cabrillo',
    DEBUG: true,
    extend: extend,
    copyValues: copyValues,
    log: log,
    q: QInterface()
  };
  window[cabrillo.EXPORT_NAME] = cabrillo;
  var CabrilloClient = window[cabrillo.CLIENT_EXPORT_NAME];
  var cabrilloClientConfig = {
    isNative: true,
    acceptObjects: false,
    supportedMethods: null
  };
  if (typeof CabrilloClient === 'undefined') {
    CabrilloClient = _getIOSClient();
    if (!CabrilloClient) {
      CabrilloClient = _getWebClient();
    }
  }
  (function() {
    var clientConfig = CabrilloClient.getConfig();
    if (!clientConfig) {
      return;
    }
    if (typeof clientConfig === 'string') {
      clientConfig = JSON.parse(clientConfig);
    }
    extend(cabrilloClientConfig, clientConfig);
  })();
  var _methods = null;
  if (cabrilloClientConfig.supportedMethods) {
    _methods = {};
    cabrilloClientConfig.supportedMethods.forEach(function(name) {
      _methods[name] = true;
    });
  }

  function _getIOSClient() {
    var webkit = window.webkit;
    var _nativeMethod = webkit &amp;&amp; webkit.messageHandlers ? webkit.messageHandlers[cabrillo.PACKAGE + '.camera.getBarcode'] : undefined;
    if (typeof _nativeMethod === 'undefined') {
      return;
    }
    var _client = {
      getConfig: function() {
        return {
          acceptObjects: true,
          supportedMethods: null
        };
      },
      hasMethod: function(name) {
        var method = webkit ? webkit.messageHandlers[name] : undefined;
        return (typeof method !== 'undefined');
      },
      postMethod: function(name, data) {
        if (!_client.hasMethod(name)) {
          log('Missing method: ' + name);
          return;
        }
        var method = webkit.messageHandlers[name];
        method.postMessage(data);
      }
    };
    return _client;
  }

  function _getWebClient() {
    return {
      getConfig: function() {
        return {
          isNative: false,
          acceptObjects: true,
          supportedMethods: []
        };
      },
      hasMethod: function() {
        return false;
      },
      postMethod: function() {}
    };
  }

  function isNative() {
    return cabrilloClientConfig.isNative;
  }

  function _hasMethod(name) {
    if (_methods) {
      return _methods[name];
    }
    if (CabrilloClient.hasMethod) {
      return CabrilloClient.hasMethod(name);
    }
    return false;
  }

  function extend(defaults, options, newObject) {
    var extended = newObject ? {} : defaults;
    var prop;
    for (prop in defaults) {
      if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
        extended[prop] = defaults[prop];
      }
    }
    for (prop in options) {
      if (Object.prototype.hasOwnProperty.call(options, prop)) {
        extended[prop] = options[prop];
      }
    }
    return extended;
  }

  function copyValues(dest, source) {
    for (var prop in source) {
      if (Object.prototype.hasOwnProperty.call(source, prop)) {
        switch (typeof source[prop]) {
          case 'function':
            break;
          default:
            dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }

  function log(msg) {
    if (!cabrillo.DEBUG) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('(Cabrillo)');
    console.log.apply(console, args);
  }

  function postMethod(name, data) {
    if (!cabrilloClientConfig.acceptObjects) {
      data = JSON.stringify(data);
    }
    CabrilloClient.postMethod(name, data);
  }
  var _callId = 0;
  var _openCalls = {};

  function callMethod(name, data, context) {
    var defer = _getDeferred();
    if (!_hasMethod(name)) {
      var err = 'Missing method: ' + name;
      defer.reject(err);
      return defer.promise;
    }
    var callId = _callId++;
    var callbackContext = extend(context, {
      callId: callId
    }, true);
    var requestPayload = {
      callbackName: cabrillo.EXPORT_NAME + '.receiveMethod',
      callbackContext: callbackContext,
      options: data
    };
    _openCalls[callId] = {
      defer: defer
    };
    postMethod(name, requestPayload);
    return defer.promise;
  }

  function receiveMethod(data) {
    if (!cabrilloClientConfig.acceptObjects) {
      data = JSON.parse(data);
    }
    var context = data.callbackContext;
    var openCall = _openCalls[context.callId];
    if (!openCall) {
      log('No open call found for request', data);
      return
    }
    delete context.callId;
    openCall.defer.resolve(data);
    delete _openCalls[context.callId];
  }

  function _getDeferred() {
    return cabrillo.q.defer();
  }

  function QInterface() {
    return {
      defer: function() {
        return new QDeferred();
      },
      reject: function() {
        return false;
      }
    };
  };

  function QDeferred() {
    var dones = [];
    var fails = [];
    var state = null;
    var payload = null;
    this.promise = {
      then: function(done, fail) {
        dones.push(done);
        fails.push(fail);
        notify();
        return this;
      }
    };
    this.resolve = function(data) {
      if (state) {
        return;
      }
      state = 'done';
      payload = data;
      notify();
    };
    this.reject = function(reason) {
      if (state) {
        return;
      }
      state = 'fail';
      payload = reason;
      notify();
    };

    function notify() {
      switch (state) {
        case 'done':
          dones.forEach(function(done) {
            if (done) {
              payload = done.call(done, payload);
            }
          });
          dones = [];
          fails = [];
          break;
        case 'fail':
          fails.forEach(function(fail) {
            if (fail) {
              payload = fail.call(fail, payload);
            }
          });
          dones = [];
          fails = [];
          break;
        default:
      }
    }
  }
})(window);;
/*! RESOURCE: /scripts/snm/cabrillo/attachments.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'attachments';
  cabrillo.extend(cabrillo, {
    attachments: {
      addFile: addFile,
      viewFile: viewFile
    }
  });
  var ADD_ATTACHMENTS_URL = '/angular.do?sysparm_type=ngk_attachments&amp;action=add&amp;load_attachment_record=true';

  function addFile(tableName, sysID, params, options) {
    var uploadParams = cabrillo.extend({
      attachments_modified: 'true',
      sysparm_table: tableName,
      sysparm_sys_id: sysID,
      sysparm_nostack: 'yes',
      sysparm_encryption_context: ''
    }, params || {});
    var apiPath = ADD_ATTACHMENTS_URL + '&amp;sys_id=' + sysID + '&amp;table=' + tableName;
    options = options || {};
    return callMethod('addFile', {
      apiPath: apiPath,
      params: uploadParams,
      uploadParamName: 'attachFile',
      sourceRect: options.sourceRect,
      maxWidth: options.maxWidth,
      maxHeight: options.maxHeight,
      jpgQuality: options.jpgQuality
    }).then(function(response) {
      return response.results;
    });
  }

  function viewFile(attachment, sourceRect, sourceBase64) {
    return callMethod('viewFile', {
      attachment: {
        sys_id: attachment.sys_id,
        content_type: attachment.content_type,
        file_name: attachment.file_name,
        sys_updated_on: attachment.sys_updated_on,
        path: attachment.sys_id + '.iix',
        thumbnail_path: attachment.thumbSrc
      },
      sourceRect: sourceRect,
      sourceBase64: sourceBase64
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/camera.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'camera';
  cabrillo.extend(cabrillo, {
    camera: {
      getBarcode: getBarcode
    }
  });

  function getBarcode() {
    return callMethod('getBarcode').then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('Failed to get barcode value:', err);
      return cabrillo.q.reject(err);
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/debug.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'debug';
  cabrillo.extend(cabrillo, {
    debug: {
      log: log
    }
  });

  function log(message) {
    cabrillo.log(message);
    callMethod('log', {
      message: message
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/form.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'form';
  cabrillo.extend(cabrillo, {
    form: {
      didChangeRecord: didChangeRecord
    }
  });

  function didChangeRecord(isNewRecord, tableName, sysId) {
    if (isNewRecord) {
      didCreateRecord(tableName, sysId);
    } else {
      didUpdateRecord(tableName, sysId);
    }
  }

  function didCreateRecord(tableName, sysId) {
    callMethod('didCreateRecord', {
      table: tableName,
      sysId: sysId
    });
  }

  function didUpdateRecord(tableName, sysId) {
    callMethod('didUpdateRecord', {
      table: tableName,
      sysId: sysId
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/geolocation.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'geolocation';
  cabrillo.extend(cabrillo, {
    geolocation: {
      getCurrentLocation: getCurrentLocation
    }
  });

  function getCurrentLocation() {
    return callMethod('getCurrentLocation').then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('Failed to get geolocation value:', err);
      return cabrillo.q.reject(err);
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/list.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'list';
  cabrillo.extend(cabrillo, {
    list: {
      selectItem: selectItem,
      selectItems: selectItems
    }
  });

  function selectItem(title, tableName, query, selectedItem, params) {
    var _selectedItem;
    if (selectedItem) {
      _selectedItem = {
        value: selectedItem.value,
        displayValue: selectedItem.displayValue
      };
    }
    return callMethod('selectItem', {
      title: title,
      table: tableName,
      query: query,
      selectedItem: _selectedItem,
      params: params
    }).then(function(data) {
      cabrillo.log('selectItem response', arguments);
      return data.results;
    });
  }

  function selectItems(title, tableName, query, selectedItems, params) {
    return callMethod('selectItems', {
      title: title,
      table: tableName,
      query: query,
      selectedItems: selectedItems,
      params: params
    }).then(function(data) {
      cabrillo.log('selectItems response', arguments);
      return data.results;
    });
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/modal.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'modal';
  cabrillo.extend(cabrillo, {
    modal: {
      MODAL_PRESENTATION_STYLE_FULL_SCREEN: 'fullScreen',
      MODAL_PRESENTATION_STYLE_FORM_SHEET: 'formSheet',
      CLOSE_BUTTON_STYLE_CANCEL: 'cancel',
      CLOSE_BUTTON_STYLE_CLOSE: 'close',
      presentModal: presentModal,
      dismissModal: dismissModal
    }
  });

  function presentModal(title, url, closeButtonStyle, modalPresentationStyle) {
    return callMethod('presentModal', {
      title: title,
      url: url,
      closeButtonStyle: closeButtonStyle ? closeButtonStyle : null,
      modalPresentationStyle: modalPresentationStyle ? modalPresentationStyle : null
    }).then(function(data) {
      return data.results;
    }, function(err) {
      cabrillo.log('presentModal error: ' + err);
    });
  }

  function dismissModal(data, redirect) {
    return callMethod('dismissModal', {
      results: {
        results: data,
        redirect: redirect
      }
    });
  }

  function callMethod(methodName, data, context) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data, context);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/navigation.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'navigation';
  cabrillo.extend(cabrillo, {
    navigation: {
      goto: goto,
      goBack: goBack
    }
  });

  function goto(uri, params) {
    params = params || {};
    return callMethod('goto', {
      uri: uri,
      table: params.table,
      sysId: params.sysId,
      query: params.query
    });
  }

  function goBack() {
    callMethod('goBack');
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/viewLayout.js */
(function(window, cabrillo, undefined) {
  'use strict';
  var PACKAGE = 'viewLayout';
  cabrillo.extend(cabrillo, {
    'viewLayout': {
      MORE_MENU_BUTTON_STYLE: 'moreMenuButtonStyle',
      SUCCESS_SPINNER_STYLE: 'successStyle',
      setTitle: setTitle,
      setNavigationBarButtons: setNavigationBarButtons,
      setBottomButtons: setBottomButtons,
      showSpinner: showSpinner,
      hideSpinner: hideSpinner,
      executeCallback: executeCallback
    }
  });
  var _callbackHandlers = {};
  var _callbackHandlerId = 0;

  function setTitle(title) {
    return callMethod('setTitle', {
      title: title
    });
  }

  function setNavigationBarButtons(buttons, execute) {
    var externalHandler = _registerCallbackHandler('registerNavigationBarButtons', buttons, execute);
    return callMethod('setNavigationBarButtons', {
      buttons: externalHandler.payloads
    }).then(function() {
      return externalHandler;
    }, function() {
      externalHandler();
    });
  }

  function setBottomButtons(buttons, execute) {
    var externalHandler = _registerCallbackHandler('registerBottomButtons', buttons, execute);
    return callMethod('setBottomButtons', {
      buttons: externalHandler.payloads
    }).then(function() {
      return externalHandler;
    }, function() {
      externalHandler();
    });
  }

  function showSpinner(options) {
    options = options || {};
    var mask = options.mask;
    var maskColor = options.maskColor;
    callMethod('showSpinner', {
      mask: !!mask,
      maskColor: maskColor
    });
  }

  function hideSpinner(spinnerStyle) {
    callMethod('hideSpinner', {
      dismissStyle: spinnerStyle
    });
  }

  function executeCallback(handlerPayload) {
    var callbackContext = handlerPayload.callbackContext;
    var handler = _callbackHandlers[callbackContext.className];
    if (!handler || (handler.id !== callbackContext.id)) {
      cabrillo.log('Handler not found');
      return;
    }
    var activeElement = document.activeElement;
    if (activeElement) {
      activeElement.blur();
    }
    handler.executeCallback(callbackContext.payloadId);
  }

  function _registerCallbackHandler(handlerClass, payloads, executeCallback) {
    if (!handlerClass) {
      throw 'Handler class must be specified';
    }
    if (!payloads) {
      payloads = [];
    }
    _unregisterCallbackHandler(handlerClass);
    var handlerPayloads = [];
    var handlerId = _callbackHandlerId++;
    payloads.forEach(function(payload, payloadIndex) {
      var callbackName = cabrillo.EXPORT_NAME + '.' + PACKAGE + '.executeCallback';
      var handlerPayload = {
        callbackName: callbackName,
        callbackContext: {
          id: handlerId,
          className: handlerClass,
          payloadId: payloadIndex
        }
      };
      handlerPayload = cabrillo.copyValues(handlerPayload, payload);
      handlerPayload.callbackScript = callbackName + '(' + JSON.stringify(handlerPayload) + ')';
      handlerPayloads.push(handlerPayload);
    });
    var handler = function() {
      var handler = _callbackHandlers[handlerClass];
      if (handler &amp;&amp; handler === this) {
        handler.payloads = null;
        handler.executeCallback = null;
        delete _callbackHandlers[handlerClass];
      }
    };
    handler.id = handlerId;
    handler.className = handlerClass;
    handler.payloads = handlerPayloads;
    handler.executeCallback = function() {
      var handlerPayload = arguments;
      var d = cabrillo.q.defer();
      d.promise.then(function() {
        executeCallback.apply(this, handlerPayload);
      });
      d.resolve();
    };
    _callbackHandlers[handlerClass] = handler;
    return handler;
  }

  function _unregisterCallbackHandler(handler) {
    var className = typeof handler === 'string' ? handler : handler.className;
    if (_callbackHandlers[className]) {
      _callbackHandlers[className]();
    }
  }

  function callMethod(methodName, data) {
    return cabrillo.callMethod(cabrillo.PACKAGE + '.' + PACKAGE + '.' + methodName, data);
  }
})(window, window['snmCabrillo']);;
/*! RESOURCE: /scripts/snm/cabrillo/angular/cabrillo.factory.js */
if (typeof angular !== 'undefined') {
  'use strict';
  angular.module('snm.cabrillo', []).factory('cabrillo', function($window, $q) {
    var cabrillo = $window['snmCabrillo'];
    cabrillo.q = $q;
    return cabrillo;
  });
};;
/*! RESOURCE: /scripts/sn/common/glide/js_includes_glide.js */
/*! RESOURCE: /scripts/sn/common/glide/_module.js */
angular.module('sn.common.glide', [
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/sn/common/glide/factory.glideUrlBuilder.js */
angular.module('sn.common.glide').factory('glideUrlBuilder', ['$window', function($window) {
  "use strict";

  function GlideUrl(contextPath) {
    var objDef = {
      contextPath: '',
      params: {},
      encodedString: '',
      encode: true,
      setFromCurrent: function() {
        this.setFromString($window.location.href);
      },
      setFromString: function(href) {
        var pos = href.indexOf('?');
        if (pos &lt; 0) {
          this.contextPath = href;
          return;
        }
        this.contextPath = href.slice(0, pos);
        var hashes = href.slice(pos + 1).split('&amp;');
        var i = hashes.length;
        while (i--) {
          var pos = hashes[i].indexOf('=');
          this.params[hashes[i].substring(0, pos)] = hashes[i].substring(++pos);
        }
      },
      setContextPath: function(c) {
        this.contextPath = c;
      },
      getParam: function(p) {
        return this.params[p];
      },
      getParams: function() {
        return this.params;
      },
      addParam: function(name, value) {
        this.params[name] = value;
        return this;
      },
      addToken: function() {
        if (typeof g_ck != 'undefined' &amp;&amp; g_ck != "")
          this.addParam('sysparm_ck', g_ck);
        return this;
      },
      deleteParam: function(name) {
        delete this.params[name];
      },
      addEncodedString: function(s) {
        if (!s)
          return;
        if (s.substr(0, 1) != "&amp;")
          this.encodedString += "&amp;";
        this.encodedString += s;
        return this;
      },
      getQueryString: function(additionalParams) {
        var qs = this._getParamsForURL(this.params);
        qs += this._getParamsForURL(additionalParams);
        qs += this.encodedString;
        if (qs.length == 0)
          return "";
        return qs.substring(1);
      },
      _getParamsForURL: function(params) {
        if (!params)
          return '';
        var url = '';
        for (var n in params) {
          var p = params[n] || '';
          url += '&amp;' + n + '=' + (this.encode ? encodeURIComponent(p + '') : p);
        }
        return url;
      },
      getURL: function(additionalParams) {
        var url = this.contextPath;
        var qs = this.getQueryString(additionalParams);
        if (qs)
          url += "?" + qs;
        return url;
      },
      setEncode: function(b) {
        this.encode = b;
      },
      toString: function() {
        return 'GlideURL';
      }
    }
    return objDef;
  }
  return {
    newGlideUrl: function(contextPath) {
      var glideUrl = new GlideUrl();
      glideUrl.setFromString(contextPath ? contextPath : '');
      return glideUrl;
    },
    refresh: function() {
      $window.location.replace($window.location.href);
    },
    getCancelableLink: function(link) {
      if ($window.NOW &amp;&amp; $window.NOW.g_cancelPreviousTransaction) {
        var nextChar = link.indexOf('?') &gt; -1 ? '&amp;' : '?';
        link += nextChar + "sysparm_cancelable=true";
      }
      return link;
    }
  };
}]);;
/*! RESOURCE: /scripts/sn/common/glide/service.queryFilter.js */
angular.module('sn.common.glide').factory('queryFilter', function() {
  "use strict";
  return {
    create: function() {
      var that = {};
      that.conditions = [];

      function newCondition(field, operator, value, label, displayValue, type) {
        var condition = {
          field: field,
          operator: operator,
          value: value,
          displayValue: displayValue,
          label: label,
          left: null,
          right: null,
          type: null,
          setValue: function(value, displayValue) {
            this.value = value;
            this.displayValue = displayValue ? displayValue : value;
          }
        };
        if (type)
          condition.type = type;
        return condition;
      }

      function addCondition(condition) {
        that.conditions.push(condition);
        return condition;
      }

      function removeCondition(condition) {
        for (var i = that.conditions.length - 1; i &gt;= 0; i--) {
          if (that.conditions[i] === condition)
            that.conditions.splice(i, 1);
        }
      }

      function getConditionsByField(conditions, field) {
        var conditionsToReturn = [];
        for (var condition in conditions) {
          if (conditions.hasOwnProperty(condition)) {
            if (conditions[condition].field == field)
              conditionsToReturn.push(conditions[condition]);
          }
        }
        return conditionsToReturn;
      }

      function encodeCondition(condition) {
        var output = "";
        if (condition.hasOwnProperty("left") &amp;&amp; condition.left) {
          output += encodeCondition(condition.left);
        }
        if (condition.hasOwnProperty("right") &amp;&amp; condition.right) {
          var right = encodeCondition(condition.right);
          if (right.length &gt; 0) {
            output += "^" + condition.type + right;
          }
        }
        if (condition.field) {
          output += condition.field;
          output += condition.operator;
          if (condition.value !== null &amp;&amp; typeof condition.value !== "undefined")
            output += condition.value;
        }
        return output;
      }

      function createEncodedQuery() {
        var eq = "";
        var ca = that.conditions;
        for (var i = 0; i &lt; ca.length; i++) {
          var condition = ca[i];
          if (eq.length)
            eq += '^';
          eq += encodeCondition(condition);
        }
        eq += "^EQ";
        return eq;
      }
      that.addCondition = addCondition;
      that.newCondition = newCondition;
      that.createEncodedQuery = createEncodedQuery;
      that.getConditionsByField = getConditionsByField;
      that.removeCondition = removeCondition;
      return that;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.filterExpressionParser.js */
angular.module('sn.common.glide').factory('filterExpressionParser', function() {
  'use strict';
  var operatorExpressions = [{
    wildcardExp: '(.*)',
    operator: 'STARTSWITH',
    toExpression: function(filter) {
      return filter;
    }
  }, {
    wildcardExp: '^\\*(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return (filter === '*' ? filter : '*' + filter);
    }
  }, {
    wildcardExp: '^\\.(.*)',
    operator: 'LIKE',
    toExpression: function(filter) {
      return '.' + filter;
    }
  }, {
    wildcardExp: '^%(.*)',
    operator: 'ENDSWITH',
    toExpression: function(filter) {
      return (filter === '%' ? filter : '%' + filter);
    }
  }, {
    wildcardExp: '(.*)%',
    operator: 'LIKE',
    toExpression: function(filter) {
      return filter + '%';
    }
  }, {
    wildcardExp: '^=(.*)',
    operator: '=',
    toExpression: function(filter) {
      return (filter === '=' ? filter : '=' + filter);
    }
  }, {
    wildcardExp: '^!\\*(.*)',
    operator: 'NOT LIKE',
    toExpression: function(filter) {
      return (filter === '!*' || filter === '!' ? filter : '!*' + filter);
    }
  }, {
    wildcardExp: '^!=(.*)',
    operator: '!=',
    toExpression: function(filter) {
      return (filter === '!=' || filter === '!' ? filter : '!=' + filter);
    }
  }];
  return {
    getOperatorExpressionForOperator: function(operator) {
      for (var i = 0; i &lt; operatorExpressions.length; i++) {
        var item = operatorExpressions[i];
        if (item.operator === operator)
          return item;
      }
      throw {
        name: 'OperatorNotSupported',
        message: 'The operator ' + operator + ' is not in the list of operatorExpressions.'
      };
    },
    parse: function(val, defaultOperator) {
      var parsedValue = {
        filterText: val,
        operator: defaultOperator || 'STARTSWITH'
      };
      for (var i = 1; i &lt; operatorExpressions.length; i++) {
        var operatorItem = operatorExpressions[i];
        var match = val.match(operatorItem.wildcardExp);
        if (match &amp;&amp; match[1] !== '') {
          parsedValue.operator = operatorItem.operator;
          parsedValue.filterText = match[1];
        }
      }
      return parsedValue;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.userPreferences.js */
angular.module('sn.common.glide').factory("userPreferences", function($http, $q, unwrappedHTTPPromise, urlTools) {
  "use strict";
  var preferencesCache = {};

  function getPreference(preferenceName) {
    if (preferenceName in preferencesCache)
      return preferencesCache[preferenceName];
    var targetURL = urlTools.getURL('user_preference', {
        "sysparm_pref_name": preferenceName,
        "sysparm_action": "get"
      }),
      deferred = $q.defer();
    $http.get(targetURL).success(function(response) {
      deferred.resolve(response.sysparm_pref_value);
    }).error(function(data, status) {
      deferred.reject("Error getting preference " + preferenceName + ": " + status);
    });
    preferencesCache[preferenceName] = deferred.promise;
    return deferred.promise;
  }

  function setPreference(preferenceName, preferenceValue) {
    var targetURL = urlTools.getURL('user_preference', {
      "sysparm_pref_name": preferenceName,
      "sysparm_action": "set",
      "sysparm_pref_value": "" + preferenceValue
    });
    var httpPromise = $http.get(targetURL);
    addToCache(preferenceName, preferenceValue);
    return unwrappedHTTPPromise(httpPromise);
  }

  function addToCache(preferenceName, preferenceValue) {
    preferencesCache[preferenceName] = $q.when(preferenceValue);
  }
  var userPreferences = {
    getPreference: getPreference,
    setPreference: setPreference,
    addToCache: addToCache
  };
  return userPreferences;
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowStream.js */
angular.module('sn.common.glide').constant('nowStreamTimerInterval', 5000);
angular.module('sn.common.glide').factory('nowStream', function($q, $timeout, urlTools, nowStreamTimerInterval, snResource, $log) {
  'use strict';
  var Stream = function() {
    this.initialize.apply(this, arguments);
  };
  Stream.prototype = {
    initialize: function(table, query, sys_id, processor, interval, source, includeAttachments) {
      this.table = table;
      this.query = query;
      this.sysparmQuery = null;
      this.sys_id = sys_id;
      this.processor = processor;
      this.lastTimestamp = 0;
      this.inflightRequest = null;
      this.requestImmediateUpdate = false;
      this.interval = interval;
      this.source = source;
      this.includeAttachments = includeAttachments;
      this.stopped = true;
    },
    setQuery: function(sysparmQuery) {
      this.sysparmQuery = sysparmQuery;
    },
    poll: function(callback, preRequestCallback) {
      this.callback = callback;
      this.preRequestCallback = preRequestCallback;
      this._stopPolling();
      this._startPolling();
    },
    tap: function() {
      if (!this.inflightRequest) {
        this._stopPolling();
        this._startPolling();
      } else
        this.requestImmediateUpdate = true;
    },
    insert: function(field, text) {
      this.insertForEntry(field, text, this.table, this.sys_id);
    },
    insertForEntry: function(field, text, table, sys_id) {
      return this.insertEntries([{
        field: field,
        text: text
      }], table, sys_id);
    },
    expandMentions: function(entryText, mentionIDMap) {
      return entryText.replace(/@\[(.+?)\]/gi, function(mention) {
        var mentionedName = mention.substring(2, mention.length - 1);
        if (mentionIDMap[mentionedName]) {
          return "@[" + mentionIDMap[mentionedName] + ":" + mentionedName + "]";
        } else {
          return mention;
        }
      });
    },
    insertEntries: function(entries, table, sys_id, mentionIDMap) {
      mentionIDMap = mentionIDMap || {};
      var sanitizedEntries = [];
      for (var i = 0; i &lt; entries.length; i++) {
        var entryText = entries[i].text;
        if (entryText &amp;&amp; entryText.endsWith('\n'))
          entryText = entryText.substring(0, entryText.length - 1);
        if (!entryText)
          continue;
        entries[i].text = this.expandMentions(entryText, mentionIDMap);
        sanitizedEntries.push(entries[i]);
      }
      if (sanitizedEntries.length === 0)
        return;
      this._isInserting = true;
      var url = this._getInsertURL(table, sys_id);
      var that = this;
      return snResource().post(url, {
        entries: sanitizedEntries
      }).then(this._successCallback.bind(this), function() {
        $log.warn('Error submitting entries', sanitizedEntries);
      }).then(function() {
        that._isInserting = false;
      });
    },
    cancel: function() {
      this._stopPolling();
    },
    _startPolling: function() {
      var interval = this._getInterval();
      var that = this;
      var successCallback = this._successCallback.bind(this);
      that.stopped = false;

      function runPoll() {
        if (that._isInserting) {
          establishNextRequest();
          return;
        }
        if (!that.inflightRequest) {
          that.inflightRequest = that._executeRequest();
          that.inflightRequest.then(successCallback);
          that.inflightRequest.finally(function() {
            that.inflightRequest = null;
            if (that.requestImmediateUpdate) {
              that.requestImmediateUpdate = false;
              establishNextRequest(0);
            } else {
              establishNextRequest();
            }
          });
        }
      }

      function establishNextRequest(intervalOverride) {
        if (that.stopped)
          return;
        intervalOverride = (parseFloat(intervalOverride) &gt;= 0) ? intervalOverride : interval;
        $timeout.cancel(that.timer);
        that.timer = $timeout(runPoll, intervalOverride);
      }
      runPoll();
    },
    _stopPolling: function() {
      if (this.timer)
        $timeout.cancel(this.timer);
      this.stopped = true;
    },
    _executeRequest: function() {
      var url = this._getURL();
      if (this.preRequestCallback) {
        this.preRequestCallback();
      }
      return snResource().get(url);
    },
    _getURL: function() {
      var params = {
        table: this.table,
        action: this._getAction(),
        sysparm_silent_request: true,
        sysparm_auto_request: true,
        sysparm_timestamp: this.lastTimestamp,
        include_attachments: this.includeAttachments
      };
      if (this.sys_id) {
        params['sys_id'] = this.sys_id;
      } else if (this.sysparmQuery) {
        params['sysparm_query'] = this.sysparmQuery;
      }
      var url = urlTools.getURL(this.processor, params);
      if (!this.sys_id) {
        url += "&amp;p=" + this.query;
      }
      return url;
    },
    _getInsertURL: function(table, sys_id) {
      return urlTools.getURL(this.processor, {
        action: 'insert',
        table: table,
        sys_id: sys_id,
        sysparm_timestamp: this.timestamp || 0,
        sysparm_source: this.source
      });
    },
    _successCallback: function(response) {
      var response = response.data;
      if (response.entries &amp;&amp; response.entries.length) {
        response.entries = this._filterOld(response.entries);
        if (response.entries.length &gt; 0) {
          this.lastEntry = angular.copy(response.entries[0]);
          this.lastTimestamp = response.sys_timestamp || response.entries[0].sys_timestamp;
        }
      }
      this.callback.call(null, response);
    },
    _filterOld: function(entries) {
      for (var i = 0; i &lt; entries.length; i++) {
        if (entries[i].sys_timestamp == this.lastTimestamp) {
          if (!angular.equals(this._makeComparable(entries[i]), this._makeComparable(this.lastEntry)))
            continue;
        }
        if (entries[i].sys_timestamp &lt;= this.lastTimestamp)
          return entries.slice(0, i);
      }
      return entries;
    },
    _makeComparable: function(entry) {
      var copy = angular.copy(entry);
      delete copy.short_description;
      delete copy.display_value;
      return copy;
    },
    _getAction: function() {
      return this.sys_id ? 'get_new_entries' : 'get_set_entries';
    },
    _getInterval: function() {
      if (this.interval)
        return this.interval;
      else if (window.NOW &amp;&amp; NOW.stream_poll_interval)
        return NOW.stream_poll_interval * 1000;
      else
        return nowStreamTimerInterval;
    }
  };
  return {
    create: function(table, query, sys_id, processor, interval, source) {
      return new Stream(table, query, sys_id, processor, interval, source);
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/glide/service.nowServer.js */
angular.module('sn.common.glide').factory('nowServer', function($http, $q, userPreferences, angularProcessorUrl, urlTools) {
  return {
    getBaseURL: function() {
      return angularProcessorUrl;
    },
    getPartial: function(scope, partial, parms, callback) {
      var url = this.getPartialURL(partial, parms);
      if (url === scope.url) {
        callback.call();
        return;
      }
      var fn = scope.$on('$includeContentLoaded', function() {
        fn.call();
        callback.call();
      });
      scope.url = url;
    },
    replaceView: function($location, newView) {
      var p = $location.path();
      var a = p.split("/");
      a[1] = newView;
      p = a.join("/");
      return p;
    },
    getPartialURL: urlTools.getPartialURL,
    getURL: urlTools.getURL,
    urlFor: urlTools.urlFor,
    getPropertyURL: urlTools.getPropertyURL,
    setPreference: userPreferences.setPreference,
    getPreference: userPreferences.getPreference
  }
});;;
/*! RESOURCE: /scripts/sn/common/util/js_includes_util.js */
/*! RESOURCE: /scripts/sn/common/util/_module.js */
angular.module('sn.common.util', ['sn.common.auth']);
angular.module('sn.util', ['sn.common.util']);;
/*! RESOURCE: /scripts/sn/common/util/service.dateUtils.js */
angular.module('sn.common.util').factory('dateUtils', function() {
  var dateUtils = {
    SYS_DATE_FORMAT: "yyyy-MM-dd",
    SYS_TIME_FORMAT: "HH:mm:ss",
    SYS_DATE_TIME_FORMAT: "yyyy-MM-dd HH:mm:ss",
    MONTH_NAMES: new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'),
    DAY_NAMES: new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'),
    LZ: function(x) {
      return (x &lt; 0 || x &gt; 9 ? "" : "0") + x
    },
    isDate: function(val, format) {
      var date = this.getDateFromFormat(val, format);
      if (date == 0) {
        return false;
      }
      return true;
    },
    compareDates: function(date1, dateformat1, date2, dateformat2) {
      var d1 = this.getDateFromFormat(date1, dateformat1);
      var d2 = this.getDateFromFormat(date2, dateformat2);
      if (d1 == 0 || d2 == 0) {
        return -1;
      } else if (d1 &gt; d2) {
        return 1;
      }
      return 0;
    },
    formatDateServer: function(date, format) {
      var ga = new GlideAjax("DateTimeUtils");
      ga.addParam("sysparm_name", "formatCalendarDate");
      var browserOffset = date.getTimezoneOffset() * 60000;
      var utcTime = date.getTime() - browserOffset;
      var userDateTime = utcTime - g_tz_offset;
      ga.addParam("sysparm_value", userDateTime);
      ga.getXMLWait();
      return ga.getAnswer();
    },
    formatDate: function(date, format) {
      if (format.indexOf("z") &gt; 0)
        return this.formatDateServer(date, format);
      format = format + "";
      var result = "";
      var i_format = 0;
      var c = "";
      var token = "";
      var y = date.getYear() + "";
      var M = date.getMonth() + 1;
      var d = date.getDate();
      var E = date.getDay();
      var H = date.getHours();
      var m = date.getMinutes();
      var s = date.getSeconds();
      var yyyy, yy, MMM, MM, dd, hh, h, mm, ss, ampm, HH, H, KK, K, kk, k;
      var value = new Object();
      value["M"] = M;
      value["MM"] = this.LZ(M);
      value["MMM"] = this.MONTH_NAMES[M + 11];
      value["NNN"] = this.MONTH_NAMES[M + 11];
      value["MMMM"] = this.MONTH_NAMES[M - 1];
      value["d"] = d;
      value["dd"] = this.LZ(d);
      value["E"] = this.DAY_NAMES[E + 7];
      value["EE"] = this.DAY_NAMES[E];
      value["H"] = H;
      value["HH"] = this.LZ(H);
      if (format.indexOf('w') != -1) {
        var wk = date.getWeek();
        if (wk &gt;= 52 &amp;&amp; M == 1) {
          y = date.getYear();
          y--;
          y = y + "";
        }
        if (wk == 1 &amp;&amp; M == 12) {
          y = date.getYear();
          y++;
          y = y + "";
        }
        value["w"] = wk;
        value["ww"] = this.LZ(wk);
      }
      var dayOfWeek = (7 + (E + 1) - (g_first_day_of_week - 1)) % 7;
      if (dayOfWeek == 0)
        dayOfWeek = 7;
      value["D"] = dayOfWeek;
      if (y.length &lt; 4) {
        y = "" + (y - 0 + 1900);
      }
      value["y"] = "" + y;
      value["yyyy"] = y;
      value["yy"] = y.substring(2, 4);
      if (H == 0) {
        value["h"] = 12;
      } else if (H &gt; 12) {
        value["h"] = H - 12;
      } else {
        value["h"] = H;
      }
      value["hh"] = this.LZ(value["h"]);
      if (H &gt; 11) {
        value["K"] = H - 12;
      } else {
        value["K"] = H;
      }
      value["k"] = H + 1;
      value["KK"] = this.LZ(value["K"]);
      value["kk"] = this.LZ(value["k"]);
      if (H &gt; 11) {
        value["a"] = "PM";
      } else {
        value["a"] = "AM";
      }
      value["m"] = m;
      value["mm"] = this.LZ(m);
      value["s"] = s;
      value["ss"] = this.LZ(s);
      while (i_format &lt; format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) &amp;&amp; (i_format &lt; format.length)) {
          token += format.charAt(i_format++);
        }
        if (value[token] != null) {
          result = result + value[token];
        } else {
          result = result + token;
        }
      }
      return result;
    },
    _isInteger: function(val) {
      var digits = "1234567890";
      for (var i = 0; i &lt; val.length; i++) {
        if (digits.indexOf(val.charAt(i)) == -1) {
          return false;
        }
      }
      return true;
    },
    _getInt: function(str, i, minlength, maxlength) {
      for (var x = maxlength; x &gt;= minlength; x--) {
        var token = str.substring(i, i + x);
        if (token.length &lt; minlength) {
          return null;
        }
        if (this._isInteger(token)) {
          return token;
        }
      }
      return null;
    },
    getDateFromFormat: function(val, format) {
      val = val + "";
      format = format + "";
      var i_val = 0;
      var i_format = 0;
      var c = "";
      var token = "";
      var token2 = "";
      var x, y;
      var now = new Date();
      var year = now.getYear();
      var month = now.getMonth() + 1;
      var date = 0;
      var hh = now.getHours();
      var mm = now.getMinutes();
      var ss = now.getSeconds();
      var ampm = "";
      var week = false;
      while (i_format &lt; format.length) {
        c = format.charAt(i_format);
        token = "";
        while ((format.charAt(i_format) == c) &amp;&amp; (i_format &lt; format.length)) {
          token += format.charAt(i_format++);
        }
        if (token == "yyyy" || token == "yy" || token == "y") {
          if (token == "yyyy") {
            x = 4;
            y = 4;
          }
          if (token == "yy") {
            x = 2;
            y = 2;
          }
          if (token == "y") {
            x = 2;
            y = 4;
          }
          year = this._getInt(val, i_val, x, y);
          if (year == null) {
            return 0;
          }
          i_val += year.length;
          if (year.length == 2) {
            if (year &gt; 70) {
              year = 1900 + (year - 0);
            } else {
              year = 2000 + (year - 0);
            }
          }
        } else if (token == "MMM" || token == "NNN") {
          month = 0;
          for (var i = 0; i &lt; this.MONTH_NAMES.length; i++) {
            var month_name = this.MONTH_NAMES[i];
            if (val.substring(i_val, i_val + month_name.length).toLowerCase() == month_name.toLowerCase()) {
              if (token == "MMM" || (token == "NNN" &amp;&amp; i &gt; 11)) {
                month = i + 1;
                if (month &gt; 12) {
                  month -= 12;
                }
                i_val += month_name.length;
                break;
              }
            }
          }
          if ((month &lt; 1) || (month &gt; 12)) {
            return 0;
          }
        } else if (token == "EE" || token == "E") {
          for (var i = 0; i &lt; this.DAY_NAMES.length; i++) {
            var day_name = this.DAY_NAMES[i];
            if (val.substring(i_val, i_val + day_name.length).toLowerCase() == day_name.toLowerCase()) {
              if (week) {
                if (i == 0 || i == 7)
                  date += 6;
                else if (i == 2 || i == 9)
                  date += 1;
                else if (i == 3 || i == 10)
                  date += 2;
                else if (i == 4 || i == 11)
                  date += 3;
                else if (i == 5 || i == 12)
                  date += 4;
                else if (i == 6 || i == 13)
                  date += 5;
              }
              i_val += day_name.length;
              break;
            }
          }
        } else if (token == "MM" || token == "M") {
          month = this._getInt(val, i_val, token.length, 2);
          if (month == null || (month &lt; 1) || (month &gt; 12)) {
            return 0;
          }
          i_val += month.length;
        } else if (token == "dd" || token == "d") {
          date = this._getInt(val, i_val, token.length, 2);
          if (date == null || (date &lt; 1) || (date &gt; 31)) {
            return 0;
          }
          i_val += date.length;
        } else if (token == "hh" || token == "h") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 1) || (hh &gt; 12)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "HH" || token == "H") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 0) || (hh &gt; 23)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "KK" || token == "K") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 0) || (hh &gt; 11)) {
            return 0;
          }
          i_val += hh.length;
        } else if (token == "kk" || token == "k") {
          hh = this._getInt(val, i_val, token.length, 2);
          if (hh == null || (hh &lt; 1) || (hh &gt; 24)) {
            return 0;
          }
          i_val += hh.length;
          hh--;
        } else if (token == "mm" || token == "m") {
          mm = this._getInt(val, i_val, token.length, 2);
          if (mm == null || (mm &lt; 0) || (mm &gt; 59)) {
            return 0;
          }
          i_val += mm.length;
        } else if (token == "ss" || token == "s") {
          ss = this._getInt(val, i_val, token.length, 2);
          if (ss == null || (ss &lt; 0) || (ss &gt; 59)) {
            return 0;
          }
          i_val += ss.length;
        } else if (token == "a") {
          if (val.substring(i_val, i_val + 2).toLowerCase() == "am") {
            ampm = "AM";
          } else if (val.substring(i_val, i_val + 2).toLowerCase() == "pm") {
            ampm = "PM";
          } else {
            return 0;
          }
          i_val += 2;
        } else if (token == "w" || token == "ww") {
          var weekNum = this._getInt(val, i_val, token.length, 2);
          week = true;
          if (weekNum != null) {
            var temp = new Date(year, 0, 1, 0, 0, 0);
            temp.setWeek(parseInt(weekNum, 10));
            year = temp.getFullYear();
            month = temp.getMonth() + 1;
            date = temp.getDate();
          }
          weekNum += "";
          i_val += weekNum.length;
        } else if (token == "D") {
          if (week) {
            var day = this._getInt(val, i_val, token.length, 1);
            if ((day == null) || (day &lt;= 0) || (day &gt; 7))
              return 0;
            var temp = new Date(year, month - 1, date, hh, mm, ss);
            var dayOfWeek = temp.getDay();
            day = parseInt(day, 10);
            day = (day + g_first_day_of_week - 1) % 7;
            if (day == 0)
              day = 7;
            day--;
            if (day &lt; dayOfWeek)
              day = 7 - (dayOfWeek - day);
            else
              day -= dayOfWeek;
            if (day &gt; 0) {
              temp.setDate(temp.getDate() + day);
              year = temp.getFullYear();
              month = temp.getMonth() + 1;
              date = temp.getDate();
            }
            i_val++;
          }
        } else if (token == "z")
          i_val += 3;
        else {
          if (val.substring(i_val, i_val + token.length) != token) {
            return 0;
          } else {
            i_val += token.length;
          }
        }
      }
      if (i_val != val.length) {
        return 0;
      }
      if (month == 2) {
        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) {
          if (date &gt; 29) {
            return 0;
          }
        } else {
          if (date &gt; 28) {
            return 0;
          }
        }
      }
      if ((month == 4) || (month == 6) || (month == 9) || (month == 11)) {
        if (date &gt; 30) {
          return 0;
        }
      }
      if (hh &lt; 12 &amp;&amp; ampm == "PM") {
        hh = hh - 0 + 12;
      } else if (hh &gt; 11 &amp;&amp; ampm == "AM") {
        hh -= 12;
      }
      var newdate = new Date(year, month - 1, date, hh, mm, ss);
      return newdate.getTime();
    },
    parseDate: function(val) {
      var preferEuro = (arguments.length == 2) ? arguments[1] : false;
      generalFormats = new Array('y-M-d', 'MMM d, y', 'MMM d,y', 'y-MMM-d', 'd-MMM-y', 'MMM d');
      monthFirst = new Array('M/d/y', 'M-d-y', 'M.d.y', 'MMM-d', 'M/d', 'M-d');
      dateFirst = new Array('d/M/y', 'd-M-y', 'd.M.y', 'd-MMM', 'd/M', 'd-M');
      yearFirst = new Array('yyyyw.F', 'yyw.F');
      var checkList = new Array('generalFormats', preferEuro ? 'dateFirst' : 'monthFirst', preferEuro ? 'monthFirst' : 'dateFirst', 'yearFirst');
      var d = null;
      for (var i = 0; i &lt; checkList.length; i++) {
        var l = window[checkList[i]];
        for (var j = 0; j &lt; l.length; j++) {
          d = this.getDateFromFormat(val, l[j]);
          if (d != 0) {
            return new Date(d);
          }
        }
      }
      return null;
    }
  };
  Date.prototype.getWeek = function() {
    var newYear = new Date(this.getFullYear(), 0, 1);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    day = (day &gt;= 0 ? day : day + 7);
    var dayNum = Math.floor((this.getTime() - newYear.getTime() - (this.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    var weekNum;
    if (day &lt; 4) {
      weekNum = Math.floor((dayNum + day - 1) / 7) + 1;
      if (weekNum &gt; 52)
        weekNum = this._checkNextYear(weekNum);
      return weekNum;
    }
    weekNum = Math.floor((dayNum + day - 1) / 7);
    if (weekNum &lt; 1)
      weekNum = this._lastWeekOfYear();
    else if (weekNum &gt; 52)
      weekNum = this._checkNextYear(weekNum);
    return weekNum;
  };
  Date.prototype._lastWeekOfYear = function() {
    var newYear = new Date(this.getFullYear() - 1, 0, 1);
    var endOfYear = new Date(this.getFullYear() - 1, 11, 31);
    var day = newYear.getDay() - (g_first_day_of_week - 1);
    var dayNum = Math.floor((endOfYear.getTime() - newYear.getTime() - (endOfYear.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
    return day &lt; 4 ? Math.floor((dayNum + day - 1) / 7) + 1 : Math.floor((dayNum + day - 1) / 7);
  };
  Date.prototype._checkNextYear = function() {
    var nYear = new Date(this.getFullYear() + 1, 0, 1);
    var nDay = nYear.getDay() - (g_first_day_of_week - 1);
    nDay = nDay &gt;= 0 ? nDay : nDay + 7;
    return nDay &lt; 4 ? 1 : 53;
  };
  Date.prototype.setWeek = function(weekNum) {
    weekNum--;
    var startOfYear = new Date(this.getFullYear(), 0, 1);
    var day = startOfYear.getDay() - (g_first_day_of_week - 1);
    if (day &gt; 0 &amp;&amp; day &lt; 4) {
      this.setFullYear(startOfYear.getFullYear() - 1);
      this.setDate(31 - day + 1);
      this.setMonth(11);
    } else if (day &gt; 3)
      this.setDate(startOfYear.getDate() + (7 - day));
    this.setDate(this.getDate() + (7 * weekNum));
  };
  return dateUtils;
});
/*! RESOURCE: /scripts/sn/common/util/service.debounceFn.js */
angular.module("sn.common.util").service("debounceFn", function() {
  "use strict";

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this,
        args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate &amp;&amp; !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
  return {
    debounce: debounce
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.unwrappedHTTPPromise.js */
angular.module('sn.common.util').factory("unwrappedHTTPPromise", function($q) {
  "use strict";

  function isGenericPromise(promise) {
    return (typeof promise.then === "function" &amp;&amp;
      promise.success === undefined &amp;&amp;
      promise.error === undefined);
  }
  return function(httpPromise) {
    if (isGenericPromise(httpPromise))
      return httpPromise;
    var deferred = $q.defer();
    httpPromise.success(function(data) {
      deferred.resolve(data);
    }).error(function(data, status) {
      deferred.reject({
        data: data,
        status: status
      })
    });
    return deferred.promise;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.urlTools.js */
angular.module('sn.common.util').constant('angularProcessorUrl', 'angular.do?sysparm_type=');
angular.module('sn.common.util').factory("urlTools", function(getTemplateUrl, angularProcessorUrl) {
  "use strict";

  function getPartialURL(name, parameters) {
    var url = getTemplateUrl(name);
    if (parameters) {
      if (typeof parameters !== 'string') {
        parameters = encodeURIParameters(parameters);
      }
      if (parameters.length) {
        url += "&amp;" + parameters;
      }
    }
    if (window.NOW &amp;&amp; window.NOW.ng_cache_defeat)
      url += "&amp;t=" + new Date().getTime();
    return url;
  }

  function getURL(name, parameters) {
    if (parameters &amp;&amp; typeof parameters === 'object')
      return urlFor(name, parameters);
    var url = angularProcessorUrl;
    url += name;
    if (parameters)
      url += "&amp;" + parameters;
    return url;
  }

  function urlFor(route, parameters) {
    var p = encodeURIParameters(parameters);
    return angularProcessorUrl + route + (p.length ? '&amp;' + p : '');
  }

  function getPropertyURL(name) {
    var url = angularProcessorUrl + "get_property&amp;name=" + name;
    url += "&amp;t=" + new Date().getTime();
    return url;
  }

  function encodeURIParameters(parameters) {
    var s = [];
    for (var parameter in parameters) {
      if (parameters.hasOwnProperty(parameter)) {
        var key = encodeURIComponent(parameter);
        var value = parameters[parameter] ? encodeURIComponent(parameters[parameter]) : '';
        s.push(key + "=" + value);
      }
    }
    return s.join('&amp;');
  }

  function parseQueryString(qs) {
    qs = qs || '';
    if (qs.charAt(0) === '?') {
      qs = qs.substr(1);
    }
    var a = qs.split('&amp;');
    if (a === "") {
      return {};
    }
    if (a &amp;&amp; a[0].indexOf('http') != -1)
      a[0] = a[0].split("?")[1];
    var b = {};
    for (var i = 0; i &lt; a.length; i++) {
      var p = a[i].split('=', 2);
      if (p.length == 1) {
        b[p[0]] = "";
      } else {
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
      }
    }
    return b;
  }
  return {
    getPartialURL: getPartialURL,
    getURL: getURL,
    urlFor: urlFor,
    getPropertyURL: getPropertyURL,
    encodeURIParameters: encodeURIParameters,
    parseQueryString: parseQueryString
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.getTemplateUrl.js */
angular.module('sn.common.util').provider('getTemplateUrl', function(angularProcessorUrl) {
  'use strict';
  var _handlerId = 0;
  var _handlers = {};
  this.registerHandler = function(handler) {
    var registeredId = _handlerId;
    _handlers[_handlerId] = handler;
    _handlerId++;
    return function() {
      delete _handlers[registeredId];
    };
  };
  this.$get = function() {
    return getTemplateUrl;
  };

  function getTemplateUrl(templatePath) {
    if (_handlerId &gt; 0) {
      var path;
      var handled = false;
      angular.forEach(_handlers, function(handler) {
        if (!handled) {
          var handlerPath = handler(templatePath);
          if (typeof handlerPath !== 'undefined') {
            path = handlerPath;
            handled = true;
          }
        }
      });
      if (handled) {
        return path;
      }
    }
    return angularProcessorUrl + 'get_partial&amp;name=' + templatePath;
  }
});;
/*! RESOURCE: /scripts/sn/common/util/service.snTabActivity.js */
angular.module("sn.common.util").service("snTabActivity", function($window, $timeout, $rootElement, $document) {
  "use strict";
  var activeEvents = ["keydown", "DOMMouseScroll", "mousewheel", "mousedown", "touchstart", "mousemove", "mouseenter", "input", "focus", "scroll"],
    defaultIdle = 75000,
    isPrimary = true,
    idleTime = 0,
    isVisible = true,
    idleTimeout = void(0),
    pageIdleTimeout = void(0),
    hasActed = false,
    appName = $rootElement.attr('ng-app') || "",
    storageKey = "sn.tabs." + appName + ".activeTab";
  var callbacks = {
    "tab.primary": [],
    "tab.secondary": [],
    "activity.active": [],
    "activity.idle": [{
      delay: defaultIdle,
      cb: function() {}
    }]
  };
  $window.tabGUID = $window.tabGUID || createGUID();

  function setAppName(an) {
    appName = an;
    storageKey = "sn.tabs." + appName + ".activeTab";
    makePrimary(true);
  }

  function createGUID(l) {
    l = l || 32;
    var strResult = '';
    while (strResult.length &lt; l)
      strResult += (((1 + Math.random() + new Date().getTime()) * 0x10000) | 0).toString(16).substring(1);
    return strResult.substr(0, l);
  }

  function ngObjectIndexOf(arr, obj) {
    for (var i = 0, len = arr.length; i &lt; len; i++)
      if (angular.equals(arr[i], obj))
        return i;
    return -1;
  }
  var detectedApi,
    apis = [{
      eventName: 'visibilitychange',
      propertyName: 'hidden'
    }, {
      eventName: 'mozvisibilitychange',
      propertyName: 'mozHidden'
    }, {
      eventName: 'msvisibilitychange',
      propertyName: 'msHidden'
    }, {
      eventName: 'webkitvisibilitychange',
      propertyName: 'webkitHidden'
    }];
  apis.some(function(api) {
    if (angular.isDefined($document[0][api.propertyName])) {
      detectedApi = api;
      return true;
    }
  });
  if (detectedApi)
    $document.on(detectedApi.eventName, function() {
      if (!$document[0][detectedApi.propertyName]) {
        makePrimary();
        isVisible = true;
      } else {
        if (!idleTimeout &amp;&amp; !idleTime)
          waitForIdle(0);
        isVisible = false;
      }
    });
  angular.element($window).on({
    "mouseleave": function(e) {
      var destination = angular.isUndefined(e.toElement) ? e.relatedTarget : e.toElement;
      if (destination === null &amp;&amp; $document[0].hasFocus()) {
        waitForIdle(0);
      }
    },
    "storage": function(e) {
      if (e.originalEvent.key !== storageKey)
        return;
      if ($window.localStorage.getItem(storageKey) !== $window.tabGUID)
        makeSecondary();
    }
  });

  function waitForIdle(index, delayOffset) {
    var callback = callbacks['activity.idle'][index];
    var numCallbacks = callbacks['activity.idle'].length;
    delayOffset = delayOffset || callback.delay;
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    angular.element($window).one(activeEvents.join(".snTabActivity "), setActive);
    if (index &gt;= numCallbacks)
      return;
    if (idleTimeout)
      $timeout.cancel(idleTimeout);
    idleTimeout = $timeout(function() {
      idleTime = callback.delay;
      callback.cb();
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
      angular.element($window).off(activeEvents.join(".snTabActivity "));
      angular.element($window).one(activeEvents.join(".snTabActivity "), setActive);
      for (var i = index + 1; i &lt; numCallbacks; i++) {
        var nextDelay = callbacks['activity.idle'][i].delay;
        if (nextDelay &lt;= callback.delay)
          callbacks['activity.idle'][i].cb();
        else {
          waitForIdle(i, nextDelay - callback.delay);
          break;
        }
      }
    }, delayOffset, false);
  }

  function setActive() {
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    if (idleTimeout) {
      $timeout.cancel(idleTimeout);
      idleTimeout = void(0);
    }
    var activeCallbacks = callbacks['activity.active'];
    activeCallbacks.some(function(callback) {
      if (callback.delay &lt;= idleTime)
        callback.cb();
      else
        return true;
    });
    idleTime = 0;
    makePrimary();
    if (pageIdleTimeout) {
      $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = void(0);
    }
    var minDelay = callbacks['activity.idle'][0].delay;
    hasActed = false;
    if (!pageIdleTimeout)
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
    listenForActivity();
  }

  function pageIdleHandler() {
    if (idleTimeout)
      return;
    var minDelay = callbacks['activity.idle'][0].delay;
    if (hasActed) {
      hasActed = false;
      if (pageIdleTimeout)
        $timeout.cancel(pageIdleTimeout);
      pageIdleTimeout = $timeout(pageIdleHandler, minDelay, false);
      listenForActivity();
      return;
    }
    var delayOffset = minDelay;
    if (callbacks['activity.idle'].length &gt; 1)
      delayOffset = callbacks['activity.idle'][1].delay - minDelay;
    idleTime = minDelay;
    callbacks['activity.idle'][0].cb();
    waitForIdle(1, delayOffset);
    pageIdleTimeout = void(0);
  }

  function listenForActivity() {
    angular.element($window).off(activeEvents.join(".snTabActivity "));
    angular.element($window).one(activeEvents.join(".snTabActivity "), onActivity);
    angular.element("#gsft_main").on("load.snTabActivity", function() {
      var src = angular.element(this).attr('src');
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = this.contentWindow ? this.contentWindow : this.contentDocument.defaultView;
        angular.element(iframeWindow).off(activeEvents.join(".snTabActivity "));
        angular.element(iframeWindow).one(activeEvents.join(".snTabActivity "), onActivity);
      }
    });
    angular.element('iframe').each(function(idx, iframe) {
      var src = angular.element(iframe).attr('src');
      if (!src)
        return;
      if (src.indexOf("/") == 0 || src.indexOf($window.location.origin) == 0 || src.indexOf('http') == -1) {
        var iframeWindow = iframe.contentWindow ? iframe.contentWindow : iframe.contentDocument.defaultView;
        angular.element(iframeWindow).off(activeEvents.join(".snTabActivity "));
        angular.element(iframeWindow).one(activeEvents.join(".snTabActivity "), onActivity);
      }
    });
  }

  function onActivity() {
    hasActed = true;
    makePrimary();
  }

  function makePrimary(initial) {
    var oldGuid = $window.localStorage.getItem(storageKey);
    isPrimary = true;
    isVisible = true;
    $timeout.cancel(idleTimeout);
    idleTimeout = void(0);
    if (canUseStorage() &amp;&amp; oldGuid !== $window.tabGUID &amp;&amp; !initial)
      for (var i = 0, len = callbacks["tab.primary"].length; i &lt; len; i++)
        callbacks["tab.primary"][i].cb();
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
    } catch (ignored) {}
    if (idleTime &amp;&amp; $document[0].hasFocus())
      setActive();
  }

  function makeSecondary() {
    isPrimary = false;
    isVisible = false;
    for (var i = 0, len = callbacks["tab.secondary"].length; i &lt; len; i++)
      callbacks["tab.secondary"][i].cb();
  }

  function registerCallback(event, callback, scope) {
    var cbObject = angular.isObject(callback) ? callback : {
      delay: defaultIdle,
      cb: callback
    };
    if (callbacks[event]) {
      callbacks[event].push(cbObject);
      callbacks[event].sort(function(a, b) {
        return a.delay - b.delay;
      })
    }

    function destroyCallback() {
      if (callbacks[event]) {
        var pos = ngObjectIndexOf(callbacks[event], cbObject);
        if (pos !== -1)
          callbacks[event].splice(pos, 1);
      }
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyCallback();
      });
    return destroyCallback;
  }

  function registerIdleCallback(options, onIdle, onReturn, scope) {
    var delay = options,
      onIdleDestroy,
      onReturnDestroy;
    if (angular.isObject(options)) {
      delay = options.delay;
      onIdle = options.onIdle || onIdle;
      onReturn = options.onReturn || onReturn;
      scope = options.scope || scope;
    }
    if (angular.isFunction(onIdle))
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: onIdle
      });
    else if (angular.isFunction(onReturn)) {
      onIdleDestroy = registerCallback("activity.idle", {
        delay: delay,
        cb: function() {}
      });
    }
    if (angular.isFunction(onReturn))
      onReturnDestroy = registerCallback("activity.active", {
        delay: delay,
        cb: onReturn
      });

    function destroyAll() {
      if (angular.isFunction(onIdleDestroy))
        onIdleDestroy();
      if (angular.isFunction(onReturnDestroy))
        onReturnDestroy();
    }
    if (scope)
      scope.$on("$destroy", function() {
        destroyAll();
      });
    return destroyAll;
  }

  function canUseStorage() {
    var canWe = false;
    try {
      $window.localStorage.setItem(storageKey, $window.tabGUID);
      canWe = true;
    } catch (ignored) {}
    return canWe;
  }
  makePrimary(true);
  listenForActivity();
  pageIdleTimeout = $timeout(pageIdleHandler, defaultIdle, false);
  return {
    on: registerCallback,
    onIdle: registerIdleCallback,
    setAppName: setAppName,
    get isPrimary() {
      return isPrimary;
    },
    get isIdle() {
      return idleTime &gt; 0;
    },
    get idleTime() {
      return idleTime;
    },
    get isVisible() {
      return isVisible;
    },
    get appName() {
      return appName;
    },
    get defaultIdleTime() {
      return defaultIdle
    },
    isActive: function() {
      return this.idleTime &lt; this.defaultIdleTime &amp;&amp; this.isVisible;
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/factory.ArraySynchronizer.js */
angular.module("sn.common.util").factory("ArraySynchronizer", function() {
  'use strict';

  function ArraySynchronizer() {}

  function index(key, arr) {
    var result = {};
    var keys = [];
    result.orderedKeys = keys;
    angular.forEach(arr, function(item) {
      var keyValue = item[key];
      result[keyValue] = item;
      keys.push(keyValue);
    });
    return result;
  }

  function sortByKeyAndModel(arr, key, model) {
    arr.sort(function(a, b) {
      var aIndex = model.indexOf(a[key]);
      var bIndex = model.indexOf(b[key]);
      if (aIndex &gt; bIndex)
        return 1;
      else if (aIndex &lt; bIndex)
        return -1;
      return 0;
    });
  }
  ArraySynchronizer.prototype = {
    add: function(syncField, dest, source, end) {
      end = end || "bottom";
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1) {
          if (end === "bottom") {
            dest.push(sourceIndex[key]);
          } else {
            dest.unshift(sourceIndex[key]);
          }
        }
      });
    },
    synchronize: function(syncField, dest, source, deepKeySyncArray) {
      var destIndex = index(syncField, dest);
      var sourceIndex = index(syncField, source);
      deepKeySyncArray = (typeof deepKeySyncArray === "undefined") ? [] : deepKeySyncArray;
      for (var i = destIndex.orderedKeys.length - 1; i &gt;= 0; i--) {
        var key = destIndex.orderedKeys[i];
        if (sourceIndex.orderedKeys.indexOf(key) === -1) {
          destIndex.orderedKeys.splice(i, 1);
          dest.splice(i, 1);
        }
        if (deepKeySyncArray.length &gt; 0) {
          angular.forEach(deepKeySyncArray, function(deepKey) {
            if (sourceIndex[key] &amp;&amp; destIndex[key][deepKey] !== sourceIndex[key][deepKey]) {
              destIndex[key][deepKey] = sourceIndex[key][deepKey];
            }
          });
        }
      }
      angular.forEach(sourceIndex.orderedKeys, function(key) {
        if (destIndex.orderedKeys.indexOf(key) === -1)
          dest.push(sourceIndex[key]);
      });
      sortByKeyAndModel(dest, syncField, sourceIndex.orderedKeys);
    }
  };
  return ArraySynchronizer;
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBindOnce.js */
angular.module("sn.common.util").directive("snBindOnce", function($sanitize) {
  "use strict";
  return {
    restrict: "A",
    link: function(scope, element, attrs) {
      var value = scope.$eval(attrs.snBindOnce);
      var sanitizedValue = $sanitize(value);
      element.append(sanitizedValue);
    }
  }
});
/*! RESOURCE: /scripts/sn/common/util/directive.snCloak.js */
angular.module("sn.common.util").directive("snCloak", function() {
  "use strict";
  return {
    restrict: "A",
    compile: function(element, attr) {
      return function() {
        attr.$set('snCloak', undefined);
        element.removeClass('sn-cloak');
      }
    }
  };
});
/*! RESOURCE: /scripts/sn/common/util/service.md5.js */
angular.module('sn.common.util').factory('md5', function() {
  'use strict';
  var md5cycle = function(x, k) {
    var a = x[0],
      b = x[1],
      c = x[2],
      d = x[3];
    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);
    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);
    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);
    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  };
  var cmn = function(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32((a &lt;&lt; s) | (a &gt;&gt;&gt; (32 - s)), b);
  };
  var ff = function(a, b, c, d, x, s, t) {
    return cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);
  };
  var gg = function(a, b, c, d, x, s, t) {
    return cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);
  };
  var hh = function(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  };
  var ii = function(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
  };
  var md51 = function(s) {
    var txt = '';
    var n = s.length,
      state = [1732584193, -271733879, -1732584194, 271733878],
      i;
    for (i = 64; i &lt;= s.length; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i &lt; s.length; i++)
      tail[i &gt;&gt; 2] |= s.charCodeAt(i) &lt;&lt; ((i % 4) &lt;&lt; 3);
    tail[i &gt;&gt; 2] |= 0x80 &lt;&lt; ((i % 4) &lt;&lt; 3);
    if (i &gt; 55) {
      md5cycle(state, tail);
      for (i = 0; i &lt; 16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  };
  var md5blk = function(s) {
    var md5blks = [],
      i;
    for (i = 0; i &lt; 64; i += 4) {
      md5blks[i &gt;&gt; 2] = s.charCodeAt(i) +
        (s.charCodeAt(i + 1) &lt;&lt; 8) +
        (s.charCodeAt(i + 2) &lt;&lt; 16) +
        (s.charCodeAt(i + 3) &lt;&lt; 24);
    }
    return md5blks;
  };
  var hex_chr = '0123456789abcdef'.split('');
  var rhex = function(n) {
    var s = '',
      j = 0;
    for (; j &lt; 4; j++)
      s += hex_chr[(n &gt;&gt; (j * 8 + 4)) &amp; 0x0F] +
      hex_chr[(n &gt;&gt; (j * 8)) &amp; 0x0F];
    return s;
  };
  var hex = function(x) {
    for (var i = 0; i &lt; x.length; i++)
      x[i] = rhex(x[i]);
    return x.join('');
  };
  var add32 = function(a, b) {
    return (a + b) &amp; 0xFFFFFFFF;
  };
  return function(s) {
    return hex(md51(s));
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.priorityQueue.js */
angular.module('sn.common.util').factory('priorityQueue', function() {
  'use strict';
  return function(comparator) {
    var items = [];
    var compare = comparator || function(a, b) {
      return a - b;
    };
    var swap = function(a, b) {
      var temp = items[a];
      items[a] = items[b];
      items[b] = temp;
    };
    var bubbleUp = function(pos) {
      var parent;
      while (pos &gt; 0) {
        parent = (pos - 1) &gt;&gt; 1;
        if (compare(items[pos], items[parent]) &gt;= 0)
          break;
        swap(parent, pos);
        pos = parent;
      }
    };
    var bubbleDown = function(pos) {
      var left, right, min, last = items.length - 1;
      while (true) {
        left = (pos &lt;&lt; 1) + 1;
        right = left + 1;
        min = pos;
        if (left &lt;= last &amp;&amp; compare(items[left], items[min]) &lt; 0)
          min = left;
        if (right &lt;= last &amp;&amp; compare(items[right], items[min]) &lt; 0)
          min = right;
        if (min === pos)
          break;
        swap(min, pos);
        pos = min;
      }
    };
    return {
      add: function(item) {
        items.push(item);
        bubbleUp(items.length - 1);
      },
      poll: function() {
        var first = items[0],
          last = items.pop();
        if (items.length &gt; 0) {
          items[0] = last;
          bubbleDown(0);
        }
        return first;
      },
      peek: function() {
        return items[0];
      },
      clear: function() {
        items = [];
      },
      inspect: function() {
        return angular.toJson(items, true);
      },
      get size() {
        return items.length;
      },
      get all() {
        return items;
      },
      set comparator(fn) {
        compare = fn;
      }
    };
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snResource.js */
angular.module('sn.common.util').factory('snResource', function($http, $q, priorityQueue, md5) {
  'use strict';
  var methods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'jsonp', 'trace'],
    queue = priorityQueue(function(a, b) {
      return a.timestamp - b.timestamp;
    }),
    resource = {},
    pendingRequests = [],
    inFlightRequests = [];
  return function() {
    var requestInterceptors = $http.defaults.transformRequest,
      responseInterceptors = $http.defaults.transformResponse;
    var next = function() {
      var request = queue.peek();
      pendingRequests.shift();
      inFlightRequests.push(request.hash);
      $http(request.config).then(function(response) {
        request.deferred.resolve(response);
      }, function(reason) {
        request.deferred.reject(reason);
      }).finally(function() {
        queue.poll();
        inFlightRequests.shift();
        if (queue.size &gt; 0)
          next();
      });
    };
    angular.forEach(methods, function(method) {
      resource[method] = function(url, data) {
        var deferredRequest = $q.defer(),
          promise = deferredRequest.promise,
          deferredAbort = $q.defer(),
          config = {
            method: method,
            url: url,
            data: data,
            transformRequest: requestInterceptors,
            transformResponse: responseInterceptors,
            timeout: deferredAbort.promise
          },
          hash = md5(JSON.stringify(config));
        pendingRequests.push(hash);
        queue.add({
          config: config,
          deferred: deferredRequest,
          timestamp: Date.now(),
          hash: hash
        });
        if (queue.size === 1)
          next();
        promise.abort = function() {
          deferredAbort.resolve('Request cancelled');
        };
        return promise;
      };
    });
    resource.addRequestInterceptor = function(fn) {
      requestInterceptors = requestInterceptors.concat([fn]);
    };
    resource.addResponseInterceptor = function(fn) {
      responseInterceptors = responseInterceptors.concat([fn]);
    };
    resource.queueSize = function() {
      return queue.size;
    };
    resource.queuedRequests = function() {
      return queue.all;
    };
    return resource;
  };
});;
/*! RESOURCE: /scripts/sn/common/util/service.snConnect.js */
angular.module("sn.common.util").service("snConnectService", function($http, snCustomEvent) {
  "use strict";
  var connectPaths = ["/$c.do", "/$chat.do"];

  function canOpenInFrameset() {
    return window.top.NOW.collaborationFrameset;
  }

  function isInConnect() {
    var parentPath = getParentPath();
    return connectPaths.some(function(path) {
      return parentPath == path;
    });
  }

  function getParentPath() {
    try {
      return window.top.location.pathname;
    } catch (IGNORED) {
      return "";
    }
  }

  function openWithProfile(profile) {
    if (isInConnect() || canOpenInFrameset())
      snCustomEvent.fireTop('chat:open_conversation', profile);
    else
      window.open("$c.do#/with/" + profile.sys_id, "_blank");
  }
  return {
    openWithProfile: openWithProfile
  }
});;
/*! RESOURCE: /scripts/sn/common/util/snPolyfill.js */
(function() {
  "use strict";
  polyfill(String.prototype, 'startsWith', function(prefix) {
    return this.indexOf(prefix) === 0;
  });
  polyfill(String.prototype, 'endsWith', function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  });
  polyfill(Number, 'isNaN', function(value) {
    return value !== value;
  });
  polyfill(window, 'btoa', function(input) {
    var str = String(input);
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    for (
      var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 &amp; block &gt;&gt; 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3 / 4);
      if (charCode &gt; 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block &lt;&lt; 8 | charCode;
    }
    return output;
  });

  function polyfill(obj, slot, fn) {
    if (obj[slot] === void(0)) {
      obj[slot] = fn;
    }
  }
  window.console = window.console || {
    log: function() {}
  };
})();;
/*! RESOURCE: /scripts/sn/common/util/directive.snFocus.js */
angular.module('sn.common.util').directive('snFocus', function($timeout) {
  'use strict';
  return function(scope, element, attrs) {
    scope.$watch(attrs.snFocus, function(value) {
      if (value !== true)
        return;
      $timeout(function() {
        element[0].focus();
      });
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snResizeHeight.js */
angular.module('sn.common.util').directive('snResizeHeight', function($timeout) {
  "use strict";
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      var typographyStyles = [
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
      ];
      var maxHeight = parseInt(elem.css('max-height'), 10) || 0;
      var offset = 0;
      if (elem.css('box-sizing') === 'border-box' || elem.css('-moz-box-sizing') === 'border-box' || elem.css('-webkit-box-sizing') === 'border-box')
        offset = elem.outerHeight() - elem.height();
      var styles = {};
      angular.forEach(typographyStyles, function(val) {
        styles[val] = elem.css(val);
      });
      var $clone = angular.element('&lt;textarea rows="1" tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"&gt;&lt;/textarea&gt;');
      $clone.css(styles);
      $timeout(function() {
        angular.element(document.body).append($clone);
        reSize();
      }, 0, false);
      if (window.chrome) {
        var width = elem[0].style.width;
        elem[0].style.width = '0px';
        var ignore = elem[0].offsetWidth;
        elem[0].style.width = width;
      }

      function reSize() {
        if (!setWidth())
          return;
        if (!elem[0].value &amp;&amp; attrs['placeholder'])
          $clone[0].value = attrs['placeholder'] || '';
        else
          $clone[0].value = elem[0].value;
        $clone[0].scrollTop = 0;
        $clone[0].scrollTop = 9e4;
        var newHeight = $clone[0].scrollTop;
        if (maxHeight &amp;&amp; newHeight &gt; maxHeight) {
          newHeight = maxHeight;
          elem[0].style.overflow = "auto";
        } else
          elem[0].style.overflow = "hidden";
        newHeight += offset;
        elem[0].style.height = newHeight + "px";
      }

      function setWidth() {
        var width;
        var style = window.getComputedStyle ? window.getComputedStyle(elem[0], null) : false;
        if (style) {
          width = elem[0].getBoundingClientRect().width;
          if (width === 0 || typeof width !== 'number') {
            if (style.width.length &amp;&amp; style.width[style.width.length - 1] === '%') {
              $timeout(reSize, 0, false);
              return false;
            }
            width = parseInt(style.width, 10);
          }
          angular.forEach(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(val) {
            width -= parseInt(style[val], 10);
          });
        } else {
          width = Math.max(elem.width(), 0);
        }
        $clone[0].style.width = width + 'px';
        return true;
      }
      scope.$watch(
        function() {
          return elem[0].value
        },
        function(newValue, oldValue) {
          if (newValue === oldValue)
            return;
          reSize();
        }
      );
      elem.on('input.resize', reSize);
      if (attrs['snResizeHeight'] == "trim") {
        elem.on('blur', function() {
          elem.val(elem.val().trim());
          reSize();
        });
      }
      scope.$on('$destroy', function() {
        $clone.remove();
      });
    }
  }
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snBlurOnEnter.js */
angular.module('sn.common.util').directive('snBlurOnEnter', function() {
  'use strict';
  return function(scope, element) {
    element.bind("keydown keypress", function(event) {
      if (event.which !== 13)
        return;
      element.blur();
      event.preventDefault();
    });
  };
});;
/*! RESOURCE: /scripts/sn/common/util/directive.snStickyHeaders.js */
angular.module('sn.common.util').directive('snStickyHeaders', function() {
  "use strict";
  return {
    restrict: 'A',
    transclude: false,
    replace: false,
    link: function(scope, element, attrs) {
      element.addClass('sticky-headers');
      var containers;
      var scrollContainer = element.find('[sn-sticky-scroll-container]');
      scrollContainer.addClass('sticky-scroll-container');

      function refreshHeaders() {
        if (attrs.snStickyHeaders !== 'false') {
          angular.forEach(containers, function(container) {
            var stickyContainer = angular.element(container);
            var stickyHeader = stickyContainer.find('[sn-sticky-header]');
            var stickyOffset = stickyContainer.position().top + stickyContainer.outerHeight();
            stickyContainer.addClass('sticky-container');
            if (stickyOffset &lt; stickyContainer.outerHeight() &amp;&amp; stickyOffset &gt; -stickyHeader.outerHeight()) {
              stickyContainer.css('padding-top', stickyHeader.outerHeight());
              stickyHeader.css('width', stickyHeader.outerWidth());
              stickyHeader.removeClass('sticky-header-disabled').addClass('sticky-header-enabled');
            } else {
              stickyContainer.css('padding-top', '');
              stickyHeader.css('width', '');
              stickyHeader.removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
            }
          });
        } else {
          element.find('[sn-sticky-container]').removeClass('sticky-container');
          element.find('[sn-sticky-container]').css('padding-top', '');
          element.find('[sn-sticky-header]').css('width', '');
          element.find('[sn-sticky-header]').removeClass('sticky-header-enabled').addClass('sticky-header-disabled');
        }
      }
      scope.$watch(function() {
        scrollContainer.find('[sn-sticky-header]').addClass('sticky-header');
        containers = element.find('[sn-sticky-container]');
        return attrs.snStickyHeaders;
      }, refreshHeaders);
      scope.$watch(function() {
        return scrollContainer[0].scrollHeight;
      }, refreshHeaders);
      scrollContainer.on('scroll', refreshHeaders);
    }
  };
});;;
/*! RESOURCE: /scripts/sn/common/form/js_includes_form.js */
/*! RESOURCE: /scripts/sn/common/form/_module.js */
angular.module('sn.common.form', [
  'sn.common.clientScript'
]);;
/*! RESOURCE: /scripts/sn/common/form/directive.glideFormField.js */
angular.module('sn.common.form').directive('glideFormField', function(getTemplateUrl, cabrillo, glideFormFieldFactory, $log) {
  'use strict';
  return {
    restrict: 'E',
    templateUrl: getTemplateUrl('directive_glide_form_field.xml'),
    scope: {
      field: '=',
      tableName: '=',
      getGlideForm: '&amp;glideForm'
    },
    controller: function($element, $scope) {
      var g_form;
      if (!$scope.getGlideForm) {
        $log.warn('glideFormField: Field directive is missing GlideForm');
      } else {
        g_form = $scope.getGlideForm();
      }
      var field = $scope.field;
      var glideField = glideFormFieldFactory.create(field);
      $scope.isReadonly = glideField.isReadonly;
      $scope.isMandatory = glideField.isMandatory;
      $scope.isVisible = glideField.isVisible;
      $scope.hasMessages = glideField.hasMessages;
      var isNative = cabrillo.isNative();
      $scope.showBarcodeHelper = isNative &amp;&amp; glideField.hasBarcodeHelper();
      $scope.showCurrentLocationHelper = isNative &amp;&amp; glideField.hasCurrentLocationHelper();
      $scope.getBarcode = function() {
        cabrillo.camera.getBarcode().then(function(value) {
          cabrillo.log('Received barcode value: ' + value);
          g_form.setValue($scope.field.name, value);
        });
      };
      $scope.getCurrentLocation = function() {
        cabrillo.geolocation.getCurrentLocation().then(function(value) {
          var composite = value.coordinate.latitude + ',' + value.coordinate.longitude;
          g_form.setValue($scope.field.name, composite);
        });
      };
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/form/directive.recursiveHelper.js */
angular.module('sn.common.form').directive('recursiveHelper', function($compile) {
  return {
    restrict: "EACM",
    priority: 100000,
    compile: function(tElement, tAttr) {
      var contents = tElement.contents().remove();
      var compiledContents;
      return function(scope, iElement, iAttr) {
        if (!compiledContents)
          compiledContents = $compile(contents);
        iElement.append(compiledContents(scope, function(clone) {
          return clone;
        }));
      };
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/form/glideUIActionsFactory.js */
angular.module('sn.common.form').factory('glideUIActionsFactory', function(urlTools, $http, $q, $log) {
  'use strict';
  var ACTION_OPERATIONS = {
    'INSERT': 'insert',
    'UPDATE': 'update'
  };
  var ACTION_TYPES = {
    'LIST': 'list',
    'FORM': 'form'
  };
  var ACTION_DISPLAY_TYPES = {
    'LIST_BUTTON': 'list_button',
    'FORM_BUTTON': 'form_button',
    'FORM_MORE_ITEM': 'form_more_item'
  };
  return {
    ACTION_OPERATIONS: ACTION_OPERATIONS,
    ACTION_TYPES: ACTION_TYPES,
    create: function(uiActions, options) {
      return new GlideUIActions(uiActions, options);
    },
    executeUIAction: executeUIAction
  };

  function GlideUIActions(uiActions, options) {
    if (!uiActions) {
      throw 'uiActions must be provided';
    }
    var _uiActionsById = {};
    var _uiActions = [];
    options = options || {};
    uiActions.forEach(function(uiAction) {
      var action = new GlideUIAction(
        uiAction.action_name,
        uiAction.sys_id,
        uiAction.name,
        uiAction.disabled,
        uiAction.display_types,
        uiAction.navigate_back === true ? 'back' : 'default',
        options.uiActionNotifier
      );
      _uiActionsById[action.getSysId()] = action;
      _uiActions.push(action);
    });
    this.getActions = function() {
      return _uiActions;
    };
    this.getAction = function(sysId) {
      return _uiActionsById[sysId];
    };
    this.getActionByName = function(name) {
      var foundAction;
      _uiActions.forEach(function(action) {
        if (foundAction) {
          return;
        }
        if (name === action.getName()) {
          foundAction = action;
        }
      });
      return foundAction;
    };
  }

  function GlideUIAction(name, sysId, displayName, disabled, displayTypes, navigateBehavior, uiActionNotifier) {
    var _inProgress = false;
    var _name = name;
    var _sysId = sysId;
    var _displayName = displayName;
    var _disabled = !!disabled;
    var _navigateBehavior;
    var _notifier = uiActionNotifier;
    switch (navigateBehavior) {
      case 'back':
        _navigateBehavior = 'back';
        break;
      default:
        _navigateBehavior = 'default';
        break;
    }
    var _displayTypes = {};
    if (displayTypes) {
      displayTypes.forEach(function(type) {
        _displayTypes[type] = true;
      });
    }
    this.getSysId = function() {
      return _sysId;
    };
    this.getName = function() {
      return _name;
    };
    this.getDisplayName = function() {
      return _displayName;
    };
    this.getNavigateBehavior = function() {
      return _navigateBehavior;
    };
    this.isDisabled = function() {
      return _disabled;
    };
    this.isMoreMenuItem = function() {
      return !_displayTypes[ACTION_DISPLAY_TYPES.FORM_BUTTON] &amp;&amp; _displayTypes[ACTION_DISPLAY_TYPES.FORM_MORE_ITEM];
    };
    this.execute = function(g_form) {
      if (this.isDisabled() || _inProgress) {
        return false;
      }
      _inProgress = true;
      var $execute = executeUIAction(
        ACTION_TYPES.FORM,
        this.getSysId(),
        g_form.getTableName(),
        g_form.getSysId(),
        g_form.isNewRecord() ? ACTION_OPERATIONS.INSERT : ACTION_OPERATIONS.UPDATE,
        g_form.serialize(true),
        g_form.getEncodedRecord()
      ).finally(function() {
        _inProgress = false;
      });
      _notifier(this.getName(), $execute);
      return $execute;
    };
  }

  function executeUIAction(actionType, actionSysId, tableName, recordSysId, operation, fields, encodedRecord) {
    var queryParams = {
      method: 'execute',
      type: actionType,
      operation: angular.isDefined(operation) ? operation : ACTION_OPERATIONS.UPDATE,
      action_id: actionSysId,
      table: tableName,
      sys_id: recordSysId,
      save_parms: JSON.stringify({})
    };
    var url = urlTools.getURL('ui_action', queryParams);
    return $http.post(url, {
      fields: fields || [],
      encoded_record: encodedRecord
    }).then(function(response) {
      var data = response.data;
      return {
        sys_id: data.sys_id,
        redirect: data.redirect
      };
    }).catch(function(data, status) {
      $log.log("Error executing uiAction: " + status);
    });
  }
});;;
/*! RESOURCE: /scripts/snm/auth/data/js_includes_data.js */
/*! RESOURCE: /scripts/snm/auth/data/snm.auth.data.module.js */
angular.module('snm.auth.data', []);;
/*! RESOURCE: /scripts/snm/auth/data/glideUserSession.js */
angular.module('snm.auth.data').provider('glideUserSession', function glideUserSessionProvider() {
  'use strict';
  var _initialLoginState;
  var _initialUser;
  this.setUserSession = function(session) {
    if (!session) {
      return;
    }
    _initialLoginState = session.initialLoginState;
    if (session.initialLoginState &amp;&amp; session.initialUser) {
      _initialUser = session.initialUser;
    }
  };
  this.$get = function glideUserSession($rootScope, $q, $http, $log, urlTools, glideUserFactory, $window, glideSystemProperties, xmlUtil) {
    var $currentUser;
    var _currentLoginState = false;
    var _currentUser;
    $rootScope.$on('@page.login', function() {
      _currentLoginState = false;
      _initialLoginState = false;
      $currentUser = null;
    });

    function loadCurrentUser() {
      if (!$currentUser) {
        $currentUser = $q.defer();
        if (_initialLoginState &amp;&amp; _initialUser) {
          _currentUser = glideUserFactory.create(_initialUser);
          $currentUser.resolve(_currentUser);
          return $currentUser.promise;
        }
        var src = urlTools.getURL('get_user');
        $http.get(src).then(function(response) {
          _currentUser = glideUserFactory.create(response.data);
          $currentUser.resolve(_currentUser);
        }, function() {
          if ($currentUser)
            $currentUser.reject();
          $currentUser = null;
        });
      }
      return $currentUser.promise;
    }

    function isLoggedIn() {
      return _initialLoginState || _currentLoginState;
    }

    function isExternalAuthEnabled() {
      return glideSystemProperties.get('glide.authenticate.multisso.enabled');
    }

    function getIdpRedirectUrl(ssoId) {
      var ssoRedirectUri;
      if (isExternalAuthEnabled()) {
        var redirectSysId = glideSystemProperties.get('glide.authenticate.sso.redirect.idp') || ssoId;
        if (redirectSysId &amp;&amp; redirectSysId.length &gt; 0) {
          ssoRedirectUri = '/login_with_sso.do?glide_sso_id=' + redirectSysId;
        }
      }
      return ssoRedirectUri;
    }

    function logout() {
      $window.location.href = '/logout.do';
      var $d = $q.defer();
      return $d.promise;
    }

    function login(username, password, rememberMe) {
      _initialLoginState = false;
      var params = {
        'sysparm_type': 'login',
        'ni.nolog.user_password': true,
        'remember_me': !!rememberMe,
        'user_name': username,
        'user_password': password
      };
      return _sendLoginRequest(params).then(function(response) {
        if (!response.data) {
          $log.warn('login server failure:', response);
          return $q.reject('unknown_error');
        }
        var status;
        switch (response.data.status) {
          default:
            case 'error':
            _currentLoginState = false;
          status = $q.reject('invalid_username_or_password');
          break;
          case 'success':
              _currentLoginState = true;
            status = $q.resolve(response.data.status);
            break;
          case 'mfa_code_required':
              _currentLoginState = false;
            status = $q.resolve(response.data.status);
            break;
        }
        return status;
      }, function(response) {
        $log.warn('login server failure:', response);
        _currentLoginState = false;
        return $q.reject('unknown_error');
      });
    }

    function requestMfaCode() {
      return _sendLoginRequest({
        send_mfa_code: true
      }).then(function(response) {
        var status;
        if (!response.data) {
          status = $q.reject('unknown_error');
        } else if (response.data.status === 'send_mfa_code_success') {
          status = $q.resolve('success');
        } else {
          status = $q.reject('send_mfa_code_failure');
        }
        return status;
      }, function(response) {
        $log.warn('mfa code delivery error:', response);
        return $q.reject('unknown_error');
      });
    }

    function validateMfaCode(mfaCode) {
      var params = {
        'sysparm_type': 'login',
        'validate_mfa_code': true,
        'mfa_code': mfaCode
      };
      return _sendLoginRequest(params).then(function(response) {
        var status;
        if (!response.data) {
          _currentLoginState = false;
          status = $q.reject('unknown_error');
        } else {
          _currentLoginState = response.data.status === 'success';
          status = _currentLoginState ? $q.resolve('success') : $q.reject('invalid_mfa_code');
        }
        return status;
      }, function(response) {
        $log.warn('mfa validation server error:', response);
        return $q.reject('unknown_error');
      });
    }

    function _sendLoginRequest(params) {
      return $http({
        method: 'POST',
        url: urlTools.getURL('view_form.login'),
        data: urlTools.encodeURIParameters(params),
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });
    }

    function getSsoRedirectUrlForUsername(username) {
      var $d = $q.defer();
      $http({
        method: 'POST',
        url: '/xmlhttp.do',
        data: urlTools.encodeURIParameters({
          sysparm_processor: 'MultiSSO_ClientHelper',
          sysparm_scope: 'global',
          sysparm_name: 'ssoByUser',
          sysparm_user_id: username
        }),
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        transformResponse: function(response) {
          return xmlUtil.getDataFromXml(response, 'result');
        }
      }).then(function(response) {
          var data = response.data[0];
          var url;
          if (data) {
            if (data.glide_sso_id) {
              url = getIdpRedirectUrl(data.glide_sso_id);
            } else {
              url = data.discovery_service_url;
            }
            $d.resolve(url);
          } else {
            $d.reject('No external identity provider found for the username: ' + username);
          }
        },
        function(err) {
          $d.reject(err);
        });
      return $d.promise;
    }
    return {
      loadCurrentUser: loadCurrentUser,
      isLoggedIn: isLoggedIn,
      logout: logout,
      login: login,
      requestMfaCode: requestMfaCode,
      validateMfaCode: validateMfaCode,
      isExternalAuthEnabled: isExternalAuthEnabled,
      getIdpRedirectUrl: getIdpRedirectUrl,
      getSsoRedirectUrlForUsername: getSsoRedirectUrlForUsername
    };
  };
}).config(function(glideUserSessionProvider) {
  glideUserSessionProvider.setUserSession(window['SNM_USER_SESSION']);
});;;
/*! RESOURCE: /scripts/sn/common/clientScript/js_includes_clientScript.js */
/*! RESOURCE: /scripts/sn/common/clientScript/dist/clientScript_components.js */
! function(b, a) {
  "function" == typeof define &amp;&amp; define.amd ? define([], a) : b.amdWeb = a()
}(this, function() {
  "function" != typeof Array.prototype.indexOf &amp;&amp; (Array.prototype.indexOf = function(d, a) {
    var b, c = this.length;
    if (!c) return -1;
    if (a = Number(a), ("number" != typeof a || isNaN(a)) &amp;&amp; (a = 0), a &gt;= c) return -1;
    for (0 &gt; a &amp;&amp; (a = c - Math.abs(a)), b = a; c &gt; b; b++)
      if (this[b] === d) return b;
    return -1
  }), "function" != typeof Function.prototype.bind &amp;&amp; (Function.prototype.bind = function(a) {
    var b, d, c, e;
    if ("function" != typeof this) throw new TypeError("Target is not callable, and unable to be bound");
    return b = Array.prototype.slice, d = b.call(arguments, 1), c = this, "undefined" == typeof a &amp;&amp; (a = c), e = function() {
      var e = b.call(arguments, 0);
      return c.apply(a, d.concat(e))
    }
  })
});
(function() {
  "use strict";

  function $$utils$$objectOrFunction(x) {
    return typeof x === 'function' || (typeof x === 'object' &amp;&amp; x !== null);
  }

  function $$utils$$isFunction(x) {
    return typeof x === 'function';
  }

  function $$utils$$isMaybeThenable(x) {
    return typeof x === 'object' &amp;&amp; x !== null;
  }
  var $$utils$$_isArray;
  if (!Array.isArray) {
    $$utils$$_isArray = function(x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    };
  } else {
    $$utils$$_isArray = Array.isArray;
  }
  var $$utils$$isArray = $$utils$$_isArray;
  var $$utils$$now = Date.now || function() {
    return new Date().getTime();
  };

  function $$utils$$F() {}
  var $$utils$$o_create = (Object.create || function(o) {
    if (arguments.length &gt; 1) {
      throw new Error('Second argument not supported');
    }
    if (typeof o !== 'object') {
      throw new TypeError('Argument must be an object');
    }
    $$utils$$F.prototype = o;
    return new $$utils$$F();
  });
  var $$asap$$len = 0;
  var $$asap$$default = function asap(callback, arg) {
    $$asap$$queue[$$asap$$len] = callback;
    $$asap$$queue[$$asap$$len + 1] = arg;
    $$asap$$len += 2;
    if ($$asap$$len === 2) {
      $$asap$$scheduleFlush();
    }
  };
  var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
  var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;
  var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &amp;&amp;
    typeof importScripts !== 'undefined' &amp;&amp;
    typeof MessageChannel !== 'undefined';

  function $$asap$$useNextTick() {
    return function() {
      process.nextTick($$asap$$flush);
    };
  }

  function $$asap$$useMutationObserver() {
    var iterations = 0;
    var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
    var node = document.createTextNode('');
    observer.observe(node, {
      characterData: true
    });
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }

  function $$asap$$useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = $$asap$$flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }

  function $$asap$$useSetTimeout() {
    return function() {
      setTimeout($$asap$$flush, 1);
    };
  }
  var $$asap$$queue = new Array(1000);

  function $$asap$$flush() {
    for (var i = 0; i &lt; $$asap$$len; i += 2) {
      var callback = $$asap$$queue[i];
      var arg = $$asap$$queue[i + 1];
      callback(arg);
      $$asap$$queue[i] = undefined;
      $$asap$$queue[i + 1] = undefined;
    }
    $$asap$$len = 0;
  }
  var $$asap$$scheduleFlush;
  if (typeof process !== 'undefined' &amp;&amp; {}.toString.call(process) === '[object process]') {
    $$asap$$scheduleFlush = $$asap$$useNextTick();
  } else if ($$asap$$BrowserMutationObserver) {
    $$asap$$scheduleFlush = $$asap$$useMutationObserver();
  } else if ($$asap$$isWorker) {
    $$asap$$scheduleFlush = $$asap$$useMessageChannel();
  } else {
    $$asap$$scheduleFlush = $$asap$$useSetTimeout();
  }

  function $$$internal$$noop() {}
  var $$$internal$$PENDING = void 0;
  var $$$internal$$FULFILLED = 1;
  var $$$internal$$REJECTED = 2;
  var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();

  function $$$internal$$selfFullfillment() {
    return new TypeError("You cannot resolve a promise with itself");
  }

  function $$$internal$$cannotReturnOwn() {
    return new TypeError('A promises callback cannot return that same promise.')
  }

  function $$$internal$$getThen(promise) {
    try {
      return promise.then;
    } catch (error) {
      $$$internal$$GET_THEN_ERROR.error = error;
      return $$$internal$$GET_THEN_ERROR;
    }
  }

  function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
    try {
      then.call(value, fulfillmentHandler, rejectionHandler);
    } catch (e) {
      return e;
    }
  }

  function $$$internal$$handleForeignThenable(promise, thenable, then) {
    $$asap$$default(function(promise) {
      var sealed = false;
      var error = $$$internal$$tryThen(then, thenable, function(value) {
        if (sealed) {
          return;
        }
        sealed = true;
        if (thenable !== value) {
          $$$internal$$resolve(promise, value);
        } else {
          $$$internal$$fulfill(promise, value);
        }
      }, function(reason) {
        if (sealed) {
          return;
        }
        sealed = true;
        $$$internal$$reject(promise, reason);
      }, 'Settle: ' + (promise._label || ' unknown promise'));
      if (!sealed &amp;&amp; error) {
        sealed = true;
        $$$internal$$reject(promise, error);
      }
    }, promise);
  }

  function $$$internal$$handleOwnThenable(promise, thenable) {
    if (thenable._state === $$$internal$$FULFILLED) {
      $$$internal$$fulfill(promise, thenable._result);
    } else if (promise._state === $$$internal$$REJECTED) {
      $$$internal$$reject(promise, thenable._result);
    } else {
      $$$internal$$subscribe(thenable, undefined, function(value) {
        $$$internal$$resolve(promise, value);
      }, function(reason) {
        $$$internal$$reject(promise, reason);
      });
    }
  }

  function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
    if (maybeThenable.constructor === promise.constructor) {
      $$$internal$$handleOwnThenable(promise, maybeThenable);
    } else {
      var then = $$$internal$$getThen(maybeThenable);
      if (then === $$$internal$$GET_THEN_ERROR) {
        $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
      } else if (then === undefined) {
        $$$internal$$fulfill(promise, maybeThenable);
      } else if ($$utils$$isFunction(then)) {
        $$$internal$$handleForeignThenable(promise, maybeThenable, then);
      } else {
        $$$internal$$fulfill(promise, maybeThenable);
      }
    }
  }

  function $$$internal$$resolve(promise, value) {
    if (promise === value) {
      $$$internal$$reject(promise, $$$internal$$selfFullfillment());
    } else if ($$utils$$objectOrFunction(value)) {
      $$$internal$$handleMaybeThenable(promise, value);
    } else {
      $$$internal$$fulfill(promise, value);
    }
  }

  function $$$internal$$publishRejection(promise) {
    if (promise._onerror) {
      promise._onerror(promise._result);
    }
    $$$internal$$publish(promise);
  }

  function $$$internal$$fulfill(promise, value) {
    if (promise._state !== $$$internal$$PENDING) {
      return;
    }
    promise._result = value;
    promise._state = $$$internal$$FULFILLED;
    if (promise._subscribers.length === 0) {} else {
      $$asap$$default($$$internal$$publish, promise);
    }
  }

  function $$$internal$$reject(promise, reason) {
    if (promise._state !== $$$internal$$PENDING) {
      return;
    }
    promise._state = $$$internal$$REJECTED;
    promise._result = reason;
    $$asap$$default($$$internal$$publishRejection, promise);
  }

  function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
    var subscribers = parent._subscribers;
    var length = subscribers.length;
    parent._onerror = null;
    subscribers[length] = child;
    subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
    subscribers[length + $$$internal$$REJECTED] = onRejection;
    if (length === 0 &amp;&amp; parent._state) {
      $$asap$$default($$$internal$$publish, parent);
    }
  }

  function $$$internal$$publish(promise) {
    var subscribers = promise._subscribers;
    var settled = promise._state;
    if (subscribers.length === 0) {
      return;
    }
    var child, callback, detail = promise._result;
    for (var i = 0; i &lt; subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];
      if (child) {
        $$$internal$$invokeCallback(settled, child, callback, detail);
      } else {
        callback(detail);
      }
    }
    promise._subscribers.length = 0;
  }

  function $$$internal$$ErrorObject() {
    this.error = null;
  }
  var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();

  function $$$internal$$tryCatch(callback, detail) {
    try {
      return callback(detail);
    } catch (e) {
      $$$internal$$TRY_CATCH_ERROR.error = e;
      return $$$internal$$TRY_CATCH_ERROR;
    }
  }

  function $$$internal$$invokeCallback(settled, promise, callback, detail) {
    var hasCallback = $$utils$$isFunction(callback),
      value, error, succeeded, failed;
    if (hasCallback) {
      value = $$$internal$$tryCatch(callback, detail);
      if (value === $$$internal$$TRY_CATCH_ERROR) {
        failed = true;
        error = value.error;
        value = null;
      } else {
        succeeded = true;
      }
      if (promise === value) {
        $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
        return;
      }
    } else {
      value = detail;
      succeeded = true;
    }
    if (promise._state !== $$$internal$$PENDING) {} else if (hasCallback &amp;&amp; succeeded) {
      $$$internal$$resolve(promise, value);
    } else if (failed) {
      $$$internal$$reject(promise, error);
    } else if (settled === $$$internal$$FULFILLED) {
      $$$internal$$fulfill(promise, value);
    } else if (settled === $$$internal$$REJECTED) {
      $$$internal$$reject(promise, value);
    }
  }

  function $$$internal$$initializePromise(promise, resolver) {
    try {
      resolver(function resolvePromise(value) {
        $$$internal$$resolve(promise, value);
      }, function rejectPromise(reason) {
        $$$internal$$reject(promise, reason);
      });
    } catch (e) {
      $$$internal$$reject(promise, e);
    }
  }

  function $$$enumerator$$makeSettledResult(state, position, value) {
    if (state === $$$internal$$FULFILLED) {
      return {
        state: 'fulfilled',
        value: value
      };
    } else {
      return {
        state: 'rejected',
        reason: value
      };
    }
  }

  function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor($$$internal$$noop, label);
    this._abortOnReject = abortOnReject;
    if (this._validateInput(input)) {
      this._input = input;
      this.length = input.length;
      this._remaining = input.length;
      this._init();
      if (this.length === 0) {
        $$$internal$$fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate();
        if (this._remaining === 0) {
          $$$internal$$fulfill(this.promise, this._result);
        }
      }
    } else {
      $$$internal$$reject(this.promise, this._validationError());
    }
  }
  $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
    return $$utils$$isArray(input);
  };
  $$$enumerator$$Enumerator.prototype._validationError = function() {
    return new Error('Array Methods must be provided an Array');
  };
  $$$enumerator$$Enumerator.prototype._init = function() {
    this._result = new Array(this.length);
  };
  var $$$enumerator$$default = $$$enumerator$$Enumerator;
  $$$enumerator$$Enumerator.prototype._enumerate = function() {
    var length = this.length;
    var promise = this.promise;
    var input = this._input;
    for (var i = 0; promise._state === $$$internal$$PENDING &amp;&amp; i &lt; length; i++) {
      this._eachEntry(input[i], i);
    }
  };
  $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
    var c = this._instanceConstructor;
    if ($$utils$$isMaybeThenable(entry)) {
      if (entry.constructor === c &amp;&amp; entry._state !== $$$internal$$PENDING) {
        entry._onerror = null;
        this._settledAt(entry._state, i, entry._result);
      } else {
        this._willSettleAt(c.resolve(entry), i);
      }
    } else {
      this._remaining--;
      this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
    }
  };
  $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
    var promise = this.promise;
    if (promise._state === $$$internal$$PENDING) {
      this._remaining--;
      if (this._abortOnReject &amp;&amp; state === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, value);
      } else {
        this._result[i] = this._makeResult(state, i, value);
      }
    }
    if (this._remaining === 0) {
      $$$internal$$fulfill(promise, this._result);
    }
  };
  $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
    return value;
  };
  $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
    var enumerator = this;
    $$$internal$$subscribe(promise, undefined, function(value) {
      enumerator._settledAt($$$internal$$FULFILLED, i, value);
    }, function(reason) {
      enumerator._settledAt($$$internal$$REJECTED, i, reason);
    });
  };
  var $$promise$all$$default = function all(entries, label) {
    return new $$$enumerator$$default(this, entries, true, label).promise;
  };
  var $$promise$race$$default = function race(entries, label) {
    var Constructor = this;
    var promise = new Constructor($$$internal$$noop, label);
    if (!$$utils$$isArray(entries)) {
      $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
      return promise;
    }
    var length = entries.length;

    function onFulfillment(value) {
      $$$internal$$resolve(promise, value);
    }

    function onRejection(reason) {
      $$$internal$$reject(promise, reason);
    }
    for (var i = 0; promise._state === $$$internal$$PENDING &amp;&amp; i &lt; length; i++) {
      $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
    }
    return promise;
  };
  var $$promise$resolve$$default = function resolve(object, label) {
    var Constructor = this;
    if (object &amp;&amp; typeof object === 'object' &amp;&amp; object.constructor === Constructor) {
      return object;
    }
    var promise = new Constructor($$$internal$$noop, label);
    $$$internal$$resolve(promise, object);
    return promise;
  };
  var $$promise$reject$$default = function reject(reason, label) {
    var Constructor = this;
    var promise = new Constructor($$$internal$$noop, label);
    $$$internal$$reject(promise, reason);
    return promise;
  };
  var $$es6$promise$promise$$counter = 0;

  function $$es6$promise$promise$$needsResolver() {
    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  }

  function $$es6$promise$promise$$needsNew() {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

  function $$es6$promise$promise$$Promise(resolver) {
    this._id = $$es6$promise$promise$$counter++;
    this._state = undefined;
    this._result = undefined;
    this._subscribers = [];
    if ($$$internal$$noop !== resolver) {
      if (!$$utils$$isFunction(resolver)) {
        $$es6$promise$promise$$needsResolver();
      }
      if (!(this instanceof $$es6$promise$promise$$Promise)) {
        $$es6$promise$promise$$needsNew();
      }
      $$$internal$$initializePromise(this, resolver);
    }
  }
  $$es6$promise$promise$$Promise.all = $$promise$all$$default;
  $$es6$promise$promise$$Promise.race = $$promise$race$$default;
  $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
  $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;
  $$es6$promise$promise$$Promise.prototype = {
    constructor: $$es6$promise$promise$$Promise,
    then: function(onFulfillment, onRejection) {
      var parent = this;
      var state = parent._state;
      if (state === $$$internal$$FULFILLED &amp;&amp; !onFulfillment || state === $$$internal$$REJECTED &amp;&amp; !onRejection) {
        return this;
      }
      var child = new this.constructor($$$internal$$noop);
      var result = parent._result;
      if (state) {
        var callback = arguments[state - 1];
        $$asap$$default(function() {
          $$$internal$$invokeCallback(state, child, callback, result);
        });
      } else {
        $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
      }
      return child;
    },
    'catch': function(onRejection) {
      return this.then(null, onRejection);
    }
  };
  var $$es6$promise$polyfill$$default = function polyfill() {
    var local;
    if (typeof global !== 'undefined') {
      local = global;
    } else if (typeof window !== 'undefined' &amp;&amp; window.document) {
      local = window;
    } else {
      local = self;
    }
    var es6PromiseSupport =
      "Promise" in local &amp;&amp;
      "resolve" in local.Promise &amp;&amp;
      "reject" in local.Promise &amp;&amp;
      "all" in local.Promise &amp;&amp;
      "race" in local.Promise &amp;&amp;
      (function() {
        var resolve;
        new local.Promise(function(r) {
          resolve = r;
        });
        return $$utils$$isFunction(resolve);
      }());
    if (!es6PromiseSupport) {
      local.Promise = $$es6$promise$promise$$default;
    }
  };
  var es6$promise$umd$$ES6Promise = {
    'Promise': $$es6$promise$promise$$default,
    'polyfill': $$es6$promise$polyfill$$default
  };
  if (typeof define === 'function' &amp;&amp; define['amd']) {
    define(function() {
      return es6$promise$umd$$ES6Promise;
    });
  } else if (typeof module !== 'undefined' &amp;&amp; module['exports']) {
    module['exports'] = es6$promise$umd$$ES6Promise;
  } else if (typeof this !== 'undefined') {
    this['ES6Promise'] = es6$promise$umd$$ES6Promise;
  }
}).call(this);
(function() {
  'use strict';
  if (self.fetch) {
    return
  }

  function Headers(headers) {
    this.map = {}
    var self = this
    if (headers instanceof Headers) {
      headers.forEach(function(name, values) {
        values.forEach(function(value) {
          self.append(name, value)
        })
      })
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        self.append(name, headers[name])
      })
    }
  }
  Headers.prototype.append = function(name, value) {
    name = name.toLowerCase()
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }
  Headers.prototype['delete'] = function(name) {
    delete this.map[name.toLowerCase()]
  }
  Headers.prototype.get = function(name) {
    var values = this.map[name.toLowerCase()]
    return values ? values[0] : null
  }
  Headers.prototype.getAll = function(name) {
    return this.map[name.toLowerCase()] || []
  }
  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(name.toLowerCase())
  }
  Headers.prototype.set = function(name, value) {
    this.map[name.toLowerCase()] = [value]
  }
  Headers.prototype.forEach = function(callback) {
    var self = this
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      callback(name, self.map[name])
    })
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }
  var support = {
    blob: 'FileReader' in self &amp;&amp; 'Blob' in self &amp;&amp; (function() {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
    formData: 'FormData' in self
  }

  function Body() {
    this.bodyUsed = false
    if (support.blob) {
      this._initBody = function(body) {
        this._bodyInit = body
        if (typeof body === 'string') {
          this._bodyText = body
        } else if (support.blob &amp;&amp; Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body
        } else if (support.formData &amp;&amp; FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body
        } else if (!body) {
          this._bodyText = ''
        } else {
          throw new Error('unsupported BodyInit type')
        }
      }
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }
        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }
      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }
      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this._initBody = function(body) {
        this._bodyInit = body
        if (typeof body === 'string') {
          this._bodyText = body
        } else if (support.formData &amp;&amp; FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body
        } else if (!body) {
          this._bodyText = ''
        } else {
          throw new Error('unsupported BodyInit type')
        }
      }
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }
    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }
    this.json = function() {
      return this.text().then(JSON.parse)
    }
    return this
  }
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) &gt; -1) ? upcased : method
  }

  function Request(url, options) {
    options = options || {}
    this.url = url
    this.credentials = options.credentials || 'omit'
    this.headers = new Headers(options.headers)
    this.method = normalizeMethod(options.method || 'GET')
    this.mode = options.mode || null
    this.referrer = null
    if ((this.method === 'GET' || this.method === 'HEAD') &amp;&amp; options.body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(options.body)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&amp;').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }
  Request.prototype.fetch = function() {
    var self = this
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest()
      if (self.credentials === 'cors') {
        xhr.withCredentials = true;
      }

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }
        return;
      }
      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status &lt; 100 || status &gt; 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }
      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }
      xhr.open(self.method, self.url, true)
      if ('responseType' in xhr &amp;&amp; support.blob) {
        xhr.responseType = 'blob'
      }
      self.headers.forEach(function(name, values) {
        values.forEach(function(value) {
          xhr.setRequestHeader(name, value)
        })
      })
      xhr.send(typeof self._bodyInit === 'undefined' ? null : self._bodyInit)
    })
  }
  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }
    this._initBody(bodyInit)
    this.type = 'default'
    this.url = null
    this.status = options.status
    this.statusText = options.statusText
    this.headers = options.headers
    this.url = options.url || ''
  }
  Body.call(Response.prototype)
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
  self.fetch = function(url, options) {
    return new Request(url, options).fetch()
  }
  self.fetch.polyfill = true
})();;
/*! RESOURCE: /scripts/sn/common/clientScript/glideFormFieldFactory.js */
(function(exports, undefined) {
  'use strict';
  var IS_INITIALIZED = 'isInitialized';
  exports.glideFormFieldFactory = {
    create: create,
    hasInputHelpers: hasInputHelpers,
    useDisplayValueForValue: useDisplayValueForValue,
    isMandatory: isMandatory,
    hasValue: hasValue,
    isInitialized: isInitialized,
    setInitialized: setInitialized
  };

  function create(field) {
    var attributes = field.attributes || {};
    return {
      isVisible: function() {
        if (typeof field.fields !== 'undefined') {
          var childVisibility = false;
          field.fields.forEach(function(child) {
            childVisibility |= !!child.visible;
          });
          if (!childVisibility) {
            return false;
          }
        }
        return field.visible === true;
      },
      isReadonly: function() {
        return field.readonly === true || field.sys_readonly === true;
      },
      isMandatory: function() {
        return isMandatory(field);
      },
      hasBarcodeHelper: function() {
        return hasInputHelpers(field) &amp;&amp; attributes.barcode === 'true';
      },
      hasCurrentLocationHelper: function() {
        return hasInputHelpers(field) &amp;&amp; attributes.current_location === 'true';
      },
      hasMessages: function() {
        return field.messages &amp;&amp; (field.messages.length &gt; 0);
      }
    };
  }

  function isInitialized(field) {
    return field[IS_INITIALIZED] === true;
  }

  function setInitialized(field) {
    field[IS_INITIALIZED] = true;
  }

  function hasInputHelpers(field) {
    switch (field.type) {
      case 'boolean':
      case 'reference':
        return false;
      default:
        return true;
    }
  }

  function isMandatory(field) {
    switch (field.type) {
      case 'widget':
        return false;
      default:
        return !field.readonly &amp;&amp; (field.mandatory === true || field.sys_mandatory === true);
    }
  }

  function hasValue(field) {
    if (field.type === "boolean")
      return true;
    var value = useDisplayValueForValue(field) ? field.displayValue : field.value;
    if (value == null) {
      return false;
    }
    if (typeof value === 'undefined') {
      return false;
    }
    var trimmed = String(value).trim();
    return trimmed.length &gt; 0;
  }

  function useDisplayValueForValue(field) {
    switch (field.type) {
      case 'user_image':
      case 'glide_encrypted':
      case 'translated_text':
        return true;
      default:
        return false;
    }
  }
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideFormFactory.js */
(function(exports, document, glideFormFieldFactory, undefined) {
  'use strict';
  exports.glideFormFactory = {
    create: createGlideForm,
    glideRequest: exports.glideRequest
  };
  var DEFAULT_ACTION_NAME = 'none';
  var SUBMIT_ACTION_NAME = 'submit';
  var SAVE_ACTION_NAME = 'save';
  var EVENT_ON_CHANGE = 'onChange';
  var EVENT_CHANGE = 'change';
  var EVENT_ON_SUBMIT = 'onSubmit';
  var EVENT_SUBMIT = 'submit';
  var EVENT_ON_SUBMITTED = 'onSubmitted';
  var EVENT_SUBMITTED = 'submitted';
  var EVENT_ON_CHANGED = 'onChanged';
  var EVENT_CHANGED = 'changed';
  var EVENT_PROPERTY_CHANGE = 'propertyChange';
  var EVENT_ON_PROPERTY_CHANGE = 'onPropertyChange';
  var PROPERTY_CHANGE_FORM = 'FORM';
  var PROPERTY_CHANGE_FIELD = 'FIELD';
  var PROPERTY_CHANGE_SECTION = 'SECTION';
  var PROPERTY_CHANGE_RELATED_LIST = 'RELATED_LIST';

  function createGlideForm(tableName, sysId, fields, uiActions, options) {
    if (!fields) {
      fields = [];
    }
    var _sysId = sysId ? sysId : '-1';
    var _fields = fields;
    var _dirtyFields = _getDirtyQueryFields(fields);
    var _submitActionName = DEFAULT_ACTION_NAME;
    var _onSubmitHandlers = [];
    var _onSubmittedHandlers = [];
    var _onChangeHandlers = [];
    var _onChangedHandlers = [];
    var _onPropertyChangeHandlers = [];
    var _options = {
      getMappedField: null,
      getMappedFieldName: null,
      uiMessageHandler: null,
      encodedRecord: null,
      relatedLists: null,
      sections: null,
      document: null
    };

    function GlideForm() {
      this.hasField = function(fieldName) {
        var field = _getField(fieldName);
        return field !== null;
      };
      this.getFieldNames = function() {
        var fieldNames = [];
        _fields.forEach(function(field) {
          fieldNames.push(field.name);
        });
        return fieldNames;
      };
      this.setLabel = function(fieldName, label) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        field.label = label;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          fieldName,
          'label'
        );
      };
      this.setLabelOf = this.setLabel;
      this.getLabel = function(fieldName) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        return field.label;
      };
      this.getLabelOf = this.getLabel;
      this.addDecoration = function(fieldName, icon, text) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        if (!field.decorations || !_isArray(field.decorations)) {
          field.decorations = [];
        }
        var deco = {
          icon: icon,
          text: text
        };
        for (var i = 0; i &lt; field.decorations.length; i++) {
          var dec = field.decorations[i];
          if ((dec.icon === icon) &amp;&amp; (dec.text === text)) {
            return;
          }
        }
        field.decorations.push(deco);
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'decorations'
        );
      };
      this.removeDecoration = function(fieldName, icon, text) {
        var field = _getField(fieldName);
        if (!field)
          return;
        if (!field.decorations || !_isArray(field.decorations)) {
          return;
        }
        for (var i = 0; i &lt; field.decorations.length; i++) {
          var dec = field.decorations[i];
          if ((dec.icon === icon) &amp;&amp; (dec.text === text)) {
            field.decorations.splice(i, 1);
            return;
          }
        }
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'decorations'
        );
      };
      this.setFieldPlaceholder = function(fieldName, value) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        field.placeholder = value;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'placeholder'
        );
      };
      this.getEncodedRecord = function() {
        return _options.encodedRecord || '';
      };
      this.isMandatory = function(fieldName) {
        var field = _getField(fieldName);
        return field ? !!field.mandatory : false;
      };
      this.setMandatory = function(fieldName, isMandatory) {
        var field = _getField(fieldName);
        if (!field)
          return;
        if (field.sys_mandatory) {
          return;
        }
        isMandatory = _getBoolean(isMandatory);
        field.mandatory = isMandatory;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'mandatory'
        );
      };
      this.isReadOnly = function(fieldName) {
        var field = _getField(fieldName);
        return field ? !!field.readonly : false;
      };
      this.setReadOnly = function(fieldName, readonly) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        if (field.sys_readonly) {
          return;
        }
        field.readonly = _getBoolean(readonly);
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'readonly'
        );
      };
      this.setReadonly = this.setReadOnly;
      this.setDisabled = this.setReadOnly;
      this.isVisible = function(fieldName) {
        var field = _getField(fieldName);
        return field ? !!field.visible : false;
      };
      this.setVisible = function(fieldName, isVisible) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        field.visible = _getBoolean(isVisible);
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'visible'
        );
      };
      this.setDisplay = this.setVisible;
      this.getValue = function(fieldName) {
        var field = _getField(fieldName);
        if (!field) {
          return '';
        }
        return (typeof field.value !== 'undefined' &amp;&amp; field.value !== null) ? field.value.toString() : '';
      };
      this.getDisplayValue = function(fieldName) {
        var field = _getField(fieldName);
        if (!field) {
          return '';
        }
        return field.displayValue;
      };
      this.clearValue = function(fieldName) {
        this.setValue(fieldName, '');
      };
      this.setValue = function(fieldName, value, displayValue) {
        var field = _getField(fieldName);
        _setValue(this, field, value, displayValue);
      };
      this.getTableName = function() {
        return tableName;
      };
      this.isNewRecord = function() {
        return _sysId === "-1";
      };
      this.getSysId = function() {
        return _sysId;
      };
      this.getUniqueValue = this.getSysId;
      this.getBooleanValue = function(fieldName) {
        var val = this.getValue(fieldName);
        val = val ? val + '' : val;
        if (!val || val.length === 0 || val == "false") {
          return false;
        }
        return true;
      };
      this.getDecimalValue = function(fieldName) {
        var value = this.getValue(fieldName);
        if (!value || (value.length === 0)) {
          return 0;
        }
        return parseFloat(value);
      };
      this.getIntValue = function(fieldName) {
        var value = this.getValue(fieldName);
        if (typeof value === 'string') {
          value = value.trim();
        }
        if (!value || (value.length === 0)) {
          return 0;
        }
        return parseInt(value, 10);
      };
      this.addOption = function(fieldName, choiceValue, choiceLabel, choiceIndex) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        _addToOptionStack(field, 'add', choiceValue, choiceLabel, choiceIndex);
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'optionStack'
        );
      };
      this.clearOptions = function(fieldName) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        _addToOptionStack(field, 'clear');
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'optionStack'
        );
      };
      this.removeOption = function(fieldName, choiceValue) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        _addToOptionStack(field, 'remove', choiceValue);
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          field.name,
          'optionStack'
        );
      };
      this.hideRelatedList = function(listTableName) {
        var list = _getRelatedList(listTableName);
        if (!list) {
          return;
        }
        list.visible = false;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_RELATED_LIST,
          listTableName,
          'visible'
        );
      };
      this.hideRelatedLists = function() {
        if (!_options.relatedLists) {
          return;
        }
        _options.relatedLists.forEach(function(list) {
          this.hideRelatedList(_getRelatedListName(list));
        }, this);
      };
      this.showRelatedList = function(listTableName) {
        var list = _getRelatedList(listTableName);
        if (!list) {
          return;
        }
        list.visible = true;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_RELATED_LIST,
          listTableName,
          'visible'
        );
      };
      this.showRelatedLists = function() {
        if (!_options.relatedLists) {
          return;
        }
        _options.relatedLists.forEach(function(list) {
          this.showRelatedList(_getRelatedListName(list));
        }, this);
      };
      this.getRelatedListNames = function() {
        var listNames = [];
        if (_options.relatedLists) {
          _options.relatedLists.forEach(function(list) {
            listNames.push(_getRelatedListName(list));
          });
        }
        return listNames;
      };
      this.getSectionNames = function() {
        var sectionNames = [];
        if (_options.sections) {
          _options.sections.forEach(function(section) {
            var sectionName = _getSectionName(section);
            if (sectionName !== null) {
              sectionNames.push(sectionName);
            }
          });
        }
        return sectionNames;
      };
      this.setSectionDisplay = function(sectionName, display) {
        var section = _getSection(sectionName);
        if (!section) {
          return;
        }
        section.visible = !!display;
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_SECTION,
          sectionName,
          'visible'
        );
      };
      this.getReference = function(fieldName, callback) {
        if (!callback) {
          _logWarn('GETREF:NOCB', 'Mobile scripts must specify a callback function');
          return;
        }
        var field = _getField(fieldName);
        if (!field) {
          _logWarn('GETREF:FNF', 'Field not found: ' + fieldName);
          return;
        }
        var table = _getReferenceTable(field);
        var referenceKey = field.reference_key ? field.reference_key : 'sys_id';
        var gr = new exports.GlideRecord(table);
        gr.get(referenceKey, field.value, callback);
      };
      this.addErrorMessage = function(message) {
        _fireUiMessage(this, 'errorMessage', message);
      };
      this.addInfoMessage = function(message) {
        _fireUiMessage(this, 'infoMessage', message);
      };
      this.clearMessages = function() {
        _fireUiMessage(this, 'clearMessages');
      };
      this.showFieldMsg = function(fieldName, message, type, scrollForm) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        if (!field.messages) {
          field.messages = [];
        }
        switch (type) {
          default: return;
          case 'info':
              case 'error':
              break;
        }
        field.messages.push({
          message: message,
          type: type
        });
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          fieldName,
          'messages'
        );
      };
      this.hideFieldMsg = function(fieldName, clearAll) {
        var field = _getField(fieldName);
        if (!field) {
          return;
        }
        if (!field.messages || !_isArray(field.messages)) {
          return;
        }
        if (clearAll) {
          field.messages = [];
        } else {
          field.messages.shift();
        }
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FIELD,
          fieldName,
          'messages'
        );
      };
      this.hideAllFieldMsgs = function(type) {
        switch (type) {
          default: return;
          case 'info':
              case 'error':
              break;
        }
        for (var i = 0; i &lt; _fields.length; i++) {
          var msgs = _fields[i].messages;
          if (!msgs || !_isArray(msgs)) {
            continue;
          }
          for (var j = 0; j &lt; msgs.length; j++) {
            if (msgs[j].type === type) {
              msgs.splice(j, 1);
            }
          }
        }
        this.$private.events.propertyChange(
          PROPERTY_CHANGE_FORM,
          null,
          'messages'
        );
      };
      this.showErrorBox = function(fieldName, message, scrollForm) {
        this.showFieldMsg(fieldName, message, 'error', scrollForm);
      };
      this.hideErrorBox = function(fieldName) {
        this.hideFieldMsg(fieldName, false);
      };
      this.getActionName = function() {
        return _submitActionName;
      };
      this.save = function() {
        return this.submit(SAVE_ACTION_NAME);
      };
      this.submit = function(submitActionName) {
        var formDocument = _options.document ? _options.document : document;
        var activeElement = formDocument.activeElement;
        if (activeElement) {
          activeElement.blur();
        }
        _submitActionName = submitActionName || SUBMIT_ACTION_NAME;
        if (!_hasMandatoryFields(this) || !_runSubmitScripts()) {
          _submitActionName = DEFAULT_ACTION_NAME;
          return false;
        }
        var uiAction = _getUIAction(submitActionName);
        if (!uiAction)
          return true;
        return uiAction.execute(this);
      };
      this.serialize = function(onlyDirtyFields) {
        var serializeField = function(field, fields) {
          var fieldCopy = _copy(field);
          if (fieldCopy.value == null || typeof fieldCopy.value === 'undefined') {
            fieldCopy.value = '';
          }
          fields.push(fieldCopy);
        };
        var serializedFields = [];
        if (onlyDirtyFields === true) {
          Object.keys(_dirtyFields).forEach(function(fieldName) {
            serializeField(_getField(fieldName), serializedFields);
          });
        } else {
          _fields.forEach(function(field) {
            serializeField(field, serializedFields);
          });
        }
        return serializedFields;
      };
      this.$private = {
        options: function(options) {
          if (!options) {
            return;
          }
          if (typeof options === 'string') {
            return _options[options];
          }
          Object.keys(options).forEach(function(optionName) {
            if (_options[optionName]) {
              throw 'Cannot override option: ' + optionName;
            }
            _options[optionName] = options[optionName];
          });
        },
        events: {
          on: function(eventName, fn) {
            switch (eventName) {
              case EVENT_CHANGE:
              case EVENT_ON_CHANGE:
                _onChangeHandlers.push(fn);
                break;
              case EVENT_SUBMIT:
              case EVENT_ON_SUBMIT:
                _onSubmitHandlers.push(fn);
                break;
              case EVENT_SUBMITTED:
              case EVENT_ON_SUBMITTED:
                _onSubmittedHandlers.push(fn);
                break;
              case EVENT_CHANGED:
              case EVENT_ON_CHANGED:
                _onChangedHandlers.push(fn);
                break;
              case EVENT_PROPERTY_CHANGE:
              case EVENT_ON_PROPERTY_CHANGE:
                _onPropertyChangeHandlers.push(fn);
                break;
              default:
                throw 'Unsupported GlideForm event: ' + eventName;
            }
          },
          propertyChange: function(type, name, propertyName) {
            if (_onPropertyChangeHandlers.length == 0) {
              return;
            }
            switch (type) {
              default: type = PROPERTY_CHANGE_FIELD;
              case PROPERTY_CHANGE_FIELD:
                  case PROPERTY_CHANGE_SECTION:
                  case PROPERTY_CHANGE_RELATED_LIST:
                  break;
            }
            _onPropertyChangeHandlers.forEach(function(fn) {
              fn.call(
                fn,
                type,
                name,
                propertyName
              );
            });
          },
          off: function(eventName) {
            switch (eventName) {
              case EVENT_CHANGE:
              case EVENT_ON_CHANGE:
                _onChangeHandlers = [];
                break;
              case EVENT_SUBMIT:
              case EVENT_ON_SUBMIT:
                _onSubmitHandlers = [];
                break;
              case EVENT_SUBMITTED:
              case EVENT_ON_SUBMITTED:
                _onSubmittedHandlers = [];
                break;
              case EVENT_CHANGED:
              case EVENT_ON_CHANGED:
                _onChangedHandlers = [];
                break;
              case EVENT_PROPERTY_CHANGE:
              case EVENT_ON_PROPERTY_CHANGE:
                _onPropertyChangeHandlers = [];
                break;
              default:
                throw 'Unsupported GlideForm event: ' + eventName;
            }
          },
          cleanup: function() {
            _onChangeHandlers = [];
            _onSubmitHandlers = [];
            _onSubmittedHandlers = [];
            _onChangedHandlers = [];
            _onPropertyChangeHandlers = [];
          }
        }
      };
    }
    var _valueCalls = 0;

    function _setValue(g_form, field, value, displayValue, skipDerivedFieldUpdate, skipDisplayValueUpdate) {
      if (!field) {
        return;
      }
      var oldValue = field.value;
      if (oldValue !== value) {
        _dirtyFields[field.name] = true;
      }
      field.value = value;
      if (field.type === 'reference') {
        if (!skipDerivedFieldUpdate) {
          _updateDerivedFields(g_form, field);
        }
        if (!skipDisplayValueUpdate &amp;&amp; glideFormFieldFactory.hasValue(field) &amp;&amp; !displayValue) {
          field.displayValue = '';
          g_form.getReference(field.name, function(gr) {
            var displayValue = gr.getDisplayValue();
            field.value = oldValue;
            _setValue(g_form, field, value, displayValue, true, true);
          });
          return;
        }
      }
      field.displayValue = typeof displayValue !== 'undefined' &amp;&amp; displayValue != null ? displayValue : value;
      var fields = _getDependentFields(field.name);
      fields.forEach(function(field) {
        if (field.dependentValue !== value) {
          field.dependentValue = value;
        }
        if (field.ed &amp;&amp; field.ed.dependent_value !== value)
          field.ed.dependent_value = value;
      });
      _fireValueChange(field, oldValue, value);
    }

    function _getRelatedList(listTableName) {
      if (!_options.relatedLists) {
        return null;
      }
      var foundList = null;
      _options.relatedLists.forEach(function(list) {
        if (foundList) {
          return;
        }
        if (listTableName === _getRelatedListName(list)) {
          foundList = list;
          return;
        }
        if (listTableName === list.table || listTableName === list.field) {
          foundList = list;
          return;
        }
      });
      return foundList;
    }

    function _getRelatedListName(list) {
      return list.table + '.' + list.field;
    }

    function _getSection(sectionName) {
      if (!_options.sections) {
        return null;
      }
      var foundSection = null;
      _options.sections.forEach(function(section) {
        if (foundSection) {
          return;
        }
        var name = _getSectionName(section);
        if (name === sectionName) {
          foundSection = section;
          return;
        }
      });
      return foundSection;
    }

    function _getSectionName(section) {
      var sectionName = section.caption;
      if (!sectionName) {
        return null;
      }
      return sectionName.toLowerCase().replace(" ", "_").replace(/[^0-9a-z_]/gi, "");
    }

    function _fireValueChange(field, oldValue, value) {
      if (_onChangeHandlers.length &gt; 0) {
        _valueCalls++;
        _onChangeHandlers.forEach(function(fn) {
          fn.call(fn, field.name, oldValue, value);
        });
        _valueCalls--;
      }
      if (_options.getMappedFieldName) {
        var mappedName = _options.getMappedFieldName(field.name);
        _valueCalls++;
        _onChangeHandlers.forEach(function(fn) {
          fn.call(fn, mappedName, oldValue, value);
        });
        _valueCalls--;
      }
      if ((_valueCalls == 0) &amp;&amp; _onChangedHandlers.length &gt; 0) {
        _onChangedHandlers.forEach(function(fn) {
          fn.call(fn);
        });
      }
    }

    function _updateDerivedFields(g_form, originatingField) {
      var derivedFields = _getDerivedFields(originatingField.name);
      if (!glideFormFieldFactory.hasValue(originatingField)) {
        derivedFields.forEach(function(field) {
          _setValue(g_form, field, '', null, true);
        });
        return;
      }
      var relativeFieldNames = [];
      var fieldsByRelativeFieldName = {};
      derivedFields.forEach(function(field) {
        var relativeField = _relativeDerivedFieldName(field.name, originatingField.name);
        fieldsByRelativeFieldName[relativeField] = field;
        relativeFieldNames.push(relativeField);
      });
      if (relativeFieldNames.length == 0) {
        return;
      }
      var glideRequest = glideFormFactory.glideRequest;
      var referenceTable = _getReferenceTable(originatingField);
      var referenceKey = originatingField.reference_key ? originatingField.reference_key : 'sys_id';
      var requestUri = '/api/now/v1/table/' + referenceTable;
      var requestParams = {
        sysparm_display_value: 'all',
        sysparm_fields: relativeFieldNames.join(','),
        sysparm_query: referenceKey + '=' + originatingField.value,
        sysparm_limit: 1
      };
      glideRequest.get(requestUri, {
        params: requestParams
      }).then(function(response) {
        var result = response &amp;&amp; response.data ? response.data.result : null;
        if (result.length &gt; 0) {
          result = result[0];
          var keys = Object.keys(result);
          keys.forEach(function(fieldName) {
            var field = fieldsByRelativeFieldName[fieldName];
            var newFieldValues = result[fieldName];
            _setValue(g_form, field, newFieldValues.value, newFieldValues.display_value, true);
          });
        }
      });
    }

    function _getField(fieldName) {
      for (var i = 0, iM = _fields.length; i &lt; iM; i++) {
        var field = _fields[i];
        if (field.variable_name === fieldName || field.name === fieldName) {
          return field;
        }
      }
      if (_options.getMappedField) {
        var mapped = _options.getMappedField(fieldName);
        if (mapped) {
          return mapped;
        }
      }
      return null;
    }

    function _getDependentFields(fieldName) {
      var fields = [];
      for (var i = 0, iM = _fields.length; i &lt; iM; i++) {
        var field = _fields[i];
        if (field.dependentField === fieldName) {
          fields.push(field);
        }
      }
      return fields;
    }

    function _getDerivedFields(fieldName) {
      var fields = [];
      var derivedFieldPrefix = fieldName + '.';
      for (var i = 0, iM = _fields.length; i &lt; iM; i++) {
        var field = _fields[i];
        if (field.name.startsWith(derivedFieldPrefix)) {
          fields.push(field);
        }
      }
      return fields;
    }

    function _relativeDerivedFieldName(derivedFieldName, rootFieldName) {
      var prefix = rootFieldName + '.';
      return derivedFieldName.replace(prefix, '');
    }

    function _addToOptionStack(field, operation, value, label, index) {
      if (!field.optionStack) {
        field.optionStack = [];
      }
      if (operation === 'add') {
        var foundOperations = [];
        for (var i = 0, iM = field.optionStack.length; i &lt; iM; i++) {
          if (field.optionStack[i].value === value) {
            foundOperations.push(field.optionStack[i]);
          }
        }
        if (foundOperations.length &gt; 0) {
          var isInChoiceList = false;
          for (var i = 0, iM = foundOperations.length; i &lt; iM; i++) {
            switch (foundOperations[i].operation) {
              case 'add':
                isInChoiceList = true;
                break;
              case 'clear':
              case 'remove':
                isInChoiceList = false;
                break;
            }
          }
          if (isInChoiceList) {
            return false;
          }
        }
      }
      var optionOper = {
        operation: operation,
        label: label,
        value: value,
        index: index
      };
      if (operation === 'clear') {
        field.optionStack.splice(0, field.optionStack.length, optionOper);
      } else {
        field.optionStack.push(optionOper);
      }
      return true;
    }

    function _hasMandatoryFields(g_form) {
      var emptyMandatoryFields = [];
      for (var i = 0; i &lt; _fields.length; i++) {
        var f = _fields[i];
        if (!glideFormFieldFactory.isMandatory(f)) {
          continue;
        }
        if (!glideFormFieldFactory.hasValue(f)) {
          emptyMandatoryFields.push(f.label);
        }
      }
      if (emptyMandatoryFields.length === 0) {
        return true;
      }
      var mandatoryFieldMsg = "The following fields are incomplete:";
      if (g_mandatory_field_msg)
        mandatoryFieldMsg = g_mandatory_field_msg;
      var message = mandatoryFieldMsg + "\n\n" + emptyMandatoryFields.join("\n");
      _fireUiMessage(g_form, 'mandatoryMessage', message);
      return false;
    }

    function _runSubmitScripts() {
      if (_onSubmitHandlers.length &gt; 0) {
        var result;
        for (var i = 0, iM = _onSubmitHandlers.length; i &lt; iM; i++) {
          result = _onSubmitHandlers[i].call(null);
          if (result === false) {
            return false;
          }
        }
      }
      if (_onSubmittedHandlers.length &gt; 0) {
        _onSubmittedHandlers.forEach(function(fn) {
          fn.call(fn, _submitActionName);
        });
      }
      return true;
    }

    function _getUIAction(name) {
      if (!uiActions) {
        return false;
      }
      return uiActions.getActionByName(name);
    }

    function _getDirtyQueryFields(fields) {
      var dirtyFields = {};
      fields.forEach(function(field) {
        if (typeof field.dirtyQueryField !== 'undefined' &amp;&amp; field.dirtyQueryField === true) {
          dirtyFields[field.name] = true;
        }
      });
      return dirtyFields;
    }

    function _getReferenceTable(field) {
      var referenceTable = field.ed ? field.ed.reference : undefined;
      if (typeof referenceTable === 'undefined') {
        referenceTable = field.refTable;
      }
      if (typeof referenceTable === 'undefined') {
        referenceTable = field.ref_table;
      }
      return referenceTable;
    }

    function _fireUiMessage(g_form, type, message) {
      var handledMessage = false;
      if (_options.uiMessageHandler) {
        var response = _options.uiMessageHandler(g_form, type, message);
        handledMessage = response !== false;
      }
      if (!handledMessage &amp;&amp; typeof message !== 'undefined') {
        alert(message);
      }
      g_form.$private.events.propertyChange(
        PROPERTY_CHANGE_FORM,
        null,
        type
      );
    }
    var instance = new GlideForm();
    if (options) {
      instance.$private.options(options);
    }
    _deprecate(instance, [
      'disableAttachments',
      'enableAttachments',
      'flash',
      'getControl',
      'getElement',
      'getFormElement',
      'getSections'
    ]);
    return instance;
  }

  function _getBoolean(value) {
    if (value === 'true') {
      value = true;
    } else if (value === 'false') {
      value = false;
    }
    return value ? true : false;
  }

  function _notImplemented(instance, methods) {
    methods.forEach(function(method) {
      if (!instance[method]) {
        instance[method] = function() {
          _logWarn('UNSUPPORTED', 'Method ' + method + ' is not supported on mobile');
        };
      }
    });
  }

  function _deprecate(instance, methods) {
    methods.forEach(function(method) {
      if (!instance[method]) {
        instance[method] = function() {
          _logWarn('DEPRECATED', 'Method ' + method + ' is deprecated and unsupported on mobile');
        };
      }
    });
  }

  function _logWarn(code, msg) {
    if (console &amp;&amp; console.warn) {
      console.warn('(g_form) [' + code + '] ' + msg);
    }
  }

  function _isArray(o) {
    if (!Array.isArray) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }
    return Array.isArray(o);
  }

  function _copy(source) {
    var dest = {};
    for (var prop in source) {
      if (Object.prototype.hasOwnProperty.call(source, prop)) {
        switch (typeof source[prop]) {
          case 'function':
            break;
          default:
            dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
})(window, window.document || {}, window.glideFormFieldFactory);;
/*! RESOURCE: /scripts/sn/common/clientScript/uiPolicyTypes.js */
(function(exports, undefined) {
  'use strict';
  var UI_POLICY_TYPES = {
    dateTypes: {
      glide_date_time: "datetime",
      glide_date: "date",
      date: "date",
      datetime: "datetime",
      due_date: "datetime"
    },
    numberTypes: {
      decimal: "decimal",
      numeric: "numeric",
      integer: "integer",
      float: "float"
    },
    currencyTypes: {
      currency: "currency",
      price: "price"
    }
  };
  exports.UI_POLICY_TYPES = UI_POLICY_TYPES;
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/uiPolicyFactory.js */
(function(exports, undefined) {
  'use strict';
  exports.uiPolicyFactory = {
    create: createUiPolicy
  };
  var uiPolicyTypes = exports.UI_POLICY_TYPES;

  function createUiPolicy(g_form, uiPolicyMap, scripts) {
    var _tableName = uiPolicyMap.table;
    var _description = uiPolicyMap.short_description;
    var _onLoad = uiPolicyMap.onload;
    var _fields = uiPolicyMap.condition_fields;
    var _conditions = uiPolicyMap.conditions;
    var _watchFields = {};
    var _lastResult = null;
    var _isDebug = false;
    initializePolicy();

    function initializePolicy() {
      _fields.forEach(function(field, i) {
        var condition = _conditions[i];
        _watchFields[field] = true;
        if (_isField2FieldComparisonlOper(condition.oper)) {
          var field2 = condition.value.split('@')[0];
          _watchFields[field2] = true;
        }
      });
      g_form.$private.events.on('change', onChangeForm);
      if (_onLoad) {
        runPolicy();
      }
    }

    function onChangeForm(fieldName, oldValue, newValue) {
      if (_watchFields[fieldName]) {
        runPolicy();
      }
    }

    function runPolicy() {
      _debug("Running policy on table: " + _tableName + " " + _description);
      runActions(!!evaluateCondition());
    }

    function evaluateCondition() {
      _debug("---&gt;&gt;&gt; Evaluating condition:");
      var result = "?";
      var conditionResult = true;
      var terms = _conditions;
      for (var i = 0; i &lt; terms.length; i++) {
        var t = terms[i];
        if (t.newquery) {
          if (result == "t") {
            _debug("---&lt;&lt;&lt; condition exited with: TRUE");
            return true;
          } else {
            _debug(" OR (next condition)");
            conditionResult = true;
          }
        }
        if (!conditionResult)
          continue;
        if (t.or) {
          if (result != "t")
            result = _evaluateTermTF(t);
        } else {
          if ((result == "f") &amp;&amp; (!t.newquery)) {
            conditionResult = false;
          } else {
            result = _evaluateTermTF(t);
          }
        }
      }
      var response = result != "f";
      _debug("---&lt;&lt;&lt; End evaluating condition with result: " + response);
      return response;
    }

    function _evaluateTermTF(term) {
      var result = evaluateTerm(term);
      _debugTerm(term, result);
      if (result)
        return "t";
      else
        return "f";
    }

    function evaluateTerm(term) {
      var type = term.type;
      if (uiPolicyTypes.dateTypes[type])
        return evaluateTermDate(term);
      if (uiPolicyTypes.numberTypes[type] || uiPolicyTypes.currencyTypes[type])
        return evaluateTermNumber(term);
      var field = term.field;
      if (!field)
        return false;
      var oper = term.oper;
      var value = term.value;
      var userValue = g_form.getValue(field) + '';
      switch (oper) {
        case '=':
          return userValue === value;
        case '!=':
          return userValue != value;
        case '&lt;':
          return userValue &lt; value;
        case '&lt;=':
          return userValue &lt;= value;
        case '&gt;':
          return userValue &gt; value;
        case '&gt;=':
          return userValue &gt;= value;
        case 'IN':
          var values = value.split(',');
          return userValue &amp;&amp; (_inArray(userValue, values) !== -1);
        case 'NOT IN':
          var values2 = value.split(',');
          return _inArray(userValue, values2) === -1;
        case 'STARTSWITH':
          if (type == 'reference')
            userValue = g_form.getDisplayValue(field);
          return userValue.indexOf(value) === 0;
        case 'ENDSWITH':
          if (type == 'reference')
            userValue = g_form.getDisplayValue(field);
          return userValue.lastIndexOf(value) == userValue.length - value.length;
        case 'LIKE':
          if (type == 'reference')
            userValue = g_form.getDisplayValue(field);
          return userValue.indexOf(value) != -1;
        case 'NOT LIKE':
          if (type == 'reference')
            userValue = g_form.getDisplayValue(field);
          return userValue.indexOf(value) == -1;
        case 'ISEMPTY':
          return userValue === '';
        case 'ISNOTEMPTY':
          return userValue !== '';
        case 'BETWEEN':
          var values3 = value.split('@');
          return userValue &amp;&amp; userValue &gt;= values3[0] &amp;&amp; userValue &lt;= values3[1];
        case 'SAMEAS':
          userValue = (type == 'reference') ? g_form.getDisplayValue(term.field) : g_form.getValue(term.field);
          value = (type == 'reference') ? g_form.getDisplayValue(term.value) : g_form.getValue(term.value);
          return userValue == value;
        case 'NSAMEAS':
          userValue = (type == 'reference') ? g_form.getDisplayValue(term.field) : g_form.getValue(term.field);
          value = (type == 'reference') ? g_form.getDisplayValue(term.value) : g_form.getValue(term.value);
          return userValue != value;
        default:
          return false;
      }
    }

    function evaluateTermNumber(term) {
      var field = term.field;
      if (!field)
        return false;
      var oper = term.oper;
      var value = term.value;
      if (value !== '' &amp;&amp; value.indexOf(',') === -1)
        value = parseFloat(value);
      var userValue = getUserValue(term);
      switch (oper) {
        case '=':
          return userValue === value;
        case '!=':
          return userValue != value;
        case '&lt;':
          return userValue &lt; value;
        case '&lt;=':
          return userValue &lt;= value;
        case '&gt;':
          return userValue &gt; value;
        case '&gt;=':
          return userValue &gt;= value;
        case 'IN':
          var values = (value + "").split(',');
          return userValue.toString() &amp;&amp; (_inArray(userValue.toString(), values) !== -1);
        case 'NOT IN':
          var values2 = (value + "").split(',');
          return _inArray(userValue.toString(), values2) === -1;
        case 'ISEMPTY':
          return userValue.toString() === '';
        case 'ISNOTEMPTY':
          return userValue.toString() !== '';
        case "GT_FIELD":
          userValue = parseInt(g_form.getValue(term.field));
          value = parseInt(g_form.getValue(term.value));
          return userValue &gt; value;
        case "LT_FIELD":
          userValue = parseInt(g_form.getValue(term.field));
          value = parseInt(g_form.getValue(term.value));
          return userValue &lt; value;
        case "GT_OR_EQUALS_FIELD":
          userValue = parseInt(g_form.getValue(term.field));
          value = parseInt(g_form.getValue(term.value));
          return userValue &gt;= value;
        case "LT_OR_EQUALS_FIELD":
          userValue = parseInt(g_form.getValue(term.field));
          value = parseInt(g_form.getValue(term.value));
          return userValue &lt;= value;
        default:
          return false;
      }
    }

    function evaluateTermDate(term) {
      var value = term.value;
      var userValue = g_form.getValue(term.field) + '';
      var values = value.split('@');
      var isDateTime = uiPolicyTypes.dateTypes[term.type] == "datetime";
      if (!isDateTime)
        userValue += " 00:00:00";
      if (term.oper == 'ISEMPTY')
        return userValue === '';
      var userDate = _getDate(userValue);
      if (isNaN(userDate)) {
        _debug("evaluateTermDate - invalid date, returning false");
        return false;
      }
      if (term.oper == "RELATIVE")
        return _evaluateTermDateRelative(userDate, value, isDateTime);
      if (term.oper == "DATEPART")
        return _evaluateTermDateTrend(userDate, value);
      var valueDate, valueDate1, valueDate2;
      switch (term.oper) {
        case '=':
          return g_form.getValue(term.field) === value;
        case '!=':
          return g_form.getValue(term.field) != value;
        case 'ISNOTEMPTY':
          return userValue !== '';
        case '&lt;=':
        case '&lt;':
          valueDate = _getDate(value);
          return (valueDate !== 0) &amp;&amp; (userDate &lt; valueDate);
        case '&gt;=':
        case '&gt;':
          valueDate = _getDate(value);
          return (valueDate !== 0) &amp;&amp; (userDate &gt; valueDate);
        case 'ON':
          valueDate1 = _getDate(values[1]);
          valueDate2 = _getDate(values[2]);
          return (valueDate1 !== 0) &amp;&amp; (valueDate2 !== 0) &amp;&amp; (userDate &gt;= valueDate1) &amp;&amp; (userDate &lt;= valueDate2);
        case 'NOTON':
          valueDate1 = _getDate(values[1]);
          valueDate2 = _getDate(values[2]);
          return (valueDate1 !== 0) &amp;&amp; (valueDate2 !== 0) &amp;&amp; ((userDate &lt; valueDate1) || (userDate &gt; valueDate2));
        case 'BETWEEN':
          valueDate1 = _getDate(values[0]);
          valueDate2 = _getDate(values[1]);
          return (valueDate1 !== 0) &amp;&amp; (valueDate2 !== 0) &amp;&amp; (userDate &gt;= valueDate1) &amp;&amp; (userDate &lt;= valueDate2);
        case 'LESSTHAN':
          return _dateComparisonHelper(term.field, term.value, 'LT');
        case 'MORETHAN':
          return _dateComparisonHelper(term.field, term.value, 'GT');
        default:
          _debug("evaluateTermDate - unsupported operator '" + term.oper + "'. Returning FALSE.");
          return false;
      }
    }

    function _dateComparisonHelper(left, right, comparison) {
      var parsed = _parseField2FieldValue(right);
      var userValue = g_form.getValue(left);
      var value = g_form.getValue(parsed.fieldName);
      if (_isNullField(value) || _isNullField(userValue)) {
        _debug("ui policy could not find a valid field to compare against. Returning FALSE.");
        return false;
      }
      var userDate = _getDate(userValue);
      var theDate = _getDate(value);
      if (parsed.interval == 'quarter') {
        userDate = _roundDateToQuarter(userDate);
        theDate = _roundDateToQuarter(theDate);
      }
      var diff = userDate - theDate;
      if (parsed.beforeAfter == 'before' &amp;&amp; diff &gt; 0)
        return false;
      if (parsed.beforeAfter == 'after' &amp;&amp; diff &lt; 0)
        return false;
      var xDiff;
      if (parsed.interval == 'quarter') {
        var Qdiff = Math.abs(_getAbsQuarter(theDate) - _getAbsQuarter(userDate));
        xDiff = Qdiff - parsed.intervalValue;
      } else {
        var timeSpan = _getIntervalInMilliSeconds(parsed.interval, parsed.intervalValue);
        xDiff = Math.abs(diff) - Math.abs(timeSpan);
      }
      if (comparison === 'GT')
        return xDiff &gt; 0;
      if (comparison === 'LT')
        return xDiff &lt; 0;
    }

    function _getAbsQuarter(theDate) {
      var quarters = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4];
      var Q = quarters[theDate.getMonth()];
      var Y = theDate.getFullYear() * 4;
      return Y + Q;
    }

    function _roundDateToQuarter(theDate) {
      var quarters = [0, 0, 0, 3, 3, 3, 6, 6, 6, 9, 9, 9];
      var Q = quarters[theDate.getMonth()];
      var d = new Date();
      d.setFullYear(theDate.getFullYear(), Q, 0);
      d.setHours(0, 0, 0);
      return d;
    }

    function _isNullField(fieldValue) {
      return typeof fieldValue == 'undefined' || fieldValue == null || fieldValue == '';
    }

    function _parseField2FieldValue(daString) {
      var daArray = daString.split('@');
      return {
        fieldName: daArray[0],
        interval: daArray[1],
        intervalValue: parseInt(daArray[3], 10),
        beforeAfter: daArray[2]
      };
    }

    function _getIntervalInMilliSeconds(interval, value) {
      var ms = {};
      ms.hour = 1000 * 60 * 60;
      ms.day = ms.hour * 24;
      ms.week = ms.day * 7;
      ms.month = ms.day * 30;
      ms.year = ms.day * 365;
      return ms[interval] * value;
    }

    function _getDate(dateValue) {
      if (dateValue)
        dateValue = dateValue.replace(/\s/, 'T');
      return new Date(dateValue);
    }

    function _evaluateTermDateTrend(userDateMilliseconds, trendValueString) {
      var userDate = new Date(userDateMilliseconds);
      var trendParams = trendValueString.split("@");
      if (trendParams.length != 2 || !trendParams[1])
        return;
      var trendParamParts = trendParams[1].split(",");
      if (trendParamParts.length != 3)
        return;
      var trendType = trendParamParts[0];
      var trendValue = trendParamParts[1];
      var trendOper = trendParamParts[2];
      var checkVals;
      switch (trendType) {
        case 'dayofweek':
          checkVals = _trendDayOfWeek(userDate, trendValue, trendOper);
          break;
        case 'month':
          checkVals = _trendMonth(userDate, trendValue, trendOper);
          break;
        case 'year':
          checkVals = _trendYear(userDate, trendValue, trendOper);
          break;
        case 'week':
          checkVals = _trendWeek(userDate, trendValue, trendOper);
          break;
        case 'hour':
          checkVals = _trendHour(userDate, trendValue, trendOper);
          break;
        case 'quarter':
          checkVals = _trendQuarter(userDate, trendValue, trendOper);
          break;
        default:
          _debug("_evaluateTermDateTrend - unsupported trend type '" + trendType + "'. Returning FALSE.");
          return false;
      }
      return _evaluateDateValues(checkVals, trendOper);
    }

    function _evaluateTermDateRelative(userDateMilliseconds, relativeValueString, isDateTime) {
      var relativeValues = relativeValueString.split('@');
      if (!relativeValues || relativeValues.length != 4 || isNaN(relativeValues[3]))
        return false;
      var oper = relativeValues[0];
      var termType = relativeValues[1];
      var termWhen = relativeValues[2];
      var termValue = parseInt(relativeValues[3], 10);
      var modifier = 1;
      if (termWhen == "ahead")
        modifier = -1;
      var relativeValueMilliseconds;
      switch (termType) {
        case 'hour':
          relativeValueMilliseconds = hoursAgoInMilliseconds(modifier * termValue);
          break;
        case 'minute':
          relativeValueMilliseconds = minutesAgoInMilliseconds(modifier * termValue);
          break;
        case 'dayofweek':
          relativeValueMilliseconds = daysAgoInMilliseconds(modifier * termValue);
          break;
        case 'month':
          relativeValueMilliseconds = monthsAgoInMilliseconds(modifier * termValue);
          break;
        case 'quarter':
          relativeValueMilliseconds = quartersAgoInMilliseconds(modifier * termValue);
          break;
        case 'year':
          relativeValueMilliseconds = yearsAgoInMilliseconds(modifier * termValue);
          break;
        default:
          _debug("_evaluateTermDateRelative - unsupported type '" + termType + "'. Returning FALSE.");
          return false;
      }
      var checkVals;
      if (isDateTime) {
        checkVals = {
          checkValue: relativeValueMilliseconds,
          userValue: userDateMilliseconds
        };
      } else {
        checkVals = {
          checkValue: _removeTime(relativeValueMilliseconds),
          userValue: _removeTime(userDateMilliseconds)
        };
      }
      return _evaluateDateValues(checkVals, oper);
    }

    function _evaluateDateValues(checkVals, oper) {
      if (!checkVals)
        return;
      switch (oper) {
        case 'EE':
          return checkVals.userValue === checkVals.checkValue;
        case 'LT':
          return checkVals.userValue &lt; checkVals.checkValue;
        case 'LE':
          return checkVals.userValue &lt;= checkVals.checkValue;
        case 'GT':
          return checkVals.userValue &gt; checkVals.checkValue;
        case 'GE':
          return checkVals.userValue &gt;= checkVals.checkValue;
        default:
          _debug("_evaluateDateValues - unsupported operator '" + oper + "'. Returning FALSE.");
          return false;
      }
    }

    function _removeTime(dateInMilliseconds) {
      var newDate = new Date(dateInMilliseconds);
      newDate.setHours(0);
      newDate.setMinutes(0);
      newDate.setSeconds(0);
      newDate.setMilliseconds(0);
      return newDate.getTime();
    }

    function _trendDayOfWeek(userDate, trendValue) {
      var trendDays = ['monday', 'tuesday', 'wednesday', 'thurday', 'friday', 'saturday', 'sunday'];
      var foundIn = -1;
      for (var i = 0; i &lt; 7; i++)
        if (trendDays[i] == trendValue) {
          foundIn = i;
          break;
        }
      if (foundIn &lt; 0)
        return;
      var userDOW = userDate.getDay();
      userDOW = userDOW - 1;
      if (userDOW &lt; 0)
        userDOW = 6;
      return {
        checkValue: foundIn,
        userValue: userDOW
      };
    }

    function _trendMonth(userDate, trendValue) {
      var trendMonths = ['jan', 'feb', 'mar', 'apr', 'may', 'june', 'july', 'aug', 'sep', 'oct', 'nov', 'dec'];
      var foundIn = -1;
      for (var i = 0; i &lt; 12; i++)
        if (trendMonths[i] == trendValue) {
          foundIn = i;
          break;
        }
      if (foundIn &lt; 0)
        return;
      return {
        checkValue: foundIn,
        userValue: userDate.getMonth()
      };
    }

    function _trendYear(userDate, trendValue) {
      return {
        checkValue: trendValue,
        userValue: userDate.getFullYear()
      };
    }

    function _trendHour(userDate, trendValue) {
      return {
        checkValue: trendValue,
        userValue: userDate.getHour()
      };
    }

    function _trendQuarter(userDate, trendValue) {
      var quarters = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4];
      return {
        checkValue: trendValue,
        userValue: quarters[userDate.getMonth()]
      };
    }

    function _trendWeek(userDate, trendValue) {
      var checkDate = new Date(userDate.getFullYear(), 0, 1);
      var userWeek = (Math.ceil((((userDate.getTime() - checkDate) / 86400000) + checkDate.getDay() + 1) / 7)) - 1;
      return {
        checkValue: trendValue,
        userValue: userWeek
      };
    }

    function quartersAgoInMilliseconds(quarters) {
      var now = new Date();
      var quartersModifier = [0, 1, 1, 1, 4, 4, 4, 7, 7, 7, 10, 10, 10];
      var month = now.getMonth() + 1;
      var quarterBegin = quartersModifier[month];
      var monthsBack = month - quarterBegin + (quarters * 3);
      return monthsAgoInMilliseconds(monthsBack);
    }

    function yearsAgoInMilliseconds(years) {
      var now = new Date();
      var yearsAgo = now.getFullYear() - years;
      now.setFullYear(yearsAgo);
      return now.getTime(now);
    }

    function monthsAgoInMilliseconds(months) {
      var now = new Date();
      var monthsAgo = now.getMonth() - months;
      now.setMonth(monthsAgo);
      return now.getTime(now);
    }

    function daysAgoInMilliseconds(days) {
      return hoursAgoInMilliseconds(days * 24);
    }

    function hoursAgoInMilliseconds(hours) {
      return minutesAgoInMilliseconds(hours * 60);
    }

    function minutesAgoInMilliseconds(minutes) {
      return secondsAgoInMilliseconds(minutes * 60);
    }

    function secondsAgoInMilliseconds(seconds) {
      return new Date().getTime() - (seconds * 1000);
    }

    function getUserValue(term) {
      if (typeof g_form == "undefined")
        return '';
      var userValue = g_form.getValue(term.field + ".storage") + '';
      if (userValue)
        return g_form.getDecimalValue(term.field + ".storage");
      var uv = g_form.getValue(term.field);
      if (!uv || uv.length === 0)
        return '';
      return g_form.getDecimalValue(term.field);
    }

    function runActions(result) {
      if (result === _lastResult) {
        _debug("No change - not running any actions");
        return;
      }
      _lastResult = result;
      if (result) {
        for (var i = 0; i &lt; uiPolicyMap.actions.length; i++) {
          var action = uiPolicyMap.actions[i];
          _runAction(action, result);
        }
        _runScript(uiPolicyMap.script_true.name);
      } else if (uiPolicyMap.reverse) {
        for (var j = 0; j &lt; uiPolicyMap.actions.length; j++) {
          var action2 = uiPolicyMap.actions[j];
          _runAction(action2, result);
        }
        _runScript(uiPolicyMap.script_false.name);
      }
    }

    function _runScript(name) {
      if (typeof name !== "string" || !name.length)
        return;
      try {
        scripts[name].execute();
      } catch (e) {
        console.log("UI policy script error: " + e);
      }
    }

    function _runAction(action, result) {
      if (typeof g_form == "undefined")
        return;
      var field = action.name,
        mandatory = action.mandatory,
        visible = action.visible,
        disabled = action.disabled;
      if (mandatory == 'true') {
        g_form.setMandatory(field, result);
        _debugAction(field, "mandatory", result);
      } else if (mandatory == 'false') {
        g_form.setMandatory(field, !result);
        _debugAction(field, "mandatory", !result);
      }
      if (visible == 'true') {
        g_form.setDisplay(field, result);
        _debugAction(field, "visible", result);
      } else if (visible == 'false') {
        g_form.setDisplay(field, !result);
        _debugAction(field, "visible", !result);
      }
      if (disabled == 'true') {
        g_form.setReadOnly(field, result);
        _debugAction(field, "disabled", result);
      } else if (disabled == 'false') {
        g_form.setReadOnly(field, !result);
        _debugAction(field, "disabled", !result);
      }
      if (mandatory == 'true') {
        g_form.setMandatory(field, result);
        _debugAction(field, "mandatory", result);
      }
    }

    function _isField2FieldComparisonlOper(oper) {
      var special = [
        "MORETHAN",
        "LESSTHAN",
        "GT_FIELD",
        "LT_FIELD",
        "GT_OR_EQUALS_FIELD",
        "LT_OR_EQUALS_FIELD",
        "SAMEAS",
        "NSAMEAS"
      ];
      return special.indexOf(oper) &gt; -1;
    }

    function _inArray(val, array) {
      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf.call(array, val);
      }
      for (var i = 0, iM = array.length; i &lt; iM; i++) {
        if (array[i] === val) {
          return i;
        }
      }
      return -1;
    }

    function _debugAction(field, action, flag) {
      if (!_isDebug) {
        return;
      }
      _debug('Setting ' + action + ' on field:' + field + ' to ' + flag);
    }

    function _debug(msg) {
      if (!_isDebug) {
        return;
      }
      console.log('(uiPolicyFactory)', msg);
    }

    function _debugTerm(term, result) {
      if (!_isDebug) {
        return;
      }
      var or = "";
      if (term.or)
        or = "  or ";
      var userValue;
      if (term.field)
        userValue = g_form.getValue(term.field) + '';
      else
        userValue = "(null)";
      if (!userValue)
        userValue = "&lt;blank&gt;";
      var dspValue = "";
      if (dspValue)
        dspValue = " [" + dspValue + "] ";
      if (result)
        result = "true";
      else
        result = "false";
      _debug(or + term.field + " " + "(" + userValue + dspValue + ") " + term.oper + " " + term.value + " -&gt; " + result);
    }
  }
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideFormEnvironmentFactory.js */
(function(exports, $log, undefined) {
  'use strict';
  var factory = exports.glideFormEnvironmentFactory = {
    create: createGlideFormEnvironment,
    defaultExtensionPoints: {
      'window': null,
      'document': null,
      '$': null,
      'jQuery': null,
      '$$': null,
      '$j': null,
      'angular': null,
      'snmCabrillo': null,
      'cabrillo': null
    }
  };

  function createGlideFormEnvironment(g_form, g_scratchpad, g_user, g_modal) {
    if (typeof g_user === 'undefined' || !g_user) {
      throw 'g_user is required!';
    }
    if (typeof g_scratchpad === 'undefined' || !g_scratchpad) {
      g_scratchpad = {};
    }
    var _extensionPoints = {
      g_scratchpad: extend(g_scratchpad, {}, true),
      g_user: typeof g_user.clone === 'function' ? g_user.clone() : g_user
    };
    if (typeof g_modal !== 'undefined') {
      _extensionPoints['g_modal'] = g_modal;
    }
    var defaults = factory.defaultExtensionPoints;
    Object.keys(defaults).forEach(function(name) {
      registerExtensionPoint(name, defaults[name]);
    });
    var _isFormLoading = true;
    var _isTemplateLoading = false;
    var _onChangeScripts = {};
    var _onSubmitScripts = [];
    return {
      initScripts: initScripts,
      initUIPolicyScripts: initUIPolicyScripts,
      getExtensionPoints: getExtensionPoints,
      registerExtensionPoint: registerExtensionPoint
    };

    function initScripts(scriptMap) {
      var cs, script;
      var onLoadScripts = [];
      if (scriptMap.onLoad) {
        for (var i = 0; i &lt; scriptMap.onLoad.length; i++) {
          try {
            cs = scriptMap.onLoad[i];
            script = _wrapScript(cs.script, null, 'onLoad');
            onLoadScripts.push(_wrapExecuteClientScript(script, g_form, cs.name));
          } catch (e) {
            _logError('CS:ONLOAD', 'Could not load onLoad Client Script "' + cs.name + '": ' + e);
          }
        }
      }
      if (scriptMap.onChange) {
        for (var j = 0; j &lt; scriptMap.onChange.length; j++) {
          try {
            cs = scriptMap.onChange[j];
            script = _wrapScript(cs.script, ['control', 'oldValue', 'newValue', 'isLoading', 'isTemplate'], 'onChange');
            if (!_onChangeScripts[cs.fieldName]) {
              _onChangeScripts[cs.fieldName] = [];
            }
            _onChangeScripts[cs.fieldName].push(
              _wrapExecuteClientScript(script, g_form, cs.name)
            );
          } catch (e) {
            _logError('CS:ONCHANGE', 'Could not load onChange Client Script "' + cs.name + '": ' + e);
          }
        }
      }
      if (scriptMap.onSubmit) {
        for (var k = 0; k &lt; scriptMap.onSubmit.length; k++) {
          try {
            cs = scriptMap.onSubmit[k];
            script = _wrapScript(cs.script, null, 'onSubmit');
            _onSubmitScripts.push(
              _wrapExecuteClientScript(script, g_form, cs.name)
            );
          } catch (e) {
            _logError('CS:ONSUBMIT', 'Could not load onSubmit Client Script "' + cs.name + '": ' + e);
          }
        }
      }
      _onLoadForm(onLoadScripts);
    }

    function initUIPolicyScripts(uiPolicies) {
      uiPolicies.forEach(function(uiPolicyMap) {
        var scripts = _initUIPolicyMap(uiPolicyMap);
        var uiPolicy = uiPolicyFactory.create(g_form, uiPolicyMap, scripts);
      });
    }

    function getExtensionPoints() {
      return extend(_extensionPoints, {}, true);
    }

    function registerExtensionPoint(name, value) {
      if (_extensionPoints.hasOwnProperty(name)) {
        $log.warn('Overwriting extension point: ' + name);
      }
      _extensionPoints[name] = value;
    }

    function _initUIPolicyMap(uiPolicyMap) {
      var resultScriptMap = {};
      ['script_true', 'script_false'].forEach(function(type) {
        var policyScript = uiPolicyMap[type];
        if (!policyScript) {
          return;
        }
        try {
          var wrappedScript = _wrapScript(policyScript.script);
          resultScriptMap[policyScript.name] = {
            execute: _wrapExecuteClientScript(wrappedScript, g_form, uiPolicyMap.short_description)
          };
        } catch (e) {
          var errType = type.toUpperCase();
          _logError('UI:' + errType, 'Could not load UIPolicy script for policy "' + uiPolicyMap.short_description + '"');
        }
      });
      return resultScriptMap;
    }

    function _onLoadForm(onLoadScripts) {
      for (var i = 0, iM = onLoadScripts.length; i &lt; iM; i++) {
        onLoadScripts[i].call(null);
      }
      g_form.$private.events.on('change', _onChangeForm);
      g_form.$private.events.on('submit', _onSubmitForm);
      var value;
      Object.keys(_onChangeScripts).forEach(function(fieldName) {
        value = g_form.getValue(fieldName);
        _onChangeForm(fieldName, value, value);
      });
      _isFormLoading = false;
    }

    function _onChangeForm(fieldName, oldValue, newValue) {
      var scripts = _onChangeScripts[fieldName];
      if (scripts) {
        var scriptVariables = {
          control: null,
          oldValue: oldValue,
          newValue: newValue,
          isLoading: !!_isFormLoading,
          isTemplate: !!_isTemplateLoading
        };
        scripts.forEach(function(script) {
          script.call(null, scriptVariables);
        });
      }
    }

    function _onSubmitForm() {
      var result;
      for (var i = 0, iM = _onSubmitScripts.length; i &lt; iM; i++) {
        result = _onSubmitScripts[i].call(null);
        if (result === false) {
          return result;
        }
      }
    }

    function _wrapScript(script, parameters, mainFuncName) {
      var scriptParams = parameters || [];
      var allParams = scriptParams.slice(0);
      allParams = allParams.concat('g_form', Object.keys(getExtensionPoints()));
      var fn;
      try {
        fn = new Function(allParams, 'return (' + script + ')(' + scriptParams.join(',') + ')');
      } catch (e) {
        if (mainFuncName) {
          script = new Function([], script + ' return ' + mainFuncName + '.apply(this, arguments);');
          fn = new Function(allParams, 'return (' + script + ')(' + scriptParams.join(',') + ')');
        } else
          throw e;
      }
      fn.$inject = allParams;
      return fn;
    }

    function _wrapExecuteClientScript(script, g_form, name) {
      return function(apiParams) {
        return _executeClientScript(script, g_form, name, apiParams);
      };
    }

    function _executeClientScript(script, g_form, name, apiParams) {
      var injectedParams = apiParams || {};
      if (typeof injectedParams === 'string') {
        _logError('SCRIPT:EXEC', 'Invalid params passed into Client Script "' + name + '"');
        return;
      }
      var baseParams = {
        g_form: g_form
      };
      extend(injectedParams, baseParams);
      extend(injectedParams, getExtensionPoints());
      try {
        var result = _invoke(script, this, injectedParams);
        return result;
      } catch (e) {
        _logError('SCRIPT:EXEC', 'Error while running Client Script "' + name + '": ' + e);
      }
    }

    function _invoke(fn, self, locals) {
      var $inject = fn.$inject;
      if (typeof $inject === 'undefined') {
        throw 'Missing $inject. Did you try calling externally?';
      }
      var key;
      var args = [];
      for (var i = 0, iM = $inject.length; i &lt; iM; i++) {
        key = $inject[i];
        if (typeof key !== 'string') {
          throw 'Invalid injection key provided: ' + key;
        }
        var arg = locals[key];
        if (typeof arg === 'undefined') {
          throw 'Injection argument not found (' + key + ')';
        }
        args.push(arg);
      }
      return fn.apply(self, args);
    }

    function extend(defaults, options, newObject) {
      var extended = newObject === true ? {} : defaults;
      var prop;
      for (prop in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, prop)) {
          extended[prop] = defaults[prop];
        }
      }
      for (prop in options) {
        if (Object.prototype.hasOwnProperty.call(options, prop)) {
          extended[prop] = options[prop];
        }
      }
      return extended;
    }

    function _logError(code, msg) {
      if ($log &amp;&amp; $log.error) {
        $log.error('(g_env) [' + code + '] ' + msg);
      }
    }
  }
})(window, console);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideRequest.js */
(function(exports, undefined) {
  'use strict';
  var glideRequest = {
    getAngularURL: function(path, parameters) {
      return 'angular.do?sysparm_type=' + path + (parameters ? encodeURIParameters(parameters) : '');
    },
    get: function(url, options) {
      if (!url) {
        throw 'Must specify a URL';
      }
      var fetchOptions = _applyOptions('get', url, options);
      return exports.fetch(fetchOptions.url, fetchOptions);
    },
    post: function(url, options) {
      if (!url) {
        throw 'Must specify a URL';
      }
      var fetchOptions = _applyOptions('post', url, options);
      return exports.fetch(fetchOptions.url, fetchOptions);
    }
  };

  function _applyOptions(method, url, options) {
    var fetchOptions = {
      method: method,
      url: url
    };
    switch (method) {
      case 'get':
        var url = fetchOptions.url;
        if (options.data) {
          var params = encodeURIParameters(options.data);
          if (url.indexOf('?') !== -1) {
            url += '&amp;' + params;
          } else {
            url += '?' + params;
          }
        }
        fetchOptions.url = url;
        break;
      case 'post':
        fetchOptions.url = options.url;
        fetchOptions.body = JSON.stringify(options.data || {});
        break;
    }
    switch (options.dataType) {
      default:
        case 'json':
        fetchOptions.headers = {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'X-UserToken': window.g_ck
      };
      break;
      case 'xml':
          fetchOptions.headers = {
          'Accept': 'application/xml',
          'Content-Type': 'application/xml',
          'X-UserToken': window.g_ck
        };
        break;
    }
    return fetchOptions;
  }

  function encodeURIParameters(parameters) {
    var s = [];
    for (var parameter in parameters) {
      if (parameters.hasOwnProperty(parameter)) {
        var key = encodeURIComponent(parameter);
        var value = parameters[parameter] ? encodeURIComponent(parameters[parameter]) : '';
        s.push(key + "=" + value);
      }
    }
    return s.join('&amp;');
  }
  exports.glideRequest = glideRequest;
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideAjax.js */
(function(exports, undefined) {
  'use strict';
  var url = '/xmlhttp.do';
  var logError = function() {
    if (console &amp;&amp; console.error)
      console.error.apply(console, arguments);
  };

  function GlideAjax() {
    this.initialize.apply(this, arguments);
  }
  GlideAjax.glideRequest = exports.glideRequest;
  GlideAjax.logError = logError;
  GlideAjax.prototype = {
    initialize: function(targetProcessor, targetURL) {
      this.processor = null;
      this.params = {};
      this.callbackFn = function() {};
      this.errorCallbackFn = function(e) {
        GlideAjax.logError('Unhandled exception in GlideAjax.', e.responseText);
      };
      this.wantAnswer = false;
      this.requestObject = null;
      this.setProcessor(targetProcessor);
      url = targetURL || url;
    },
    addParam: function(name, value) {
      this.params[name] = value;
    },
    getXML: function(callback) {
      this.wantAnswer = false;
      this.callbackFn = callback;
      this.execute();
    },
    getXMLWait: function() {
      GlideAjax.logError('GlideAjax.getXMLWait is no longer supported');
    },
    getXMLAnswer: function(callback) {
      this.wantAnswer = true;
      this.callbackFn = callback;
      this.execute();
    },
    getAnswer: function() {
      return this.responseXML ? this.responseXML.documentElement.getAttribute('answer') : null;
    },
    setErrorCallback: function(errorCallback) {
      this.errorCallbackFn = errorCallback;
    },
    getURL: function() {
      return url;
    },
    getParams: function() {
      return this.params;
    },
    setProcessor: function(p) {
      this.addParam('sysparm_processor', p);
      if (!p) {
        GlideAjax.logError('GlideAjax.initalize: must specify a processor');
      }
      this.processor = p;
    },
    execute: function() {
      var that = this;
      GlideAjax.glideRequest.post(url, {
          data: this.params,
          dataType: 'xml'
        })
        .then(function(response) {
          that.responseXML = response.responseXML;
          that.responseText = response.responseText;
          var ajaxResponse = {
            type: response.type,
            responseText: response.responseText,
            responseXML: response.responseXML
          };
          var args = [
            that.wantAnswer ? that.getAnswer() : ajaxResponse
          ];
          try {
            that.callbackFn.apply(null, args);
          } catch (e) {
            if (that.errorCallbackFn) {
              that.errorCallbackFn({
                type: 'unhandled exception',
                responseText: e.message
              });
            } else
              GlideAjax.logError('Unhandled exception in GlideAjax callback.', e);
          }
        })
        .catch(function(error) {
          var errorResponse = {
            type: error.type,
            status: error.status,
            responseText: error.responseText,
            responseXML: error.responseXML
          };
          if (that.errorCallbackFn) {
            that.errorCallbackFn(errorResponse);
          }
        });
    },
    setScope: function(scope) {
      if (scope) {
        this.addParam('sysparm_scope', scope);
      }
      return this;
    }
  };
  exports.GlideAjax = GlideAjax;
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideRecord.js */
(function(exports, undefined) {
  'use strict';

  function GlideRecord(table) {
    if (!(this instanceof GlideRecord)) {
      return new GlideRecord(table);
    }
    this.initialize.apply(this, arguments);
  }
  GlideRecord.glideRequest = exports.glideRequest;
  GlideRecord.prototype = {
    initialize: function(table) {
      this.tableName = table;
      this.encodedQuery = '';
      this.conditions = [];
      this.orderByFields = [];
      this.limit = 0;
      this._callback = null;
      this.currentRow = -1;
      this.recordSet = [];
    },
    addQuery: function() {
      var args = [];
      Array.prototype.push.apply(args, arguments);
      var name = args.shift(),
        oper, value;
      oper = args.length == 1 ? "=" : args.shift();
      value = args.shift();
      this.conditions.push({
        'name': name,
        'oper': oper,
        'value': value
      });
    },
    setEncodedQuery: function(queryString) {
      this.encodedQuery = queryString;
    },
    getEncodedQuery: function() {
      var qc = [];
      var ec = this.encodedQuery;
      if (ec) {
        qc.push(ec);
      }
      for (var i = 0; i &lt; this.conditions.length; i++) {
        var q = this.conditions[i];
        qc.push(q['name'] + q['oper'] + q['value']);
      }
      return '^' + qc.join('^');
    },
    addOrderBy: function(field) {
      this.orderByFields.push(field);
    },
    setLimit: function(maxRows) {
      this.limit = maxRows;
    },
    getLimit: function() {
      return this.limit;
    },
    get: function() {
      this.initialize(this.tableName);
      this.setLimit(1);
      var callback;
      if (arguments.length == 2) {
        this.addQuery('sys_id', arguments[0]);
        callback = arguments[1];
      } else if (arguments.length == 3) {
        this.addQuery(arguments[0], arguments[1]);
        callback = arguments[2];
      }
      if (!callback) {
        _logWarn('GET:NOCB', 'Get must be called with a callback function');
        return;
      }
      this.query(this._getResponse.bind(this, callback));
    },
    _getResponse: function(callback) {
      this.next();
      callback(this);
    },
    query: function(callback) {
      if (typeof callback !== 'function') {
        _logWarn('Q:NOCB', 'Query must be called with a callback function');
        return;
      }
      var glideRequest = GlideRecord.glideRequest;
      var src = glideRequest.getAngularURL('gliderecord', {
        operation: 'query'
      });
      glideRequest.post(src, {
        dataType: 'json',
        data: {
          table: this.tableName,
          query: this.getEncodedQuery(),
          orderBy: this.orderByFields.join(','),
          limit: this.getLimit()
        }
      }).then(this._queryResponse.bind(this, callback));
    },
    _queryResponse: function(callback, response) {
      this._loadRecordSet(response.data.records);
      callback(this);
    },
    deleteRecord: function() {
      _logError('UNSUPPORTED', 'deleteRecord is not supported on mobile');
    },
    update: function() {
      _logError('UNSUPPORTED', 'update is not supported on mobile');
    },
    hasNext: function() {
      return this.currentRow + 1 &lt; this.recordSet.length;
    },
    next: function() {
      if (!this.hasNext())
        return false;
      this.loadRow(this.currentRow + 1);
      return true;
    },
    loadRow: function(index) {
      var row = this.recordSet[index];
      this.currentRow = index;
      var currentRow = this.getCurrentRow();
      for (var i in currentRow) {
        if (!currentRow.hasOwnProperty(i)) {
          continue;
        }
        this[i] = currentRow[i].value;
      }
    },
    _loadRecordSet: function(records) {
      this.recordSet = records || [];
    },
    getValue: function(fieldName) {
      var current = this.getCurrentRow();
      return current ? current[fieldName].value : '';
    },
    getDisplayValue: function(fieldName) {
      var current = this.getCurrentRow();
      if (!fieldName) {
        return current ? current['$$displayValue'] : '';
      }
      return current ? current[fieldName].displayvalue : '';
    },
    getCurrentRow: function() {
      return this.recordSet[this.currentRow];
    },
    getRowCount: function() {
      return this.recordSet.length;
    },
    getTableName: function() {
      return this.tableName;
    },
    toString: function() {
      return 'GlideRecord';
    }
  };

  function _logError(code, msg) {
    if (console &amp;&amp; console.error) {
      console.error('(GlideRecord) [' + code + '] ' + msg);
    }
  }

  function _logWarn(code, msg) {
    if (console &amp;&amp; console.warn) {
      console.warn('(GlideRecord) [' + code + '] ' + msg);
    }
  }
  exports.GlideRecord = GlideRecord;
})(window);;
/*! RESOURCE: /scripts/sn/common/clientScript/glideUser.js */
(function(exports, undefined) {
  'use strict';
  var ROLE_MAINT = 'maint';
  var ROLE_ADMIN = 'admin';

  function GlideUser(fields) {
    if (!(this instanceof GlideUser)) {
      return new GlideUser(fields);
    }
    var _firstName = fields.firstName || null;
    var _lastName = fields.lastName || null;
    var _userName = fields.userName || null;
    var _userId = fields.userID || null;
    var _roles = fields.roles || null;
    var _allRoles = fields.allRoles || null;
    var _email = fields.email || null;
    var _title = fields.title || null;
    var _avatar = fields.avatar || null;
    var _clientData = fields.clientData || {};
    Object.defineProperties(this, {
      firstName: {
        get: function() {
          return _firstName;
        }
      },
      lastName: {
        get: function() {
          return _lastName;
        }
      },
      userName: {
        get: function() {
          return _userName;
        }
      },
      userID: {
        get: function() {
          return _userId;
        }
      },
      title: {
        get: function() {
          return _title;
        }
      },
      email: {
        get: function() {
          return _email;
        }
      },
      avatar: {
        get: function() {
          return _avatar;
        }
      }
    });
    this.getFullName = function() {
      return _firstName + ' ' + _lastName;
    };
    this.getClientData = function(key) {
      return _clientData[key];
    };
    this.hasRoles = function(includeDefaults) {
      if (includeDefaults)
        return _allRoles &amp;&amp; (_allRoles.length &gt; 0);
      else
        return _roles &amp;&amp; (_roles.length &gt; 0);
    };
    this.hasRoleExactly = function(role, includeDefaults) {
      if (!this.hasRoles(includeDefaults) || !role || (typeof role !== 'string')) {
        return false;
      }
      var normalizedRole = role.toLowerCase();
      var rolesToCheck = _roles;
      if (includeDefaults)
        rolesToCheck = _allRoles;
      for (var i = 0, iM = rolesToCheck.length; i &lt; iM; i++) {
        if (normalizedRole === rolesToCheck[i].toLowerCase()) {
          return true;
        }
      }
      return false;
    };
    this.hasRole = function(role, includeDefaults) {
      if (!this.hasRoles(includeDefaults)) {
        return false;
      }
      if (this.hasRoleExactly(ROLE_MAINT, includeDefaults)) {
        return true;
      } else if (role === ROLE_MAINT) {
        return false;
      }
      if (this.hasRoleExactly(role, includeDefaults)) {
        return true;
      }
      if (this.hasRoleExactly(ROLE_ADMIN, includeDefaults)) {
        return true;
      }
      return false;
    };
    this.hasRoleFromList = function(roles, includeDefaults) {
      if (!this.hasRoles(includeDefaults)) {
        return false;
      }
      var checkRoles = roles;
      if (typeof roles === 'string') {
        checkRoles = roles.split(/\s*,\s*/);
      }
      if (checkRoles.length === 0) {
        return true;
      }
      for (var i = 0, iM = checkRoles.length; i &lt; iM; i++) {
        var role = checkRoles[i];
        if (role &amp;&amp; this.hasRole(role, includeDefaults)) {
          return true;
        }
      }
      return false;
    };
    this.clone = function() {
      return new GlideUser(fields);
    };
  }
  exports.GlideUser = GlideUser;
})(window);;;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/js_includes_angular.js */
/*! RESOURCE: /scripts/sn/common/clientScript/angular/_module.js */
angular.module('sn.common.clientScript', [
  'sn.common.i18n',
  'sn.common.util'
]);;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideAjaxFactory.js */
angular.module('sn.common.clientScript').factory('glideAjaxFactory', function($window, glideRequest) {
  $window.GlideAjax.glideRequest = glideRequest;
  return {
    create: function(processor) {
      return new $window.GlideAjax(processor);
    },
    getClass: function() {
      return $window.GlideAjax;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideFormEnvironmentFactory.js */
angular.module('sn.common.clientScript').factory('glideFormEnvironmentFactory', function(
  $q,
  $window,
  $timeout,
  glideFormFieldFactory,
  glideAjaxFactory,
  glideRecordFactory,
  i18n,
  glideModalFactory,
  jQueryRequestShim
) {
  'use strict';
  var factory = $window.glideFormEnvironmentFactory;
  angular.extend(factory.defaultExtensionPoints, {
    GlideAjax: glideAjaxFactory.getClass(),
    GlideRecord: glideRecordFactory.getClass(),
    getMessage: i18n.getMessage,
    getMessages: i18n.getMessages,
    $: jQueryRequestShim
  });
  factory.createInitializer = function(g_form, g_user, g_scratchpad, clientScripts, uiPolicies, g_modal) {
    if (typeof g_modal === 'undefined') {
      g_modal = glideModalFactory.create();
    }
    var g_env = glideFormEnvironmentFactory.create(g_form, g_scratchpad, g_user, g_modal);
    if (clientScripts &amp;&amp; clientScripts.messages) {
      for (var key in clientScripts.messages) {
        i18n.loadMessage(key, clientScripts.messages[key]);
      }
    }
    return function() {
      g_env.initScripts(clientScripts);
      if (uiPolicies &amp;&amp; (uiPolicies.length &gt; 0)) {
        g_env.initUIPolicyScripts(uiPolicies);
      }
      return g_env;
    };
  };
  factory.createWithConfiguration = function(g_form, g_user, g_scratchpad, clientScripts, uiPolicies, g_modal) {
    if (typeof g_modal === 'undefined') {
      g_modal = glideModalFactory.create();
    }
    var g_env = glideFormEnvironmentFactory.create(g_form, g_scratchpad, g_user, g_modal);
    if (clientScripts &amp;&amp; clientScripts.messages) {
      for (var key in clientScripts.messages) {
        i18n.loadMessage(key, clientScripts.messages[key]);
      }
    }
    return {
      g_env: g_env,
      initialize: function() {
        g_env.initScripts(clientScripts);
        if (uiPolicies &amp;&amp; (uiPolicies.length &gt; 0)) {
          g_env.initUIPolicyScripts(uiPolicies);
        }
      }
    };
  };
  var FIELDS_INITIALIZED_INTERVAL = 195;
  factory.onFieldsInitialized = function(fields) {
    var $fieldsReady = $q.defer();
    var $readyTimeout = $timeout(checkFormFields, FIELDS_INITIALIZED_INTERVAL);

    function checkFormFields() {
      var ready = fields.reduce(function(previous, field) {
        return previous &amp;&amp; glideFormFieldFactory.isInitialized(field);
      }, true);
      if (!ready) {
        $readyTimeout = $timeout(checkFormFields, FIELDS_INITIALIZED_INTERVAL);
        return;
      }
      $fieldsReady.resolve();
    }
    return $fieldsReady.promise;
  };
  return factory;
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideFormFactory.js */
angular.module('sn.common.clientScript').factory('glideFormFactory', function($window, glideRecordFactory, glideRequest, glideFormMessageHandler) {
  'use strict';
  var factory = $window.glideFormFactory;
  factory.glideRequest = glideRequest;
  var EVENT_CHANGED = 'changed';
  var EVENT_PROPERTY_CHANGE = 'propertyChange';

  function createAngularGlideForm($scope, tableName, sysId, fields, uiActions, options, relatedLists, sections) {
    options = angular.extend({
      GlideRecord: glideRecordFactory.getClass(),
      uiMessageHandler: glideFormMessageHandler
    }, options);
    var g_form = factory.create(tableName, sysId, fields, uiActions, options, relatedLists, sections);
    g_form.$private.events.on(EVENT_CHANGED, function() {
      if (!$scope.$root.$$phase) {
        $scope.$apply();
      }
    });
    g_form.$private.events.on(EVENT_PROPERTY_CHANGE, function() {
      if (!$scope.$root.$$phase) {
        $scope.$apply();
      }
    });
    $scope.$on('$destroy', function() {
      g_form.$private.events.cleanup();
    });
    return g_form;
  }
  return {
    create: createAngularGlideForm
  }
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideFormFieldFactory.js */
angular.module('sn.common.clientScript').factory('glideFormFieldFactory', function($window) {
  'use strict';
  return $window.glideFormFieldFactory;
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideFormMessageHandler.js */
angular.module('sn.common.clientScript').factory('glideFormMessageHandler', function($rootScope) {
  'use strict';
  return function(g_form, type, message) {
    switch (type) {
      case 'infoMessage':
        $rootScope.$emit('snm.ui.sessionNotification', {
          type: 'info',
          message: message
        });
        break;
      case 'errorMessage':
        $rootScope.$emit('snm.ui.sessionNotification', {
          type: 'error',
          message: message
        });
        break;
      case 'clearMessages':
        break;
      default:
        return false;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideListFactory.js */
angular.module('sn.common.clientScript').factory('glideListFactory', function() {
  'use strict';
  if (typeof g_glide_list_separator == "undefined")
    var g_glide_list_separator = ", ";
  return {
    init: init
  };

  function init(g_form, fields) {
    return {
      get: function(fieldName) {
        return _glideListUtil(fieldName, g_form, fields);
      }
    };
  }

  function getField(fieldName, g_form, fields) {
    for (var i = 0, iM = fields.length; i &lt; iM; i++) {
      var field = fields[i];
      if (field.variable_name === fieldName || field.name === fieldName) {
        return field;
      }
    }
    if (g_form.$private.options('getMappedField')) {
      var mapped = g_form.$private.options('getMappedField')(fieldName);
      if (mapped) {
        return mapped;
      }
    }
  }

  function _glideListUtil(fieldName, g_form, fields) {
    var field = getField(fieldName, g_form, fields);
    if (!field)
      return;

    function addItem(item, itemDV) {
      var v = field.value;
      if (v.indexOf(item) &gt; -1)
        return;
      var dv = field.display_value_list;
      v = v == '' ? [] : v.split(',');
      if (v.indexOf(item) == -1) {
        v.push(item);
        dv.push(itemDV);
      }
      g_form.setValue(fieldName, v.join(','), dv.join(g_glide_list_separator));
    }

    function removeItem(item) {
      var v = field.value;
      if (v.indexOf(item) == -1)
        return;
      var values = field.value.split(',');
      var displayValues = field.display_value_list;
      for (var i = values.length - 1; i &gt;= 0; i--) {
        if (item == values[i]) {
          values.splice(i, 1);
          displayValues.splice(i, 1);
          break;
        }
      }
      g_form.setValue(field.name, values.join(','), displayValues.join(g_glide_list_separator));
    }

    function reset() {
      field.ed.queryString = '';
    }

    function setQuery(queryString) {
      field.ed.queryString = queryString;
      field.ed.queryString.replace("^EQ", "");
    }

    function setDefaultOperator(operator) {
      field.ed.defaultOperator = operator;
    }

    function getDefaultOperator() {
      return field.ed.defaultOperator;
    }
    return {
      addItem: addItem,
      removeItem: removeItem,
      setQuery: setQuery,
      getDefaultOperator: getDefaultOperator,
      setDefaultOperator: setDefaultOperator,
      queryString: field.ed.queryString,
      reset: reset
    };
  }
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideModalFactory.js */
angular.module('sn.common.clientScript').factory('glideModalFactory', function($q) {
  'use strict';
  return {
    create: create
  };

  function create(options) {
    options = options || {};
    var alertHandler = options.alert || _browserAlertHandler;
    var confirmHandler = options.confirm || _browserConfirmHandler;
    return {
      alert: function() {
        var args = _getArgs(arguments);
        var $d = $q.defer();
        if (args.callback) {
          $d.promise.then(function() {
            args.callback();
          });
        }
        if (alertHandler) {
          alertHandler(args.title, args.message, function() {
            $d.resolve();
          });
        } else {
          $d.reject();
        }
        return $d.promise;
      },
      confirm: function() {
        var args = _getArgs(arguments);
        var $d = $q.defer();
        if (args.callback) {
          $d.promise.then(function(result) {
            args.callback(result);
          });
        }
        if (confirmHandler) {
          confirmHandler(args.title, args.message, function(result) {
            $d.resolve(result === true ? true : false);
          });
        } else {
          $d.reject();
        }
        return $d.promise;
      }
    };
  }

  function _getArgs(args) {
    var title = args[0];
    var message = args[1];
    var callback = args[2];
    switch (typeof message) {
      case 'function':
        callback = message;
      case 'undefined':
        message = title;
        title = null;
        break;
      default:
        break;
    }
    return {
      title: title,
      message: message,
      callback: callback
    };
  }

  function _browserAlertHandler(title, message, done) {
    alert(message);
    done();
  }

  function _browserConfirmHandler(title, message, done) {
    done(confirm(message));
  }
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideRecordFactory.js */
angular.module('sn.common.clientScript').factory('glideRecordFactory', function($window, glideRequest) {
  $window.GlideRecord.glideRequest = glideRequest;
  return {
    create: function(table) {
      return new $window.GlideRecord(table);
    },
    getClass: function() {
      return $window.GlideRecord;
    }
  };
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideRequest.js */
angular.module('sn.common.clientScript').factory('glideRequest', function($q, $log, $http, $window, urlTools, xmlUtil) {
  'use strict';
  $window.glideRequest = {
    getAngularURL: urlTools.getURL,
    get: $http.get,
    post: function(url, options) {
      options = options || {};
      options.url = url;
      options.method = 'post';
      if (!options.headers) {
        options.headers = {};
      }
      var getXml = false;
      switch (options.dataType) {
        case 'json':
          break;
        case 'xml':
          options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
          var data = options.data || {};
          options.data = urlTools.encodeURIParameters(data);
          getXml = true;
          options.responseType = 'text';
          if (!options.data) {
            options.data = '';
          }
          options.headers['Accept'] = 'application/xml, text/xml';
          break;
        default:
      }
      return $http(options).then(function(response) {
        response.type = getXml ? 'xml' : 'json';
        response.responseText = response.data;
        response.responseXML = getXml ? xmlUtil.xmlToElement(response.data) : null;
        return response;
      }, function(error) {
        error.type = getXml ? 'xml' : 'json';
        error.responseText = error.data;
        error.responseXML = getXml ? xmlUtil.xmlToElement(error.data) : null;
        return $q.reject(error);
      });
    }
  };
  return $window.glideRequest;
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/glideUserFactory.js */
angular.module('sn.common.clientScript').factory('glideUserFactory', function($window) {
  function getClass() {
    return $window.GlideUser;
  }
  return {
    create: function(fields) {
      var u = getClass();
      return new u(fields);
    },
    getClass: getClass
  };
});;
/*! RESOURCE: /scripts/sn/common/clientScript/angular/jQueryRequestShim.js */
angular.module('sn.common.clientScript').factory('jQueryRequestShim', function(glideRequest) {
      if (angular.isDefined(window.jQuery)) {
        return {
          get: window.jQuery.get,
          post: window.jQuery.post
        };
      }
      var jQueryRequestShim = {
          get: function() {
            var args = Array.prototype.slice.call(arguments);
            return _createJQueryRequest('get', args);
          },
          post: function() {
              var args = Array.prototype.slice.call(arguments);
              return _createJQueryRequest('post', args</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
